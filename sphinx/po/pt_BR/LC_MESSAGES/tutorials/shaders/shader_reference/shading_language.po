# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Shading language"
msgstr "Linguagem de shading"

msgid "Introduction"
msgstr "Introdução"

msgid ""
"Godot uses a shading language similar to GLSL ES 3.0. Most datatypes and "
"functions are supported, and the few remaining ones will likely be added "
"over time."
msgstr ""
"Godot usa uma linguagem de shading semelhante à GLSL ES 3.0. A maioria dos "
"tipos de dados e funções são suportados e os poucos restantes provavelmente "
"serão adicionados com o tempo."

msgid ""
"If you are already familiar with GLSL, the :ref:`Godot Shader Migration "
"Guide<doc_converting_glsl_to_godot_shaders>` is a resource that will help "
"you transition from regular GLSL to Godot's shading language."
msgstr ""
"Se você já está familiarizado com GLSL, o :ref:`Godot Shader Migration "
"Guide<doc_converting_glsl_to_godot_shaders>` é um recurso que o ajudará na "
"transição de GLSL regular para a linguagem de shaders do Godot."

msgid "Data types"
msgstr "Tipos de dados"

msgid "Most GLSL ES 3.0 datatypes are supported:"
msgstr "A maioria dos tipos de dados de GLSL ES 3.0 são suportados:"

msgid "Type"
msgstr "Tipo"

msgid "Description"
msgstr "Descrição"

msgid "**void**"
msgstr "**void**"

msgid "Void datatype, useful only for functions that return nothing."
msgstr ""

msgid "**bool**"
msgstr "**bool**"

msgid "Boolean datatype, can only contain ``true`` or ``false``."
msgstr "Tipo de dados booleano, só podem conter ``true`` ou ``false``."

msgid "**bvec2**"
msgstr "**bvec2**"

msgid "Two-component vector of booleans."
msgstr ""

msgid "**bvec3**"
msgstr "**bvec3**"

msgid "Three-component vector of booleans."
msgstr ""

msgid "**bvec4**"
msgstr "**bvec4**"

msgid "Four-component vector of booleans."
msgstr ""

msgid "**int**"
msgstr "**int**"

msgid "Signed scalar integer."
msgstr ""

msgid "**ivec2**"
msgstr "**ivec2**"

msgid "Two-component vector of signed integers."
msgstr ""

msgid "**ivec3**"
msgstr "**ivec3**"

msgid "Three-component vector of signed integers."
msgstr ""

msgid "**ivec4**"
msgstr "**ivec4**"

msgid "Four-component vector of signed integers."
msgstr ""

msgid "**uint**"
msgstr "**uint**"

msgid "Unsigned scalar integer; can't contain negative numbers."
msgstr ""

msgid "**uvec2**"
msgstr "**uvec2**"

msgid "Two-component vector of unsigned integers."
msgstr ""

msgid "**uvec3**"
msgstr "**uvec3**"

msgid "Three-component vector of unsigned integers."
msgstr ""

msgid "**uvec4**"
msgstr "**uvec4**"

msgid "Four-component vector of unsigned integers."
msgstr ""

msgid "**float**"
msgstr "**float**"

msgid "Floating-point scalar."
msgstr "Número de ponto flutuante (real)."

msgid "**vec2**"
msgstr "**vec2**"

msgid "Two-component vector of floating-point values."
msgstr ""

msgid "**vec3**"
msgstr "**vec3**"

msgid "Three-component vector of floating-point values."
msgstr ""

msgid "**vec4**"
msgstr "**vec4**"

msgid "Four-component vector of floating-point values."
msgstr ""

msgid "**mat2**"
msgstr "**mat2**"

msgid "2x2 matrix, in column major order."
msgstr ""

msgid "**mat3**"
msgstr "**mat3**"

msgid "3x3 matrix, in column major order."
msgstr ""

msgid "**mat4**"
msgstr "**mat4**"

msgid "4x4 matrix, in column major order."
msgstr ""

msgid "**sampler2D**"
msgstr "**sampler2D**"

msgid "Sampler type for binding 2D textures, which are read as float."
msgstr ""

msgid "**isampler2D**"
msgstr "**isampler2D**"

msgid "Sampler type for binding 2D textures, which are read as signed integer."
msgstr ""

msgid "**usampler2D**"
msgstr "**usampler2D**"

msgid ""
"Sampler type for binding 2D textures, which are read as unsigned integer."
msgstr ""

msgid "**sampler2DArray**"
msgstr "**sampler2DArray**"

msgid "Sampler type for binding 2D texture arrays, which are read as float."
msgstr ""

msgid "**isampler2DArray**"
msgstr "**isampler2DArray**"

msgid ""
"Sampler type for binding 2D texture arrays, which are read as signed integer."
msgstr ""

msgid "**usampler2DArray**"
msgstr "**usampler2DArray**"

msgid ""
"Sampler type for binding 2D texture arrays, which are read as unsigned "
"integer."
msgstr ""

msgid "**sampler3D**"
msgstr "**sampler3D**"

msgid "Sampler type for binding 3D textures, which are read as float."
msgstr ""

msgid "**isampler3D**"
msgstr "**isampler3D**"

msgid "Sampler type for binding 3D textures, which are read as signed integer."
msgstr ""

msgid "**usampler3D**"
msgstr "**usampler3D**"

msgid ""
"Sampler type for binding 3D textures, which are read as unsigned integer."
msgstr ""

msgid "**samplerCube**"
msgstr "**samplerCube**"

msgid "Sampler type for binding Cubemaps, which are read as float."
msgstr ""

#, fuzzy
msgid "**samplerCubeArray**"
msgstr "**samplerCube**"

msgid "Sampler type for binding Cubemap arrays, which are read as float."
msgstr ""

msgid "Casting"
msgstr "Conversão"

msgid ""
"Just like GLSL ES 3.0, implicit casting between scalars and vectors of the "
"same size but different type is not allowed. Casting of types of different "
"size is also not allowed. Conversion must be done explicitly via "
"constructors."
msgstr ""

msgid "Example:"
msgstr "Exemplo:"

msgid ""
"Default integer constants are signed, so casting is always needed to convert "
"to unsigned:"
msgstr ""

msgid "Members"
msgstr "Membros"

msgid ""
"Individual scalar members of vector types are accessed via the \"x\", \"y\", "
"\"z\" and \"w\" members. Alternatively, using \"r\", \"g\", \"b\" and \"a\" "
"also works and is equivalent. Use whatever fits best for your needs."
msgstr ""

msgid ""
"For matrices, use the ``m[column][row]`` indexing syntax to access each "
"scalar, or ``m[idx]`` to access a vector by row index. For example, for "
"accessing the y position of an object in a mat4 you use ``m[3][1]``."
msgstr ""

msgid "Constructing"
msgstr "Construindo"

msgid "Construction of vector types must always pass:"
msgstr ""

msgid ""
"Construction of matrix types requires vectors of the same dimension as the "
"matrix. You can also build a diagonal matrix using ``matx(float)`` syntax. "
"Accordingly, ``mat4(1.0)`` is an identity matrix."
msgstr ""

msgid ""
"Matrices can also be built from a matrix of another dimension. There are two "
"rules:"
msgstr ""

msgid ""
"1. If a larger matrix is constructed from a smaller matrix, the additional "
"rows and columns are set to the values they would have in an identity "
"matrix. 2. If a smaller matrix is constructed from a larger matrix, the top, "
"left submatrix of the larger matrix is used."
msgstr ""

msgid "Swizzling"
msgstr "Swizzling"

msgid ""
"It is possible to obtain any combination of components in any order, as long "
"as the result is another vector type (or scalar). This is easier shown than "
"explained:"
msgstr ""

msgid "Precision"
msgstr "Precisão"

msgid ""
"It is possible to add precision modifiers to datatypes; use them for "
"uniforms, variables, arguments and varyings:"
msgstr ""

msgid ""
"Using lower precision for some operations can speed up the math involved (at "
"the cost of less precision). This is rarely needed in the vertex processor "
"function (where full precision is needed most of the time), but is often "
"useful in the fragment processor."
msgstr ""

msgid ""
"Some architectures (mainly mobile) can benefit significantly from this, but "
"there are downsides such as the additional overhead of conversion between "
"precisions. Refer to the documentation of the target architecture for "
"further information. In many cases, mobile drivers cause inconsistent or "
"unexpected behavior and it is best to avoid specifying precision unless "
"necessary."
msgstr ""

msgid "Arrays"
msgstr "Arrays"

msgid "Arrays are containers for multiple variables of a similar type."
msgstr ""

msgid "Local arrays"
msgstr "Arrays locais"

msgid ""
"Local arrays are declared in functions. They can use all of the allowed "
"datatypes, except samplers. The array declaration follows a C-style syntax: "
"``[const] + [precision] + typename + identifier + [array size]``."
msgstr ""

msgid "They can be initialized at the beginning like:"
msgstr ""

msgid ""
"You can declare multiple arrays (even with different sizes) in one "
"expression:"
msgstr ""

msgid "To access an array element, use the indexing syntax:"
msgstr ""

msgid ""
"Arrays also have a built-in function ``.length()`` (not to be confused with "
"the built-in ``length()`` function). It doesn't accept any parameters and "
"will return the array's size."
msgstr ""

msgid ""
"If you use an index either below 0 or greater than array size - the shader "
"will crash and break rendering. To prevent this, use ``length()``, ``if``, "
"or ``clamp()`` functions to ensure the index is between 0 and the array's "
"length. Always carefully test and check your code. If you pass a constant "
"expression or a number, the editor will check its bounds to prevent this "
"crash."
msgstr ""

#, fuzzy
msgid "Global arrays"
msgstr "Arrays locais"

msgid "You can declare arrays at global space like:"
msgstr ""

msgid ""
"Global arrays have to be declared as global constants, otherwise they can be "
"declared the same as local arrays."
msgstr ""

msgid "Constants"
msgstr "Constantes"

msgid ""
"Use the ``const`` keyword before the variable declaration to make that "
"variable immutable, which means that it cannot be modified. All basic types, "
"except samplers can be declared as constants. Accessing and using a constant "
"value is slightly faster than using a uniform. Constants must be initialized "
"at their declaration."
msgstr ""

msgid ""
"Constants cannot be modified and additionally cannot have hints, but "
"multiple of them (if they have the same type) can be declared in a single "
"expression e.g"
msgstr ""

msgid "Similar to variables, arrays can also be declared with ``const``."
msgstr ""

msgid ""
"Constants can be declared both globally (outside of any function) or locally "
"(inside a function). Global constants are useful when you want to have "
"access to a value throughout your shader that does not need to be modified. "
"Like uniforms, global constants are shared between all shader stages, but "
"they are not accessible outside of the shader."
msgstr ""

msgid ""
"Constants of the ``float`` type must be initialized using ``.`` notation "
"after the decimal part or by using the scientific notation. The optional "
"``f`` post-suffix is also supported."
msgstr ""

msgid ""
"Constants of the ``uint`` (unsigned int) type must have a ``u`` suffix to "
"differentiate them from signed integers. Alternatively, this can be done by "
"using the ``uint(x)`` built-in conversion function."
msgstr ""

#, fuzzy
msgid "Structs"
msgstr "Construtores"

msgid ""
"Structs are compound types which can be used for better abstraction of "
"shader code. You can declare them at the global scope like:"
msgstr ""

msgid "After declaration, you can instantiate and initialize them like:"
msgstr ""

msgid "Or use struct constructor for same purpose:"
msgstr ""

msgid ""
"Structs may contain other struct or array, you can also instance them as "
"global constant:"
msgstr ""

#, fuzzy
msgid "You can also pass them to functions:"
msgstr "Você também pode alterar a propriedade com o código:"

msgid "Operators"
msgstr "Operadores"

msgid ""
"Godot shading language supports the same set of operators as GLSL ES 3.0. "
"Below is the list of them in precedence order:"
msgstr ""

msgid "Precedence"
msgstr "Precedência"

msgid "Class"
msgstr "Classe"

msgid "Operator"
msgstr "Operador"

msgid "1 (highest)"
msgstr "1 (mais alto)"

msgid "parenthetical grouping"
msgstr "agrupamento entre parênteses"

msgid "**()**"
msgstr "**()**"

msgid "2"
msgstr "2"

#, fuzzy
msgid "unary"
msgstr "unário"

msgid "**+, -, !, ~**"
msgstr ""

msgid "3"
msgstr "3"

msgid "multiplicative"
msgstr "multiplicativo"

msgid "**/, \\*, %**"
msgstr ""

msgid "4"
msgstr "4"

msgid "additive"
msgstr "aditivo"

msgid "**+, -**"
msgstr "**+, -**"

msgid "5"
msgstr "5"

msgid "bit-wise shift"
msgstr ""

msgid "**<<, >>**"
msgstr "**<<, >>**"

msgid "6"
msgstr "6"

msgid "relational"
msgstr "relacional"

msgid "**<, >, <=, >=**"
msgstr ""

msgid "7"
msgstr "7"

msgid "equality"
msgstr "igualdade"

msgid "**==, !=**"
msgstr "**==, !=**"

msgid "8"
msgstr "8"

msgid "bit-wise AND"
msgstr "Operador bit a bit AND"

msgid "**&**"
msgstr "**&**"

msgid "9"
msgstr "9"

msgid "bit-wise exclusive OR"
msgstr ""

msgid "**^**"
msgstr "**^**"

msgid "10"
msgstr "10"

msgid "bit-wise inclusive OR"
msgstr ""

msgid "**|**"
msgstr "**|**"

msgid "11"
msgstr "11"

msgid "logical AND"
msgstr "AND lógico"

msgid "**&&**"
msgstr "**&&**"

msgid "12 (lowest)"
msgstr "12 (mais baixo)"

msgid "logical inclusive OR"
msgstr ""

msgid "**||**"
msgstr "**||**"

msgid "Flow control"
msgstr "Controle de fluxo"

msgid "Godot Shading language supports the most common types of flow control:"
msgstr ""

msgid ""
"Keep in mind that in modern GPUs, an infinite loop can exist and can freeze "
"your application (including editor). Godot can't protect you from this, so "
"be careful not to make this mistake!"
msgstr ""

msgid ""
"Also, when comparing floating-point values against a number, make sure to "
"compare them against a *range* instead of an exact number."
msgstr ""

msgid ""
"A comparison like ``if (value == 0.3)`` may not evaluate to ``true``. "
"Floating-point math is often approximate and can defy expectations. It can "
"also behave differently depending on the hardware."
msgstr ""

msgid "**Don't** do this."
msgstr ""

msgid ""
"Instead, always perform a range comparison with an epsilon value. The larger "
"the floating-point number (and the less precise the floating-point number), "
"the larger the epsilon value should be."
msgstr ""

msgid ""
"See `floating-point-gui.de <https://floating-point-gui.de/>`__ for more "
"information."
msgstr ""

msgid "Discarding"
msgstr "Descartando"

msgid ""
"Fragment and light functions can use the ``discard`` keyword. If used, the "
"fragment is discarded and nothing is written."
msgstr ""

msgid ""
"Beware that ``discard`` has a performance cost when used, as it will prevent "
"the depth prepass from being effective on any surfaces using the shader. "
"Also, a discarded pixel still needs to be rendered in the vertex shader, "
"which means a shader that uses ``discard`` on all of its pixels is still "
"more expensive to render compared to not rendering any object in the first "
"place."
msgstr ""

msgid "Functions"
msgstr "Funções"

msgid ""
"It is possible to define functions in a Godot shader. They use the following "
"syntax:"
msgstr ""

msgid ""
"You can only use functions that have been defined above (higher in the "
"editor) the function from which you are calling them. Redefining a function "
"that has already been defined above (or is a built-in function name) will "
"cause an error."
msgstr ""

msgid "Function arguments can have special qualifiers:"
msgstr ""

msgid "**in**: Means the argument is only for reading (default)."
msgstr ""

msgid "**out**: Means the argument is only for writing."
msgstr ""

msgid "**inout**: Means the argument is fully passed via reference."
msgstr ""

msgid ""
"**const**: Means the argument is a constant and cannot be changed, may be "
"combined with **in** qualifier."
msgstr ""

msgid "Example below:"
msgstr "Exemplo abaixo:"

msgid ""
"Unlike GLSL, Godot's shader language does **not** support function "
"overloading. This means that a function cannot be defined several times with "
"different argument types or numbers of arguments. As a workaround, use "
"different names for functions that accept a different number of arguments or "
"arguments of different types."
msgstr ""

msgid "Varyings"
msgstr "Variações"

msgid ""
"To send data from the vertex to the fragment (or light) processor function, "
"*varyings* are used. They are set for every primitive vertex in the *vertex "
"processor*, and the value is interpolated for every pixel in the *fragment "
"processor*."
msgstr ""

msgid "Varying can also be an array:"
msgstr ""

msgid ""
"It's also possible to send data from *fragment* to *light* processors using "
"*varying* keyword. To do so you can assign it in the *fragment* and later "
"use it in the *light* function."
msgstr ""

msgid ""
"Note that varying may not be assigned in custom functions or a *light "
"processor* function like:"
msgstr ""

msgid ""
"This limitation was introduced to prevent incorrect usage before "
"initialization."
msgstr ""

msgid "Interpolation qualifiers"
msgstr ""

msgid ""
"Certain values are interpolated during the shading pipeline. You can modify "
"how these interpolations are done by using *interpolation qualifiers*."
msgstr ""

msgid "There are two possible interpolation qualifiers:"
msgstr ""

msgid "Qualifier"
msgstr "Qualificador"

msgid "**flat**"
msgstr "**flat**"

msgid "The value is not interpolated."
msgstr ""

#, fuzzy
msgid "**smooth**"
msgstr "**smooth**"

msgid ""
"The value is interpolated in a perspective-correct fashion. This is the "
"default."
msgstr ""

msgid "Uniforms"
msgstr "Uniforms"

msgid ""
"Passing values to shaders is possible. These are global to the whole shader "
"and are called *uniforms*. When a shader is later assigned to a material, "
"the uniforms will appear as editable parameters in it. Uniforms can't be "
"written from within the shader."
msgstr ""

msgid ""
"You can set uniforms in the editor in the material. Or you can set them "
"through GDScript:"
msgstr ""

msgid ""
"The first argument to ``set_shader_parameter`` is the name of the uniform in "
"the shader. It must match *exactly* to the name of the uniform in the shader "
"or else it will not be recognized."
msgstr ""

msgid ""
"Any GLSL type except for *void* can be a uniform. Additionally, Godot "
"provides optional shader hints to make the compiler understand for what the "
"uniform is used, and how the editor should allow users to modify it."
msgstr ""

msgid ""
"It's important to understand that textures *that are supplied as color* "
"require hints for proper sRGB -> linear conversion (i.e. ``source_color``), "
"as Godot's 3D engine renders in linear color space. If this is not done, the "
"texture will appear washed out."
msgstr ""

msgid ""
"The 2D renderer also renders in linear color space if the **Rendering > "
"Viewport > HDR 2D** project setting is enabled, so ``source_color`` must "
"also be used in ``canvas_item`` shaders. If 2D HDR is disabled, "
"``source_color`` will keep working correctly in ``canvas_item`` shaders, so "
"it's recommend to use it either way."
msgstr ""

msgid "Full list of hints below:"
msgstr ""

msgid "Hint"
msgstr "Dica"

#, fuzzy
msgid "**vec3, vec4**"
msgstr "**vec4**"

msgid "source_color"
msgstr ""

msgid "Used as color."
msgstr ""

msgid "**int, float**"
msgstr "**int, float**"

msgid "hint_range(min, max[, step])"
msgstr ""

msgid "Restricted to values in a range (with min/max/step)."
msgstr ""

#, fuzzy
msgid "Used as albedo color."
msgstr "Use como Albedo"

msgid "hint_normal"
msgstr "hint_normal"

msgid "Used as normalmap."
msgstr ""

#, fuzzy
msgid "hint_default_white"
msgstr "hint_white"

msgid "As value or albedo color, default to opaque white."
msgstr ""

#, fuzzy
msgid "hint_default_black"
msgstr "hint_black"

msgid "As value or albedo color, default to opaque black."
msgstr ""

msgid "hint_default_transparent"
msgstr ""

msgid "As value or albedo color, default to transparent black."
msgstr ""

#, fuzzy
msgid "hint_anisotropy"
msgstr "hint_aniso"

msgid "As flowmap, default to right."
msgstr ""

msgid "hint_roughness[_r, _g, _b, _a, _normal, _gray]"
msgstr ""

msgid ""
"Used for roughness limiter on import (attempts reducing specular aliasing). "
"``_normal`` is a normal map that guides the roughness limiter, with "
"roughness increasing in areas that have high-frequency detail."
msgstr ""

msgid "filter[_nearest, _linear][_mipmap][_anisotropic]"
msgstr ""

msgid "Enabled specified texture filtering."
msgstr ""

msgid "repeat[_enable, _disable]"
msgstr ""

msgid "Enabled texture repeating."
msgstr ""

msgid "hint_screen_texture"
msgstr ""

msgid "Texture is the screen texture."
msgstr ""

#, fuzzy
msgid "hint_depth_texture"
msgstr "Textura de profundidade"

msgid "Texture is the depth texture."
msgstr ""

msgid "hint_normal_roughness_texture"
msgstr ""

msgid "Texture is the normal roughness texture (only supported in Forward+)."
msgstr ""

msgid ""
"GDScript uses different variable types than GLSL does, so when passing "
"variables from GDScript to shaders, Godot converts the type automatically. "
"Below is a table of the corresponding types:"
msgstr ""

msgid "GLSL type"
msgstr "Tipo GLSL"

msgid "GDScript type"
msgstr "Tipo GDScript"

msgid "Notes"
msgstr "Notas"

msgid "Bitwise packed int where bit 0 (LSB) corresponds to x."
msgstr ""

msgid "For example, a bvec2 of (bx, by) could be created in the following way:"
msgstr ""

#, fuzzy
msgid "**Vector2i**"
msgstr "**Vector2**"

#, fuzzy
msgid "**Vector3i**"
msgstr "**Vector3**"

#, fuzzy
msgid "**Vector4i**"
msgstr "**Vector2**"

msgid "**Vector2**"
msgstr "**Vector2**"

#, fuzzy
msgid "**Vector3**, **Color**"
msgstr "**Vector3**"

msgid "When Color is used, it will be interpreted as (r, g, b)."
msgstr ""

msgid "**Vector4**, **Color**, **Rect2**, **Plane**, **Quaternion**"
msgstr ""

msgid "When Color is used, it will be interpreted as (r, g, b, a)."
msgstr ""

msgid ""
"When Rect2 is used, it will be interpreted as (position.x, position.y, size."
"x, size.y)."
msgstr ""

msgid ""
"When Plane is used it will be interpreted as (normal.x, normal.y, normal.z, "
"d)."
msgstr ""

msgid "**Transform2D**"
msgstr "**Transform2D**"

#, fuzzy
msgid "**Basis**"
msgstr "Base"

#, fuzzy
msgid "**mat4** **mat4**"
msgstr "**mat4**"

#, fuzzy
msgid "**Projection**, **Transform3D**"
msgstr "**Transform2D**"

msgid "When a Transform3D is used, the w Vector is set to the identity."
msgstr ""

#, fuzzy
msgid "**Texture2D**"
msgstr "Textura"

#, fuzzy
msgid "**Texture2DArray**"
msgstr "**sampler2DArray**"

#, fuzzy
msgid "**Texture3D**"
msgstr "Textura"

#, fuzzy
msgid "**Cubemap**"
msgstr "**samplerCube**"

#, fuzzy
msgid "**CubemapArray**"
msgstr "**usampler2DArray**"

msgid ""
"Be careful when setting shader uniforms from GDScript, no error will be "
"thrown if the type does not match. Your shader will just exhibit undefined "
"behavior."
msgstr ""

msgid "Uniforms can also be assigned default values:"
msgstr ""

msgid ""
"Note that when adding a default value and a hint, the default value goes "
"after the hint."
msgstr ""

msgid ""
"If you need to make multiple uniforms to be grouped in the specific category "
"of an inspector, you can use a `group_uniform` keyword like:"
msgstr ""

#, fuzzy
msgid "You can close the group by using:"
msgstr "Você também pode alterar a propriedade com o código:"

msgid ""
"The syntax also supports subgroups (it's not mandatory to declare the base "
"group before this):"
msgstr ""

#, fuzzy
msgid "Global uniforms"
msgstr "Built-ins globais"

msgid ""
"Sometimes, you want to modify a parameter in many different shaders at once. "
"With a regular uniform, this takes a lot of work as all these shaders need "
"to be tracked and the uniform needs to be set for each of them. Global "
"uniforms allow you to create and update uniforms that will be available in "
"all shaders, in every shader type (``canvas_item``, ``spatial``, "
"``particles``, ``sky`` and ``fog``)."
msgstr ""

msgid ""
"Global uniforms are especially useful for environmental effects that affect "
"many objects in a scene, like having foliage bend when the player is nearby, "
"or having objects move with the wind."
msgstr ""

msgid ""
"To create a global uniform, open the **Project Settings** then go to the "
"**Shader Globals** tab. Specify a name for the uniform (case-sensitive) and "
"a type, then click **Add** in the top-right corner of the dialog. You can "
"then edit the value assigned to the uniform by clicking the value in the "
"list of uniforms:"
msgstr ""

msgid ""
"Adding a global uniform in the Shader Globals tab of the Project Settings"
msgstr ""

msgid "After creating a global uniform, you can use it in a shader as follows:"
msgstr ""

msgid ""
"Note that the global uniform *must* exist in the Project Settings at the "
"time the shader is saved, or compilation will fail. While you can assign a "
"default value using ``global uniform vec4 my_color = ...`` in the shader "
"code, it will be ignored as the global uniform must always be defined in the "
"Project Settings anyway."
msgstr ""

msgid ""
"To change the value of a global uniform at run-time, use the :ref:"
"`RenderingServer.global_shader_parameter_set "
"<class_RenderingServer_method_global_shader_parameter_set>` method in a "
"script:"
msgstr ""

msgid ""
"Assigning global uniform values can be done as many times as desired without "
"impacting performance, as setting data doesn't require synchronization "
"between the CPU and GPU."
msgstr ""

#, fuzzy
msgid "You can also add or remove global uniforms at run-time:"
msgstr "Você também pode usar seus próprios nós como tipos de retorno:"

msgid ""
"Adding or removing global uniforms at run-time has a performance cost, "
"although it's not as pronounced compared to getting global uniform values "
"from a script (see the warning below)."
msgstr ""

msgid ""
"While you *can* query the value of a global uniform at run-time in a script "
"using ``RenderingServer.global_shader_parameter_get(\"uniform_name\")``, "
"this has a large performance penalty as the rendering thread needs to "
"synchronize with the calling thread."
msgstr ""

msgid ""
"Therefore, it's not recommended to read global shader uniform values "
"continuously in a script. If you need to read values in a script after "
"setting them, consider creating an :ref:`autoload <doc_singletons_autoload>` "
"where you store the values you need to query at the same time you're setting "
"them as global uniforms."
msgstr ""

msgid "Per-instance uniforms"
msgstr ""

msgid "Per-instance uniforms are only available in ``spatial`` (3D) shaders."
msgstr ""

msgid ""
"Sometimes, you want to modify a parameter on each node using the material. "
"As an example, in a forest full of trees, when you want each tree to have a "
"slightly different color that is editable by hand. Without per-instance "
"uniforms, this requires creating a unique material for each tree (each with "
"a slightly different hue). This makes material management more complex, and "
"also has a performance overhead due to the scene requiring more unique "
"material instances. Vertex colors could also be used here, but they'd "
"require creating unique copies of the mesh for each different color, which "
"also has a performance overhead."
msgstr ""

msgid ""
"Per-instance uniforms are set on each GeometryInstance3D, rather than on "
"each Material instance. Take this into account when working with meshes that "
"have multiple materials assigned to them, or MultiMesh setups."
msgstr ""

msgid ""
"After saving the shader, you can change the per-instance uniform's value "
"using the inspector:"
msgstr ""

msgid ""
"Setting a per-instance uniform's value in the GeometryInstance3D section of "
"the inspector"
msgstr ""

msgid ""
"Per-instance uniform values can also be set at run-time using :ref:"
"`set_instance_shader_parameter "
"<class_GeometryInstance3D_method_set_instance_shader_parameter>` method on a "
"node that inherits from :ref:`class_GeometryInstance3D`:"
msgstr ""

msgid ""
"When using per-instance uniforms, there are some restrictions you should be "
"aware of:"
msgstr ""

msgid ""
"**Per-instance uniforms do not support textures**, only regular scalar and "
"vector types. As a workaround, you can pass a texture array as a regular "
"uniform, then pass the index of the texture to be drawn using a per-instance "
"uniform."
msgstr ""

msgid "There is a practical maximum limit of 16 instance uniforms per shader."
msgstr ""

msgid ""
"If your mesh uses multiple materials, the parameters for the first mesh "
"material found will \"win\" over the subsequent ones, unless they have the "
"same name, index *and* type. In this case, all parameters are affected "
"correctly."
msgstr ""

msgid ""
"If you run into the above situation, you can avoid clashes by manually "
"specifying the index (0-15) of the instance uniform by using the "
"``instance_index`` hint:"
msgstr ""

msgid "Built-in variables"
msgstr "Variáveis embutidas"

msgid ""
"A large number of built-in variables are available, like ``UV``, ``COLOR`` "
"and ``VERTEX``. What variables are available depends on the type of shader "
"(``spatial``, ``canvas_item`` or ``particle``) and the function used "
"(``vertex``, ``fragment`` or ``light``). For a list of the built-in "
"variables that are available, please see the corresponding pages:"
msgstr ""

msgid ":ref:`Spatial shaders <doc_spatial_shader>`"
msgstr ":ref:`Spatial shaders <doc_spatial_shader>`"

msgid ":ref:`Canvas item shaders <doc_canvas_item_shader>`"
msgstr ":ref:`Canvas item shaders <doc_canvas_item_shader>`"

msgid ":ref:`Particle shaders <doc_particle_shader>`"
msgstr ":ref:`Shading de particulas <doc_particle_shader>`"

#, fuzzy
msgid ":ref:`Sky shaders <doc_sky_shader>`"
msgstr ":ref:`Spatial shaders <doc_spatial_shader>`"

#, fuzzy
msgid ":ref:`Fog shaders <doc_fog_shader>`"
msgstr ":ref:`Spatial shaders <doc_spatial_shader>`"

msgid "Built-in functions"
msgstr "Funções embutidas"

msgid ""
"A large number of built-in functions are supported, conforming to GLSL ES "
"3.0. When vec_type (float), vec_int_type, vec_uint_type, vec_bool_type "
"nomenclature is used, it can be scalar or vector."
msgstr ""

msgid "Function"
msgstr "Função"

msgid "Description / Return value"
msgstr ""

msgid "vec_type **radians** (vec_type degrees)"
msgstr ""

#, fuzzy
msgid "Convert degrees to radians."
msgstr "Converter Recuo em Tabulação"

msgid "vec_type **degrees** (vec_type radians)"
msgstr ""

#, fuzzy
msgid "Convert radians to degrees."
msgstr "Converter Recuos em Espaços"

msgid "vec_type **sin** (vec_type x)"
msgstr ""

#, fuzzy
msgid "Sine."
msgstr "Seno"

msgid "vec_type **cos** (vec_type x)"
msgstr "vec_type **cos** (vec_type x)"

#, fuzzy
msgid "Cosine."
msgstr "Cosseno"

msgid "vec_type **tan** (vec_type x)"
msgstr "vec_type **tan** (vec_type x)"

#, fuzzy
msgid "Tangent."
msgstr "Tangente"

msgid "vec_type **asin** (vec_type x)"
msgstr "vec_type **asin** (vec_type x)"

#, fuzzy
msgid "Arcsine."
msgstr "Arco seno"

msgid "vec_type **acos** (vec_type x)"
msgstr "vec_type **acos** (vec_type x)"

#, fuzzy
msgid "Arccosine."
msgstr "Arco cosseno"

msgid "vec_type **atan** (vec_type y_over_x)"
msgstr "vec_type **atan** (vec_type y_over_x)"

#, fuzzy
msgid "Arctangent."
msgstr "Arco tangente"

msgid "vec_type **atan** (vec_type y, vec_type x)"
msgstr "vec_type **atan** (vec_type y, vec_type x)"

msgid "vec_type **sinh** (vec_type x)"
msgstr "vec_type **sinh** (vec_type x)"

#, fuzzy
msgid "Hyperbolic sine."
msgstr "Seno hiperbólico"

msgid "vec_type **cosh** (vec_type x)"
msgstr "vec_type **cosh** (vec_type x)"

#, fuzzy
msgid "Hyperbolic cosine."
msgstr "Cosseno hiperbólico"

msgid "vec_type **tanh** (vec_type x)"
msgstr "vec_type **tanh** (vec_type x)"

#, fuzzy
msgid "Hyperbolic tangent."
msgstr "Tangente hiperbólica"

msgid "vec_type **asinh** (vec_type x)"
msgstr "vec_type **asinh** (vec_type x)"

#, fuzzy
msgid "Inverse hyperbolic sine."
msgstr "Seno hiperbólico inverso"

msgid "vec_type **acosh** (vec_type x)"
msgstr "vec_type **acosh** (vec_type x)"

#, fuzzy
msgid "Inverse hyperbolic cosine."
msgstr "Cosseno hiperbólico inverso"

msgid "vec_type **atanh** (vec_type x)"
msgstr "vec_type **atanh** (vec_type x)"

#, fuzzy
msgid "Inverse hyperbolic tangent."
msgstr "Tangente hiperbólica inversa"

msgid "vec_type **pow** (vec_type x, vec_type y)"
msgstr "vec_type **pow** (vec_type x, vec_type y)"

#, fuzzy
msgid "Power (undefined if ``x`` < 0 or if ``x`` == 0 and ``y`` <= 0)."
msgstr "Potência (indefinida se ``x`` < 0 ou se ``x`` = 0 e ``y`` <= 0)"

msgid "vec_type **exp** (vec_type x)"
msgstr "vec_type **exp** (vec_type x)"

#, fuzzy
msgid "Base-e exponential."
msgstr "Base-e exponencial"

msgid "vec_type **exp2** (vec_type x)"
msgstr "vec_type **exp2** (vec_type x)"

#, fuzzy
msgid "Base-2 exponential."
msgstr "Base-2 exponencial"

msgid "vec_type **log** (vec_type x)"
msgstr "vec_type **log** (vec_type x)"

#, fuzzy
msgid "Natural logarithm."
msgstr "Logaritmo natural"

msgid "vec_type **log2** (vec_type x)"
msgstr "vec_type **log2** (vec_type x)"

#, fuzzy
msgid "Base-2 logarithm."
msgstr "Logaritmo de base 2"

msgid "vec_type **sqrt** (vec_type x)"
msgstr "vec_type **sqrt** (vec_type x)"

#, fuzzy
msgid "Square root."
msgstr "Raiz quadrada"

msgid "vec_type **inversesqrt** (vec_type x)"
msgstr "vec_type **inversesqrt** (vec_type x)"

#, fuzzy
msgid "Inverse square root."
msgstr "Raiz quadrada inversa"

msgid "vec_type **abs** (vec_type x)"
msgstr "vec_type **abs** (vec_type x)"

msgid "ivec_type **abs** (ivec_type x)"
msgstr "ivec_type **abs** (ivec_type x)"

msgid "Absolute value (returns positive value if negative)."
msgstr ""

msgid "vec_type **sign** (vec_type x)"
msgstr "vec_type **sign** (vec_type x)"

msgid "ivec_type **sign** (ivec_type x)"
msgstr "ivec_type **sign** (ivec_type x)"

msgid ""
"Sign (returns ``1.0`` if positive, ``-1.0`` if negative, ``0.0`` if zero)."
msgstr ""

msgid "vec_type **floor** (vec_type x)"
msgstr "vec_type **floor** (vec_type x)"

#, fuzzy
msgid "Round to the integer below."
msgstr "Arredondar para o número par mais próximo"

msgid "vec_type **round** (vec_type x)"
msgstr "vec_type **round** (vec_type x)"

#, fuzzy
msgid "Round to the nearest integer."
msgstr "Arredondar para o número par mais próximo"

msgid "vec_type **roundEven** (vec_type x)"
msgstr "vec_type **roundEven** (vec_type x)"

#, fuzzy
msgid "Round to the nearest even integer."
msgstr "Arredondar para o número par mais próximo"

msgid "vec_type **trunc** (vec_type x)"
msgstr "vec_type **trunc** (vec_type x)"

#, fuzzy
msgid "Truncation."
msgstr "Truncamento"

msgid "vec_type **ceil** (vec_type x)"
msgstr "vec_type **ceil** (vec_type x)"

#, fuzzy
msgid "Round to the integer above."
msgstr "Arredondar para o número par mais próximo"

msgid "vec_type **fract** (vec_type x)"
msgstr "vec_type **fract** (vec_type x)"

msgid "Fractional (returns ``x - floor(x)``)."
msgstr ""

msgid "vec_type **mod** (vec_type x, vec_type y)"
msgstr "vec_type **mod** (vec_type x, vec_type y)"

#, fuzzy
msgid "vec_type **mod** (vec_type x, float y)"
msgstr "vec_type **mod** (vec_type x , float y)"

#, fuzzy
msgid "Modulo (division remainder)."
msgstr "Multiplicação / Divisão / Resto"

msgid "vec_type **modf** (vec_type x, out vec_type i)"
msgstr "vec_type **modf** (vec_type x, out vec_type i)"

#, fuzzy
msgid "Fractional of ``x``, with ``i`` as integer part."
msgstr "Parte fracionária de ``x``, com ``i`` como parte inteira"

msgid "vec_type  **min** (vec_type a, vec_type b)"
msgstr "vec_type  **min** (vec_type a, vec_type b)"

msgid "Lowest value between ``a`` and ``b``."
msgstr ""

msgid "vec_type  **max** (vec_type a, vec_type b)"
msgstr "vec_type  **max** (vec_type a, vec_type b)"

#, fuzzy
msgid "Highest value between ``a`` and ``b``."
msgstr "Isso dará a cada peixe uma velocidade única entre ``2`` e ``10``."

msgid "vec_type **clamp** (vec_type x, vec_type min, vec_type max)"
msgstr "vec_type **clamp** (vec_type x, vec_type min, vec_type max)"

msgid "Clamp ``x`` between ``min`` and ``max`` (inclusive)."
msgstr ""

msgid "float **mix** (float a, float b, float c)"
msgstr "float **mix** (float a, float b, float c)"

msgid "vec_type **mix** (vec_type a, vec_type b, float c)"
msgstr "vec_type **mix** (vec_type a, vec_type b, float c)"

msgid "vec_type **mix** (vec_type a, vec_type b, bvec_type c)"
msgstr "vec_type **mix** (vec_type a, vec_type b, bvec_type c)"

msgid "Linear interpolate between ``a`` and ``b`` by ``c``."
msgstr ""

#, fuzzy
msgid "vec_type **fma** (vec_type a, vec_type b, vec_type c)"
msgstr "vec_type **mix** (vec_type a, vec_type b, vec_type c)"

msgid ""
"Performs a fused multiply-add operation: ``(a * b + c)`` (faster than doing "
"it manually)."
msgstr ""

msgid "vec_type **step** (vec_type a, vec_type b)"
msgstr "vec_type **step** (vec_type a, vec_type b)"

#, fuzzy
msgid "``b[i] < a[i] ? 0.0 : 1.0``."
msgstr "``b[i] < a[i] ? 0.0 : 1.0``"

msgid "vec_type **step** (float a, vec_type b)"
msgstr "vec_type **step** (float a, vec_type b)"

#, fuzzy
msgid "``b[i] < a ? 0.0 : 1.0``."
msgstr "``b[i] < a ? 0.0 : 1.0``"

msgid "vec_type **smoothstep** (vec_type a, vec_type b, vec_type c)"
msgstr "vec_type **smoothstep** (vec_type a, vec_type b, vec_type c)"

msgid "vec_type **smoothstep** (float a, float b, vec_type c)"
msgstr "vec_type **smoothstep** (float a, float b, vec_type c)"

msgid "Hermite interpolate between ``a`` and ``b`` by ``c``."
msgstr ""

msgid "bvec_type **isnan** (vec_type x)"
msgstr "bvec_type **isnan** (vec_type x)"

#, fuzzy
msgid "Returns ``true`` if scalar or vector component is ``NaN``."
msgstr "Retorna ``true`` se o componente escalar ou vetorial for ``NaN``"

msgid "bvec_type **isinf** (vec_type x)"
msgstr "bvec_type **isinf** (vec_type x)"

#, fuzzy
msgid "Returns ``true`` if scalar or vector component is ``INF``."
msgstr "Retorna ``true`` se o componente escalar ou vetorial for ``NaN``"

msgid "ivec_type **floatBitsToInt** (vec_type x)"
msgstr ""

msgid "Float->Int bit copying, no conversion."
msgstr ""

msgid "uvec_type **floatBitsToUint** (vec_type x)"
msgstr ""

msgid "Float->UInt bit copying, no conversion."
msgstr ""

msgid "vec_type **intBitsToFloat** (ivec_type x)"
msgstr ""

msgid "Int->Float bit copying, no conversion."
msgstr ""

msgid "vec_type **uintBitsToFloat** (uvec_type x)"
msgstr ""

msgid "UInt->Float bit copying, no conversion."
msgstr ""

msgid "float **length** (vec_type x)"
msgstr ""

#, fuzzy
msgid "Vector length."
msgstr "Tamanho do vetor"

msgid "float **distance** (vec_type a, vec_type b)"
msgstr ""

msgid "Distance between vectors i.e ``length(a - b)``."
msgstr ""

msgid "float **dot** (vec_type a, vec_type b)"
msgstr ""

#, fuzzy
msgid "Dot product."
msgstr "Projeto de demonstração"

msgid "vec3 **cross** (vec3 a, vec3 b)"
msgstr ""

#, fuzzy
msgid "Cross product."
msgstr "Promoção cruzada"

msgid "vec_type **normalize** (vec_type x)"
msgstr ""

msgid "Normalize to unit length."
msgstr ""

msgid "vec3 **reflect** (vec3 I, vec3 N)"
msgstr ""

#, fuzzy
msgid "Reflect."
msgstr "Refletir"

msgid "vec3 **refract** (vec3 I, vec3 N, float eta)"
msgstr ""

#, fuzzy
msgid "Refract."
msgstr "Refratar"

msgid "vec_type **faceforward** (vec_type N, vec_type I, vec_type Nref)"
msgstr ""

msgid "If ``dot(Nref, I)`` < 0, return ``N``, otherwise ``-N``."
msgstr ""

msgid "mat_type **matrixCompMult** (mat_type x, mat_type y)"
msgstr ""

#, fuzzy
msgid "Matrix component multiplication."
msgstr "Multiplicação escalar"

msgid "mat_type **outerProduct** (vec_type column, vec_type row)"
msgstr ""

msgid "Matrix outer product."
msgstr ""

msgid "mat_type **transpose** (mat_type m)"
msgstr ""

#, fuzzy
msgid "Transpose matrix."
msgstr "Transpor matriz"

msgid "float **determinant** (mat_type m)"
msgstr ""

#, fuzzy
msgid "Matrix determinant."
msgstr "Matriz determinante"

msgid "mat_type **inverse** (mat_type m)"
msgstr ""

#, fuzzy
msgid "Inverse matrix."
msgstr "Matriz inversa"

msgid "bvec_type **lessThan** (vec_type x, vec_type y)"
msgstr ""

msgid "Bool vector comparison on < int/uint/float vectors."
msgstr ""

msgid "bvec_type **greaterThan** (vec_type x, vec_type y)"
msgstr ""

msgid "Bool vector comparison on > int/uint/float vectors."
msgstr ""

msgid "bvec_type **lessThanEqual** (vec_type x, vec_type y)"
msgstr ""

msgid "Bool vector comparison on <= int/uint/float vectors."
msgstr ""

msgid "bvec_type **greaterThanEqual** (vec_type x, vec_type y)"
msgstr ""

msgid "Bool vector comparison on >= int/uint/float vectors."
msgstr ""

msgid "bvec_type **equal** (vec_type x, vec_type y)"
msgstr ""

msgid "Bool vector comparison on == int/uint/float vectors."
msgstr ""

msgid "bvec_type **notEqual** (vec_type x, vec_type y)"
msgstr ""

msgid "Bool vector comparison on != int/uint/float vectors."
msgstr ""

msgid "bool **any** (bvec_type x)"
msgstr ""

msgid "``true`` if any component is ``true``, ``false`` otherwise."
msgstr ""

msgid "bool **all** (bvec_type x)"
msgstr ""

msgid "``true`` if all components are ``true``, ``false`` otherwise."
msgstr ""

msgid "bvec_type **not** (bvec_type x)"
msgstr ""

#, fuzzy
msgid "Invert boolean vector."
msgstr "Inverter vetor booleano"

#, fuzzy
msgid "ivec2 **textureSize** (gsampler2D s, int lod)"
msgstr "ivec2 **textureSize** ( sampler2D_type s, int lod )"

#, fuzzy
msgid "ivec3 **textureSize** (gsampler2DArray s, int lod)"
msgstr "ivec2 **textureSize** ( sampler2D_type s, int lod )"

#, fuzzy
msgid "ivec3 **textureSize** (gsampler3D s, int lod)"
msgstr "ivec2 **textureSize** ( samplerCube s, int lod )"

msgid "ivec2 **textureSize** (samplerCube s, int lod)"
msgstr ""

#, fuzzy
msgid "ivec2 **textureSize** (samplerCubeArray s, int lod)"
msgstr "ivec2 **textureSize** ( samplerCube s, int lod )"

#, fuzzy
msgid "Get the size of a texture."
msgstr "Mudança de textura."

msgid ""
"The LOD defines which mipmap level is used. An LOD value of ``0`` will use "
"the full resolution texture."
msgstr ""

#, fuzzy
msgid "vec2 **textureQueryLod** (gsampler2D s, vec2 p)"
msgstr "ivec2 **textureSize** ( sampler2D_type s, int lod )"

#, fuzzy
msgid "vec3 **textureQueryLod** (gsampler2DArray s, vec2 p)"
msgstr "ivec2 **textureSize** ( sampler2D_type s, int lod )"

#, fuzzy
msgid "vec2 **textureQueryLod** (gsampler3D s, vec3 p)"
msgstr "ivec2 **textureSize** ( samplerCube s, int lod )"

#, fuzzy
msgid "vec2 **textureQueryLod** (samplerCube s, vec3 p)"
msgstr "ivec2 **textureSize** ( samplerCube s, int lod )"

msgid ""
"Compute the level-of-detail that would be used to sample from a texture. The "
"``x`` component of the resulted value is the mipmap array that would be "
"accessed. The ``y`` component is computed level-of-detail relative to the "
"base level (regardless of the mipmap levels of the texture)."
msgstr ""

#, fuzzy
msgid "int **textureQueryLevels** (gsampler2D s)"
msgstr "ivec2 **textureSize** ( sampler2D_type s, int lod )"

msgid "int **textureQueryLevels** (gsampler2DArray s)"
msgstr ""

msgid "int **textureQueryLevels** (gsampler3D s)"
msgstr ""

#, fuzzy
msgid "int **textureQueryLevels** (samplerCube s)"
msgstr "ivec2 **textureSize** ( samplerCube s, int lod )"

msgid "Get the number of accessible mipmap levels of a texture."
msgstr ""

msgid ""
"If the texture is unassigned to a sampler, ``1`` is returned (Godot always "
"internally assigns a texture even to an empty sampler)."
msgstr ""

#, fuzzy
msgid "gvec4_type **texture** (gsampler2D s, vec2 p [, float bias])"
msgstr "vec4_type **texture** ( sampler_type s, vec_type uv [, float bias] )"

#, fuzzy
msgid "gvec4_type **texture** (gsampler2DArray s, vec3 p [, float bias])"
msgstr "vec4_type **texture** ( sampler_type s, vec_type uv [, float bias] )"

#, fuzzy
msgid "gvec4_type **texture** (gsampler3D s, vec3 p [, float bias])"
msgstr "vec4_type **texture** ( sampler_type s, vec_type uv [, float bias] )"

#, fuzzy
msgid "vec4 **texture** (samplerCube s, vec3 p [, float bias])"
msgstr "vec4_type **texture** ( sampler_type s, vec_type uv [, float bias] )"

#, fuzzy
msgid "vec4 **texture** (samplerCubeArray s, vec4 p [, float bias])"
msgstr "vec4_type **texture** ( sampler_type s, vec_type uv [, float bias] )"

msgid "Perform a texture read."
msgstr ""

#, fuzzy
msgid "gvec4_type **textureProj** (gsampler2D s, vec3 p [, float bias])"
msgstr ""
"vec4_type **textureProj** ( sampler_type s, vec_type uv [, float bias] )"

#, fuzzy
msgid "gvec4_type **textureProj** (gsampler2D s, vec4 p [, float bias])"
msgstr ""
"vec4_type **textureProj** ( sampler_type s, vec_type uv [, float bias] )"

#, fuzzy
msgid "gvec4_type **textureProj** (gsampler3D s, vec4 p [, float bias])"
msgstr ""
"vec4_type **textureProj** ( sampler_type s, vec_type uv [, float bias] )"

msgid "Perform a texture read with projection."
msgstr ""

#, fuzzy
msgid "gvec4_type **textureLod** (gsampler2D s, vec2 p, float lod)"
msgstr "vec4_type **textureLod** ( sampler_type s, vec_type uv, float lod )"

#, fuzzy
msgid "gvec4_type **textureLod** (gsampler2DArray s, vec3 p, float lod)"
msgstr "vec4_type **textureLod** ( sampler_type s, vec_type uv, float lod )"

#, fuzzy
msgid "gvec4_type **textureLod** (gsampler3D s, vec3 p, float lod)"
msgstr "vec4_type **textureLod** ( sampler_type s, vec_type uv, float lod )"

#, fuzzy
msgid "vec4 **textureLod** (samplerCube s, vec3 p, float lod)"
msgstr "vec4_type **textureLod** ( sampler_type s, vec_type uv, float lod )"

#, fuzzy
msgid "vec4 **textureLod** (samplerCubeArray s, vec4 p, float lod)"
msgstr "vec4_type **textureLod** ( sampler_type s, vec_type uv, float lod )"

msgid "Perform a texture read at custom mipmap."
msgstr ""

msgid ""
"The LOD defines which mipmap level is used. An LOD value of ``0.0`` will use "
"the full resolution texture. If the texture lacks mipmaps, all LOD values "
"will act like ``0.0``."
msgstr ""

#, fuzzy
msgid "gvec4_type **textureProjLod** (gsampler2D s, vec3 p, float lod)"
msgstr ""
"vec4_type **textureProjLod** ( sampler_type s, vec_type uv, float lod )"

#, fuzzy
msgid "gvec4_type **textureProjLod** (gsampler2D s, vec4 p, float lod)"
msgstr ""
"vec4_type **textureProjLod** ( sampler_type s, vec_type uv, float lod )"

#, fuzzy
msgid "gvec4_type **textureProjLod** (gsampler3D s, vec4 p, float lod)"
msgstr ""
"vec4_type **textureProjLod** ( sampler_type s, vec_type uv, float lod )"

msgid "Performs a texture read with projection/LOD."
msgstr ""

#, fuzzy
msgid "gvec4_type **textureGrad** (gsampler2D s, vec2 p, vec2 dPdx, vec2 dPdy)"
msgstr ""
"vec4_type **textureGrad** ( sampler_type s, vec_type uv, vec_type dPdx, "
"vec_type dPdy )"

#, fuzzy
msgid ""
"gvec4_type **textureGrad** (gsampler2DArray s, vec3 p, vec2 dPdx, vec2 dPdy)"
msgstr ""
"vec4_type **textureGrad** ( sampler_type s, vec_type uv, vec_type dPdx, "
"vec_type dPdy )"

#, fuzzy
msgid "gvec4_type **textureGrad** (gsampler3D s, vec3 p, vec2 dPdx, vec2 dPdy)"
msgstr ""
"vec4_type **textureGrad** ( sampler_type s, vec_type uv, vec_type dPdx, "
"vec_type dPdy )"

#, fuzzy
msgid "vec4 **textureGrad** (samplerCube s, vec3 p, vec3 dPdx, vec3 dPdy)"
msgstr ""
"vec4_type **textureGrad** ( sampler_type s, vec_type uv, vec_type dPdx, "
"vec_type dPdy )"

#, fuzzy
msgid "vec4 **textureGrad** (samplerCubeArray s, vec3 p, vec3 dPdx, vec3 dPdy)"
msgstr ""
"vec4_type **textureGrad** ( sampler_type s, vec_type uv, vec_type dPdx, "
"vec_type dPdy )"

msgid "Performs a texture read with explicit gradients."
msgstr ""

#, fuzzy
msgid ""
"gvec4_type **textureProjGrad** (gsampler2D s, vec3 p, vec2 dPdx, vec2 dPdy)"
msgstr ""
"vec4_type **textureGrad** ( sampler_type s, vec_type uv, vec_type dPdx, "
"vec_type dPdy )"

#, fuzzy
msgid ""
"gvec4_type **textureProjGrad** (gsampler2D s, vec4 p, vec2 dPdx, vec2 dPdy)"
msgstr ""
"vec4_type **textureGrad** ( sampler_type s, vec_type uv, vec_type dPdx, "
"vec_type dPdy )"

#, fuzzy
msgid ""
"gvec4_type **textureProjGrad** (gsampler3D s, vec4 p, vec3 dPdx, vec3 dPdy)"
msgstr ""
"vec4_type **textureGrad** ( sampler_type s, vec_type uv, vec_type dPdx, "
"vec_type dPdy )"

msgid ""
"Performs a texture read with projection/LOD and with explicit gradients."
msgstr ""

#, fuzzy
msgid "gvec4_type **texelFetch** (gsampler2D s, ivec2 p, int lod)"
msgstr "vec4_type **textureLod** ( sampler_type s, vec_type uv, float lod )"

#, fuzzy
msgid "gvec4_type **texelFetch** (gsampler2DArray s, ivec3 p, int lod)"
msgstr "vec4_type **textureLod** ( sampler_type s, vec_type uv, float lod )"

#, fuzzy
msgid "gvec4_type **texelFetch** (gsampler3D s, ivec3 p, int lod)"
msgstr "vec4_type **textureLod** ( sampler_type s, vec_type uv, float lod )"

msgid "Fetches a single texel using integer coordinates."
msgstr ""

#, fuzzy
msgid "gvec4_type **textureGather** (gsampler2D s, vec2 p [, int comps])"
msgstr "vec4_type **texture** ( sampler_type s, vec_type uv [, float bias] )"

#, fuzzy
msgid "gvec4_type **textureGather** (gsampler2DArray s, vec3 p [, int comps])"
msgstr "vec4_type **texture** ( sampler_type s, vec_type uv [, float bias] )"

#, fuzzy
msgid "vec4 **textureGather** (samplerCube s, vec3 p [, int comps])"
msgstr "ivec2 **textureSize** ( samplerCube s, int lod )"

msgid ""
"Gathers four texels from a texture. Use ``comps`` within range of 0..3 to "
"define which component (x, y, z, w) is returned. If ``comps`` is not "
"provided: 0 (or x-component) is used."
msgstr ""

msgid "vec_type **dFdx** (vec_type p)"
msgstr ""

msgid ""
"Derivative in ``x`` using local differencing. Internally, can use either "
"``dFdxCoarse`` or ``dFdxFine``, but the decision for which to use is made by "
"the GPU driver."
msgstr ""

#, fuzzy
msgid "vec_type **dFdxCoarse** (vec_type p)"
msgstr "vec_type **dFdx** ( vec_type p )"

msgid ""
"Calculates derivative with respect to ``x`` window coordinate using local "
"differencing based on the value of ``p`` for the current fragment "
"neighbour(s), and will possibly, but not necessarily, include the value for "
"the current fragment. This function is not available on ``gl_compatibility`` "
"profile."
msgstr ""

#, fuzzy
msgid "vec_type **dFdxFine** (vec_type p)"
msgstr "vec_type **dFdx** ( vec_type p )"

msgid ""
"Calculates derivative with respect to ``x`` window coordinate using local "
"differencing based on the value of ``p`` for the current fragment and its "
"immediate neighbour(s). This function is not available on "
"``gl_compatibility`` profile."
msgstr ""

msgid "vec_type **dFdy** (vec_type p)"
msgstr ""

msgid ""
"Derivative in ``y`` using local differencing. Internally, can use either "
"``dFdyCoarse`` or ``dFdyFine``, but the decision for which to use is made by "
"the GPU driver."
msgstr ""

#, fuzzy
msgid "vec_type **dFdyCoarse** (vec_type p)"
msgstr "vec_type **dFdy** ( vec_type p )"

msgid ""
"Calculates derivative with respect to ``y`` window coordinate using local "
"differencing based on the value of ``p`` for the current fragment "
"neighbour(s), and will possibly, but not necessarily, include the value for "
"the current fragment. This function is not available on ``gl_compatibility`` "
"profile."
msgstr ""

#, fuzzy
msgid "vec_type **dFdyFine** (vec_type p)"
msgstr "vec_type **dFdy** ( vec_type p )"

msgid ""
"Calculates derivative with respect to ``y`` window coordinate using local "
"differencing based on the value of ``p`` for the current fragment and its "
"immediate neighbour(s). This function is not available on "
"``gl_compatibility`` profile."
msgstr ""

msgid "vec_type **fwidth** (vec_type p)"
msgstr ""

msgid ""
"Sum of absolute derivative in ``x`` and ``y``. This is the equivalent of "
"using ``abs(dFdx(p)) + abs(dFdy(p))``."
msgstr ""

#, fuzzy
msgid "vec_type **fwidthCoarse** (vec_type p)"
msgstr "vec_type **fwidth** ( vec_type p )"

msgid ""
"Sum of absolute derivative in ``x`` and ``y``. This is the equivalent of "
"using ``abs(dFdxCoarse(p)) + abs(dFdyCoarse(p))``. This function is not "
"available on ``gl_compatibility`` profile."
msgstr ""

#, fuzzy
msgid "vec_type **fwidthFine** (vec_type p)"
msgstr "vec_type **fwidth** ( vec_type p )"

msgid ""
"Sum of absolute derivative in ``x`` and ``y``. This is the equivalent of "
"using ``abs(dFdxFine(p)) + abs(dFdyFine(p))``. This function is not "
"available on ``gl_compatibility`` profile."
msgstr ""

msgid "uint **packHalf2x16** (vec2 v)"
msgstr ""

msgid "vec2 **unpackHalf2x16** (uint v)"
msgstr ""

msgid ""
"Convert two 32-bit floating-point numbers into 16-bit and pack them into a "
"32-bit unsigned integer and vice-versa."
msgstr ""

msgid "uint **packUnorm2x16** (vec2 v)"
msgstr ""

msgid "vec2 **unpackUnorm2x16** (uint v)"
msgstr ""

msgid ""
"Convert two 32-bit floating-point numbers (clamped within 0..1 range) into "
"16-bit and pack them into a 32-bit unsigned integer and vice-versa."
msgstr ""

msgid "uint **packSnorm2x16** (vec2 v)"
msgstr ""

msgid "vec2 **unpackSnorm2x16** (uint v)"
msgstr ""

msgid ""
"Convert two 32-bit floating-point numbers (clamped within -1..1 range) into "
"16-bit and pack them into a 32-bit unsigned integer and vice-versa."
msgstr ""

msgid "uint **packUnorm4x8** (vec4 v)"
msgstr ""

msgid "vec4 **unpackUnorm4x8** (uint v)"
msgstr ""

msgid ""
"Convert four 32-bit floating-point numbers (clamped within 0..1 range) into "
"8-bit and pack them into a 32-bit unsigned integer and vice-versa."
msgstr ""

msgid "uint **packSnorm4x8** (vec4 v)"
msgstr ""

msgid "vec4 **unpackSnorm4x8** (uint v)"
msgstr ""

msgid ""
"Convert four 32-bit floating-point numbers (clamped within -1..1 range) into "
"8-bit and pack them into a 32-bit unsigned integer and vice-versa."
msgstr ""

#, fuzzy
msgid "ivec_type **bitfieldExtract** (ivec_type value, int offset, int bits)"
msgstr "vec_type **step** (vec_type a, vec_type b)"

#, fuzzy
msgid "uvec_type **bitfieldExtract** (uvec_type value, int offset, int bits)"
msgstr "vec_type **step** (vec_type a, vec_type b)"

msgid "Extracts a range of bits from an integer."
msgstr ""

#, fuzzy
msgid ""
"ivec_type **bitfieldInsert** (ivec_type base, ivec_type insert, int offset, "
"int bits)"
msgstr "vec_type **mix** (vec_type a, vec_type b, float c)"

#, fuzzy
msgid ""
"uvec_type **bitfieldInsert** (uvec_type base, uvec_type insert, int offset, "
"int bits)"
msgstr "vec_type **mix** (vec_type a, vec_type b, float c)"

msgid "Insert a range of bits into an integer."
msgstr ""

#, fuzzy
msgid "ivec_type **bitfieldReverse** (ivec_type value)"
msgstr "ivec_type **abs** (ivec_type x)"

#, fuzzy
msgid "uvec_type **bitfieldReverse** (uvec_type value)"
msgstr "vec_type **inversesqrt** (vec_type x)"

msgid "Reverse the order of bits in an integer."
msgstr ""

#, fuzzy
msgid "ivec_type **bitCount** (ivec_type value)"
msgstr "ivec_type **sign** (ivec_type x)"

#, fuzzy
msgid "uvec_type **bitCount** (uvec_type value)"
msgstr "vec_type **round** (vec_type x)"

msgid "Counts the number of 1 bits in an integer."
msgstr ""

#, fuzzy
msgid "ivec_type **findLSB** (ivec_type value)"
msgstr "ivec_type **sign** (ivec_type x)"

#, fuzzy
msgid "uvec_type **findLSB** (uvec_type value)"
msgstr "vec_type **asin** (vec_type x)"

msgid "Find the index of the least significant bit set to 1 in an integer."
msgstr ""

#, fuzzy
msgid "ivec_type **findMSB** (ivec_type value)"
msgstr "ivec_type **sign** (ivec_type x)"

#, fuzzy
msgid "uvec_type **findMSB** (uvec_type value)"
msgstr "vec_type **asin** (vec_type x)"

msgid "Find the index of the most significant bit set to 1 in an integer."
msgstr ""

#, fuzzy
msgid ""
"void **imulExtended** (ivec_type x, ivec_type y, out ivec_type msb, out "
"ivec_type lsb)"
msgstr "vec_type **mix** (vec_type a, vec_type b, vec_type c)"

#, fuzzy
msgid ""
"void **umulExtended** (uvec_type x, uvec_type y, out uvec_type msb, out "
"uvec_type lsb)"
msgstr "vec_type **mix** (vec_type a, vec_type b, vec_type c)"

msgid ""
"Multiplies two 32-bit numbers and produce a 64-bit result. ``x`` - the first "
"number. ``y`` - the second number. ``msb`` - will contain the most "
"significant bits. ``lsb`` - will contain the least significant bits."
msgstr ""

#, fuzzy
msgid "uvec_type **uaddCarry** (uvec_type x, uvec_type y, out uvec_type carry)"
msgstr "vec_type **mix** (vec_type a, vec_type b, vec_type c)"

msgid "Adds two unsigned integers and generates carry."
msgstr ""

#, fuzzy
msgid ""
"uvec_type **usubBorrow** (uvec_type x, uvec_type y, out uvec_type borrow)"
msgstr "vec_type **smoothstep** (vec_type a, vec_type b, vec_type c)"

msgid "Subtracts two unsigned integers and generates borrow."
msgstr ""

#, fuzzy
msgid "vec_type **ldexp** (vec_type x, out ivec_type exp)"
msgstr "vec_type **modf** (vec_type x, out vec_type i)"

msgid "Assemble a floating-point number from a value and exponent."
msgstr ""

msgid ""
"If this product is too large to be represented in the floating-point type "
"the result is undefined."
msgstr ""

#, fuzzy
msgid "vec_type **frexp** (vec_type x, out ivec_type exp)"
msgstr "vec_type **modf** (vec_type x, out vec_type i)"

msgid ""
"Splits a floating-point number(``x``) into significand (in the range of "
"[0.5, 1.0]) and an integral exponent."
msgstr ""

msgid ""
"For ``x`` equals zero the significand and exponent are both zero. For ``x`` "
"of infinity or NaN, the results are undefined."
msgstr ""

msgid "Translation status"
msgstr "Progresso da Tradução"
