# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#, fuzzy
msgid "High-level multiplayer"
msgstr "하이 레벨 멀티플레이어(High level multiplayer)"

#, fuzzy
msgid "High-level vs low-level API"
msgstr "하이 레벨 vs 로우 레벨 API(High level vs low level API)"

msgid ""
"The following explains the differences of high- and low-level networking in "
"Godot as well as some fundamentals. If you want to jump in head-first and "
"add networking to your first nodes, skip to `Initializing the network`_ "
"below. But make sure to read the rest later on!"
msgstr ""
"여기부터는 몇 가지 기본 사항과 함께, Godot에서 하이 레벨 네트워킹과 로우 레"
"벨 네트워킹의 차이를 설명합니다. 바로 실전으로 가서 첫 노드에 네트워킹을 추가"
"하고 싶다면, 아래의 `네트워크 초기화하기(Initializing the network)`_\\ 로 건"
"너 뛰세요. 하지만 나중에라도 이 부분을 읽어주세요!"

#, fuzzy
msgid ""
"Godot always supported standard low-level networking via :abbr:`UDP (User "
"Datagram Protocol)`, :abbr:`TCP (Transmission Control Protocol)` and some "
"higher-level protocols such as :abbr:`HTTP (Hypertext Transfer Protocol)` "
"and :abbr:`SSL (Secure Sockets Layer)`. These protocols are flexible and can "
"be used for almost anything. However, using them to synchronize game state "
"manually can be a large amount of work. Sometimes that work can't be avoided "
"or is worth it, for example when working with a custom server implementation "
"on the backend. But in most cases, it's worthwhile to consider Godot's high-"
"level networking API, which sacrifices some of the fine-grained control of "
"low-level networking for greater ease of use."
msgstr ""
"Godot는 항상 UDP, TCP, 그 외 SSL이나 HTTP와 같은 일부 하이 레벨 프로토콜을 통"
"해, 일반적인 로우 레벨 네트워킹을 지원했습니다. 이 프로토콜은 유연하고 거의 "
"모든 것에 사용될 수 있습니다. 하지만 게임 상태를 일일이 동기화하기 위해 이 프"
"로토콜을 사용하는 일은 많은 작업이 필요합니다. 때로는 그 작업이 필요하고, 가"
"치가 있습니다. 예를 들면 백엔드에서 맞춤 서버 구현을 작업할 때가 있죠. 하지"
"만, 대부분의 경우, Godot의 하이 레벨 네트워킹 API를 생각하게 만들었습니다. 쉽"
"게 쓸 수 있지만, 로우 레벨 네트워킹의 세밀한 제어를 희생하죠."

msgid "This is due to the inherent limitations of the low-level protocols:"
msgstr "이는 로우 레벨 프로토콜의 고유의 한계 때문입니다:"

msgid ""
"TCP ensures packets will always arrive reliably and in order, but latency is "
"generally higher due to error correction. It's also quite a complex protocol "
"because it understands what a \"connection\" is, and optimizes for goals "
"that often don't suit applications like multiplayer games. Packets are "
"buffered to be sent in larger batches, trading less per-packet overhead for "
"higher latency. This can be useful for things like HTTP, but generally not "
"for games. Some of this can be configured and disabled (e.g. by disabling "
"\"Nagle's algorithm\" for the TCP connection)."
msgstr ""
"TCP는 패킷(Packet)이 항상 안전하게 도착하도록 보장합니다. 하지만 오류 연결 때"
"문에 지연 시간은 점진적으로 길어집니다. 이 또한 복잡한 프로토콜입니다. 왜냐하"
"면 무엇이 \"연결(Connection)\"인지를 이해해야 하고, 멀티플레이어 게임과 같은 "
"애플리케이션과는 맞지 않은 목적을 이루기 위해 최적화를 해야 합니다. 패킷은 "
"더 큰 배치(Batch)로 전송되도록 버퍼링됩니다. 그렇게 되면 전달하는 패킷 당 오"
"버헤드(Overhead)는 줄어들고 지연 시간이 길어집니다. 이는 HTTP에는 유용하겠지"
"만, 일반적인 게임에는 아니죠. 일부 프로토콜은 이를 설정하거나 끌 수 있습니"
"다. (예: TCP 연결의 \"네이글 알고리즘(Nagle Algorithm)\"을 끔)."

msgid ""
"UDP is a simpler protocol, which only sends packets (and has no concept of a "
"\"connection\"). No error correction makes it pretty quick (low latency), "
"but packets may be lost along the way or received in the wrong order. Added "
"to that, the MTU (maximum packet size) for UDP is generally low (only a few "
"hundred bytes), so transmitting larger packets means splitting them, "
"reorganizing them and retrying if a part fails."
msgstr ""
"UDP는 더 간단한 프로토콜로, 패킷을 보내기만 합니다 (즉, \"연결"
"(Connection)\"의 개념이 없습니다). 오류 연결이 없어서 꽤 빠릅니다 (짧은 지연 "
"시간). 하지만 패킷을 보내는 과정에서 잃을 수 있고, 잘못된 상대방이 받을 수 있"
"습니다. 게다가, UDP의 MTU (최대 패킷 크기)는 (겨우 몇 백 바이트로) 보통 낮습"
"니다. 따라서 더 큰 패킷을 전송하려면 패킷을 분리하고, 다시 구조화하고, 만일 "
"일부분이 잘못되면 다시 시도해야 합니다."

msgid ""
"In general, TCP can be thought of as reliable, ordered, and slow; UDP as "
"unreliable, unordered and fast. Because of the large difference in "
"performance, it often makes sense to re-build the parts of TCP wanted for "
"games (optional reliability and packet order), while avoiding the unwanted "
"parts (congestion/traffic control features, Nagle's algorithm, etc). Due to "
"this, most game engines come with such an implementation, and Godot is no "
"exception."
msgstr ""
"보통은, TCP를 신뢰할 수 있고 질서 있고 느리다고 생각할 수 있습니다. 반대로 "
"UDP는 신뢰할 수 없고, 무질서하며, 빠르다고 생각하겠죠. 그 이유는 둘 간의 큰 "
"성능 차이입니다. 종종 게임에 필요한 TCP 부분을 새로 만드는 것이 합리적이기도 "
"합니다 (선택적인 안정성과 패킷 순서). 그러면서 원하지 않은 부분은 피할 수 있"
"으니까요 (혼잡(Congestion)/트래픽(traffic) 제어 기능, 네이글 알고리즘 등). "
"이 때문에 대부분의 게임 엔진은 이러한 네트워킹 구현을 제공합니다. Godot 역시 "
"예외가 아니죠."

msgid ""
"In summary, you can use the low-level networking API for maximum control and "
"implement everything on top of bare network protocols or use the high-level "
"API based on :ref:`SceneTree <class_SceneTree>` that does most of the heavy "
"lifting behind the scenes in a generally optimized way."
msgstr ""
"요약해서 말하자면, 최대한의 제어와 순수한 네트워크 프로토콜에서 모든 것을 구"
"현하려면, 로우 레벨 네트워킹 API를 사용할 수 있습니다. 혹은 일반적으로 최적"
"화 된 방식에서 씬 뒤로 대부분의 무거운 리프팅을 수행하는 :ref:`SceneTree(씬 "
"트리) <class_SceneTree>`\\ 에서 하이 레벨 API를 사용할 수 있습니다."

#, fuzzy
msgid ""
"Most of Godot's supported platforms offer all or most of the mentioned high- "
"and low-level networking features. As networking is always largely hardware "
"and operating system dependent, however, some features may change or not be "
"available on some target platforms. Most notably, the HTML5 platform "
"currently offers WebSockets and WebRTC support but lacks some of the higher-"
"level features, as well as raw access to low-level protocols like TCP and "
"UDP."
msgstr ""
"Godot의 지원하는 플랫폼 대부분은 앞서 언급한 하이 레벨과 로우 레벨 네트워킹 "
"기능을 거의 전부 제공합니다. 그러나 네트워킹은 항상 하드웨어와 운영체제에 따"
"라 크게 달라지므로, 일부 기능은 특정 플랫폼에서 달라지거나 이용할 수 없을지"
"도 모릅니다. 가장 주목할 것으로, HTML5 플랫폼은 현재로써 오직 WebSocket 지원"
"을 제공하고 하이 레벨 기능은 부족하고, TCP 및 UDP와 같은 로우 레벨 프로토콜"
"로 원시 접근만 지원합니다."

#, fuzzy
msgid ""
"More about TCP/IP, UDP, and networking: https://gafferongames.com/post/"
"udp_vs_tcp/"
msgstr ""
"TCP/IP, UDP, 네트워킹에 더 알아보세요: https://gafferongames.com/post/"
"udp_vs_tcp/"

#, fuzzy
msgid ""
"Gaffer On Games has a lot of useful articles about networking in Games "
"(`here <https://gafferongames.com/categories/game-networking/>`__), "
"including the comprehensive `introduction to networking models in games "
"<https://gafferongames.com/post/"
"what_every_programmer_needs_to_know_about_game_networking/>`__."
msgstr ""
"Gaffer On Games에는 게임의 네트워크에 관한 많은 유용한 기사가 있습니다 (`여기"
"로 <https://gafferongames.com/tags/networking>`__). 기사 중에는 포괄적인 `게"
"임에서 네트워킹 모델 소개 <https://gafferongames.com/post/"
"what_every_programmer_needs_to_know_about_game_networking/>`__\\ 도 있습니다."

msgid ""
"If you want to use your low-level networking library of choice instead of "
"Godot's built-in networking, see here for an example: https://github.com/"
"PerduGames/gdnet3"
msgstr ""
"Godot의 내장 네트워킹 대신 로우 레벨 네트워킹 라이브러리를 쓰고 싶다면, 여기"
"서 예제를 확인하세요: https://github.com/PerduGames/gdnet3"

#, fuzzy
msgid ""
"Adding networking to your game comes with some responsibility. It can make "
"your application vulnerable if done wrong and may lead to cheats or "
"exploits. It may even allow an attacker to compromise the machines your "
"application runs on and use your servers to send spam, attack others or "
"steal your users' data if they play your game."
msgstr ""
"게임에 네트워킹을 추가하는 일은 책임도 따릅니다. 이 작업은 애플리케이션이 잘"
"못되어 사기나 착취에 취약해질 수 있습니다. 게다가 공격자가 실행 중인 애플리케"
"이션의 시스템을 손상시키고, 서버를 통해 스팸을 보내거나, 다른 이를 공격하고, "
"게임을 하고 있던 사용자 정보를 훔칠 수도 있습니다."

msgid ""
"This is always the case when networking is involved and has nothing to do "
"with Godot. You can of course experiment, but when you release a networked "
"application, always take care of any possible security concerns."
msgstr ""
"이 일은 네트워킹에 관련되어 있고 Godot와는 관련이 없는 경우입니다. 물론 시험"
"을 해볼 수는 있지만, 네트워크가 연결된 애플리케이션을 출시하면, 가능한 보안 "
"문제를 항상 관리하세요."

#, fuzzy
msgid "Mid-level abstraction"
msgstr "중급 추상화(Mid level abstraction)"

msgid ""
"Before going into how we would like to synchronize a game across the "
"network, it can be helpful to understand how the base network API for "
"synchronization works."
msgstr ""
"어떻게 네트워크를 통해 게임을 동기화할 지 알아보기 전에, 기본 네트워크 API가 "
"어떻게 동기화에 작동하는지 이해하는 것이 좋습니다."

#, fuzzy
msgid ""
"Godot uses a mid-level object :ref:`MultiplayerPeer "
"<class_MultiplayerPeer>`. This object is not meant to be created directly, "
"but is designed so that several C++ implementations can provide it."
msgstr ""
"Godot는 중급(mid level) 오브젝트로 :ref:`NetworkedMultiplayerPeer "
"<class_NetworkedMultiplayerPeer>`\\ 를 사용합니다. 이 오브젝트는 바로 네트워"
"크를 만드는 것은 아니지만, 설계를 함으로써 여러 C++ 구현 기능을 제공합니다."

msgid ""
"This object extends from :ref:`PacketPeer <class_PacketPeer>`, so it "
"inherits all the useful methods for serializing, sending and receiving data. "
"On top of that, it adds methods to set a peer, transfer mode, etc. It also "
"includes signals that will let you know when peers connect or disconnect."
msgstr ""
"이 오브젝트는 :ref:`PacketPeer <class_PacketPeer>`\\ 에서 확장됩니다. 따라서 "
"직렬화(Serialize), 데이터 보내기 및 받기에 유용한 메서드를 갖습니다. 또한 피"
"어(Peer), 전송 모드(Transfer Mode) 등을 설정하는 메서드를 추가합니다. 그리고 "
"시그널을 갖고 있어 언제 피어가 연결되고 끊기는지 알 수 있습니다."

msgid ""
"This class interface can abstract most types of network layers, topologies "
"and libraries. By default, Godot provides an implementation based on ENet (:"
"ref:`ENetMultiplayerPeer <class_ENetMultiplayerPeer>`), one based on WebRTC "
"(:ref:`WebRTCMultiplayerPeer <class_WebRTCMultiplayerPeer>`), and one based "
"on WebSocket (:ref:`WebSocketPeer <class_WebSocketPeer>`), but this could be "
"used to implement mobile APIs (for ad hoc WiFi, Bluetooth) or custom device/"
"console-specific networking APIs."
msgstr ""

msgid ""
"For most common cases, using this object directly is discouraged, as Godot "
"provides even higher level networking facilities. This object is still made "
"available in case a game has specific needs for a lower-level API."
msgstr ""

#, fuzzy
msgid "Hosting considerations"
msgstr "내보내기 고려 사항"

msgid ""
"When hosting a server, clients on your :abbr:`LAN (Local Area Network)` can "
"connect using the internal IP address which is usually of the form ``192.168."
"*.*``. This internal IP address is **not** reachable by non-LAN/Internet "
"clients."
msgstr ""

msgid ""
"On Windows, you can find your internal IP address by opening a command "
"prompt and entering ``ipconfig``. On macOS, open a Terminal and enter "
"``ifconfig``. On Linux, open a terminal and enter ``ip addr``."
msgstr ""

msgid ""
"If you're hosting a server on your own machine and want non-LAN clients to "
"connect to it, you'll probably have to *forward* the server port on your "
"router. This is required to make your server reachable from the Internet "
"since most residential connections use a `NAT <https://en.wikipedia.org/wiki/"
"Network_address_translation>`__. Godot's high-level multiplayer API only "
"uses UDP, so you must forward the port in UDP, not just TCP."
msgstr ""

msgid ""
"After forwarding an UDP port and making sure your server uses that port, you "
"can use `this website <https://icanhazip.com/>`__ to find your public IP "
"address. Then give this public IP address to any Internet clients that wish "
"to connect to your server."
msgstr ""

msgid ""
"Godot's high-level multiplayer API uses a modified version of ENet which "
"allows for full IPv6 support."
msgstr ""

msgid "Initializing the network"
msgstr ""

msgid ""
"High level networking in Godot is managed by the :ref:`SceneTree "
"<class_SceneTree>`."
msgstr ""

msgid ""
"Each node has a ``multiplayer`` property, which is a reference to the "
"``MultiplayerAPI`` instance configured for it by the scene tree. Initially, "
"every node is configured with the same default ``MultiplayerAPI`` object."
msgstr ""

msgid ""
"It is possible to create a new ``MultiplayerAPI`` object and assign it to a "
"``NodePath`` in the the scene tree, which will override ``multiplayer`` for "
"the node at that path and all of its descendants. This allows sibling nodes "
"to be configured with different peers, which makes it possible to run a "
"server and a client simultaneously in one instance of Godot."
msgstr ""

msgid ""
"To initialize networking, a ``MultiplayerPeer`` object must be created, "
"initialized as a server or client, and passed to the ``MultiplayerAPI``."
msgstr ""

msgid "To terminate networking:"
msgstr ""

msgid ""
"When exporting to Android, make sure to enable the ``INTERNET`` permission "
"in the Android export preset before exporting the project or using one-click "
"deploy. Otherwise, network communication of any kind will be blocked by "
"Android."
msgstr ""

msgid "Managing connections"
msgstr ""

msgid ""
"Every peer is assigned a unique ID. The server's ID is always 1, and clients "
"are assigned a random positive integer."
msgstr ""

msgid ""
"Responding to connections or disconnections is possible by connecting to "
"``MultiplayerAPI``'s signals:"
msgstr ""

msgid ""
"``peer_connected(id: int)`` This signal is emitted with the newly connected "
"peer's ID on each other peer, and on the new peer multiple times, once with "
"each other peer's ID."
msgstr ""

msgid ""
"``peer_disconnected(id: int)`` This signal is emitted on every remaining "
"peer when one disconnects."
msgstr ""

#, fuzzy
msgid "The rest are only emitted on clients:"
msgstr "다음과 같은 주의 사항이 있습니다:"

#, fuzzy
msgid "``connected_to_server()``"
msgstr "연결(Connections)"

#, fuzzy
msgid "``connection_failed()``"
msgstr "연결(Connections)"

msgid "``server_disconnected()``"
msgstr ""

msgid "To get the unique ID of the associated peer:"
msgstr ""

msgid "To check whether the peer is server or client:"
msgstr ""

msgid "Remote procedure calls"
msgstr ""

msgid ""
"Remote procedure calls, or RPCs, are functions that can be called on other "
"peers. To create one, use the ``@rpc`` annotation before a function "
"definition. To call an RPC, use ``Callable``'s method ``rpc()`` to call in "
"every peer, or ``rpc_id()`` to call in a specific peer."
msgstr ""

msgid "RPCs will not serialize objects or callables."
msgstr ""

msgid ""
"For a remote call to be successful, the sending and receiving node need to "
"have the same ``NodePath``, which means they must have the same name. When "
"using ``add_child()`` for nodes which are expected to use RPCs, set the "
"argument ``force_readable_name`` to ``true``."
msgstr ""

msgid ""
"If a function is annotated with ``@rpc`` on the client script (resp. server "
"script), then this function must also be declared on the server script "
"(resp. client script). Both RPCs must have the same signature which is "
"evaluated with a checksum of **all RPCs**. All RPCs in a script are checked "
"at once, and all RPCs must be declared on both the client scripts and the "
"server scripts, **even functions that are currently not in use**."
msgstr ""

msgid ""
"The signature of the RPC includes the ``@rpc()`` declaration, the function, "
"return type, AND the nodepath. If an RPC resides in a script attached to ``/"
"root/Main/Node1``, then it must reside in precisely the same path and node "
"on both the client script and the server script. Function arguments "
"(example: ``func sendstuff():`` and ``func sendstuff(arg1, arg2):`` **will "
"pass** signature matching)."
msgstr ""

msgid ""
"If these conditions are not met (if all RPCs do not pass signature "
"matching), the script may print an error or cause unwanted behavior. The "
"error message may be unrelated to the RPC function you are currently "
"building and testing."
msgstr ""

msgid ""
"See further explanation and troubleshooting on `this post <https://github."
"com/godotengine/godot/issues/57869#issuecomment-1034215138>`__."
msgstr ""

msgid ""
"The annotation can take a number of arguments, which have default values. "
"``@rpc`` is equivalent to:"
msgstr ""

#, fuzzy
msgid "The parameters and their functions are as follows:"
msgstr "가장 일반적인 사용 케이스는 다음과 같습니다:"

#, fuzzy
msgid "``mode``:"
msgstr "``그룹 노드``"

msgid ""
"``\"authority\"``: Only the multiplayer authority (the server) can call "
"remotely."
msgstr ""

msgid ""
"``\"any_peer\"``: Clients are allowed to call remotely. Useful for "
"transferring user input."
msgstr ""

#, fuzzy
msgid "``sync``:"
msgstr "`remotesync`"

msgid "``\"call_remote\"``: The function will not be called on the local peer."
msgstr ""

msgid ""
"``\"call_local\"``: The function can be called on the local peer. Useful "
"when the server is also a player."
msgstr ""

#, fuzzy
msgid "``transfer_mode``:"
msgstr "'변형'"

msgid ""
"``\"unreliable\"`` Packets are not acknowledged, can be lost, and can arrive "
"at any order."
msgstr ""

msgid ""
"``\"unreliable_ordered\"`` Packets are received in the order they were sent "
"in. This is achieved by ignoring packets that arrive later if another that "
"was sent after them has already been received. Can cause packet loss if used "
"incorrectly."
msgstr ""

msgid ""
"``\"reliable\"`` Resend attempts are sent until packets are acknowledged, "
"and their order is preserved. Has a significant performance penalty."
msgstr ""

msgid "``transfer_channel`` is the channel index."
msgstr ""

msgid ""
"The first 3 can be passed in any order, but ``transfer_channel`` must always "
"be last."
msgstr ""

msgid ""
"The function ``multiplayer.get_remote_sender_id()`` can be used to get the "
"unique id of an rpc sender, when used within the function called by rpc."
msgstr ""

#, fuzzy
msgid "Channels"
msgstr "변경사항"

msgid ""
"Modern networking protocols support channels, which are separate connections "
"within the connection. This allows for multiple streams of packets that do "
"not interfere with each other."
msgstr ""

msgid ""
"For example, game chat related messages and some of the core gameplay "
"messages should all be sent reliably, but a gameplay message should not wait "
"for a chat message to be acknowledged. This can be achieved by using "
"different channels."
msgstr ""

msgid ""
"Channels are also useful when used with the unreliable ordered transfer "
"mode. Sending packets of variable size with this transfer mode can cause "
"packet loss, since packets which are slower to arrive are ignored. "
"Separating them into multiple streams of homogeneous packets by using "
"channels allows ordered transfer with little packet loss, and without the "
"latency penalty caused by reliable mode."
msgstr ""

msgid ""
"The default channel with index 0 is actually three different channels - one "
"for each transfer mode."
msgstr ""

#, fuzzy
msgid "Example lobby implementation"
msgstr "구현"

msgid ""
"This is an example lobby that can handle peers joining and leaving, notify "
"UI scenes through signals, and start the game after all clients have loaded "
"the game scene."
msgstr ""

msgid ""
"The game scene's root node should be named Game. In the script attached to "
"it:"
msgstr ""

msgid "Exporting for dedicated servers"
msgstr "데디케이티드 서버로 내보내기"

msgid ""
"Once you've made a multiplayer game, you may want to export it to run it on "
"a dedicated server with no GPU available. See :ref:"
"`doc_exporting_for_dedicated_servers` for more information."
msgstr ""

msgid ""
"The code samples on this page aren't designed to run on a dedicated server. "
"You'll have to modify them so the server isn't considered to be a player. "
"You'll also have to modify the game starting mechanism so that the first "
"player who joins can start the game."
msgstr ""

msgid "Translation status"
msgstr "번역 상태"
