# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Optimizing Navigation Performance"
msgstr "Optimieren der Navigations-Performance"

msgid ""
"Common Navigation related performance problems can be categorized into the "
"following topics:"
msgstr ""
"Häufige Performance-Probleme im Zusammenhang mit der Navigation lassen sich "
"in die folgenden Kategorien einteilen:"

msgid ""
"Performance problems with parsing scene tree nodes for navigation mesh "
"baking."
msgstr ""
"Performance-Probleme bei der Analyse von Nodes des Szenenbaums für das "
"Backen von Navigations-Meshes."

msgid "Performance problems with baking the actual navigation mesh."
msgstr "Performance-Probleme beim Backen des eigentlichen Navigations-Meshs."

msgid "Performance problems with NavigationAgent path queries."
msgstr "Performance-Probleme mit NavigationAgent-Pfadabfragen."

msgid "Performance problems with the actual path search."
msgstr "Performance-Probleme bei der eigentlichen Pfadsuche."

msgid "Performance problems with synchronizing the navigation map."
msgstr "Performance-Probleme bei der Synchronisierung der Navigations-Map."

msgid ""
"In the following sections information can be found on how to identify and "
"fix or at least mitigate their impact on framerates."
msgstr ""
"In den folgenden Abschnitten finden Sie Informationen darüber, wie Sie deren "
"Auswirkungen auf die Framerate erkennen und beheben oder zumindest abmildern "
"können."

msgid "Performance problems with parsing scene tree nodes"
msgstr "Performance-Probleme beim Parsen von Nodes in Szenenbäumen"

msgid ""
"Prefer using simple shapes with as few edges as possible e.g. nothing "
"rounded like a circle, sphere or torus."
msgstr ""
"Verwenden Sie vorzugsweise einfache Formen mit möglichst wenigen Kanten, z. "
"B. keine runden Formen wie Kreise, Kugeln oder Torus."

msgid ""
"Prefer using physics collision shapes over complex visual meshes as source "
"geometry as meshes need to be copied from the GPU and are commonly much more "
"detailed than necessary."
msgstr ""
"Bevorzugen Sie physikalische Collision Shapes gegenüber komplexen visuellen "
"Meshes als Ausgangsgeometrie, da Meshes von der GPU kopiert werden müssen "
"und in der Regel viel detaillierter sind als nötig."

msgid ""
"In general avoid using very complex geometry as source geometry for baking "
"navigation meshes. E.g. never use a very detailed visual mesh, as parsing "
"its shape to data arrays and voxelizing it for the navigation mesh baking "
"will take a long time for no real quality gain on the final navigation mesh. "
"Instead, use a very simplified level of detail version of a shape. Even "
"better, use very primitive shapes like boxes and rectangles that only "
"roughly cover the same geometry but still yield a baked result good enough "
"for pathfinding."
msgstr ""
"Vermeiden Sie im Allgemeinen die Verwendung sehr komplexer Geometrie als "
"Ausgangsgeometrie für das Backen von Navigationsmeshes. Verwenden Sie z.B. "
"niemals ein sehr detailliertes visuelles Mesh, da das Parsen seiner Form in "
"Datenarrays und die Voxelisierung für das Backen des Navigationsmeshs viel "
"Zeit in Anspruch nehmen wird, ohne dass das endgültige Navigationsmesh "
"dadurch an Qualität gewinnt. Verwenden Sie stattdessen eine sehr detailarme "
"Version einer Geometrie. Noch besser ist es, sehr primitive Geometrien wie "
"Kästchen und Rechtecke zu verwenden, die nur grob die gleiche Geometrie "
"abdecken, aber dennoch ein Ergebnis liefern, das gut genug für die "
"Wegfindung ist."

msgid ""
"Prefer using simple physics collision shapes over visual meshes, as the "
"source geometry for baking navigation meshes. Physics shapes are by default "
"very limited and optimized shapes that are easy and quick to parse. A visual "
"mesh on the other hand can range from simple to complex. On top, to gain "
"access to visual mesh data the parser needs to request the mesh data arrays "
"from the RenderingServer as visual mesh data is stored directly on the GPU "
"and is not cached on the CPU. This requires locking the RenderingServer "
"thread and can severely impact framerate at runtime while the rendering runs "
"multi-threaded. If the rendering runs single-threaded, the framerate impact "
"might be even worse and the mesh parsing might freeze the entire game for a "
"few seconds on complex meshes."
msgstr ""
"Bevorzugen Sie einfache Physik-Collision Shapes gegenüber visuellen Meshes "
"als Ausgangsgeometrie für das Backen von Navigationsmeshes. Physik-Shapes "
"sind standardmäßig sehr begrenzte und optimierte Geometrien, die einfach und "
"schnell zu analysieren sind. Ein visuelles Mesh hingegen kann von einfach "
"bis komplex reichen. Um Zugriff auf visuelle Mesh-Daten zu erhalten, muss "
"der Parser die Mesh-Daten-Arrays vom RenderingServer anfordern, da visuelle "
"Mesh-Daten direkt auf der GPU gespeichert werden und nicht auf der CPU "
"zwischengespeichert sind. Dies erfordert das Sperren des RenderingServer-"
"Threads und kann die Framerate zur Laufzeit stark beeinträchtigen, wenn das "
"Rendering in mehreren Threads ausgeführt wird. Wenn das Rendering als Single-"
"Thread läuft, kann die Auswirkung auf die Framerate noch schlimmer sein und "
"das Mesh-Parsing kann bei komplexen Meshes das gesamte Spiel für ein paar "
"Sekunden einfrieren."

msgid "Performance problems with navigation mesh baking"
msgstr "Performance-Probleme beim Backen von Navigations-Meshes"

msgid ""
"At runtime, always prefer to use a background thread for baking navigation "
"meshes."
msgstr ""
"Zur Laufzeit sollte immer ein Hintergrund-Thread für das Backen von "
"Navigations-Meshes verwendet werden."

msgid ""
"Increase NavigationMesh ``cell_size`` and ``cell_height`` to create less "
"voxels."
msgstr ""
"NavigationMesh ``cell_size`` und ``cell_height`` erhöhen, um weniger Voxel "
"zu erzeugen."

msgid ""
"Change the ``SamplePartitionType`` from watershed to monotone or layers to "
"gain baking performance."
msgstr ""
"Ändern Sie den ``SamplePartitionType`` von Watershed auf Monotone oder "
"Layers, um die Performance beim Backen zu erhöhen."

msgid ""
"NEVER scale source geometry with nodes to avoid precision errors. Most scale "
"applies only visually and shapes that are very large at their base scale "
"require still a lot of extra processing even while downscaled."
msgstr ""
"Skalieren Sie Quellgeometrie NIEMALS mit Nodes, um Präzisionsfehler zu "
"vermeiden. Die meisten Skalierungen gelten nur visuell und Geometrien, die "
"in ihrem Grundmaßstab sehr groß sind, erfordern auch bei einer Verkleinerung "
"noch eine Menge zusätzlicher Bearbeitung."

msgid ""
"Baking navigation meshes at runtime should always be done in a background "
"thread if possible. Even small sized navigation meshes can take far longer "
"to bake than what is possible to squeeze into a single frame, at least if "
"the framerate should stay at a bearable level."
msgstr ""
"Das Backen von Navigations-Meshes zur Laufzeit sollte nach Möglichkeit immer "
"in einem Hintergrund-Thread erfolgen. Selbst kleine Meshes können weitaus "
"mehr Zeit in Anspruch nehmen, als man in ein einzelnes Frame quetschen kann, "
"zumindest wenn die Framerate auf einem erträglichen Niveau bleiben soll."

msgid ""
"Complexity of source geometry data parsed from scene tree nodes has big "
"impact on baking performance as everything needs to be mapped to a grid / "
"voxels. For runtime baking performance the NavigationMesh cell size and cell "
"height should be set as high as possible without causing navigation mesh "
"quality problems for a game. If cell size or cell height is set too low the "
"baking is forced to create an excessive amount of voxels to process the "
"source geometry. If the source geometry spans over a very large game world "
"it is even possible that the baking process runs out off memory in the "
"middle and crashes the game. The partition type can also be lowered "
"depending on how complex the games source geometry is to gain some "
"performance. E.g. games with mostly flat surfaces with blocky geometry can "
"get away with the monotone or layers mode that are a lot faster to bake (e."
"g. because they require no distance field pass)."
msgstr ""
"Die Komplexität der Quellgeometriedaten, die aus den Nodes des Szenenbaums "
"geparst werden, hat große Auswirkungen auf die Performance beim Backen, da "
"alles auf ein Raster / Voxel abgebildet werden muss. Für die Performance des "
"Backens zur Laufzeit sollten die Zellengröße und -höhe des NavigationMeshs "
"so hoch wie möglich eingestellt werden, ohne dass die Qualität des Meshs für "
"ein Spiel beeinträchtigt wird. Wenn die Zellgröße oder Zellhöhe zu niedrig "
"eingestellt ist, ist das Backen gezwungen, eine übermäßige Anzahl von Voxeln "
"zu erzeugen, um die Quellgeometrie zu verarbeiten. Wenn sich die "
"Quellgeometrie über eine sehr große Spielwelt erstreckt, ist es sogar "
"möglich, dass dem Back-Prozess in der Mitte der Speicher ausgeht und das "
"Spiel abstürzt. Der Partitionstyp kann auch herabgesetzt werden, je nachdem "
"wie komplex die Ausgangsgeometrie des Spiels ist, um etwas Performance zu "
"gewinnen. Spiele mit überwiegend flachen Oberflächen und blockartiger "
"Geometrie können z.B. mit dem Monotone- oder Layer-Modus auskommen, die viel "
"schneller zu backen sind (z.B. weil sie keinen Distance Field-Durchlauf "
"benötigen)."

msgid ""
"Never scale source geometry with nodes. Not only can it result in a lot of "
"precision errors with wrongly matched vertices and edges but also some "
"scaling only exists as visuals and not in the actual parsed data. E.g. if a "
"mesh is downscaled visually in the Editor, e.g. the scale set to 0.001 on a "
"MeshInstance, the mesh still requires a gigantic and very complex voxel grid "
"to be processed for the baking."
msgstr ""
"Skalieren Sie niemals die Quellgeometrie mit Nodes. Dies kann nicht nur zu "
"vielen Präzisionsfehlern mit falsch angepassten Vertices und Kanten führen, "
"sondern auch dazu, dass manche Skalierungen nur visuell und nicht in den "
"tatsächlich geparsten Daten vorhanden sind. Wenn z.B. ein Mesh im Editor "
"visuell herunterskaliert wird, z.B. die Skalierung auf 0.001 bei einer "
"MeshInstance, benötigt das Mesh immer noch ein gigantisches und sehr "
"komplexes Voxel-Gitter, um für das Baking verarbeitet zu werden."

msgid "Performance problems with NavigationAgent path queries"
msgstr "Performance-Probleme mit NavigationAgent-Pfadabfragen"

msgid ""
"Avoid unnecessary path resets and queries every frame in NavigationAgent "
"scripts."
msgstr ""
"Vermeiden Sie unnötige Pfadrücksetzungen und Abfragen bei jedem Frame in "
"NavigationAgent-Skripten."

msgid "Avoid updating all NavigationAgent paths in the same frame."
msgstr ""
"Vermeiden Sie es, alle NavigationAgent-Pfade im selben Frame zu "
"aktualisieren."

msgid ""
"Logical errors and wasteful operations in the custom NavigationAgent scripts "
"are very common causes of performance issues, e.g. watch out for resetting "
"the path every single frame. By default NavigationAgents are optimized to "
"only query new paths when the target position changes, the navigation map "
"changes or they are forced too far away from the desired path distance."
msgstr ""
"Logische Fehler und verschwenderische Operationen in den benutzerdefinierten "
"NavigationAgent-Skripten sind sehr häufige Ursachen für Performance-"
"Probleme, z.B. das Zurücksetzen des Pfades in jedem einzelnen Frame. "
"Standardmäßig sind NavigationAgents so optimiert, dass sie nur dann neue "
"Pfade abfragen, wenn sich die Zielposition ändert, die Navigations-Map sich "
"ändert oder sie zu weit von der gewünschten Pfaddistanz entfernt sind."

msgid ""
"E.g. when AI should move to the player, the target position should not be "
"set to the player position every single frame as this queries a new path "
"every frame. Instead, the distance from the current target position to the "
"player position should be compared and only when the player has moved too "
"far away a new target position should be set."
msgstr ""
"Wenn sich z.B. die KI auf den Spieler zubewegen soll, sollte die "
"Zielposition nicht in jedem einzelnen Frame auf die Spielerposition gesetzt "
"werden, da dies in jedem Frame einen neuen Pfad abfragt. Stattdessen sollte "
"die Distanz zwischen der aktuellen Zielposition und der Spielerposition "
"verglichen werden, und nur wenn sich der Spieler zu weit entfernt hat, "
"sollte eine neue Zielposition festgelegt werden."

msgid ""
"Do not check beforehand if a target position is reachable every frame. What "
"looks like an innocent check is the equivalent of an expensive path query "
"behind the scene. If the plan is to request a new path anyway should the "
"position be reachable, a path should be queried directly. By looking at the "
"last position of the returned path and if that position is in a "
"\"reachable\" distance to the checked position it answers the \"is this "
"position reachable?\" question. This avoids doing the equivalent of two full "
"path queries every frame for the same NavigationAgent."
msgstr ""
"Prüfen Sie nicht in jedem Frame, ob eine Zielposition erreichbar ist. Was "
"wie eine harmlose Prüfung aussieht, ist das Äquivalent einer teuren "
"Pfadabfrage hinter den Kulissen. Wenn der Plan ist, einen neuen Pfad "
"anzufordern, falls die Position erreichbar ist, sollte ein Pfad direkt "
"abgefragt werden. Die Frage \"Ist diese Position erreichbar?\" wird "
"beantwortet, indem man die letzte Position des zurückgegebenen Pfades "
"betrachtet und prüft, ob diese Position in einer \"erreichbaren\" Entfernung "
"zur geprüften Position liegt. Dadurch wird vermieden, dass für jedes Frame "
"zwei vollständige Pfadabfragen für denselben NavigationAgent durchgeführt "
"werden."

msgid ""
"Divide the total number of NavigationAgents into update groups or use random "
"timers so that they do not all request new paths in the same frame."
msgstr ""
"Teilen Sie die Gesamtzahl der NavigationAgents in Update-Gruppen ein oder "
"verwenden Sie zufällige Timer, damit sie nicht alle im selben Frame neue "
"Pfade anfordern."

msgid "Performance problems with the actual path search"
msgstr "Performance-Probleme bei der eigentlichen Pfadsuche"

msgid ""
"Optimize overdetailed navigation meshes by reducing the amount of polygons "
"and edges."
msgstr ""
"Optimieren Sie überdetaillierte Navigations-Meshes, indem Sie die Anzahl der "
"Polygone und Kanten reduzieren."

msgid ""
"The cost of the actual path search correlates directly with the amount of "
"navigation mesh polygons and edges and not the real size of a game world. If "
"a giant game world uses very optimized navigation meshes with only few "
"polygons that cover large areas, performance should be acceptable. If the "
"game world is splintered into very small navigation meshes that each have "
"tiny polygons (like for TileMaps) pathfinding performance will be reduced."
msgstr ""
"Die Kosten der eigentlichen Pfadsuche korrelieren direkt mit der Anzahl der "
"Polygone und Kanten des Navigations-Meshs und nicht mit der tatsächlichen "
"Größe der Spielwelt. Wenn eine riesige Spielwelt sehr optimierte Navigations-"
"Meshes mit nur wenigen Polygonen verwendet, die große Bereiche abdecken, "
"sollte die Performance akzeptabel sein. Wenn die Spielwelt in sehr kleine "
"Meshes mit winzigen Polygonen aufgeteilt ist (wie bei TileMaps), wird die "
"Performance der Pfadfindung reduziert."

msgid ""
"A common problem is a sudden performance drop when a target position is not "
"reachable in a path query. This performance drop is \"normal\" and the "
"result of a too large, too unoptimized navigation mesh with way to much "
"polygons and edges to search through. In normal path searches where the "
"target position can be reached quickly the pathfinding will do an early exit "
"as soon as the position is reached which can hide this lack of optimization "
"for a while. If the target position can not be reached the pathfinding has "
"to do a far longer search through the available polygons to confirm that the "
"position is absolutely not reachable."
msgstr ""
"Ein häufiges Problem ist ein plötzlicher Performance-Einbruch, wenn eine "
"Zielposition bei einer Pfadabfrage nicht erreichbar ist. Dieser Performance-"
"Einbruch ist \"normal\" und das Ergebnis eines zu großen, nicht optimierten "
"Navigations-Meshs mit viel zu vielen Polygonen und Kanten, die durchsucht "
"werden müssen. Bei normalen Pfadsuchen, bei denen die Zielposition schnell "
"erreicht werden kann, wird die Wegfindung einen vorzeitigen Abbruch "
"vornehmen, sobald die Position erreicht ist, was diesen Mangel an "
"Optimierung für eine Weile verbergen kann. Wenn die Zielposition nicht "
"erreicht werden kann, muss die Pfadsuche eine viel längere Suche durch die "
"verfügbaren Polygone durchführen, um zu bestätigen, dass die Position "
"absolut nicht erreichbar ist."

msgid "Performance problems with navigation map synchronization"
msgstr "Performance-Probleme bei der Synchronisierung von Navigations-Maps"

msgid ""
"Merge navigation meshes polygons by vertex instead of by edge connection "
"wherever possible."
msgstr ""
"Fügen Sie die Polygone von Navigations-Meshes per Vertex statt per "
"Kantenverbindung zusammen, wo immer dies möglich ist."

msgid ""
"When changes are made to e.g. navigation meshes or navigation regions, the "
"NavigationServer needs to synchronize the navigation map. Depending on the "
"complexity of navigation meshes, this can take a significant amount of time "
"which may impact the framerate."
msgstr ""
"Wenn Änderungen z.B. an Navigations-Meshes oder Navigationsregionen "
"vorgenommen werden, muss der NavigationServer die Navigation-Map "
"synchronisieren. Je nach Komplexität der Meshes kann dies sehr viel Zeit in "
"Anspruch nehmen, was sich auf die Framerate auswirken kann."

msgid ""
"The NavigationServer merges navigation meshes either by vertex or by edge "
"connection. The merge by vertex happens when the two vertex of two different "
"edges land in the same map grid cells. This is a rather quick and low-cost "
"operation. The merge by edge connection happens in a second pass for all "
"still unmerged edges. All the free edges are checked for possible edge "
"connections by both distance and angle which is rather costly."
msgstr ""
"Der NavigationServer vereinigt Navigations-Meshes entweder per Vertex oder "
"per Kantenverbindung. Die Vereinigung per Vertex erfolgt, wenn die beiden "
"Vertices zweier unterschiedlicher Kanten in denselben Map-Rasterzellen "
"landen. Dies ist ein relativ schneller und kostengünstiger Vorgang. Die "
"Vereinigung per Kantenverbindung erfolgt in einem zweiten Durchgang für alle "
"noch nicht vereinigten Kanten. Dabei werden alle freien Kanten auf mögliche "
"Kantenverbindungen anhand von Abstand und Winkel geprüft, was recht "
"aufwändig ist."

msgid ""
"So apart from the general rule to have as few polygon edges as possible, as "
"many edges as possible should be merged by vertex upfront so only a few "
"edges are left for the more costly edge connection calculation. The debug "
"Navigation PerformanceMonitor can be used to get statistics on how many "
"polygons and edges are available and how many of them are unmerged or not "
"merged by vertex. If the ratio between vertex merged and edge connections is "
"way off (vertex should be significantly higher) the navigation meshes are "
"properly created or placed very inefficient."
msgstr ""
"Abgesehen von der allgemeinen Regel, so wenig Polygonkanten wie möglich zu "
"haben, sollten also so viele Kanten wie möglich im Vorfeld per Vertex "
"vereinigt werden, damit nur wenige Kanten für die aufwendigere Berechnung "
"der Kantenverbindung übrig bleiben. Die Debug-Navigation PerformanceMonitor "
"kann verwendet werden, um Statistiken darüber zu erhalten, wie viele "
"Polygone und Kanten verfügbar sind und wie viele davon gar nicht vereinigt "
"oder nicht per Vertex vereinigt sind. Wenn das Verhältnis zwischen per "
"Vertex und per Kantenverbindung vereinigten Vertices überhaupt nicht passt "
"(Vertex-Vereinigungen sollte deutlich häufiger vorkommen), werden die "
"Navigations-Meshes nicht richtig erstellt oder sehr ineffizient platziert."

msgid "Translation status"
msgstr "Übersetzungsstatus"
