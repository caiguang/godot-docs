# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Advanced post-processing"
msgstr "Fortgeschrittenes Post Processing"

msgid "Introduction"
msgstr "Einführung"

msgid ""
"This tutorial describes an advanced method for post-processing in Godot. In "
"particular, it will explain how to write a post-processing shader that uses "
"the depth buffer. You should already be familiar with post-processing "
"generally and, in particular, with the methods outlined in the :ref:`custom "
"post-processing tutorial <doc_custom_postprocessing>`."
msgstr ""
"Dieses Tutorial beschreibt eine fortgeschrittene Methode zur Nachbearbeitung "
"in Godot. Insbesondere wird erläutert, wie ein Post Processing-Shader "
"geschrieben wird, der den Tiefenpuffer verwendet. Sie sollten bereits mit "
"der Nachbearbeitung im Allgemeinen und insbesondere mit den Methoden "
"vertraut sein, die in der folgenden Anleitung beschrieben sind :ref:"
"`Anleitung zur benutzerdefinierten Nachbearbeitung "
"<doc_custom_postprocessing>`."

msgid ""
"In the previous post-processing tutorial, we rendered the scene to a :ref:"
"`Viewport <class_Viewport>` and then rendered the Viewport in a :ref:"
"`SubViewportContainer <class_SubViewportContainer>` to the main scene. One "
"limitation of this method is that we could not access the depth buffer "
"because the depth buffer is only available in shaders and Viewports do not "
"maintain depth information."
msgstr ""
"Im vorherigen Post-Processing-Tutorial haben wir die Szene in ein :ref:"
"`Viewport <class_Viewport>` gerendert und dann das Viewport in einem :ref:"
"`SubViewportContainer <class_SubViewportContainer>` zur Hauptszene "
"gerendert. Eine Einschränkung dieser Methode ist, dass wir nicht auf den "
"Tiefenpuffer zugreifen konnten, da der Tiefenpuffer nur in Shadern verfügbar "
"ist und Viewports keine Tiefeninformationen verwalten."

msgid "Full screen quad"
msgstr "Vollbild-Quad"

msgid ""
"In the :ref:`custom post-processing tutorial <doc_custom_postprocessing>`, "
"we covered how to use a Viewport to make custom post-processing effects. "
"There are two main drawbacks of using a Viewport:"
msgstr ""
"Im :ref:`Benutzerdefiniertes Post-Processing-Tutorial "
"<doc_custom_postprocessing>` wurde erläutert, wie Sie mit einem Viewport "
"benutzerdefinierte Nachbearbeitungseffekte erzielen. Die Verwendung eines "
"Ansichtsfensters hat zwei Hauptnachteile:"

msgid "The depth buffer cannot be accessed"
msgstr "Auf den Tiefenpuffer kann nicht zugegriffen werden"

msgid "The effect of the post-processing shader is not visible in the editor"
msgstr "Der Effekt des Post Processing-Shaders ist im Editor nicht sichtbar"

msgid ""
"To get around the limitation on using the depth buffer, use a :ref:"
"`MeshInstance3D <class_MeshInstance3D>` with a :ref:`QuadMesh "
"<class_QuadMesh>` primitive. This allows us to use a shader and to access "
"the depth texture of the scene. Next, use a vertex shader to make the quad "
"cover the screen at all times so that the post-processing effect will be "
"applied at all times, including in the editor."
msgstr ""
"Um die Einschränkung bei der Verwendung des Tiefenpuffers zu umgehen, "
"verwenden Sie ein :ref:`MeshInstance3D <class_MeshInstance3D>` mit einem :"
"ref:`QuadMesh <class_QuadMesh>`-Primitiv. Dies ermöglicht uns die Verwendung "
"eines Shaders und den Zugriff auf die Tiefentextur der Szene. Als Nächstes "
"verwenden wir einen Vertex-Shader, damit das Quad jederzeit den Bildschirm "
"bedeckt, so dass der Nachbearbeitungseffekt jederzeit angewendet wird, auch "
"im Editor."

msgid ""
"First, create a new MeshInstance3D and set its mesh to a QuadMesh. This "
"creates a quad centered at position ``(0, 0, 0)`` with a width and height of "
"``1``. Set the width and height to ``2`` and enable **Flip Faces**. Right "
"now, the quad occupies a position in world space at the origin. However, we "
"want it to move with the camera so that it always covers the entire screen. "
"To do this, we will bypass the coordinate transforms that translate the "
"vertex positions through the difference coordinate spaces and treat the "
"vertices as if they were already in clip space."
msgstr ""
"Erstellen Sie zunächst eine neue MeshInstance und stellen Sie als Mesh ein "
"QuadMesh ein. Dies erzeugt ein Quad, das an der Position ``(0, 0, 0)`` mit "
"einer Breite und Höhe von ``1`` zentriert ist. Stellen Sie die Breite und "
"Höhe auf ``2`` ein und aktivieren Sie **Oberflächen wenden**. Im Moment "
"befindet sich das Quadrat am Ursprung des World Space. Wir möchten jedoch, "
"dass es sich mit der Kamera so bewegt, dass es immer den gesamten Bildschirm "
"abdeckt. Um das zu erreichen, umgehen wir die Koordinatentransformationen, "
"welche die Vertex-Positionen durch die unterschiedlichen Koordinaten-Spaces "
"verschieben und behandeln die Eckpunkte so, als wären sie bereits im Clip "
"Space."

msgid ""
"The vertex shader expects coordinates to be output in clip space, which are "
"coordinates ranging from ``-1`` at the left and bottom of the screen to "
"``1`` at the top and right of the screen. This is why the QuadMesh needs to "
"have height and width of ``2``. Godot handles the transform from model to "
"view space to clip space behind the scenes, so we need to nullify the "
"effects of Godot's transformations. We do this by setting the ``POSITION`` "
"built-in to our desired position. ``POSITION`` bypasses the built-in "
"transformations and sets the vertex position directly."
msgstr ""
"Der Vertex-Shader erwartet, dass die Koordinaten im Clip Space ausgegeben "
"werden, das sind Koordinaten, die von ``-1`` am linken und unteren Rand des "
"Bildschirms bis ``1`` am oberen und rechten Rand des Bildschirms reichen. "
"Aus diesem Grund muss das QuadMesh eine Höhe und Breite von ``2`` haben. "
"Godot handhabt die Transformation vom Model Space zum View Space zum Clip "
"Space hinter den Kulissen, daher müssen wir die Auswirkungen von Godots "
"Transformationen aufheben. Wir tun dies, indem wir den Built-in-Parameter "
"``POSITION`` auf unsere gewünschte Position setzen. ``POSITION`` umgeht die "
"Built-in-Transformationen und setzt die Position des Vertex direkt."

msgid ""
"Even with this vertex shader, the quad keeps disappearing. This is due to "
"frustum culling, which is done on the CPU. Frustum culling uses the camera "
"matrix and the AABBs of Meshes to determine if the Mesh will be visible "
"*before* passing it to the GPU. The CPU has no knowledge of what we are "
"doing with the vertices, so it assumes the coordinates specified refer to "
"world positions, not clip space positions, which results in Godot culling "
"the quad when we turn away from the center of the scene. In order to keep "
"the quad from being culled, there are a few options:"
msgstr ""
"Selbst mit diesem Vertex-Shader verschwindet das Quad immer wieder. Das "
"liegt am Frustum Culling, das auf der CPU durchgeführt wird. Frustum Culling "
"verwendet die Kameramatrix und die AABBs von Meshes, um zu bestimmen, ob das "
"Mesh sichtbar sein wird, bevor es an die GPU weitergegeben wird. Die CPU "
"weiß nicht, was wir mit den Vertices machen, also nimmt sie an, dass sich "
"die angegebenen Koordinaten auf World Space-Positionen und nicht auf Clip "
"Space-Positionen beziehen, was dazu führt, dass Godot das Quad abschneidet, "
"wenn wir uns vom Zentrum der Szene wegdrehen. Um zu verhindern, dass der "
"Quad gecullt wird, gibt es ein paar Optionen:"

msgid ""
"Add the QuadMesh as a child to the camera, so the camera is always pointed "
"at it"
msgstr ""
"Fügen Sie das QuadMesh als Child-Element der Kamera hinzu, so dass die "
"Kamera immer auf das QuadMesh gerichtet ist"

msgid ""
"Set the Geometry property ``extra_cull_margin`` as large as possible in the "
"QuadMesh"
msgstr ""
"Setzen Sie die Geometrie-Property ``extra_cull_margin`` so groß wie möglich "
"im QuadMesh"

msgid ""
"The second option ensures that the quad is visible in the editor, while the "
"first option guarantees that it will still be visible even if the camera "
"moves outside the cull margin. You can also use both options."
msgstr ""
"Die zweite Option stellt sicher, dass das Quad im Editor sichtbar ist, "
"während die erste Option gewährleistet, dass es auch dann noch sichtbar ist, "
"wenn sich die Kamera außerhalb des Cull-Bereichs bewegt. Sie können auch "
"beide Optionen verwenden."

msgid "Depth texture"
msgstr "Tiefentextur"

msgid ""
"To read from the depth texture, we first need to create a texture uniform "
"set to the depth buffer by using ``hint_depth_texture``."
msgstr ""
"Um aus der Tiefentextur zu lesen, müssen wir zuerst ein Textur-Uniform für "
"den Tiefenpuffer erstellen, indem wir ``hint_depth_texture`` benutzen."

msgid ""
"Once defined, the depth texture can be read with the ``texture()`` function."
msgstr ""
"Einmal definiert, kann die Tiefentextur mit der Funktion ``texture()`` "
"gelesen werden."

msgid ""
"Similar to accessing the screen texture, accessing the depth texture is only "
"possible when reading from the current viewport. The depth texture cannot be "
"accessed from another viewport to which you have rendered."
msgstr ""
"Ähnlich wie der Zugriff auf die Bildschirmtextur ist auch der Zugriff auf "
"die Tiefentextur nur möglich, wenn sie aus dem aktuellen Viewport gelesen "
"wird. Auf die Tiefentextur kann nicht von einem anderen Viewport aus "
"zugegriffen werden, in das Sie gerendert haben."

msgid ""
"The values returned by ``depth_texture`` are between ``0.0`` and ``1.0`` and "
"are nonlinear. When displaying depth directly from the ``depth_texture``, "
"everything will look almost white unless it is very close. This is because "
"the depth buffer stores objects closer to the camera using more bits than "
"those further, so most of the detail in depth buffer is found close to the "
"camera. In order to make the depth value align with world or model "
"coordinates, we need to linearize the value. When we apply the projection "
"matrix to the vertex position, the z value is made nonlinear, so to "
"linearize it, we multiply it by the inverse of the projection matrix, which "
"in Godot, is accessible with the variable ``INV_PROJECTION_MATRIX``."
msgstr ""
"Die von ``depth_texture`` zurückgegebenen Werte liegen zwischen ``0.0`` und "
"``1.0`` und sind nichtlinear. Wenn die Tiefe direkt von der "
"``depth_texture`` angezeigt wird, sieht alles fast weiß aus, es sei denn, es "
"ist sehr nah. Das liegt daran, dass der Tiefenpuffer Objekte, die sich näher "
"an der Kamera befinden, mit mehr Bits speichert als solche, die weiter "
"entfernt sind, so dass die meisten Details im Tiefenpuffer in der Nähe der "
"Kamera zu finden sind. Damit der Tiefenwert mit den Welt- oder "
"Modellkoordinaten übereinstimmt, müssen wir den Wert linearisieren. Wenn wir "
"die Projektionsmatrix auf die Scheitelpunktposition anwenden, wird der z-"
"Wert nichtlinear. Um ihn zu linearisieren, multiplizieren wir ihn mit der "
"Inversen der Projektionsmatrix, die in Godot über die Variable "
"``INV_PROJECTION_MATRIX`` zugänglich ist."

msgid ""
"Firstly, take the screen space coordinates and transform them into "
"normalized device coordinates (NDC). NDC run ``-1.0`` to ``1.0`` in ``x`` "
"and ``y`` directions and from ``0.0`` to ``1.0`` in the ``z`` direction when "
"using the Vulkan backend. Reconstruct the NDC using ``SCREEN_UV`` for the "
"``x`` and ``y`` axis, and the depth value for ``z``."
msgstr ""
"Zunächst werden die Bildschirmkoordinaten in normalisierte Gerätekoordinaten "
"(NDC) umgewandelt. NDC verlaufen von ``-1.0`` bis ``1.0`` in ``x`` und ``y`` "
"Richtung und von ``0.0`` bis ``1.0`` in ``z`` Richtung, wenn das Vulkan-"
"Backend benutzt wird. Rekonstruieren Sie den NDC unter Verwendung von "
"``SCREEN_UV`` für die ``x``- und ``y``-Achse, und den Tiefenwert für ``z``."

msgid ""
"This tutorial assumes the use of the Vulkan renderer, which uses NDCs with a "
"Z-range of ``[0.0, 1.0]``. In contrast, OpenGL uses NDCs with a Z-range of "
"``[-1.0, 1.0]``."
msgstr ""
"Dieses Tutorial setzt die Verwendung des Vulkan-Renderers voraus, der NDCs "
"mit einem Z-Bereich von ``[0.0, 1.0]`` verwendet. Im Gegensatz dazu "
"verwendet OpenGL NDCs mit einem Z-Bereich von ``[-1.0, 1.0]``."

msgid ""
"Convert NDC to view space by multiplying the NDC by "
"``INV_PROJECTION_MATRIX``. Recall that view space gives positions relative "
"to the camera, so the ``z`` value will give us the distance to the point."
msgstr ""
"Konvertieren Sie den NDC in den View Space, indem Sie den NDC mit "
"``INV_PROJECTION_MATRIX`` multiplizieren.Erinnern Sie sich, dass der View "
"Space Positionen relativ zur Kamera angibt, so dass der ``z``-Wert die "
"Entfernung zum Punkt angibt."

msgid ""
"Because the camera is facing the negative ``z`` direction, the position will "
"have a negative ``z`` value. In order to get a usable depth value, we have "
"to negate ``view.z``."
msgstr ""
"Da die Kamera in die negative ``z``-Richtung zeigt, wird die Position einen "
"negativen ``z``-Wert haben.Um einen brauchbaren Tiefenwert zu erhalten, "
"müssen wir ``view.z`` negieren."

msgid ""
"The world position can be constructed from the depth buffer using the "
"following code. Note that the ``INV_VIEW_MATRIX`` is needed to transform the "
"position from view space into world space, so it needs to be passed to the "
"fragment shader with a varying."
msgstr ""
"Die Weltposition kann mit dem folgenden Code aus dem Tiefenpuffer "
"konstruiert werden. Man beachte, dass der ``INV_VIEW_MATRIX`` benötigt wird, "
"um die Position vom View Space in den World Space zu transformieren, daher "
"muss er dem Fragment Shader mit einer Variation übergeben werden."

msgid "An optimization"
msgstr "Eine Optimierung"

msgid ""
"You can benefit from using a single large triangle rather than using a full "
"screen quad. The reason for this is explained `here <https://michaldrobot."
"com/2014/04/01/gcn-execution-patterns-in-full-screen-passes>`_. However, the "
"benefit is quite small and only beneficial when running especially complex "
"fragment shaders."
msgstr ""
"Es kann von Vorteil sein, ein einzelnes großes Dreieck zu verwenden, anstatt "
"ein bildschirmfüllendes Quad zu verwenden. Der Grund dafür wird `hier "
"<https://michaldrobot.com/2014/04/01/gcn-execution-patterns-in-full-screen-"
"passes>`_ erklärt. Der Vorteil ist jedoch recht gering und nur dann von "
"Vorteil, wenn besonders komplexe Fragment-Shader verwendet werden."

msgid ""
"Set the Mesh in the MeshInstance3D to an :ref:`ArrayMesh <class_ArrayMesh>`. "
"An ArrayMesh is a tool that allows you to easily construct a Mesh from "
"Arrays for vertices, normals, colors, etc."
msgstr ""
"Stellen Sie das Mesh in der MeshInstance3D auf ein :ref:`ArrayMesh "
"<class_ArrayMesh>` ein. Ein ArrayMesh ist ein Werkzeug, mit dem man leicht "
"ein Mesh aus Arrays für Vertices, Normalen, Farben, etc. konstruieren kann."

msgid "Now, attach a script to the MeshInstance3D and use the following code:"
msgstr ""
"Hängen Sie nun ein Skript an die MeshInstance3D an und verwenden Sie den "
"folgenden Code:"

msgid ""
"The triangle is specified in normalized device coordinates. Recall, NDC run "
"from ``-1.0`` to ``1.0`` in both the ``x`` and ``y`` directions. This makes "
"the screen ``2`` units wide and ``2`` units tall. In order to cover the "
"entire screen with a single triangle, use a triangle that is ``4`` units "
"wide and ``4`` units tall, double its height and width."
msgstr ""
"Das Dreieck wird in normalisierten Gerätekoordinaten angegeben. Erinnern Sie "
"sich, dass NDC von ``-1.0`` bis ``1.0`` sowohl in der ``x``- als auch in der "
"``y``-Richtung reichen. Dies macht den Bildschirm ``2`` Einheiten breit und "
"``2`` Einheiten hoch. Um den gesamten Bildschirm mit einem einzigen Dreieck "
"zu bedecken, nehmen Sie ein Dreieck, das ``4`` Einheiten breit und ``4`` "
"Einheiten hoch ist, und verdoppeln Sie seine Höhe und Breite."

msgid ""
"Assign the same vertex shader from above and everything should look exactly "
"the same."
msgstr ""
"Weisen Sie den gleichen Vertex-Shader von oben zu, und alles sollte genau "
"gleich aussehen."

msgid ""
"The one drawback to using an ArrayMesh over using a QuadMesh is that the "
"ArrayMesh is not visible in the editor because the triangle is not "
"constructed until the scene is run. To get around that, construct a single "
"triangle Mesh in a modeling program and use that in the MeshInstance3D "
"instead."
msgstr ""
"Der einzige Nachteil bei der Verwendung eines ArrayMesh gegenüber einem "
"QuadMesh ist, dass das ArrayMesh im Editor nicht sichtbar ist, da das "
"Dreieck erst beim Ausführen der Szene konstruiert wird. Um dies zu umgehen, "
"konstruieren Sie ein einzelnes Dreiecks-Mesh in einem Modellierungsprogramm "
"und verwenden Sie dieses stattdessen in der MeshInstance3D."

msgid "Translation status"
msgstr "Übersetzungsstatus"
