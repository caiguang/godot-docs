# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using a Viewport as a texture"
msgstr "Verwendung des Viewports als Textur"

msgid "Introduction"
msgstr "Einführung"

msgid ""
"This tutorial will introduce you to using the :ref:`Viewport "
"<class_Viewport>` as a texture that can be applied to 3D objects. In order "
"to do so, it will walk you through the process of making a procedural planet "
"like the one below:"
msgstr ""
"In diesem Tutorial lernen Sie die Verwendung von :ref:`Viewport "
"<class_Viewport>` als Textur kennen, die auf 3D-Objekte angewendet werden "
"kann. Zu diesem Zweck erstellen wir einen prozeduralen Planeten wie dem "
"folgenden hier:"

msgid ""
"This tutorial does not cover how to code a dynamic atmosphere like the one "
"this planet has."
msgstr ""
"Dieses Tutorial behandelt nicht, wie man eine dynamische Atmosphäre, wie die "
"dieses Planeten, programmiert."

msgid ""
"This tutorial assumes you are familiar with how to set up a basic scene "
"including: a :ref:`Camera3D <class_Camera3D>`, a :ref:`light source "
"<class_OmniLight3D>`, a :ref:`MeshInstance3D <class_MeshInstance3D>` with a :"
"ref:`Primitive Mesh <class_PrimitiveMesh>`, and applying a :ref:"
"`StandardMaterial3D <class_StandardMaterial3D>` to the mesh. The focus will "
"be on using the :ref:`Viewport <class_Viewport>` to dynamically create "
"textures that can be applied to the mesh."
msgstr ""
"Dieses Tutorial setzt voraus, dass Sie mit der Einrichtung einer "
"grundlegenden Szene vertraut sind, einschließlich: einer :ref:`Camera3D "
"<class_Camera3D>`, einer :ref:`Lichtquelle <class_OmniLight3D>`, einer :ref:"
"`MeshInstance3D <class_MeshInstance3D>` mit einem :ref:`Primitive Mesh "
"<class_PrimitiveMesh>`, und der Anwendung eines :ref:`StandardMaterial3D "
"<class_StandardMaterial3D>` auf das Mesh. Der Schwerpunkt liegt auf der "
"Verwendung des :ref:`Viewport <class_Viewport>` zur dynamischen Erstellung "
"von Texturen, die auf das Mesh angewendet werden können."

msgid "In this tutorial, we'll cover the following topics:"
msgstr "In diesem Tutorial werden wir die folgenden Themen behandeln:"

msgid "How to use a :ref:`Viewport <class_Viewport>` as a render texture"
msgstr "Verwendung von :ref:`Viewport <class_Viewport>` als Rendertextur"

msgid "Mapping a texture to a sphere with equirectangular mapping"
msgstr "Abbilden einer Textur auf eine Kugel mit gleichwinkliger Zuordnung"

msgid "Fragment shader techniques for procedural planets"
msgstr "Fragment-Shader-Techniken für prozedurale Planeten"

msgid ""
"Setting a Roughness map from a :ref:`Viewport Texture "
"<class_ViewportTexture>`"
msgstr ""
"Festlegen einer Rauheitskarte aus einer :ref:`Viewport-Textur "
"<class_ViewportTexture>`"

msgid "Setting up the Viewport"
msgstr "Einrichten des Viewports"

msgid "First, add a :ref:`Viewport <class_Viewport>` to the scene."
msgstr "Fügen Sie zuerst :ref:`Viewport <class_Viewport>` zu der Szene hinzu."

msgid ""
"Next, set the size of the :ref:`Viewport <class_Viewport>` to ``(1024, "
"512)``. The :ref:`Viewport <class_Viewport>` can actually be any size so "
"long as the width is double the height. The width needs to be double the "
"height so that the image will accurately map onto the sphere, as we will be "
"using equirectangular projection, but more on that later."
msgstr ""
"Als nächstes setzen Sie die Größe des :ref:`Viewport <class_Viewport>` auf "
"``(1024, 512)``. Das :ref:`Viewport <class_Viewport>` kann eigentlich jede "
"Größe haben, solange die Breite doppelt so groß ist wie die Höhe. Die Breite "
"muss doppelt so groß sein wie die Höhe, damit das Bild genau auf die Kugel "
"abgebildet werden kann, da wir eine gleichwinklige Projektion verwenden "
"werden, aber dazu später mehr."

msgid ""
"Next, disable HDR and disable 3D. We don't need HDR because our planet's "
"surface will not be especially bright, so values between ``0`` and ``1`` "
"will be fine. And we will be using a :ref:`ColorRect <class_ColorRect>` to "
"render the surface, so we don't need 3D either."
msgstr ""
"Als nächstes deaktivieren Sie HDR und 3D. Wir brauchen kein HDR, weil die "
"Oberfläche unseres Planeten nicht besonders hell sein wird, also sind Werte "
"zwischen ``0`` und ``1`` ausreichend. Und wir werden ein :ref:`ColorRect "
"<class_ColorRect>` zum Rendern der Oberfläche verwenden, also brauchen wir "
"auch kein 3D."

msgid ""
"Select the Viewport and add a :ref:`ColorRect <class_ColorRect>` as a child."
msgstr ""
"Wählen Sie den Viewport und fügen Sie ein :ref:`ColorRect <class_ColorRect>` "
"als Child-Element hinzu."

msgid ""
"Set the anchors \"Right\" and \"Bottom\" to ``1``, then make sure all the "
"margins are set to ``0``. This will ensure that the :ref:`ColorRect "
"<class_ColorRect>` takes up the entire :ref:`Viewport <class_Viewport>`."
msgstr ""
"Setzen Sie die Anker \"Rechts\" und \"Unten\" auf ``1``, und stellen Sie "
"sicher, dass alle Ränder auf ``0`` gesetzt sind. Dadurch wird "
"sichergestellt, dass das :ref:`ColorRect <class_ColorRect>` den gesamten :"
"ref:`Viewport <class_Viewport>` einnimmt."

msgid ""
"Next, we add a :ref:`Shader Material <class_ShaderMaterial>` to the :ref:"
"`ColorRect <class_ColorRect>` (ColorRect > CanvasItem > Material > Material "
"> ``New ShaderMaterial``)."
msgstr ""
"Als nächstes fügen wir ein :ref:`Shader Material <class_ShaderMaterial>` "
"zum :ref:`ColorRect <class_ColorRect>` hinzu (ColorRect > CanvasItem > "
"Material > Material > ``Neu: ShaderMaterial``)."

msgid ""
"Basic familiarity with shading is recommended for this tutorial. However, "
"even if you are new to shaders, all the code will be provided, so you should "
"have no problem following along."
msgstr ""
"Grundlegende Vertrautheit mit Shading wird für dieses Tutorial empfohlen. "
"Aber auch wenn Sie keine Erfahrung mit Shadern haben, wird der gesamte Code "
"zur Verfügung gestellt, so dass Sie keine Probleme haben sollten, diesem "
"Tutorial zu folgen."

msgid ""
"ColorRect > CanvasItem > Material > Material > click / Edit > ShaderMaterial "
"> Shader > ``New Shader`` > click / Edit:"
msgstr ""
"ColorRect > CanvasItem > Material > Material > Klicken / Bearbeiten > "
"ShaderMaterial > Shader > ``Neuer Shader`` > Klicken / Bearbeiten:"

msgid "The above code renders a gradient like the one below."
msgstr "Der obige Code rendert einen Farbverlauf wie den folgenden."

msgid ""
"Now we have the basics of a :ref:`Viewport <class_Viewport>` that we render "
"to and we have a unique image that we can apply to the sphere."
msgstr ""
"Jetzt haben wir die Grundlagen für einen :ref:`Viewport <class_Viewport>`, "
"den wir rendern, und wir haben ein eindeutiges Bild, das wir auf die Kugel "
"anwenden können."

msgid "Applying the texture"
msgstr "Anwenden der Textur"

msgid ""
"MeshInstance3D > GeometryInstance > Geometry > Material Override > ``New "
"StandardMaterial3D``:"
msgstr ""
"MeshInstance3D > GeometryInstance > Geometrie > Material-Überschreibung > "
"``Neu: StandardMaterial3D``:"

msgid ""
"Now we go into the :ref:`MeshInstance3D <class_MeshInstance3D>` and add a :"
"ref:`StandardMaterial3D <class_StandardMaterial3D>` to it. No need for a "
"special :ref:`Shader Material <class_ShaderMaterial>` (although that would "
"be a good idea for more advanced effects, like the atmosphere in the example "
"above)."
msgstr ""
"Jetzt gehen wir in die :ref:`MeshInstance3D <class_MeshInstance3D>` und "
"fügen ein :ref:`StandardMaterial3D <class_StandardMaterial3D>` dazu. Es "
"besteht keine Notwendigkeit für ein spezielles :ref:`Shader Material "
"<class_ShaderMaterial>` (obwohl das eine gute Idee für fortgeschrittene "
"Effekte wäre, wie die Atmosphäre im obigen Beispiel)."

msgid ""
"MeshInstance3D > GeometryInstance > Geometry > Material Override > "
"``click`` / ``Edit``:"
msgstr ""
"MeshInstance3D > GeometryInstance > Geometrie > Material-Überschreibung > "
"``Klicken`` / ``Bearbeiten``:"

msgid ""
"Open the newly created :ref:`StandardMaterial3D <class_StandardMaterial3D>` "
"and scroll down to the \"Albedo\" section and click beside the \"Texture\" "
"property to add an Albedo Texture. Here we will apply the texture we made. "
"Choose \"New ViewportTexture\""
msgstr ""
"Öffnen Sie das neu erstellte :ref:`StandardMaterial3D "
"<class_StandardMaterial3D>` und scrollen Sie nach unten zum Abschnitt "
"\"Albedo\" und klicken Sie neben der Property \"Texture\", um eine Albedo-"
"Textur hinzuzufügen. Hier werden wir die von uns erstellte Textur anwenden. "
"Wählen Sie \"Neu: ViewportTexture\""

msgid ""
"Then, from the menu that pops up, select the Viewport that we rendered to "
"earlier."
msgstr ""
"Wählen Sie dann aus dem angezeigten Menü den Viewport aus, in den zuvor "
"gerendert wurde."

msgid ""
"Your sphere should now be colored in with the colors we rendered to the "
"Viewport."
msgstr ""
"Ihre Kugel sollte jetzt mit den Farben eingefärbt sein, die wir im Viewport "
"gerendert haben."

msgid ""
"Notice the ugly seam that forms where the texture wraps around? This is "
"because we are picking a color based on UV coordinates and UV coordinates do "
"not wrap around the texture. This is a classic problem in 2D map projection. "
"Game developers often have a 2-dimensional map they want to project onto a "
"sphere, but when it wraps around, it has large seams. There is an elegant "
"workaround for this problem that we will illustrate in the next section."
msgstr ""
"Haben Sie die hässliche Naht bemerkt, die sich an der Stelle bildet, an der "
"die Textur um die Textur gewickelt wird? Das liegt daran, dass wir eine "
"Farbe auf der Grundlage von UV-Koordinaten auswählen, und UV-Koordinaten "
"lassen sich nicht um die Textur herumführen. Dies ist ein klassisches "
"Problem bei der 2D-Kartenprojektion. Spieleentwickler haben oft eine 2-"
"dimensionale Karte, die sie auf eine Kugel projizieren wollen, aber wenn sie "
"sich um die Kugel wickelt, entstehen große Nähte. Es gibt eine elegante "
"Lösung für dieses Problem, die wir im nächsten Abschnitt erläutern werden."

msgid "Making the planet texture"
msgstr "Erzeugen der Planetentextur"

msgid ""
"So now, when we render to our :ref:`Viewport <class_Viewport>`, it appears "
"magically on the sphere. But there is an ugly seam created by our texture "
"coordinates. So how do we get a range of coordinates that wrap around the "
"sphere in a nice way? One solution is to use a function that repeats on the "
"domain of our texture. ``sin`` and ``cos`` are two such functions. Let's "
"apply them to the texture and see what happens."
msgstr ""
"Wenn wir nun auf unser :ref:`Viewport <class_Viewport>` rendern, erscheint "
"es wie von Zauberhand auf der Kugel. Aber es gibt eine hässliche Naht, die "
"durch unsere Texturkoordinaten entsteht. Wie bekommen wir also einen Bereich "
"von Koordinaten, der die Kugel auf schöne Weise umhüllt? Eine Lösung besteht "
"darin, eine Funktion zu verwenden, die sich auf dem Bereich unserer Textur "
"wiederholt. ``sin`` und ``cos`` sind zwei solcher Funktionen. Wenden wir sie "
"auf die Textur an und sehen wir, was passiert."

msgid ""
"Not too bad. If you look around, you can see that the seam has now "
"disappeared, but in its place, we have pinching at the poles. This pinching "
"is due to the way Godot maps textures to spheres in its :ref:"
"`StandardMaterial3D <class_StandardMaterial3D>`. It uses a projection "
"technique called equirectangular projection, which translates a spherical "
"map onto a 2D plane."
msgstr ""
"Gar nicht so schlecht. Wenn Sie sich umsehen, können Sie sehen, dass die "
"Naht jetzt verschwunden ist, aber an ihrer Stelle haben wir eine Quetschung "
"an den Polen. Das liegt an der Art und Weise, wie Godot in seinem :ref:"
"`StandardMaterial3D <class_StandardMaterial3D>` Texturen auf Kugeln "
"abbildet. Es verwendet eine Projektionstechnik namens gleichwinklige "
"Projektion, die eine sphärische Karte auf eine 2D-Ebene überträgt."

msgid ""
"If you are interested in a little extra information on the technique, we "
"will be converting from spherical coordinates into Cartesian coordinates. "
"Spherical coordinates map the longitude and latitude of the sphere, while "
"Cartesian coordinates are, for all intents and purposes, a vector from the "
"center of the sphere to the point."
msgstr ""
"Wenn Sie sich für ein paar zusätzliche Informationen über die Methode "
"interessieren, werden wir von sphärischen Koordinaten in kartesische "
"Koordinaten umrechnen. Sphärische Koordinaten bilden die Längen- und "
"Breitengrade der Kugel ab, während kartesische Koordinaten im Grunde ein "
"Vektor vom Mittelpunkt der Kugel zum aktuellen Punkt sind."

msgid ""
"For each pixel, we will calculate its 3D position on the sphere. From that, "
"we will use 3D noise to determine a color value. By calculating the noise in "
"3D, we solve the problem of the pinching at the poles. To understand why, "
"picture the noise being calculated across the surface of the sphere instead "
"of across the 2D plane. When you calculate across the surface of the sphere, "
"you never hit an edge, and hence you never create a seam or a pinch point on "
"the pole. The following code converts the ``UVs`` into Cartesian coordinates."
msgstr ""
"Für jedes Pixel wird seine 3D-Position auf der Kugel berechnet. Daraus "
"ermitteln wir mit Hilfe von 3D-Rauschen einen Farbwert. Indem wir das "
"Rauschen in 3D berechnen, lösen wir das Problem des Quetschens an den Polen. "
"Um zu verstehen, warum das so ist, stellen Sie sich vor, dass das Rauschen "
"über die Oberfläche der Kugel und nicht über die 2D-Ebene berechnet wird. "
"Wenn man über die Oberfläche der Kugel rechnet, stößt man nie auf eine Kante "
"und erzeugt somit auch keine Naht oder einen Quetschungspunkt am Pol. Der "
"folgende Code wandelt die ``UVs`` in kartesische Koordinaten um."

msgid "And if we use ``unit`` as an output ``COLOR`` value, we get:"
msgstr ""
"Und wenn wir ``unit`` als Ausgabe-``COLOR``-Wert verwenden, erhalten wir:"

msgid ""
"Now that we can calculate the 3D position of the surface of the sphere, we "
"can use 3D noise to make the planet. We will be using this noise function "
"directly from a `Shadertoy <https://www.shadertoy.com/view/Xsl3Dl>`_:"
msgstr ""
"Da wir nun die 3D-Position der Kugeloberfläche berechnen können, können wir "
"3D-Rauschen verwenden, um den Planeten zu erstellen. Wir werden diese "
"Rauschfunktion direkt aus einem `Shadertoy <https://www.shadertoy.com/view/"
"Xsl3Dl>`_ verwenden:"

msgid ""
"All credit goes to the author, Inigo Quilez. It is published under the "
"``MIT`` licence."
msgstr ""
"Alle Anerkennung gebührt dem Autor Inigo Quilez. Es wird unter der ``MIT``-"
"Lizenz veröffentlicht."

msgid ""
"Now to use ``noise``, add the following to the    ``fragment`` function:"
msgstr ""
"Um nun ``Rauschen`` zu verwenden, fügen Sie der Funktion ``Fragment`` "
"folgendes hinzu:"

msgid "In order to highlight the texture, we set the material to unshaded."
msgstr "Um die Textur hervorzuheben, setzen wir das Material auf unschattiert."

msgid ""
"You can see now that the noise indeed wraps seamlessly around the sphere. "
"Although this looks nothing like the planet you were promised. So let's move "
"onto something more colorful."
msgstr ""
"Sie können jetzt sehen, dass das Rauschen tatsächlich nahtlos um die Kugel "
"herumgeht. Allerdings sieht das nicht aus wie der Planet, der Ihnen "
"versprochen wurde. Gehen wir also zu etwas Bunterem über."

msgid "Coloring the planet"
msgstr "Einfärben des Planeten"

msgid ""
"Now to make the planet colors. While there are many ways to do this, for "
"now, we will stick with a gradient between water and land."
msgstr ""
"Nun zum Einfärben des Planeten. Es gibt zwar viele Möglichkeiten, dies zu "
"tun, aber für den Moment werden wir bei einem Farbverlauf zwischen Wasser "
"und Land bleiben."

msgid ""
"To make a gradient in GLSL, we use the ``mix`` function. ``mix`` takes two "
"values to interpolate between and a third argument to choose how much to "
"interpolate between them; in essence, it *mixes* the two values together. In "
"other APIs, this function is often called ``lerp``. However, ``lerp`` is "
"typically reserved for mixing two floats together; ``mix`` can take any "
"values whether it be floats or vector types."
msgstr ""
"Um einen Gradienten in GLSL zu erzeugen, benutzen wir die Funktion ``mix``. "
"Die Funktion ``mix`` nimmt zwei Werte, zwischen denen interpoliert werden "
"soll, und ein drittes Argument, um festzulegen, wie stark zwischen ihnen "
"interpoliert werden soll; im Wesentlichen *mischt* sie die beiden Werte "
"zusammen. In anderen APIs wird diese Funktion oft ``lerp`` genannt. "
"Allerdings ist ``lerp`` typischerweise für das Mischen von zwei Float-Zahlen "
"reserviert; ``mix`` kann beliebige Werte annehmen, seien es Float-Zahlen "
"oder Vektortypen."

msgid ""
"The first color is blue for the ocean. The second color is a kind of reddish "
"color (because all alien planets need red terrain). And finally, they are "
"mixed together by ``n * 0.5 + 0.5``. ``n`` smoothly varies between ``-1`` "
"and ``1``. So we map it into the ``0-1`` range that ``mix`` expects. Now you "
"can see that the colors change between blue and red."
msgstr ""
"Die erste Farbe ist blau für den Ozean. Die zweite Farbe ist eine Art "
"rötliche Farbe (weil alle außerirdischen Planeten rotes Terrain brauchen). "
"Und schließlich werden sie durch ``n * 0,5 + 0,5`` zusammengemischt. ``n`` "
"variiert gleichmäßig zwischen ``-1`` und ``1``. Also übertragen wir es auf "
"den Bereich ``0-1``, den ``mix`` erwartet. Jetzt kann man sehen, dass die "
"Farben zwischen blau und rot wechseln."

msgid ""
"That is a little more blurry than we want. Planets typically have a "
"relatively clear separation between land and sea. In order to do that, we "
"will change the last term to ``smoothstep(-0.1, 0.0, n)``. And thus the "
"whole line becomes:"
msgstr ""
"Das ist ein bisschen unschärfer, als wir wollen. Planeten haben "
"normalerweise eine relativ klare Trennung zwischen Land und Meer. Um das zu "
"erreichen, ändern wir den letzten Term in ``smoothstep(-0.1, 0.0, n)``. Und "
"so wird die ganze Zeile zu:"

msgid ""
"What ``smoothstep`` does is return ``0`` if the third argument is below the "
"first and ``1`` if the third argument is larger than the second and smoothly "
"blends between ``0`` and ``1`` if the third number is between the first and "
"the second. So in this line, ``smoothstep`` returns ``0`` whenever ``n`` is "
"less than ``-0.1`` and it returns ``1`` whenever ``n`` is above ``0``."
msgstr ""
"Was ``smoothstep`` macht, ist ``0`` zurückzugeben, wenn das dritte Argument "
"kleiner als das erste ist und ``1``, wenn das dritte Argument größer als das "
"zweite ist. Es gibt einen gleitenden Wert zwischen ``0`` und ``1`` zurück, "
"wenn die dritte Zahl zwischen dem ersten und dem zweiten liegt. In dieser "
"Zeile liefert ``smoothstep`` also ``0``, wenn ``n`` kleiner als ``-0.1`` ist "
"und ``1``, wenn ``n`` größer als ``0`` ist."

msgid ""
"One more thing to make this a little more planet-y. The land shouldn't be so "
"blobby; let's make the edges a little rougher. A trick that is often used in "
"shaders to make rough looking terrain with noise is to layer levels of noise "
"over one another at various frequencies. We use one layer to make the "
"overall blobby structure of the continents. Then another layer breaks up the "
"edges a bit, and then another, and so on. What we will do is calculate ``n`` "
"with four lines of shader code instead of just one. ``n`` becomes:"
msgstr ""
"Noch eine Sache, um das Ganze ein wenig planetarer zu machen. Das Land "
"sollte nicht so klumpig sein; wir sollten die Kanten ein wenig rauer "
"gestalten. Ein Trick, der oft in Shadern verwendet wird, um rau aussehendes "
"Terrain mit Rauschen zu erzeugen, ist das Übereinanderschichten von "
"Rauschebenen mit verschiedenen Frequenzen. Wir verwenden eine Ebene, um die "
"allgemeine Klecksstruktur der Kontinente zu erzeugen. Eine weitere Ebene "
"bricht die Kanten ein wenig auf, dann eine weitere und so weiter. Wir werden "
"``n`` mit vier Zeilen Shader-Code berechnen, anstatt nur mit einer. Aus "
"``n`` wird:"

msgid "And now the planet looks like:"
msgstr "Nun sieht der Planet so aus:"

msgid "And with shading turned back on, it looks like:"
msgstr "Und wenn das Shading wieder aktiviert ist, sieht es so aus:"

msgid "Making an ocean"
msgstr "Erzeugen eines Ozeans"

msgid ""
"One final thing to make this look more like a planet. The ocean and the land "
"reflect light differently. So we want the ocean to shine a little more than "
"the land. We can do this by passing a fourth value into the ``alpha`` "
"channel of our output ``COLOR`` and using it as a Roughness map."
msgstr ""
"Eine letzte Sache, damit es mehr wie ein Planet aussieht. Der Ozean und das "
"Land reflektieren das Licht unterschiedlich. Wir wollen also, dass der Ozean "
"ein wenig mehr leuchtet als das Land. Wir können dies erreichen, indem wir "
"einen vierten Wert in den ``Alpha``-Kanal unserer Ausgabe ``COLOR`` eingeben "
"und ihn als Rauheitskarte verwenden."

msgid ""
"This line returns ``0.3`` for water and ``1.0`` for land. This means that "
"the land is going to be quite rough, while the water will be quite smooth."
msgstr ""
"Diese Zeile liefert ``0.3`` für Wasser und ``1.0`` für Land. Das bedeutet, "
"dass das Land ziemlich rau sein wird, während das Wasser ziemlich glatt sein "
"wird."

msgid ""
"And then, in the material, under the \"Metallic\" section, make sure "
"``Metallic`` is set to ``0`` and ``Specular`` is set to ``1``. The reason "
"for this is the water reflects light really well, but isn't metallic. These "
"values are not physically accurate, but they are good enough for this demo."
msgstr ""
"Dann stellen Sie im Material unter dem Abschnitt \"Metallic\" sicher, daß "
"``Metallic`` auf ``0`` und ``Specular`` auf ``1`` gesetzt ist. Der Grund "
"dafür ist, daß das Wasser das Licht sehr gut reflektiert, aber nicht "
"metallisch ist. Diese Werte sind nicht physikalisch genau, aber für diese "
"Demo sind sie gut genug."

msgid ""
"Next, under the \"Roughness\" section, set ``Roughness`` to ``1`` and set "
"the roughness texture to a :ref:`Viewport Texture <class_ViewportTexture>` "
"pointing to our planet texture :ref:`Viewport <class_Viewport>`. Finally, "
"set the ``Texture Channel`` to ``Alpha``. This instructs the renderer to use "
"the ``alpha`` channel of our output ``COLOR`` as the ``Roughness`` value."
msgstr ""
"Als nächstes setzen Sie im Abschnitt \"Rauheit\" den Wert ``Rauheit`` auf "
"``1`` und setzen die Rauheitstextur auf eine :ref:`Viewport Texture "
"<class_ViewportTexture>`, die auf unsere Planetentextur :ref:`Viewport "
"<class_Viewport>` zeigt. Schließlich setzen wir den ``Texturkanal`` auf "
"``Alpha``. Dies weist den Renderer an, den ``Alpha``-Kanal unserer ``COLOR``-"
"Ausgabe als ``Rauheits``-Wert zu verwenden."

msgid ""
"You'll notice that very little changes except that the planet is no longer "
"reflecting the sky. This is happening because, by default, when something is "
"rendered with an alpha value, it gets drawn as a transparent object over the "
"background. And since the default background of the :ref:`Viewport "
"<class_Viewport>` is opaque, the ``alpha`` channel of the :ref:`Viewport "
"Texture <class_ViewportTexture>` is ``1``, resulting in the planet texture "
"being drawn with slightly fainter colors and a ``Roughness`` value of ``1`` "
"everywhere. To correct this, we go into the :ref:`Viewport <class_Viewport>` "
"and enable the \"Transparent Bg\" property. Since we are now rendering one "
"transparent object on top of another, we want to enable "
"``blend_premul_alpha``:"
msgstr ""
"Sie werden feststellen, dass sich nur sehr wenig ändert, außer dass der "
"Planet den Himmel nicht mehr spiegelt. Dies geschieht, weil standardmäßig, "
"wenn etwas mit einem Alpha-Wert gerendert wird, es als transparentes Objekt "
"über den Hintergrund gezeichnet wird. Und da der Default-Hintergrund des :"
"ref:`Viewport <class_Viewport>` undurchsichtig ist, hat der ``Alpha``-Kanal "
"der :ref:`Viewport Texture <class_ViewportTexture>` den Wert ``1``, was dazu "
"führt, dass die Planetentextur überall mit etwas blasseren Farben und einem "
"``Rauheits``-Wert von ``1`` gezeichnet wird. Um dies zu korrigieren, gehen "
"wir in den :ref:`Viewport <class_Viewport>` und aktivieren die \"Transparent "
"Bg\"-Property. Da wir nun ein transparentes Objekt über ein anderes legen, "
"müssen wir ``blend_premul_alpha`` aktivieren:"

msgid ""
"This pre-multiplies the colors by the ``alpha`` value and then blends them "
"correctly together. Typically, when blending one transparent color on top of "
"another, even if the background has an ``alpha`` of ``0`` (as it does in "
"this case), you end up with weird color bleed issues. Setting "
"``blend_premul_alpha`` fixes that."
msgstr ""
"Dadurch werden die Farben mit dem ``Alpha``-Wert vormultipliziert und dann "
"korrekt zusammengemischt. Wenn man eine transparente Farbe über eine andere "
"mischt, selbst wenn der Hintergrund einen ``Alpha``-Wert von ``0`` hat (wie "
"in diesem Fall), kommt es normalerweise zu seltsamen Farbverläufen. Die "
"Einstellung ``blend_premul_alpha`` behebt das."

msgid ""
"Now the planet should look like it is reflecting light on the ocean but not "
"the land. If you haven't done so already, add an :ref:`OmniLight3D "
"<class_OmniLight3D>` to the scene so you can move it around and see the "
"effect of the reflections on the ocean."
msgstr ""
"Jetzt sollte der Planet so aussehen, als würde er das Licht auf dem Meer "
"reflektieren, aber nicht auf dem Land. Wenn Sie es noch nicht getan haben, "
"fügen Sie ein :ref:`OmniLight3D <class_OmniLight3D>` zur Szene hinzu, damit "
"Sie es bewegen und den Effekt der Reflexionen auf dem Ozean sehen können."

msgid ""
"And there you have it. A procedural planet generated using a :ref:`Viewport "
"<class_Viewport>`."
msgstr ""
"Und da haben Sie es. Ein prozeduraler Planet, der unter Verwendung eines :"
"ref:`Viewports <class_Viewport>` generiert wurde."

msgid "Translation status"
msgstr "Übersetzungsstatus"
