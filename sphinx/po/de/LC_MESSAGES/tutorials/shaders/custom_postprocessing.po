# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Custom post-processing"
msgstr "Benutzerdefinierte Nachbearbeitung"

msgid "Introduction"
msgstr "Einführung"

msgid ""
"Godot provides many post-processing effects out of the box, including Bloom, "
"DOF, and SSAO, which are described in :ref:"
"`doc_environment_and_post_processing`. However, advanced use cases may "
"require custom effects. This article explains how to write your own custom "
"effects."
msgstr ""
"Godot bietet von Haus aus viele Nachbearbeitungseffekte, einschließlich "
"Bloom, DOF und SSAO, die in :ref:`doc_environment_and_post_processing` "
"beschrieben sind. Für fortgeschrittene Anwendungsfälle können jedoch eigene "
"Effekte erforderlich sein. Dieser Artikel erklärt, wie Sie Ihre eigenen "
"benutzerdefinierten Effekte schreiben können."

msgid ""
"The easiest way to implement a custom post-processing shader is to use "
"Godot's built-in ability to read from the screen texture. If you're not "
"familiar with this, you should read the :ref:`Screen Reading Shaders "
"Tutorial <doc_screen-reading_shaders>` first."
msgstr ""
"Der einfachste Weg einen benutzerdefinierten Nachbearbeitungs-Shader zu "
"implementieren, besteht darin, die in Godot integrierte Fähigkeit zum Lesen "
"der Bildschirmtextur zu verwenden. Wenn Sie damit nicht vertraut sind, "
"sollten Sie zuerst die :ref:`Screen Reading-Shader Anleitung <doc_screen-"
"reading_shaders>` lesen."

msgid "Single pass post-processing"
msgstr "Single Pass Post Processing"

msgid ""
"Post-processing effects are shaders applied to a frame after Godot has "
"rendered it. To apply a shader to a frame, create a :ref:`CanvasLayer "
"<class_CanvasLayer>`, and give it a :ref:`ColorRect <class_ColorRect>`. "
"Assign a new :ref:`ShaderMaterial <class_ShaderMaterial>` to the newly "
"created ``ColorRect``, and set the ``ColorRect``'s layout to \"Full Rect\"."
msgstr ""
"Nachbearbeitungseffekte sind Shader, die auf ein Bild angewendet werden, "
"nachdem Godot es gerendert hat. Um einen Shader auf ein Frame anzuwenden, "
"erstellen Sie einen :ref:`CanvasLayer <class_CanvasLayer>`, und geben Sie "
"ihm einen :ref:`ColorRect <class_ColorRect>`. Weisen Sie ein neues :ref:"
"`ShaderMaterial <class_ShaderMaterial>` dem neu erstellten ``ColorRect`` zu "
"und setzen Sie das Layout des ``ColorRect`` auf \"Vollständiges Rechteck\"."

msgid "Your scene tree will look something like this:"
msgstr "Ihr Szenenbaum wird in etwa so aussehen:"

msgid ""
"Another more efficient method is to use a :ref:`BackBufferCopy "
"<class_BackBufferCopy>` to copy a region of the screen to a buffer and to "
"access it in a shader script through a ``sampler2D`` using "
"``hint_screen_texture``."
msgstr ""
"Eine weitere, effizientere Methode ist die Verwendung eines :ref:"
"`BackBufferCopy <class_BackBufferCopy>`, um einen Bereich des Bildschirms in "
"einen Puffer zu kopieren und in einem Shader-Skript über einen ``sampler2D`` "
"mit ``hint_screen_texture`` darauf zuzugreifen."

msgid ""
"As of the time of writing, Godot does not support rendering to multiple "
"buffers at the same time. Your post-processing shader will not have access "
"to other render passes and buffers not exposed by Godot (such as depth or "
"normal/roughness). You only have access to the rendered frame and buffers "
"exposed by Godot as samplers."
msgstr ""
"Zum Zeitpunkt der Erstellung dieses Artikels unterstützt Godot nicht das "
"gleichzeitige Rendern in mehrere Puffer. Ihr Post-Processing-Shader hat "
"keinen Zugriff auf andere Render-Passes und Puffer, die nicht von Godot "
"bereitgestellt werden (wie Tiefe oder Normalen/Rauheit). Sie haben nur "
"Zugriff auf den gerenderten Frame und die Puffer, die von Godot als Sampler "
"bereitgestellt werden."

msgid ""
"For this demo, we will use this :ref:`Sprite <class_Sprite2D>` of a sheep."
msgstr ""
"Für diese Demo werden wir diesen :ref:`Sprite <class_Sprite2D>` eines "
"Schafes verwenden."

msgid ""
"Assign a new :ref:`Shader <class_Shader>` to the ``ColorRect``'s "
"``ShaderMaterial``. You can access the frame's texture and UV with a "
"``sampler2D`` using ``hint_screen_texture`` and the built in ``SCREEN_UV`` "
"uniforms."
msgstr ""
"Weisen Sie dem ``ShaderMaterial`` des ``ColorRect`` einen neuen :ref:`Shader "
"<class_Shader>` zu. Sie können auf die Textur und UV des Frames mit einem "
"``sampler2D`` zugreifen, indem Sie ``hint_screen_texture`` und die Built-in-"
"``SCREEN_UV``-Uniforms benutzen."

msgid ""
"Copy the following code to your shader. The code below is a hex pixelization "
"shader by `arlez80 <https://bitbucket.org/arlez80/hex-mosaic/src/master/>`_,"
msgstr ""
"Kopieren Sie den folgenden Code in Ihren Shader. Der folgende Code ist ein "
"Hex-Pixelisierungs-Shader von `arlez80 <https://bitbucket.org/arlez80/hex-"
"mosaic/src/master/>`_,"

msgid "The sheep will look something like this:"
msgstr "Das Schaf wird etwa so aussehen:"

msgid "Multi-pass post-processing"
msgstr "Multi Pass Post Processing"

msgid ""
"Some post-processing effects like blurs are resource intensive. You can make "
"them run a lot faster if you break them down in multiple passes. In a "
"multipass material, each pass takes the result from the previous pass as an "
"input and processes it."
msgstr ""
"Einige Post Processing-Effekte wie Unschärfen sind ressourcenintensiv. Sie "
"können viel schneller ausgeführt werden, wenn Sie sie in mehrere Durchgänge "
"aufteilen. In einem Multi Pass-Material nimmt jeder Durchlauf das Ergebnis "
"des vorherigen Durchlaufs als Eingabe und verarbeitet es."

msgid ""
"To produce a multi-pass post-processing shader, you stack ``CanvasLayer`` "
"and ``ColorRect`` nodes. In the example above, you use a ``CanvasLayer`` "
"object to render a shader using the frame on the layer below. Apart from the "
"node structure, the steps are the same as with the single-pass post-"
"processing shader."
msgstr ""
"Um einen Multi-Pass Post-Processing-Shader zu erzeugen, stapeln Sie "
"``CanvasLayer`` und ``ColorRect``-Nodes. Im obigen Beispiel verwenden Sie "
"ein ``CanvasLayer``-Objekt, um einen Shader zu rendern, der das Frame der "
"darunter liegenden Ebene verwendet. Abgesehen von der Struktur der Nodes "
"sind die Schritte die gleichen wie beim Single Pass Post Processing-Shader."

msgid ""
"As an example, you could write a full screen Gaussian blur effect by "
"attaching the following pieces of code to each of the ``ColorRect`` nodes. "
"The order in which you apply the shaders depends on the position of the "
"``CanvasLayer`` in the scene tree, higher means sooner. For this blur "
"shader, the order does not matter."
msgstr ""
"Als Beispiel könnten Sie einen Vollbild-Gaußschen Weichzeichner-Effekt "
"schreiben, indem Sie die folgenden Code-Stücke an jeden der ``ColorRect``-"
"Nodes anhängen. Die Reihenfolge, in der Sie die Shader anwenden, hängt von "
"der Position des ``CanvasLayer`` im Szenenbaum ab, höher bedeutet früher. "
"Für diesen Blur-Shader spielt die Reihenfolge keine Rolle."

msgid ""
"Using the above code, you should end up with a full screen blur effect like "
"below."
msgstr ""
"Wenn Sie den obigen Code verwenden, sollten Sie einen Unschärfeeffekt für "
"den gesamten Bildschirm erhalten, wie unten dargestellt."

msgid "Translation status"
msgstr "Übersetzungsstatus"
