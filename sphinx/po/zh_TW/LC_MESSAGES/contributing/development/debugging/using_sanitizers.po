# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using sanitizers"
msgstr "建立內容"

msgid "What are sanitizers?"
msgstr "什麼是 Sanitizer？"

msgid ""
"Sanitizers are static instrumentation tools that help find bugs that "
"traditional debuggers usually cannot catch. This is particularly useful when "
"combined with :ref:`doc_unit_testing` in continuous integration."
msgstr ""
"Sanitizer 是一種靜態偵測工具，能夠説明找出傳統除錯器通常無法捕捉的問題。非常"
"適合在持續集成中與 :ref:`doc_unit_testing` 結合使用。"

msgid ""
"Sanitizers can be used on Windows, macOS and Linux by using the Clang "
"(LLVM), GCC or Visual Studio compilers. :ref:`Certain platforms "
"<doc_using_sanitizers_platform_specific_sanitizers>` may also have their own "
"sanitizers available. In situations where a single sanitizer is provided by "
"several different compilers, remember that their output and behavior will "
"differ slightly."
msgstr ""
"在 Windows、macOS、Linux 平臺使用 Clang（LLVM）、GCC、Visual Studio 編譯器時"
"能夠使用 Sanitizer。:ref:`部分平臺 "
"<doc_using_sanitizers_platform_specific_sanitizers>`可能也可以使用其獨有的 "
"Sanitizer。多種不同的編譯器都提供相同的某種 Sanitizer 時，請記住它們的輸出和"
"行為有可能略有不同。"

msgid "Using sanitizers on Godot"
msgstr "在 Godot 中使用 NuGet 套件"

msgid ""
"Sanitizers **require** recompiling the binary. This means you cannot use "
"official Godot binaries to run sanitizers."
msgstr ""
"Sanitizer **要求**重新編譯二進位檔案。這意味著你無法使用官方 Godot 二進位檔案"
"來運作 Sanitizer。"

msgid ""
"When :ref:`compiling <toc-devel-compiling>` with any of the sanitizers "
"enabled, the resulting binary will have the ``.san`` suffix added to its "
"name to distinguish it from a binary without sanitizers."
msgstr ""
"當在啟用任何消毒劑的情況下編譯 <toc-devel-compiling>` 時，生成的二進位檔案將"
"在其名稱中新增``.san`` 後綴，以將其與沒有消毒劑的二進位檔案區分開來。"

msgid ""
"There is a performance impact as many additional runtime checks need to be "
"performed. Memory utilization will also increase. It is possible to enable "
"certain combinations of multiple sanitizers in a single build. Beware of the "
"performance impact when using multiple sanitizers at once though, as the "
"resulting binary may be excessively slow."
msgstr ""
"由於需要執行許多額外的運作時檢查，因此會對效能產生影響。記憶體利用率也會增"
"加。可以在單一建構中啟用多種消毒劑的某些組合。不過，請注意同時使用多個消毒劑"
"時的性能影響，因為生成的二進位可能會非常慢。"

msgid ""
"Certain options can be passed to sanitizers without having to recompile the "
"binary using environment variables."
msgstr "某些選項可以傳遞給清理程式，而無需使用環境變數重新編譯二進位。"

msgid "Address sanitizer (ASAN)"
msgstr "地址 Sanitizer（ASAN）"

msgid "Available in Clang and GCC."
msgstr "與其他腳本語言溝通"

msgid "**Supported platforms:** Linux, macOS, Windows (Visual Studio), Web"
msgstr "**支援的平臺：**Linux、macOS、Windows（Visual Studio）、Web"

msgid ""
"`Clang ASAN documentation <https://clang.llvm.org/docs/AddressSanitizer."
"html>`__"
msgstr ""
"`Clang ASAN 文件 <https://clang.llvm.org/docs/AddressSanitizer.html>`__"

msgid ""
"The address sanitizer is generally the most frequently used sanitizer. It "
"can diagnose issues such as buffer overruns and out-of-bounds access. If the "
"engine crashes with a message such as ``free(): invalid pointer``, this is "
"typically the result of a buffer overrun. (This message is printed by the C "
"runtime, not Godot.)"
msgstr ""
"地址消毒劑通常是最常用的消毒劑。它可以診斷緩衝區溢位和越界存取等問題。如果引"
"擎當機並顯示諸如“free()：無效指標”之類的訊息，這通常是緩衝區溢位的結果。 （此"
"訊息是由 C 運作時列印的，而不是 Godot。）"

msgid ""
"In certain situations (such as detecting uninitialized memory reads), the "
"address sanitizer doesn't suffice. The :ref:"
"`doc_using_sanitizers_memory_sanitizer` should be used instead."
msgstr ""
"在某些情況下（例如偵測未初始化的記憶體讀取），位址清理程式還不夠。應使用 :"
"ref:`doc_using_sanitizers_memory_sanitizer` 來代替。"

msgid ""
"It is also possible to detect use-after-return situations by specifying the "
"``ASAN_OPTIONS=detect_stack_use_after_return=1`` environment variable before "
"*running* Godot (not when compiling it). This increases the address "
"sanitizer's runtime overhead, so only enable this feature when you actually "
"need it."
msgstr ""
"也可以透過在*執行* Godot 之前（而不是在編譯時）指定"
"「ASAN_OPTIONS=detect_stack_use_after_return=1」環境變數來偵測返回後使用情"
"況。這會增加地址清理程式的運作時開銷，因此僅在實際需要時才啟用此功能。"

msgid ""
"To enable the address sanitizer in a Godot build, pass the ``use_asan=yes`` "
"SCons option when compiling. Enabling ASAN generally makes the resulting "
"binary about 2× slower."
msgstr ""
"若要在 Godot 建置中啟用地址清理程式，請在編譯時傳遞“use_asan=yes”SCons 選項。"
"啟用 ASAN 通常會使產生的二進位檔案變慢約 2 倍。"

msgid ""
"Due to a `design decision <https://stackoverflow.com/questions/36971902/why-"
"cant-clang-enable-all-sanitizers/>`__, the address, memory and thread "
"sanitizers are mutually exclusive. This means you can only use one of those "
"sanitizers in a given binary."
msgstr ""
"由於“設計決策<https://stackoverflow.com/questions/36971902/why-cant-clang-"
"enable-all-sanitizers/>”，位址、記憶體和執行緒清理器是互斥的。這意味著您只能"
"在給定的二進位檔案中使用其中一種消毒劑。"

msgid "Leak sanitizer (LSAN)"
msgstr "洩漏 Sanitizer（LSAN）"

msgid "**Supported platforms:** Linux, Web"
msgstr "支援所有平台。"

msgid ""
"`Clang LSAN documentation <https://clang.llvm.org/docs/LeakSanitizer.html>`__"
msgstr "`Clang LSAN 文件 <https://clang.llvm.org/docs/LeakSanitizer.html>`__"

msgid ""
"The leak sanitizer can detect memory leaks, which are situations where "
"memory that is no longer in use is never freed by the running program. This "
"can potentially lead to out-of-memory situations if the program runs for "
"long enough. Since Godot may run on :ref:`dedicated servers "
"<doc_exporting_for_dedicated_servers>` for months or even years without a "
"restart, it's important to fix memory leaks when they occur."
msgstr ""
"洩漏清理程式可以偵測記憶體洩漏，即執行的程式永遠不會釋放不再使用的記憶體的情"
"況。如果程式運作時間夠長，這可能會導致記憶體不足的情況。由於 Godot 可能會在專"
"用伺服器 <doc_exporting_for_dedicated_servers>` 上運作數月甚至數年而無需重新"
"啟動，因此在發生記憶體洩漏時修復記憶體洩漏非常重要。"

msgid ""
"To enable the leak sanitizer in a Godot build, pass the ``use_lsan=yes`` "
"SCons option when compiling. Enabling LSAN only has a small performance "
"overhead, but the program will be much slower to exit as leak detection "
"occurs when the program exits."
msgstr ""
"若要在 Godot 建置中啟用洩漏清理程式，請在編譯時傳遞「use_lsan=yes」SCons 選"
"項。啟用LSAN只會有很小的效能開銷，但程式退出時會慢很多，因為程式退出時會發生"
"洩漏偵測。"

msgid "Memory sanitizer (MSAN)"
msgstr "記憶體 Sanitizer（MSAN）"

msgid "Available in Clang only, not GCC."
msgstr "僅 Clang 可用，GCC 不可用。"

msgid "**Supported platforms:** Linux"
msgstr "支援所有平台。"

msgid ""
"`Clang MSAN documentation <https://clang.llvm.org/docs/MemorySanitizer."
"html>`__"
msgstr "`Clang MSAN 文件 <https://clang.llvm.org/docs/MemorySanitizer.html>`__"

msgid ""
"The memory sanitizer complements the :ref:"
"`doc_using_sanitizers_address_sanitizer`. Unlike the address sanitizer, the "
"memory sanitizer can detect uninitialized memory reads."
msgstr ""
"記憶體清理程式是 doc_using_sanitizers_address_sanitizer 的補充。與位址清理程"
"式不同，記憶體清理程式可以偵測未初始化的記憶體讀取。"

msgid ""
"To enable the memory sanitizer in a Godot build, pass the ``use_msan=yes`` "
"SCons option when compiling. Enabling MSAN generally makes the resulting "
"binary about 3× slower."
msgstr ""
"若要在 Godot 建置中啟用記憶體清理程式，請在編譯時傳遞「use_msan=yes」SCons 選"
"項。啟用 MSAN 通常會使產生的二進位檔案變慢約 3 倍。"

msgid "Thread sanitizer (TSAN)"
msgstr "執行緒 Sanitizer（TSAN）"

msgid "**Supported platforms:** Linux, macOS"
msgstr "支援所有平台。"

msgid ""
"`Clang TSAN documentation <https://clang.llvm.org/docs/ThreadSanitizer."
"html>`__"
msgstr "`Clang TSAN 文件 <https://clang.llvm.org/docs/ThreadSanitizer.html>`__"

msgid ""
"The thread sanitizer is used to track down race conditions related to "
"multithreading. A race condition is when multiple threads try to modify the "
"same data at the same time. Since thread scheduling can be ordered in any "
"fashion by the operating system, this leads to incorrect behavior that only "
"occurs occasionally (and can be difficult to track as a result). To prevent "
"a race condition, you need to add a lock to ensure only one thread can "
"access the shared data at a given time."
msgstr ""
"執行緒清理程式用於追蹤與多執行緒相關的競爭條件。競爭條件是指多個執行緒嘗試同"
"時修改相同的資料。由於作業系統可以以任何方式對執行緒調度進行排序，因此這會導"
"致偶爾發生的不正確行為（並且因此可能難以追蹤）。為了防止競爭條件，您需要新增"
"一把鎖以確保在給定時間只有一個執行緒可以存取共享資料。"

msgid ""
"To enable the thread sanitizer in a Godot build, pass the ``use_tsan=yes`` "
"SCons option when compiling. Enabling TSAN generally makes the resulting "
"binary 10× slower, while also multiplying memory usage by an approximately "
"8× factor."
msgstr ""
"若要在 Godot 建置中啟用執行緒清理程式，請在編譯時傳遞“use_tsan=yes”SCons 選"
"項。啟用 TSAN 通常會使產生的二進位檔案變慢 10 倍，同時也會使記憶體使用量增加"
"約 8 倍。"

msgid "Undefined behavior sanitizer (UBSAN)"
msgstr "未定義行為 Sanitizer（UBSAN）"

msgid "**Supported platforms:** Linux, macOS, Web"
msgstr "支援所有平台。"

msgid ""
"`Clang UBSAN documentation <https://clang.llvm.org/docs/"
"UndefinedBehaviorSanitizer.html>`__"
msgstr ""
"`Clang UBSAN 文件 <https://clang.llvm.org/docs/UndefinedBehaviorSanitizer."
"html>`__"

msgid ""
"The undefined behavior sanitizer is used to track down situations where the "
"program exhibits random and unpredictable behavior. This is due to C/C++ "
"code that is accepted by the compiler, but is not *correct*. Compiling with "
"a different set of optimizations can also change the observed results of "
"undefined behavior."
msgstr ""
"未定義行為清理器用於追蹤程式表現出隨機和不可預測行為的情況。這是因為 C/C++ 程"
"式碼被編譯器接受，但不*正確*。使用不同的最佳化集進行編譯還可以更改未定義行為"
"的觀察結果。"

msgid ""
"To enable the undefined behavior sanitizer in a Godot build, pass the "
"``use_ubsan=yes`` SCons option when compiling. Enabling UBSAN only has a "
"small performance overhead."
msgstr ""
"若要在 Godot 建置中啟用未定義行為清理程式，請在編譯時傳"
"遞“use_ubsan=yes”SCons 選項。啟用 UBSAN 僅產生很小的效能開銷。"

msgid "Platform-specific sanitizers"
msgstr "個別平台"

msgid "Web"
msgstr "Web"

msgid ""
"When :ref:`compiling for the Web <doc_compiling_for_web>`, there are 2 "
"additional sanitizer SCons options available:"
msgstr ""
"當為 Web 編譯 <doc_compiling_for_web>` 時，有 2 個額外的 sanitizer SCons 選項"
"可用："

msgid ""
"``use_assertions=yes`` enables runtime Emscripten assertions, which can "
"catch various issues."
msgstr ""
"``use_assertions=yes`` 啟用運作時 Emscripten 判斷提示，它可以捕獲各種問題。"

msgid ""
"``use_safe_heap=yes`` enables `Emscripten's SAFE_HEAP sanitizer <https://"
"emscripten.org/docs/debugging/Sanitizers.html>`__. It provides similar "
"functionality to ASAN, but it focuses on issues that are specific to "
"WebAssembly. ``SAFE_HEAP`` is not guaranteed to be compatible with ASAN and "
"UBSAN in the same binary, so you may have to build it separately."
msgstr ""
"``use_safe_heap=yes`` 啟用 `Emscripten 的 SAFE_HEAP 清理器 <https://"
"emscripten.org/docs/debugging/Sanitizers.html>`__。它提供與 ASAN 類似的功能，"
"但它側重於 WebAssembly 特有的問題。 ``SAFE_HEAP`` 不保證與相同二進位檔案中的 "
"ASAN 和 UBSAN 相容，因此您可能需要單獨建置它。"

msgid "Translation status"
msgstr "翻譯狀態"
