# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Jumping and squashing monsters"
msgstr "跳躍與壓扁怪物"

msgid ""
"In this part, we'll add the ability to jump and squash the monsters. In the "
"next lesson, we'll make the player die when a monster hits them on the "
"ground."
msgstr ""
"在這一部分中，我們將新增跳躍、踩扁怪物的能力。在下一節課中，我們會讓怪物在地"
"面上擊中玩家時讓玩家死亡。"

msgid ""
"First, we have to change a few settings related to physics interactions. "
"Enter the world of :ref:`physics layers "
"<doc_physics_introduction_collision_layers_and_masks>`."
msgstr "更多有關光照烘焙的資訊，請參考 :ref:`doc_baked_lightmaps` 。"

msgid "Controlling physics interactions"
msgstr "建立內容"

msgid ""
"Physics bodies have access to two complementary properties: layers and "
"masks. Layers define on which physics layer(s) an object is."
msgstr ""
"物理實體可以存取兩個互補的屬性：層和遮罩。層（Layer）定義的是該物件位於哪些實"
"體層上。"

msgid ""
"Masks control the layers that a body will listen to and detect. This affects "
"collision detection. When you want two bodies to interact, you need at least "
"one to have a mask corresponding to the other."
msgstr ""
"遮罩（Mask）控制的是該實體會監聽並偵測的層，會影響碰撞偵測。希望兩個實體能夠"
"發生互動時，你需要讓其中至少一個的遮罩與另一個（的層）相對應。"

msgid "If that's confusing, don't worry, we'll see three examples in a second."
msgstr "可能有點繞，但請別擔心，我們馬上就會看到三個例子。"

msgid ""
"The important point is that you can use layers and masks to filter physics "
"interactions, control performance, and remove the need for extra conditions "
"in your code."
msgstr ""
"重要的知識點是，你能夠使用層和遮罩來篩選物理互動、控制性能、讓程式碼中不需要"
"再做額外的條件偵測。"

msgid ""
"By default, all physics bodies and areas are set to both layer and mask "
"``1``. This means they all collide with each other."
msgstr ""
"預設情況下，所有物理體和區域的層和遮罩都被設成了 ``1``。也就是說它們會互相碰"
"撞。"

msgid ""
"Physics layers are represented by numbers, but we can give them names to "
"keep track of what's what."
msgstr "實體層由數字表示，但我們也可以為它們命名，記錄什麼是什麼。"

msgid "Setting layer names"
msgstr "設定 SCons"

msgid ""
"Let's give our physics layers a name. Go to *Project -> Project Settings*."
msgstr "讓我們來為實體層命名。打開*專案 -> 專案設定*。"

msgid "|image0|"
msgstr "\\ |image0|"

msgid "image0"
msgstr "image0"

msgid ""
"In the left menu, navigate down to *Layer Names -> 3D Physics*. You can see "
"a list of layers with a field next to each of them on the right. You can set "
"their names there. Name the first three layers *player*, *enemies*, and "
"*world*, respectively."
msgstr ""
"在左側的選單中，找到 *Layer Names -> 3D Physics*（層名稱 -> 3D 物理）。你可以"
"在右側看到層的列表，每一層右側都有一個欄位，可以用來設定名稱。將前三層分別命"
"名為“player”“enemies”“world”（玩家、敵人、世界）。"

msgid "|image1|"
msgstr "\\ |image1|"

msgid "image1"
msgstr "image1"

msgid "Now, we can assign them to our physics nodes."
msgstr "現在，我們就可以將它們分配給我們的物理節點了。"

msgid "Assigning layers and masks"
msgstr "層和遮罩的分配"

msgid ""
"In the *Main* scene, select the ``Ground`` node. In the *Inspector*, expand "
"the *Collision* section. There, you can see the node's layers and masks as a "
"grid of buttons."
msgstr ""
"在 *Main* 場景中選中 ``Ground`` 節點。在*屬性面板*中展開 *Collision*（碰撞）"
"部分。你可以看到，該節點的層和遮罩在這裡以按鈕網格的形式排列。"

msgid "|image2|"
msgstr "\\ |image2|"

msgid "image2"
msgstr "image2"

msgid ""
"The ground is part of the world, so we want it to be part of the third "
"layer. Click the lit button to toggle **off** the first *Layer* and toggle "
"**on** the third one. Then, toggle **off** the *Mask* by clicking on it."
msgstr ""
"地面是世界的一部分，所以我們希望它屬於第三層。點擊 *Layer* 中的第一個點亮的按"
"鈕將其**關閉**，**打開**第三層。然後點擊**關閉** *Mask*。"

msgid "|image3|"
msgstr "\\ |image3|"

msgid "image3"
msgstr "image3"

msgid ""
"As mentioned before, the *Mask* property allows a node to listen to "
"interaction with other physics objects, but we don't need it to have "
"collisions. ``Ground`` doesn't need to listen to anything; it's just there "
"to prevent creatures from falling."
msgstr ""
"上面說到過，*Mask* 屬性可以讓節點監聽與其他物理物件的互動，但它不是實作碰撞所"
"必須的。``Ground`` 不需要監聽任何東西；它存在的意義是防止生物下落。"

msgid ""
"Note that you can click the \"...\" button on the right side of the "
"properties to see a list of named checkboxes."
msgstr "請注意，點擊右側的“...”按鈕會將該屬性以帶名稱的核取方塊的形式展示。"

msgid "|image4|"
msgstr "\\ |image4|"

msgid "image4"
msgstr "image4"

msgid ""
"Next up are the ``Player`` and the ``Mob``. Open ``player.tscn`` by double-"
"clicking the file in the *FileSystem* dock."
msgstr ""
"接下來就是 ``Player`` 和 ``Mob``。在*檔案系統*面板中按兩下打開 ``player."
"tscn`` 檔案。"

msgid ""
"Select the *Player* node and set its *Collision -> Mask* to both \"enemies\" "
"and \"world\". You can leave the default *Layer* property as it is, because "
"the first layer is the \"player\" layer."
msgstr ""
"選中 *Player* 節點，將其 *Collision -> Mask* 設為“enemies”和“world”。*Layer* "
"屬性可以保持預設，因為第一個層就是“player”層。"

msgid "|image5|"
msgstr "\\ |image5|"

msgid "image5"
msgstr "image5"

msgid ""
"Then, open the *Mob* scene by double-clicking on ``mob.tscn`` and select the "
"``Mob`` node."
msgstr "然後按兩下 ``mob.tscn`` 打開 *Mob* 場景，選中 ``Mob`` 節點。"

msgid ""
"Set its *Collision -> Layer* to \"enemies\" and unset its *Collision -> "
"Mask*, leaving the mask empty."
msgstr ""
"將其 *Collision -> Layer* 設為“enemies”，然後取消 *Collision -> Mask* 的設"
"定，讓遮罩為空。"

msgid "|image6|"
msgstr "|image6|"

msgid "image6"
msgstr "image6"

msgid ""
"These settings mean the monsters will move through one another. If you want "
"the monsters to collide with and slide against each other, turn **on** the "
"\"enemies\" mask."
msgstr ""
"這些設定意味著怪物可以互相穿越。如果你希望怪物之間會發生碰撞和滑動，請**打開"
"**“enemies”遮罩。"

msgid ""
"The mobs don't need to mask the \"world\" layer because they only move on "
"the XZ plane. We don't apply any gravity to them by design."
msgstr ""
"小怪並不需要遮罩“world”層，因為它們只會沿著 XZ 平面移動。我們是故意不去為它們"
"新增重力影響的。"

msgid "Jumping"
msgstr "跳躍"

msgid ""
"The jumping mechanic itself requires only two lines of code. Open the "
"*Player* script. We need a value to control the jump's strength and update "
"``_physics_process()`` to code the jump."
msgstr ""
"跳躍機制本身只需要兩行程式碼。打開 *Player* 腳本。我們需要一個值來控制跳躍的"
"強度，並更新 ``_physics_process()`` 來對跳躍進行編碼。"

msgid ""
"After the line that defines ``fall_acceleration``, at the top of the script, "
"add the ``jump_impulse``."
msgstr ""
"在定義 ``fall_acceleration`` 這一行之後，在腳本的頂部，新增 "
"``jump_impulse``。"

msgid ""
"Inside ``_physics_process()``, add the following code before the "
"``move_and_slide()`` codeblock."
msgstr ""
"在 ``_physics_process()`` 內，請在呼叫 ``move_and_slide()`` 那塊程式碼之前新"
"增以下程式碼。"

msgid "That's all you need to jump!"
msgstr "這就是跳躍所需的所有東西！"

msgid ""
"The ``is_on_floor()`` method is a tool from the ``CharacterBody3D`` class. "
"It returns ``true`` if the body collided with the floor in this frame. "
"That's why we apply gravity to the *Player*: so we collide with the floor "
"instead of floating over it like the monsters."
msgstr ""
"``is_on_floor()`` 方法是來自 ``CharacterBody3D`` 類的工具。如果物體在這一影格"
"中與地板發生碰撞返回 ``true``。這就是為什麼我們要對 *Player* 施加重力的原因："
"這樣我們就會與地板相撞，而不是像怪物一樣漂浮在地板上。"

msgid ""
"If the character is on the floor and the player presses \"jump\", we "
"instantly give them a lot of vertical speed. In games, you really want "
"controls to be responsive and giving instant speed boosts like these, while "
"unrealistic, feels great."
msgstr ""
"如果角色在地板上並且玩家按下跳躍，立即給予角色較大的垂直速度，因為在遊戲中，"
"玩家通常希望控制能得到回應，就像這樣提供的即時速度提升，雖然不切實際，但會令"
"玩家感覺很好。"

msgid ""
"Notice that the Y axis is positive upwards. That's unlike 2D, where the Y "
"axis is positive downwards."
msgstr ""
"請注意，Y 軸的正方向是朝上的。這與 2D 有所不同， 2D的Y 軸的正方向是朝下的。"

msgid "Squashing monsters"
msgstr "建立內容"

msgid ""
"Let's add the squash mechanic next. We're going to make the character bounce "
"over monsters and kill them at the same time."
msgstr ""
"接下來讓我們來新增踩扁機制。我們會讓玩家在怪物身上彈起，並同時消滅它們。"

msgid ""
"We need to detect collisions with a monster and to differentiate them from "
"collisions with the floor. To do so, we can use Godot's :ref:`group "
"<doc_groups>` tagging feature."
msgstr ""
"我們需要偵測與怪物的碰撞，並和與地板的碰撞相區分。要這麼做，我們可以使用 "
"Godot 的:ref:`群組 <doc_groups>`標籤功能。"

msgid ""
"Open the scene ``mob.tscn`` again and select the *Mob* node. Go to the "
"*Node* dock on the right to see a list of signals. The *Node* dock has two "
"tabs: *Signals*, which you've already used, and *Groups*, which allows you "
"to assign tags to nodes."
msgstr ""
"再次打開 ``mob.tscn`` 場景，選中 *Mob* 節點，就能在右側的*Node*面板中看到訊號"
"的列表。*Node*面板有兩個分頁：你已經使用過的*Signals*，以及*Groups*它允許您為"
"節點新增標籤。"

msgid ""
"Click on it to reveal a field where you can write a tag name. Enter \"mob\" "
"in the field and click the *Add* button."
msgstr ""
"按一下這個分頁就會出現一個輸入框，可以填寫標籤的名稱。在這個輸入框中輸"
"入“mob”（小怪）並按一下*新增*按鈕。"

msgid "|image7|"
msgstr "|image7|"

msgid "image7"
msgstr "image7"

msgid ""
"An icon appears in the *Scene* dock to indicate the node is part of at least "
"one group."
msgstr "*場景*面板中會出現一個圖示，表示該節點至少處在一個群組之中。"

msgid "|image8|"
msgstr "|image8|"

msgid "image8"
msgstr "image8"

msgid ""
"We can now use the group from the code to distinguish collisions with "
"monsters from collisions with the floor."
msgstr "我們現在就可以在程式碼中使用群組來區分與怪物的碰撞和與地板的碰撞了。"

msgid "Coding the squash mechanic"
msgstr "編寫踩扁機制"

msgid "Head back to the *Player* script to code the squash and bounce."
msgstr "回到 *Player* 腳本來編寫踩扁和彈跳。"

msgid ""
"At the top of the script, we need another property, ``bounce_impulse``. When "
"squashing an enemy, we don't necessarily want the character to go as high up "
"as when jumping."
msgstr ""
"在腳本頂部，我們需要新增一個屬性 ``bounce_impulse``。踩扁敵人時，我們不必讓角"
"色彈得比跳躍一樣高。"

msgid ""
"Then, after the **Jumping** codeblock we added above in "
"``_physics_process()``, add the following loop. With ``move_and_slide()``, "
"Godot makes the body move sometimes multiple times in a row to smooth out "
"the character's motion. So we have to loop over all collisions that may have "
"happened."
msgstr ""
"在**Jumping**程式碼塊之後,我們在``_physics_process()`` 之中新增以下迴圈。使"
"用 ``move_and_slide()``時，Godot 會讓實體連續進行多次移動，以平滑角色的運動。"
"所以我們要迴圈走訪所有可能發生的碰撞。"

msgid ""
"In every iteration of the loop, we check if we landed on a mob. If so, we "
"kill it and bounce."
msgstr ""
"在迴圈的每次反覆運算中，我們會檢查是否落在了小怪身上。如果是的話，我們就消滅"
"它並進行彈跳。"

msgid ""
"With this code, if no collisions occurred on a given frame, the loop won't "
"run."
msgstr "如果某一影格沒有發生碰撞，那麼這段程式碼中的迴圈就不會執行。"

msgid "That's a lot of new functions. Here's some more information about them."
msgstr "新函式很多。下面我們來進一步介紹一下。"

msgid ""
"The functions ``get_slide_collision_count()`` and ``get_slide_collision()`` "
"both come from the :ref:`CharacterBody3D <class_CharacterBody3D>` class and "
"are related to ``move_and_slide()``."
msgstr ""
"函式``get_slide_count()`` 和 ``get_slide_collision()`` 都來自於 :ref:"
"`KinematicBody<class_KinematicBody>` 類，且都與 ``move_and_slide()`` 有關。"

msgid ""
"``get_slide_collision()`` returns a :ref:"
"`KinematicCollision3D<class_KinematicCollision3D>` object that holds "
"information about where and how the collision occurred. For example, we use "
"its ``get_collider`` property to check if we collided with a \"mob\" by "
"calling ``is_in_group()`` on it: ``collision.get_collider()."
"is_in_group(\"mob\")``."
msgstr ""
"``get_slide_collision()`` 返回的是 :ref:"
"`KinematicCollision3D<class_KinematicCollision3D>` 物件，包含碰撞在哪裡發生、"
"如何發生等資訊。例如，我們對它的 ``get_collider`` 屬性呼叫 ``is_in_group()`` "
"來檢查我們是否是和“mob”發生了碰撞：``collision.collider."
"is_in_group(\"mob\")``。"

msgid ""
"The method ``is_in_group()`` is available on every :ref:`Node<class_Node>`."
msgstr "每一個 :ref:`Node<class_Node>` 都可以使用 ``is_in_group()`` 方法。"

msgid ""
"To check that we are landing on the monster, we use the vector dot product: "
"``Vector3.UP.dot(collision.get_normal()) > 0.1``. The collision normal is a "
"3D vector that is perpendicular to the plane where the collision occurred. "
"The dot product allows us to compare it to the up direction."
msgstr ""
"我們使用向量點積 ``Vector3.UP.dot(collision.get_normal()) > 0.1`` 來檢查我們"
"是不是降落在怪物身上。碰撞法線（normal）是垂直於碰撞平面的 3D 向量。可以通過"
"點積與上方向進行比較。"

msgid ""
"With dot products, when the result is greater than ``0``, the two vectors "
"are at an angle of fewer than 90 degrees. A value higher than ``0.1`` tells "
"us that we are roughly above the monster."
msgstr ""
"點積結果大於 ``0`` 時，兩個向量的夾角小於 90 度。大於 ``0.1`` 表示我們大概位"
"於怪物上方。"

msgid ""
"After handling the squash and bounce logic, we terminate the loop early via "
"the ``break`` statement to prevent further duplicate calls to ``mob."
"squash()``, which may otherwise result in unintended bugs such as counting "
"the score multiple times for one kill."
msgstr ""

msgid ""
"We are calling one undefined function, ``mob.squash()``, so we have to add "
"it to the Mob class."
msgstr ""
"我們呼叫了一個尚未定義的函式 ``mob.squash()``。所以我們需要把它加入到 Mob 類"
"中。"

msgid ""
"Open the script ``Mob.gd`` by double-clicking on it in the *FileSystem* "
"dock. At the top of the script, we want to define a new signal named "
"``squashed``. And at the bottom, you can add the squash function, where we "
"emit the signal and destroy the mob."
msgstr ""
"在*檔案系統*面板中按兩下打開 ``Mob.gd`` 腳本。在腳本頂部，我們要定義一個新的"
"訊號叫作 ``squashed``（被踩扁）。你可以在底部新增 squash 函式，在裡面發出這個"
"訊號並銷毀這個小怪。"

msgid ""
"When using C#, Godot will create the appropriate events automatically for "
"all Signals ending with `EventHandler`, see :ref:`C# Signals "
"<doc_c_sharp_signals>`."
msgstr ""

msgid "We will use the signal to add points to the score in the next lesson."
msgstr "下一節課中，我們會使用這個訊號來加分數。"

msgid ""
"With that, you should be able to kill monsters by jumping on them. You can "
"press :kbd:`F5` to try the game and set ``main.tscn`` as your project's main "
"scene."
msgstr ""
"好了，你應該可以跳在怪物身上把它們消滅了。你可以按 :kbd:`F5` 試玩遊戲，並把 "
"``main.tscn`` 設成專案的主場景。"

msgid "However, the player won't die yet. We'll work on that in the next part."
msgstr "不過玩家現在還不會死。我們會在下一部分實作。"

msgid "Translation status"
msgstr "翻譯狀態"
