# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Moving the player with code"
msgstr "使用程式碼移動玩家"

msgid ""
"It's time to code! We're going to use the input actions we created in the "
"last part to move the character."
msgstr "該輪到編寫程式碼了！我們將使用先前建立的輸入動作來移動角色。"

msgid ""
"Right-click the ``Player`` node and select *Attach Script* to add a new "
"script to it. In the popup, set the *Template* to *Empty* before pressing "
"the *Create* button."
msgstr ""
"按右鍵 ``Player`` 節點，選擇*附加腳本*為其新增一個新腳本。在快顯視窗中，先將*"
"範本*設定為 *空*，後按下*建立*按鈕 。"

msgid "|image0|"
msgstr "\\ |image0|"

msgid "image0"
msgstr "image0"

msgid ""
"Let's start with the class's properties. We're going to define a movement "
"speed, a fall acceleration representing gravity, and a velocity we'll use to "
"move the character."
msgstr ""
"先定義類的屬性。我們將定義移動速率（標量）、重力加速度，以及一個我們將用來移"
"動角色的速度（向量）。"

msgid ""
"These are common properties for a moving body. The ``target_velocity`` is a :"
"ref:`3D vector <class_Vector3>` combining a speed with a direction. Here, we "
"define it as a property because we want to update and reuse its value across "
"frames."
msgstr ""
"這是一個移動物體的常見屬性。 ``target_velocity`` 是一個組合了速度和方向的 :"
"ref:`3D 向量 <class_Vector3>`。在這裡，我們將其定義為屬性，因為我們希望在影格"
"之間更新並重用其值。"

msgid ""
"The values are quite different from 2D code because distances are in meters. "
"While in 2D, a thousand units (pixels) may only correspond to half of your "
"screen's width, in 3D, it's a kilometer."
msgstr ""
"這些值與二維程式碼完全不同，因為距離以米為單位。在 2D 中，一千個單位（像素）"
"可能只對應於螢幕寬度的一半，而在 3D 中，它是一千米。"

msgid ""
"Let's code the movement. We start by calculating the input direction vector "
"using the global ``Input`` object, in ``_physics_process()``."
msgstr ""
"那麼來編寫移動的程式碼。首先在 ``_physics_process()`` 中使用全域 ``Input`` 物"
"件來計算輸入方向向量。"

msgid ""
"Here, we're going to make all calculations using the ``_physics_process()`` "
"virtual function. Like ``_process()``, it allows you to update the node "
"every frame, but it's designed specifically for physics-related code like "
"moving a kinematic or rigid body."
msgstr ""
"在這裡，我們將使用 ``_physics_process()`` 虛函式進行所有計算。與 "
"``_process()`` 一樣，它允許您每影格更新節點，但它是專門為物理相關程式碼設計"
"的，例如運動學物體或剛體。"

msgid ""
"To learn more about the difference between ``_process()`` and "
"``_physics_process()``, see :ref:`doc_idle_and_physics_processing`."
msgstr ""
"要瞭解更多關於 ``_process()`` 和 ``_physics_process()`` 之間的區別，見 :ref:"
"`doc_idle_and_physics_processing`。"

msgid ""
"We start by initializing a ``direction`` variable to ``Vector3.ZERO``. Then, "
"we check if the player is pressing one or more of the ``move_*`` inputs and "
"update the vector's ``x`` and ``z`` components accordingly. These correspond "
"to the ground plane's axes."
msgstr ""
"我們首先將一個 ``direction`` 變數初始化為 ``Vector3.ZERO``。然後，我們檢查玩"
"家是否正在按下一個或多個 ``move_*`` 輸入，並相應地更新向量的 ``x`` 和 ``z`` "
"分量。它們對應於地平面的軸。"

msgid ""
"These four conditions give us eight possibilities and eight possible "
"directions."
msgstr "這四個條件給了我們八個可能性和八個可能的方向。"

#, fuzzy
msgid ""
"In case the player presses, say, both W and D simultaneously, the vector "
"will have a length of about ``1.4``. But if they press a single key, it will "
"have a length of ``1``. We want the vector's length to be consistent, and "
"not move faster diagonally. To do so, we can call its ``normalized()`` "
"method."
msgstr ""
"如果玩家同時按下 W 鍵 和 D 鍵，這個向量長度大約為 ``1.4``。但如果他們只按一個"
"鍵，則它的長度將為 ``1``。我們希望該向量的長度保持一致，而不是在對角線上移動"
"得更快。為此，我們需呼叫其 ``normalize()`` 方法。"

msgid ""
"Here, we only normalize the vector if the direction has a length greater "
"than zero, which means the player is pressing a direction key."
msgstr ""
"在這裡，我們只在方向的長度大於零的情況下對向量進行正規化，因為玩家正在按某個"
"方向鍵。"

msgid ""
"We compute the direction the ``$Pivot`` is looking by creating a :ref:`Basis "
"<class_Basis>` that looks in the ``direction`` direction."
msgstr ""

msgid ""
"Then, we update the velocity. We have to calculate the ground velocity and "
"the fall speed separately. Be sure to go back one tab so the lines are "
"inside the ``_physics_process()`` function but outside the condition we just "
"wrote above."
msgstr ""
"然後，更新速度。需要分別計算地面速度和下降速度。請確保 tab 縮進，使行在 "
"``_physics_process()`` 函式內部，而不在剛編寫的條件外部。"

msgid ""
"The ``CharacterBody3D.is_on_floor()`` function returns ``true`` if the body "
"collided with the floor in this frame. That's why we apply gravity to the "
"``Player`` only while it is in the air."
msgstr ""
"如果物體在這一影格中與地板發生了碰撞，那麼 ``CharacterBody3D.is_on_floor()`` "
"函式就會返回 ``true``。這就是為什麼我們只在空中對 ``Player`` 施加重力。"

#, fuzzy
msgid ""
"For the vertical velocity, we subtract the fall acceleration multiplied by "
"the delta time every frame. This line of code will cause our character to "
"fall in every frame, as long as it is not on or colliding with the floor."
msgstr ""
"對於垂直速度，在每一影格中減去下降加速度乘以影格時間。這條程式碼將使角色在沒"
"有碰撞地板的情況下，每影格都會下降。"

msgid ""
"The physics engine can only detect interactions with walls, the floor, or "
"other bodies during a given frame if movement and collisions happen. We will "
"use this property later to code the jump."
msgstr ""
"物理引擎只有在運動和碰撞發生的情況下才能偵測到在某一影格中與牆壁、地板或其他"
"物體的相互作用。我們將在後面使用這個屬性來編寫跳躍的程式碼。"

msgid ""
"On the last line, we call ``CharacterBody3D.move_and_slide()`` which is a "
"powerful method of the ``CharacterBody3D`` class that allows you to move a "
"character smoothly. If it hits a wall midway through a motion, the engine "
"will try to smooth it out for you. It uses the *velocity* value native to "
"the :ref:`CharacterBody3D <class_CharacterBody3D>`"
msgstr ""
"在最後一行，我們呼叫了 ``CharacterBody3D.move_and_slide()``，這是 "
"``CharacterBody3D`` 類的一個強大方法，可以讓你順利地移動一個角色。如果它在運"
"動過程中撞到了牆，引擎會試著為你把它進行平滑處理。它使用的是 :ref:"
"`CharacterBody3D <class_CharacterBody3D>` 自帶的*速度*值"

msgid "And that's all the code you need to move the character on the floor."
msgstr "這就是你在地面上移動角色所需的所有程式碼。"

msgid "Here is the complete ``Player.gd`` code for reference."
msgstr "下面是供參考的完整 ``Player.gd`` 程式碼。"

msgid "Testing our player's movement"
msgstr "測試玩家的移動"

msgid ""
"We're going to put our player in the ``Main`` scene to test it. To do so, we "
"need to instantiate the player and then add a camera. Unlike in 2D, in 3D, "
"you won't see anything if your viewport doesn't have a camera pointing at "
"something."
msgstr ""
"將玩家放在 ``Main`` 場景中進行測試，這時，需要先產生實體玩家，然後新增相機。 "
"3D 與 2D 不同，如果沒有新增相機，你將無法看到任何物體。"

msgid ""
"Save your ``Player`` scene and open the ``Main`` scene. You can click on the "
"*Main* tab at the top of the editor to do so."
msgstr ""
"保存 ``Player`` 場景，然後打開 ``Main`` 場景。可以點擊編輯器頂部的 *Main* 分"
"頁切換。"

msgid "|image1|"
msgstr "\\ |image1|"

msgid "image1"
msgstr "image1"

msgid ""
"If you closed the scene before, head to the *FileSystem* dock and double-"
"click ``main.tscn`` to re-open it."
msgstr ""
"如果場景之前已關閉，請轉到檔案系統欄，按兩下 ``main.tscn`` 檔重新打開。"

msgid ""
"To instantiate the ``Player``, right-click on the ``Main`` node and select "
"*Instantiate Child Scene*."
msgstr ""
"要產生實體 ``Player`` ，可按右鍵 ``Main`` 節點，然後選擇 *實體化子場景* 。"

msgid "|image2|"
msgstr "\\ |image2|"

msgid "image2"
msgstr "image2"

msgid ""
"In the popup, double-click ``player.tscn``. The character should appear in "
"the center of the viewport."
msgstr "在快顯視窗中，按兩下 ``player.tscn`` ，角色將顯示在視窗的中心。"

msgid "Adding a camera"
msgstr "新增腳本"

msgid ""
"Let's add the camera next. Like we did with our *Player*\\ 's *Pivot*, we're "
"going to create a basic rig. Right-click on the ``Main`` node again and "
"select *Add Child Node*. Create a new :ref:`Marker3D <class_Marker3D>`, and "
"name it ``CameraPivot``. Select ``CameraPivot`` and add a child node :ref:"
"`Camera3D <class_Camera3D>` to it. Your scene tree should look like this."
msgstr ""
"接下來讓我們來新增相機。就像我們對 *Player*\\\\ 的 *Pivot* 所做的那樣，我們將"
"建立一個基本裝備。再次右鍵單擊“Main”節點並選擇*新增子節點*。建立一個新的 "
"Marker3D <class_Marker3D>`，並將其命名為「CameraPivot」。選擇「CameraPivot」"
"並新增一個子節點:ref:`Camera3D <class_Camera3D>`。你的場景樹應該是這樣的。"

msgid "|image3|"
msgstr "\\ |image3|"

msgid "image3"
msgstr "image3"

msgid ""
"Notice the *Preview* checkbox that appears in the top-left when you have the "
"*Camera* selected. You can click it to preview the in-game camera projection."
msgstr ""
"請注意在選中 *Camera* 時，左上角會出現一個*預覽*核取方塊。你可以按一下預覽遊"
"戲中的相機投影視角。"

msgid "|image4|"
msgstr "\\ |image4|"

msgid "image4"
msgstr "image4"

msgid ""
"We're going to use the *Pivot* to rotate the camera as if it was on a crane. "
"Let's first split the 3D view to be able to freely navigate the scene and "
"see what the camera sees."
msgstr ""
"我們要使用 *Pivot* 來旋轉相機，讓他像被吊車吊起來一樣。讓我們先拆分 3D 視圖，"
"以便在進行自由移動的同時觀察相機拍攝到的內容。"

msgid ""
"In the toolbar right above the viewport, click on *View*, then *2 "
"Viewports*. You can also press :kbd:`Ctrl + 2` (:kbd:`Cmd + 2` on macOS)."
msgstr ""
"在視口上方的工具列中，按一下*視圖*，然後按一下*2 個視口*。你也可以按 :kbd:"
"`Ctrl + 2`（macOS 上則為 :kbd:`Cmd + 2`）。"

msgid "|image11|"
msgstr "|image11|"

msgid "image11"
msgstr "image11"

msgid "|image5|"
msgstr "\\ |image5|"

msgid "image5"
msgstr "image5"

msgid ""
"On the bottom view, select your :ref:`Camera3D <class_Camera3D>` and turn on "
"camera Preview by clicking the checkbox."
msgstr ""
"在下面那個視圖中，選中 :ref:`Camera3D <class_Camera3D>`，然後勾選預覽核取方塊"
"打開相機預覽。"

msgid "|image6|"
msgstr "|image6|"

msgid "image6"
msgstr "image6"

msgid ""
"In the top view, move the camera about ``19`` units on the Z axis (the blue "
"one)."
msgstr "在上面那個視圖中，將相機沿 Z 軸（藍色）移動 ``19`` 個單位。"

msgid "|image7|"
msgstr "|image7|"

msgid "image7"
msgstr "image7"

msgid ""
"Here's where the magic happens. Select the *CameraPivot* and rotate it "
"``-45`` degrees around the X axis (using the red circle). You'll see the "
"camera move as if it was attached to a crane."
msgstr ""
"接下來就是關鍵。選中 *CameraPivot* 並將其圍繞 X 周旋轉 ``-45`` 度（使用紅色的"
"圓圈）。你會看到相機就像是被連上了吊車一樣移動。"

msgid "|image8|"
msgstr "|image8|"

msgid "image8"
msgstr "image8"

msgid ""
"You can run the scene by pressing :kbd:`F6` and press the arrow keys to move "
"the character."
msgstr "你可以按 :kbd:`F6` 運作場景，然後按方向鍵來移動角色。"

msgid "|image9|"
msgstr "|image9|"

msgid "image9"
msgstr "image9"

msgid ""
"We can see some empty space around the character due to the perspective "
"projection. In this game, we're going to use an orthographic projection "
"instead to better frame the gameplay area and make it easier for the player "
"to read distances."
msgstr ""
"因為透視投影的緣故，我們會在角色的周圍看到一些空白區域。在這個遊戲中，我們要"
"使用的是正交投影，從而更好地展示遊戲區域，讓玩家更易於識別距離。"

msgid ""
"Select the *Camera* again and in the *Inspector*, set the *Projection* to "
"*Orthogonal* and the *Size* to ``19``. The character should now look flatter "
"and the ground should fill the background."
msgstr ""
"再次選中 *Camera*，然後在*屬性面板* 中將 *Projection*（投影）設為 "
"*Orthogonal*（正交）、將 *Size*（大小）設為 ``19``。角色現在看起來應該更加扁"
"平，背景應該被地面充滿。"

msgid ""
"When using an orthogonal camera in Godot 4, directional shadow quality is "
"dependent on the camera's *Far* value. The higher the *Far* value, the "
"further away the camera will be able to see. However, higher *Far* values "
"also decrease shadow quality as the shadow rendering has to cover a greater "
"distance."
msgstr ""
"當在 Godot 4 中使用正交相機時，方向陰影的品質取決於相機的 *Far* 值。*Far* 越"
"高，相機能夠看到的距離就更遠。然而由於更高的 *Far* 值會使得陰影算繪必須覆蓋到"
"更遠的距離，這個操作也會導致陰影品質下降。"

msgid ""
"If directional shadows look too blurry after switching to an orthogonal "
"camera, decrease the camera's *Far* property to a lower value such as "
"``100``. Don't decrease this *Far* property too much, or objects in the "
"distance will start disappearing."
msgstr ""
"如果在切換到正交相機後方向陰影看起來變得模糊，請減小相機的 *Far* 屬性到更低的"
"值，如 ``100`` 。請不要將 *Far* 屬性減小得太多，否則遠處的物體將會開始消失。"

msgid "|image10|"
msgstr "|image10|"

msgid "image10"
msgstr "image10"

msgid ""
"Test your scene and you should be able to move in all 8 directions and not "
"glitch through the floor!"
msgstr ""
"測試您的場景，你應該能夠在所有 8 個方向上移動，並且不會在地板上出現故障！"

msgid ""
"Ultimately, we have both player movement and the view in place. Next, we "
"will work on the monsters."
msgstr "這樣，我們就完成了玩家的移動以及視圖。接下來，我們要來處理怪物。"

msgid "Translation status"
msgstr "翻譯狀態"
