# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Heads up display"
msgstr "遊戲資訊顯示"

msgid ""
"The final piece our game needs is a User Interface (UI) to display things "
"like score, a \"game over\" message, and a restart button."
msgstr ""
"我們的遊戲最後還需要使用者介面（User Interface，UI），顯示分數、“遊戲結束”資"
"訊、重啟按鈕。"

#, fuzzy
msgid ""
"Create a new scene, click the \"Other Node\" button and add a :ref:"
"`CanvasLayer <class_CanvasLayer>` node named ``HUD``. \"HUD\" stands for "
"\"heads-up display\", an informational display that appears as an overlay on "
"top of the game view."
msgstr ""
"最後，這個遊戲需要 UI：一個會顯示如分數、「Game Over」訊息、與重新開始遊戲按"
"鈕的界面。建立一個新場景並新增一個名為 ``HUD`` 的 :ref:`CanvasLayer "
"<class_CanvasLayer>` 節點。HUD 是覆蓋顯示於遊戲畫面上方，用於表示資訊的「擡頭"
"顯示器 (Heads-Up Display)」的簡稱。"

msgid ""
"The :ref:`CanvasLayer <class_CanvasLayer>` node lets us draw our UI elements "
"on a layer above the rest of the game, so that the information it displays "
"isn't covered up by any game elements like the player or mobs."
msgstr ""
"使用 :ref:`CanvasLayer <class_CanvasLayer>` 節點可以讓我們在遊戲上方的圖層上"
"繪製 UI 元素，這樣上面顯示的資訊就不會被其他遊戲元素如玩家或怪物給蓋住。"

msgid "The HUD needs to display the following information:"
msgstr "HUD 需要顯示如下資訊："

msgid "Score, changed by ``ScoreTimer``."
msgstr "分數，會通過 ``ScoreTimer`` 來更改。"

msgid "A message, such as \"Game Over\" or \"Get Ready!\""
msgstr "訊息，如「Gamer Over」或「請準備！」"

msgid "A \"Start\" button to begin the game."
msgstr "用來開始遊戲的「Start」按鈕。"

msgid ""
"The basic node for UI elements is :ref:`Control <class_Control>`. To create "
"our UI, we'll use two types of :ref:`Control <class_Control>` nodes: :ref:"
"`Label <class_Label>` and :ref:`Button <class_Button>`."
msgstr ""
"UI 元素所使用的基本節點是 :ref:`Control <class_Control>` 。我們需要使用兩種類"
"型的 :ref:`Control <class_Control>` 節點來給這個遊戲建立 UI： :ref:`Label "
"<class_Label>` （標籤）與 :ref:`Button <class_Button>` （按鈕）。"

msgid "Create the following as children of the ``HUD`` node:"
msgstr "為 ``HUD`` 節點建立下列子節點："

msgid ":ref:`Label <class_Label>` named ``ScoreLabel``."
msgstr ":ref:`Label <class_Label>` ，命名為 ``ScoreLabel`` 。"

msgid ":ref:`Label <class_Label>` named ``Message``."
msgstr ":ref:`Label <class_Label>` ，命名為 ``Message`` 。"

msgid ":ref:`Button <class_Button>` named ``StartButton``."
msgstr ":ref:`Button <class_Button>` ，命名為 ``StartButton`` 。"

msgid ":ref:`Timer <class_Timer>` named ``MessageTimer``."
msgstr ":ref:`Timer <class_Timer>` ，命名為 ``MessageTimer`` 。"

msgid ""
"Click on the ``ScoreLabel`` and type a number into the ``Text`` field in the "
"Inspector. The default font for ``Control`` nodes is small and doesn't scale "
"well. There is a font file included in the game assets called \"Xolonium-"
"Regular.ttf\". To use this font, do the following:"
msgstr ""
"點擊 ``ScoreLabel`` 並在屬性面板中的 ``Text`` 輸入一個數字。 ``Control`` 節點"
"的預設字形很小，而且也縮放得不是很好。遊戲素材裡有包含了一個字形檔，檔名為"
"「Xolonium-Regular.ttf」。依照下列步驟來使用這個字形："

msgid ""
"Under \"Theme Overrides > Fonts\", choose \"Load\" and select the \"Xolonium-"
"Regular.ttf\" file."
msgstr ""
"在“Theme Overrides > Fonts”（主題覆蓋 > 字體）中選擇“載入”，然後選"
"中“Xolonium-Regular.ttf”檔。"

msgid ""
"The font size is still too small, increase it to ``64`` under \"Theme "
"Overrides > Font Sizes\". Once you've done this with the ``ScoreLabel``, "
"repeat the changes for the ``Message`` and ``StartButton`` nodes."
msgstr ""
"字形尺寸仍然太小，請在“Theme Overrides > Font Sizes”（主題覆蓋 > 字形大小）下"
"將其增加到 ``64`` 。當 ``ScoreLabel`` 完成此操作後，請重複對 ``Message`` 和 "
"``StartButton`` 節點做同樣的修改。"

msgid ""
"**Anchors:** ``Control`` nodes have a position and size, but they also have "
"anchors. Anchors define the origin - the reference point for the edges of "
"the node."
msgstr ""
"**錨點與外邊距：** ``Control`` 節點除了位置與大小之外，也可以設定錨點 "
"(Anchor) 與外邊距 (Margin)。錨點定義原點（相對於節點邊緣的參考點）。外邊距則"
"會在移動或縮放 Control 節點時自動更新。這兩個屬性的變化會反映出 Control 節點"
"到錨點的距離。詳細說明請參考 :ref:"
"`doc_design_interfaces_with_the_control_nodes` 。"

msgid ""
"Arrange the nodes as shown below. You can drag the nodes to place them "
"manually, or for more precise placement, use \"Anchor Presets\"."
msgstr ""
"請將節點如下圖排列。拖動節點可以手動放置，也可以使用\"錨點預設（Anchor "
"Preset）\"進行更精確的定位。"

msgid "ScoreLabel"
msgstr "ScoreLabel"

msgid "Add the text ``0``."
msgstr "新增文字 ``0`` 。"

msgid ""
"Set the \"Horizontal Alignment\" and \"Vertical Alignment\" to ``Center``."
msgstr "將“Horizontal Alignment”和“Vertical Alignment”設定為 ``Center`` 。"

msgid "Choose the \"Anchor Preset\" ``Center Top``."
msgstr "為“Anchor Preset”選擇 ``Center Top`` 。"

msgid "Message"
msgstr "訊息"

msgid "Add the text ``Dodge the Creeps!``."
msgstr "新增文本 ： ``Dodge the Creeps!``"

msgid ""
"Set the \"Autowrap Mode\" to ``Word``, otherwise the label will stay on one "
"line."
msgstr "將“Autowrap Mode”設定為 ``Word`` ，否則標籤只會有一行。"

msgid ""
"Under \"Control - Layout/Transform\" set \"Size X\"  to ``480`` to use the "
"entire width of the screen."
msgstr ""
"在“Control - Layout/Transform”中將“Size X”設定為 ``480`` ，使用螢幕的完整寬"
"度。"

msgid "Choose the \"Anchor Preset\" ``Center``."
msgstr "為“Anchor Preset”選擇 ``Center`` 。"

msgid "StartButton"
msgstr "StartButton"

msgid "Add the text ``Start``."
msgstr "**Text** ： ``Start``"

msgid ""
"Under \"Control - Layout/Transform\", set \"Size X\" to ``200`` and \"Size "
"Y\" to ``100`` to add a little bit more padding between the border and text."
msgstr ""
"在“Control - Layout/Transform”中將“Size X”設定為 ``200``、“Size Y”設定為 "
"``100``，在邊框和文字之間新增間距。"

msgid "Choose the \"Anchor Preset\" ``Center Bottom``."
msgstr "為“Anchor Preset”選擇 ``Center Bottom``。"

msgid "Under \"Control - Layout/Transform\", set \"Position Y\" to ``580``."
msgstr "在“Control - Layout/Transform”中將“Position Y”設定為 ``580``。"

msgid ""
"On the ``MessageTimer``, set the ``Wait Time`` to ``2`` and set the ``One "
"Shot`` property to \"On\"."
msgstr ""
"將 ``MessageTimer`` 的 ``Wait Time`` 設為 ``2`` ，將 ``One Shot`` 設為「開"
"啟」。"

msgid "Now add this script to ``HUD``:"
msgstr "現在將這個腳本新增至 ``HUD`` ："

msgid ""
"We now want to display a message temporarily, such as \"Get Ready\", so we "
"add the following code"
msgstr "當我們想要暫時顯示訊息（如「Get Ready」）時可以呼叫這個函式。"

msgid ""
"We also need to process what happens when the player loses. The code below "
"will show \"Game Over\" for 2 seconds, then return to the title screen and, "
"after a brief pause, show the \"Start\" button."
msgstr ""
"當玩家輸了之後會呼叫這個函式。會在畫面上顯示 2 秒「Game Over」，然後回到標題"
"畫面、暫停一下，最後顯示「Start」按鈕。"

msgid ""
"This function is called when the player loses. It will show \"Game Over\" "
"for 2 seconds, then return to the title screen and, after a brief pause, "
"show the \"Start\" button."
msgstr ""
"當玩家輸了之後會呼叫這個函式。會在畫面上顯示 2 秒「Game Over」，然後回到標題"
"畫面、暫停一下，最後顯示「Start」按鈕。"

msgid ""
"When you need to pause for a brief time, an alternative to using a Timer "
"node is to use the SceneTree's ``create_timer()`` function. This can be very "
"useful to add delays such as in the above code, where we want to wait some "
"time before showing the \"Start\" button."
msgstr ""
"需要暫停一下下的時候，除了使用 Timer 節點外也可以使用 SceneTree（場景樹）的 "
"``create_timer()`` 函式。當需要像上面的程式碼一樣新增一點延遲的時候很有用，上"
"面的例子中我們用它來在顯示「Start」按鈕前增加一點點等待時間。"

msgid "Add the code below to ``HUD`` to update the score"
msgstr "將以下更新分數程式碼新增到 ``HUD`` 中"

#, fuzzy
msgid ""
"Connect the ``pressed()`` signal of ``StartButton`` and the ``timeout()`` "
"signal of ``MessageTimer``, and add the following code to the new functions:"
msgstr ""
"連接 ``MessageTimer`` 的 ``timeout() 訊號與 ``StartButton`` 的 ``pressed()`` "
"訊號，並新增下列程式碼到新函式當中："

msgid "Connecting HUD to Main"
msgstr "將 HUD 場景連接至 Main 場景"

msgid ""
"Now that we're done creating the ``HUD`` scene, go back to ``Main``. "
"Instance the ``HUD`` scene in ``Main`` like you did the ``Player`` scene. "
"The scene tree should look like this, so make sure you didn't miss anything:"
msgstr ""
"我們現在做好 ``HUD`` 場景了。讓我們回到 ``Main``。像剛才實體化 ``Player`` 場"
"景一樣，在 ``Main`` 場景中實體化 ``HUD``。場景樹會看起來像這樣，檢查一下有沒"
"有漏了什麼："

msgid ""
"Now we need to connect the ``HUD`` functionality to our ``Main`` script. "
"This requires a few additions to the ``Main`` scene:"
msgstr ""
"我們現在需要把 ``HUD`` 的功能連接到 ``Main`` 腳本。所以我們需要在 ``Main`` 場"
"景內新增一點點東西："

msgid ""
"In the Node tab, connect the HUD's ``start_game`` signal to the "
"``new_game()`` function of the Main node by clicking the \"Pick\" button in "
"the \"Connect a Signal\" window and selecting the ``new_game()`` method or "
"type \"new_game\" below \"Receiver Method\" in the window. Verify that the "
"green connection icon now appears next to ``func new_game()`` in the script."
msgstr ""
"在節點分頁中，設定 HUD 的 ``start_game`` 訊號的連接，在「連接訊號」視窗中將"
"「Receiver 方法」設為「new_game」來將訊號連接到 Main 節點的 ``new_game()`` 函"
"式。之後檢查看看腳本中的 ``func new_game()``旁邊有沒有出現綠色的連線圖示。"

msgid ""
"In ``new_game()``, update the score display and show the \"Get Ready\" "
"message:"
msgstr "``new_game()`` 中，需要更新分數並顯示「Get Ready」訊息："

msgid "In ``game_over()`` we need to call the corresponding ``HUD`` function:"
msgstr "``game_over()`` 中我們需要呼叫對應的 ``HUD`` 函式："

msgid ""
"Finally, add this to ``_on_score_timer_timeout()`` to keep the display in "
"sync with the changing score:"
msgstr ""
"最後，將這段程式碼加到 ``_on_ScoreTimer_timeout()`` 來讓分數改變的時候能同步"
"顯示："

#, fuzzy
msgid ""
"Remember to remove the call to ``new_game()`` from ``_ready()`` if you "
"haven't already, otherwise your game will start automatically."
msgstr ""
"確定好了所有東西都正常後，將呼叫 ``new_game()`` 的程式碼從 ``_ready()`` 裡刪"
"除。"

msgid ""
"Now you're ready to play! Click the \"Play the Project\" button. You will be "
"asked to select a main scene, so choose ``main.tscn``."
msgstr ""
"現在已經可以執行遊戲了！點擊「執行專案」按鈕。接著會被要求選擇一個主場景，這"
"裡我們選 ``Main.tscn`` 。"

msgid "Removing old creeps"
msgstr "刪除舊的怪物"

msgid ""
"If you play until \"Game Over\" and then start a new game right away, the "
"creeps from the previous game may still be on the screen. It would be better "
"if they all disappeared at the start of a new game. We just need a way to "
"tell *all* the mobs to remove themselves. We can do this with the \"group\" "
"feature."
msgstr ""
"如果一直玩到「Game Over」並直接開始新遊戲的話，上一場遊戲的怪物可能還在畫面"
"上。開始遊戲的時候如果能讓舊的怪物消失會更好。而我們只需要告訴 **所有** 怪"
"物，刪除自己。我們可以在這裡使用「群組」功能。"

msgid ""
"In the ``Mob`` scene, select the root node and click the \"Node\" tab next "
"to the Inspector (the same place where you find the node's signals). Next to "
"\"Signals\", click \"Groups\" and you can type a new group name and click "
"\"Add\"."
msgstr ""
"在 ``Mob`` 場景中，先選擇根節點，然後點擊屬性面板旁邊的「節點」分頁（跟設定節"
"點訊號的地方相同）。點擊「訊號」旁邊的「群組」，接著編輯器會讓你設定新群組名"
"稱，最後點擊「新增」。"

msgid ""
"Now all mobs will be in the \"mobs\" group. We can then add the following "
"line to the ``new_game()`` function in ``Main``:"
msgstr ""
"現在所有的怪物都會被放在「mobs」群組內了。我們可以接著在 ``Main`` 腳本的 "
"``game_over()`` 函式中增加下面這行的程式碼："

msgid ""
"The ``call_group()`` function calls the named function on every node in a "
"group - in this case we are telling every mob to delete itself."
msgstr ""
"``call_group()`` 函式會呼叫群組中所有節點的指定名稱的函式——在這裡我們用來讓所"
"有怪物刪除自己。"

msgid ""
"The game's mostly done at this point. In the next and last part, we'll "
"polish it a bit by adding a background, looping music, and some keyboard "
"shortcuts."
msgstr ""
"遊戲在這一點上大部分已經完成。在下一部分和最後一部分中，我們將通過新增背景，"
"迴圈音樂和一些鍵盤快捷鍵來對其進行一些潤色。"

msgid "Translation status"
msgstr "翻譯狀態"
