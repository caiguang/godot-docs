# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Beziers, curves and paths"
msgstr "貝塞爾、曲線和路徑"

msgid ""
"Bezier curves are a mathematical approximation of natural geometric shapes. "
"We use them to represent a curve with as little information as possible and "
"with a high level of flexibility."
msgstr ""
"貝茲曲線是一種自然幾何形狀的數學近似. 我們用它們來代表一個曲線, 含有盡可能少"
"的資訊, 保持高水平的靈活性."

msgid ""
"Unlike more abstract mathematical concepts, Bezier curves were created for "
"industrial design. They are a popular tool in the graphics software industry."
msgstr ""
"不像抽象的數學概念, 貝茲曲線是為工業設計. 它們是圖形軟體行業中的流行工具."

msgid ""
"They rely on :ref:`interpolation<doc_interpolation>`, which we saw in the "
"previous article, combining multiple steps to create smooth curves. To "
"better understand how Bezier curves work, let's start from its simplest "
"form: Quadratic Bezier."
msgstr ""
"它們依賴於 :ref:`插值 <doc_interpolation>`, 我們在上一篇文章中看到, 如何結合"
"多個步驟來建立平滑的曲線. 為了更好地理解貝茲曲線的工作原理, 我們從最簡單的形"
"式開始: 二次貝茲曲線."

msgid "Quadratic Bezier"
msgstr "二次貝茲曲線"

msgid "Take three points, the minimum required for Quadratic Bezier to work:"
msgstr "取三個點, 這是建立二次貝茲曲線所需的最小值:"

msgid ""
"To draw a curve between them, we first interpolate gradually over the two "
"vertices of each of the two segments formed by the three points, using "
"values ranging from 0 to 1. This gives us two points that move along the "
"segments as we change the value of ``t`` from 0 to 1."
msgstr ""
"要在它們之間畫一條曲線，我們首先使用 0 到 1 之間的值，在由這三個點構成的兩個"
"線段的每個頂點上逐步插值。當我們把 ``t`` 值從 0 變成 1 時，就得到了兩個沿著線"
"段移動的點。"

msgid ""
"We then interpolate ``q0`` and ``q1`` to obtain a single point ``r`` that "
"moves along a curve."
msgstr "然後，我們插值 ``q0`` 和 ``q1``，以獲得沿著曲線移動的單點 ``r``。"

msgid "This type of curve is called a *Quadratic Bezier* curve."
msgstr "這種型別的曲線就被稱為*二次貝塞爾*曲線。"

msgid "*(Image credit: Wikipedia)*"
msgstr "*(圖像來源: 維琪百科)*"

msgid "Cubic Bezier"
msgstr "三次貝茲曲線"

msgid ""
"Building upon the previous example, we can get more control by interpolating "
"between four points."
msgstr "基於前面的例子, 我們可以通過在四個點之間插值得到更多的控制."

msgid ""
"We first use a function with four parameters to take four points as an "
"input, ``p0``, ``p1``, ``p2`` and ``p3``:"
msgstr ""
"首先我們使用一個帶有四個參數的函式，以 ``p0``、``p1``、``p2``、``p3`` 四個點"
"作為輸入："

msgid ""
"We apply a linear interpolation to each couple of points to reduce them to "
"three:"
msgstr "我們對每兩個點進行線性插值, 將它們減少到三個:"

msgid "We then take our three points and reduce them to two:"
msgstr "然後我們把這三個點縮減為兩個點:"

msgid "And to one:"
msgstr "然後到一個:"

msgid "Here is the full function:"
msgstr "這裡給出了完整的函式:"

msgid ""
"The result will be a smooth curve interpolating between all four points:"
msgstr "結果將是在所有四個點之間的平滑曲線插值:"

msgid ""
"Cubic Bezier interpolation works the same in 3D, just use ``Vector3`` "
"instead of ``Vector2``."
msgstr ""
"三次貝塞爾插值在三維中也是一樣的，只需使用 ``Vector3`` 代替 ``Vector2``。"

msgid "Adding control points"
msgstr "新增控制點"

msgid ""
"Building upon Cubic Bezier, we can change the way two of the points work to "
"control the shape of our curve freely. Instead of having ``p0``, ``p1``, "
"``p2`` and ``p3``, we will store them as:"
msgstr ""
"在三次貝塞爾的基礎上，我們可以通過改變兩個點的工作方式來自由地控制曲線的形"
"狀。我們不使用 ``p0``、``p1``、``p2``、``p3``，而是將它們儲存為："

msgid "``point0 = p0``: Is the first point, the source"
msgstr "``point0 = p0``：是第一個點，即源"

msgid "``control0 = p1 - p0``: Is a vector relative to the first control point"
msgstr "``control0 = p1 - p0``：是相對於第一個控制點的向量"

msgid ""
"``control1 = p3 - p2``: Is a vector relative to the second control point"
msgstr "``control1 = p3 - p2``：是相對於第二個控制點的向量"

msgid "``point1 = p3``: Is the second point, the destination"
msgstr "``point1 = p3``：是第二個點，即終點"

msgid ""
"This way, we have two points and two control points which are relative "
"vectors to the respective points. If you've used graphics or animation "
"software before, this might look familiar:"
msgstr ""
"使用這種方式, 有兩個點和兩個控制點, 它們是各自點的相對向量. 如果你以前用過圖"
"形或動畫軟體, 這可能看起來很熟悉:"

msgid ""
"This is how graphics software presents Bezier curves to the users, and how "
"they work and look in Godot."
msgstr ""
"這就是圖形軟體如何向使用者呈現貝茲曲線, 以及它們在Godot引擎內的工作原理."

msgid "Curve2D, Curve3D, Path and Path2D"
msgstr "Curve2D、Curve3D、Path 以及 Path2D"

msgid ""
"There are two objects that contain curves: :ref:`Curve3D <class_Curve3D>` "
"and :ref:`Curve2D <class_Curve2D>` (for 3D and 2D respectively)."
msgstr ""
"有兩個物件包含曲線 :ref:`Curve3D <class_Curve3D>` 和 :ref:`Curve2D "
"<class_Curve2D>`（分別代表 3D 和 2D）。"

msgid ""
"They can contain several points, allowing for longer paths. It is also "
"possible to set them to nodes: :ref:`Path3D <class_Path3D>` and :ref:`Path2D "
"<class_Path2D>` (also for 3D and 2D respectively):"
msgstr ""
"它們可以包含幾個點，允許更長的路徑。也可以將它們設定為節點：:ref:`Path "
"<class_Path>` 和 :ref:`Path2D <class_Path2D>`（在 3D 和 2D 內都適用）："

msgid ""
"Using them, however, may not be completely obvious, so following is a "
"description of the most common use cases for Bezier curves."
msgstr "然而它們的使用方法可能不是很直觀，下面是對貝茲曲線最常見用例的描述。"

msgid "Evaluating"
msgstr "估值"

msgid ""
"Only evaluating them may be an option, but in most cases it's not very "
"useful. The big drawback with Bezier curves is that if you traverse them at "
"constant speed, from ``t = 0`` to ``t = 1``, the actual interpolation will "
"*not* move at constant speed. The speed is also an interpolation between the "
"distances between points ``p0``, ``p1``, ``p2`` and ``p3`` and there is not "
"a mathematically simple way to traverse the curve at constant speed."
msgstr ""
"一種選擇是直接估值，不過在大多數情況下都不是很有用。貝茲曲線最大的缺點是如果"
"你以恒定的速度沿著它走，從 ``t = 0`` 到 ``t = 1``，實際的插值*不會*以恒定的速"
"度移動。速度也是根據點 ``p0``、``p1``、``p2``、``p3`` 之間距離插值出來的，無"
"法使用簡單的數學方法以恒定的速度通過曲線。"

msgid "Let's do an example with the following pseudocode:"
msgstr "填寫下列設定："

msgid ""
"As you can see, the speed (in pixels per second) of the circle varies, even "
"though ``t`` is increased at constant speed. This makes beziers difficult to "
"use for anything practical out of the box."
msgstr ""
"如你所見，即便 ``t`` 在勻速遞增，圓點的速度還是在不斷變化的（以像素每秒為單"
"位）。這也使貝塞爾難以做到任何實際的開箱即用。"

msgid "Drawing"
msgstr "繪製"

msgid ""
"Drawing beziers (or objects based on the curve) is a very common use case, "
"but it's also not easy. For pretty much any case, Bezier curves need to be "
"converted to some sort of segments. This is normally difficult, however, "
"without creating a very high amount of them."
msgstr ""
"繪製貝塞爾(或基於曲線的物件)是很常見的用例, 但這也不容易. 幾乎在任何情況下, "
"貝茲曲線需要被轉換成某種線段. 這通常很難, 然而, 並沒有建立非常高數量的線段."

msgid ""
"The reason is that some sections of a curve (specifically, corners) may "
"require considerable amounts of points, while other sections may not:"
msgstr ""
"原因是曲線的某些部分(具體來說是角落)可能需要相當多的點, 而其他部分不一定:"

msgid ""
"Additionally, if both control points were ``0, 0`` (remember they are "
"relative vectors), the Bezier curve would just be a straight line (so "
"drawing a high amount of points would be wasteful)."
msgstr ""
"另外，如果兩個控制點都是 ``0,0``（請記住它們是相對向量），貝茲曲線就是一條直"
"線（所以畫很多點就是在浪費時間）。"

msgid ""
"Before drawing Bezier curves, *tessellation* is required. This is often done "
"with a recursive or divide and conquer function that splits the curve until "
"the curvature amount becomes less than a certain threshold."
msgstr ""
"在繪製貝茲曲線之前, 需要進行 *細分* . 這通常是用遞迴函式或除法函式來完成的, "
"它可以分割曲線, 直到曲率變得小於某個閾值."

msgid ""
"The *Curve* classes provide this via the :ref:`Curve2D.tessellate() "
"<class_Curve2D_method_tessellate>` function (which receives optional "
"``stages`` of recursion and angle ``tolerance`` arguments). This way, "
"drawing something based on a curve is easier."
msgstr ""
"*Curve* 類通過 :ref:`Curve2D.tessellate() <class_Curve2D_method_tessellate>` "
"函式來提供該功能(函式接收可選的 ``stages`` 遞迴和角度 ``tolerance`` 參數). 這"
"樣一來, 基於曲線畫東西就比較容易了."

msgid "Traversal"
msgstr "走訪"

msgid ""
"The last common use case for the curves is to traverse them. Because of what "
"was mentioned before regarding constant speed, this is also difficult."
msgstr "最後曲線最常見的用例是走訪. 因為之前提到關於勻速的內容, 這也是困難的."

msgid ""
"To make this easier, the curves need to be *baked* into equidistant points. "
"This way, they can be approximated with regular interpolation (which can be "
"improved further with a cubic option). To do this, just use the :ref:"
"`Curve3D.sample_baked()<class_Curve3D_method_sample_baked>` method together "
"with :ref:`Curve2D."
"get_baked_length()<class_Curve2D_method_get_baked_length>`. The first call "
"to either of them will bake the curve internally."
msgstr ""
"為了操作起來更方便，需要先把曲線 *烘焙* 成若干等距的點。這樣就可以用常規的插"
"值操作（還可以使用立方選項進一步優化）來進行近似估值了。要實作這樣的效果，只"
"需呼叫 :ref:`Curve."
"interpolate_baked()<class_Curve_method_interpolate_baked>` 和 :ref:`Curve2D."
"get_baked_length()<class_Curve2D_method_get_baked_length>` 方法。首次呼叫兩者"
"之中的任意方法都會觸發內部對曲線的烘焙。"

msgid ""
"Traversal at constant speed, then, can be done with the following pseudo-"
"code:"
msgstr "勻速走訪, 然後, 可以用下面的偽程式碼:"

msgid "And the output will, then, move at constant speed:"
msgstr "並且輸出, 然後勻速移動:"

msgid "Translation status"
msgstr "翻譯狀態"
