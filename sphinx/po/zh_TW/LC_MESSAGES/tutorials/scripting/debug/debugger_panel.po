# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Debugger panel"
msgstr "除錯工具"

msgid ""
"Many of Godot's debugging tools, including the debugger, can be found in the "
"debugger panel at the bottom of the screen. Click on **Debugger** to open it."
msgstr ""
"在螢幕下方的除錯器面板中, 可以找到包括除錯器在內的許多Godot的除錯工具. 點擊 "
"**除錯器** 即可打開."

msgid ""
"The debugger panel is split into several tabs, each focusing on a specific "
"task."
msgstr "除錯器面板被分成幾個標籤, 每個標籤專注於一個特定的工作."

msgid "Debugger"
msgstr "除錯工具"

msgid ""
"The Debugger tab opens automatically when the GDScript compiler reaches a "
"breakpoint in your code."
msgstr ""
"當 GDScript 編譯器在你的程式碼中達到一個中斷點時，“除錯器”分頁會自動打開。"

msgid ""
"It gives you a `stack trace <https://en.wikipedia.org/wiki/Stack_trace>`__, "
"information about the state of the object, and buttons to control the "
"program's execution. When the debugger breaks on a breakpoint, a green "
"triangle arrow is visible in the script editor's gutter. This arrow "
"indicates the line of code the debugger broke on."
msgstr ""
"它給你提供了一個 `堆疊追蹤 <https://en.wikipedia.org/wiki/Stack_trace>`__ , "
"物件的狀態資訊, 以及控制程式執行的按鈕."

msgid ""
"You can create a breakpoint by clicking the gutter in the left of the script "
"editor (on the left of the line numbers). When hovering this gutter, you "
"will see a transparent red dot appearing, which turns into an opaque red dot "
"after the breakpoint is placed by clicking. Click the red dot again to "
"remove the breakpoint. Breakpoints created this way persist across editor "
"restarts, even if the script wasn't saved when exiting the editor."
msgstr ""
"您可以透過點選腳本編輯器左側的裝訂線（行號左側）來建立斷點。將滑鼠懸停在該排"
"水溝上時，您會看到出現一個透明的紅點，點擊放置斷點後，該紅點會變成不透明的紅"
"點。再次點選紅點即可刪除斷點。以這種方式建立的斷點在編輯器重新啟動後仍然存"
"在，即使退出編輯器時未儲存腳本也是如此。"

#, fuzzy
msgid ""
"You can also use the ``breakpoint`` keyword in GDScript to create a "
"breakpoint that is stored in the script itself. Unlike breakpoints created "
"by clicking in the gutter, this keyword-based breakpoint is persistent "
"across different machines when using version control."
msgstr ""
"您也可以使用 GDScript 中的「breakpoint」關鍵字來建立儲存在腳本本身中的斷點。"
"與透過點擊裝訂線建立的斷點不同，使用版本控制時，這種基於關鍵字的斷點在不同的"
"電腦上是持久的。"

msgid "You can use the buttons in the top-right corner to:"
msgstr "你可以使用右上角的按鈕來:"

msgid ""
"Skip all breakpoints. That way, you can save breakpoints for future "
"debugging sessions."
msgstr "跳過所有中斷點. 這樣一來, 你就可以為將來的除錯會話保存中斷點."

msgid "Copy the current error message."
msgstr "複製目前錯誤消息."

msgid ""
"**Step Into** the code. This button takes you to the next line of code, and "
"if it's a function, it steps line-by-line through the function."
msgstr ""
"**步入** 程式碼. 這個按鈕將帶你進入下一行程式碼, 如果是函式, 它將逐行進入函"
"式."

msgid ""
"**Step Over** the code. This button goes to the next line of code, but it "
"doesn't step line-by-line through functions."
msgstr "**步過** 的程式碼. 這個按鈕會進入下一行程式碼, 但它不會逐行跳過函式."

msgid "**Break**. This button pauses the game's execution."
msgstr "**Break** . 這個按鈕會暫停執行遊戲."

msgid "**Continue**. This button resumes the game after a breakpoint or pause."
msgstr "**繼續** . 該按鈕在中斷點或暫停後恢復遊戲."

msgid "Errors"
msgstr "錯誤"

msgid ""
"This is where error and warning messages are printed while running the game."
msgstr "這是運作遊戲時列印錯誤和警告資訊的地方."

msgid ""
"You can disable specific warnings in **Project Settings > Debug > GDScript**."
msgstr "您可以在 **專案設定>除錯> GDScript** 中禁用特定的警告."

msgid "Profiler"
msgstr "分析工具"

msgid ""
"The profiler is used to see what code is running while your project is in "
"use, and how that effects performance."
msgstr "探查器用於查看專案使用時正在運作哪些程式碼，以及它如何影響效能。"

msgid ""
"A detailed explanation of how to use the profiler can be found in the "
"dedicated :ref:`doc_the_profiler` page."
msgstr "有關如何使用探查器的詳細說明可以在專用的 doc_the_profiler 頁面中找到。"

msgid "Visual Profiler"
msgstr "分析工具"

msgid ""
"The Visual Profiler can be used to monitor what is taking the most time when "
"rendering a frame on the CPU and GPU respectively. This allows tracking "
"sources of potential CPU and GPU bottlenecks caused by rendering."
msgstr ""
"Visual Profiler 可用來監控分別在 CPU 和 GPU 上算繪影格時花費最多時間的情況。"
"這允許追蹤由算繪引起的潛在 CPU 和 GPU 瓶頸的來源。"

msgid ""
"The Visual Profiler only measures CPU time taken for rendering tasks, such "
"as performing draw calls. The Visual Profiler does **not** include CPU time "
"taken for other tasks such as scripting and physics. Use the standard "
"Profiler tab to track non-rendering-related CPU tasks."
msgstr ""
"Visual Profiler 僅測量算繪工作（例如執行繪製呼叫）所花費的 CPU 時間。 Visual "
"Profiler **不**包含其他工作（例如腳本編寫和實體）所花費的 CPU 時間。使用標準 "
"Profiler 標籤來追蹤與算繪無關的 CPU 工作。"

msgid ""
"To use the visual profiler, run the project, switch to the **Visual "
"Profiler** tab within the Debugger bottom panel, then click **Start**:"
msgstr ""
"若要使用視覺化分析器，請執行專案，切換到偵錯器底部面板中的 **Visual "
"Profiler** 分頁，然後按一下 **Start**："

msgid ""
"Visual Profiler tab after clicking Start, waiting for a few seconds, then "
"clicking Stop"
msgstr "點擊“開始”後的“Visual Profiler”分頁，等待幾秒鐘，然後點擊“停止”"

msgid ""
"Visual Profiler tab after clicking **Start**, waiting for a few seconds, "
"then clicking **Stop**"
msgstr ""
"點擊“**開始**”後的“Visual Profiler”分頁，等待幾秒鐘，然後點擊“**停止**”"

msgid ""
"You will see categories and results appearing as the profiler is running. "
"Graph lines also appear, with the left side being a CPU framegraph and the "
"right side being a GPU framegraph."
msgstr ""
"您將看到分析器運作時出現的類別和結果。也會出現圖形線，左側是 CPU 影格圖，右側"
"是 GPU 影格圖。"

msgid ""
"Click **Stop** to finish profiling, which will keep the results visible but "
"frozen in place. Results remain visible after stopping the running project, "
"but not after exiting the editor."
msgstr ""
"按一下 **停止** 完成分析，這將使結果保持可見但凍結在適當的位置。停止正在執行"
"的專案後，結果仍然可見，但退出編輯器後則不再可見。"

msgid ""
"Click on result categories on the left to highlight them in the CPU and GPU "
"graphs on the right. You can also click on the graph to move the cursor to a "
"specific frame number and highlight the selected data type in the result "
"categories on the left."
msgstr ""
"點擊左側的結果類別可在右側的 CPU 和 GPU 圖表中反白顯示它們。您也可以按一下圖"
"形將遊標移至特定影格編號，並在左側結果類別中反白顯示所選資料型別。"

msgid ""
"You can switch the result display between a time value (in milliseconds per "
"frame) or a percentage of the target frametime (which is currently hardcoded "
"to 16.67 milliseconds, or 60 FPS)."
msgstr ""
"您可以在時間值（每影格毫秒）或目標影格時間百分比（目前硬編碼為 16.67 毫秒或 "
"60 FPS）之間切換結果顯示。"

msgid ""
"If framerate spikes occur during profiling, this can cause the graph to be "
"poorly scaled. Disable **Fit to Frame** so that the graph will zoom onto the "
"60 FPS+ portion."
msgstr ""
"如果在分析過程中出現影格速率峰值，可能會導致圖表縮放不良。停用 **Fit to "
"Frame**，以便圖表將縮放到 60 FPS+ 部分。"

msgid ""
"Remember that Visual Profiler results can vary **heavily** based on viewport "
"resolution, which is determined by the window size if using the ``disabled`` "
"or ``canvas_items`` :ref:`stretch modes <doc_multiple_resolutions>`."
msgstr ""
"請記住，Visual Profiler 結果可能會根據視口分辨率而**顯著**，如果使"
"用“disabled”或“canvas_items”:ref:`拉伸模式<doc_multiple_analysis>`，則視口分"
"辨率由視窗大小決定。"

msgid ""
"When comparing results across different runs, make sure to use the same "
"viewport size for all runs."
msgstr "比較不同運作的結果時，請確保所有運作使用相同的視窗大小。"

msgid ""
"Visual Profiler is supported when using any rendering method (Forward+, "
"Mobile or Compatibility), but the reported categories will vary depending on "
"the current rendering method as well as the enabled graphics features. For "
"example, when using Forward+, a simple 2D scene with shadow-casting lights "
"will result in the following categories appearing:"
msgstr ""
"使用任何算繪方法（Forward+、Mobile 或 Compatibility）時支援 Visual Profiler，"
"但報告的類別將根據目前算繪方法以及啟用的圖形功能而有所不同。例如，當使用 "
"Forward+ 時，具有陰影投射燈的簡單 2D 場景將導致以下類別："

msgid "Example results from a 2D scene in the Visual Profiler"
msgstr "例子結果來自Callgrind, 這是Valgrind的一部分"

msgid ""
"To give another example with Forward+, a 3D scene with shadow-casting lights "
"and various effects enabled will result in the following categories enabled:"
msgstr ""
"再舉一個 Forward+ 的例子，啟用陰影投射燈和各種效果的 3D 場景將導致啟用以下類"
"別："

msgid "Example results from a 3D scene in the Visual Profiler"
msgstr "可視分析器中 3D 場景的範例結果"

msgid ""
"Notice how in the 3D example, several of the categories have **(Parallel)** "
"appended to their name. This hints that multiple tasks are being performed "
"in parallel on the GPU. This generally means that disabling only one of the "
"features involved won't improve performance as much as anticipated, as the "
"other task still needs to be performed sequentially."
msgstr ""
"請注意，在 3D 範例中，幾個類別的名稱後面附加了 **(Parallel)**。這暗示多個工作"
"正在 GPU 上並行執行。這通常意味著僅停用其中一項功能不會像預期那樣提高效能，因"
"為其他工作仍需要按順序執行。"

msgid "Network Profiler"
msgstr "網路分析工具"

msgid ""
"The Network Profiler contains a list of all the nodes that communicate over "
"the multiplayer API and, for each one, some counters on the amount of "
"incoming and outgoing network interactions. It also features a bandwidth "
"meter that displays the total bandwidth usage at any given moment."
msgstr ""
"網路剖析器包含了所有通過多人遊戲API進行通信的節點列表, 對於每個節點, 還包含了"
"一些傳入和傳出網路互動量的計數器. 它還具有一個頻寬表, 可以顯示任何特定時刻的"
"總頻寬使用情況."

msgid ""
"The bandwidth meter does **not** take the :ref:`doc_high_level_multiplayer` "
"API's own compression system into account. This means that changing the "
"compression algorithm used will not change the metrics reported by the "
"bandwidth meter."
msgstr ""
"頻寬計**不**考慮 doc_high_level_multiplayer API 自己的壓縮系統。這意味著更改"
"所使用的壓縮演算法不會更改頻寬計報告的指標。"

msgid "Monitors"
msgstr "監視器"

msgid ""
"The monitors are graphs of several aspects of the game while its running "
"such as FPS, memory usage, how many nodes are in a scene and more. All "
"monitors keep track of stats automatically, so even if one monitor isn't "
"open while the game is running, you can open it later and see how the values "
"changed."
msgstr ""
"監視器是遊戲運作時幾個方面的圖表, 如FPS, 記憶體使用情況, 場景中的節點數量等"
"等. 所有的監控器都會自動追蹤統計, 所以即使遊戲運作時一個監控器沒有打開, 你也"
"可以在以後打開它, 查看數值的變化."

msgid ""
"In addition to the default performance monitors, you can also create :ref:"
"`custom performance monitors <doc_custom_performance_monitors>` to track "
"arbitrary values in your project."
msgstr ""
"除了預設的效能監視器之外，您還可以建立:ref:`自訂效能監視器 "
"<doc_custom_performance_monitors>` 來追蹤專案中的任意值。"

msgid "Video RAM"
msgstr "顯存"

msgid ""
"The **Video RAM** tab shows the video RAM usage of the game while it is "
"running. It provides a list of every resource using video RAM by resource "
"path, the type of resource it is, what format it is in, and how much Video "
"RAM that resource is using. There is also a total video RAM usage number at "
"the top right of the panel."
msgstr ""
"**顯存**標籤顯示了遊戲運作時的顯存使用情況。它按資源路徑提供了每一個使用顯存"
"的資源列表、資源的型別、資源的格式，以及該資源使用了多少顯存。在面板的右上方"
"還有一個顯存佔用總量的數字。"

msgid "Misc"
msgstr "雜項"

msgid ""
"The **Misc** tab contains tools to identify the control nodes you are "
"clicking at runtime:"
msgstr "**其他**分頁中的工具可以用來識別你在運作時點擊了哪個控制項節點："

msgid ""
"**Clicked Control** tells you where the clicked node is in the scene tree."
msgstr "**點擊的控制項**顯示的是被點擊節點在場景樹中的位置。"

msgid "**Clicked Control Type** tells you the type of the node you clicked is."
msgstr "**點擊的控制項型別**顯示的是被點擊節點的型別。"

msgid "Translation status"
msgstr "翻譯狀態"
