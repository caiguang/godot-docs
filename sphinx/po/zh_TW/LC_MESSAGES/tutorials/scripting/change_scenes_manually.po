# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Change scenes manually"
msgstr "手動更改場景"

msgid ""
"Sometimes it helps to have more control over how one swaps scenes around. As "
"mentioned above, a :ref:`Viewport <class_Viewport>`'s child nodes will "
"render to the image it generates. This holds true even for nodes outside of "
"the \"current\" scene. Autoloads fall into this category, but so do scenes "
"which one instances and adds to the tree at runtime:"
msgstr ""
"有時候, 有必要更好地控制如何交換場景. 如上所述, 一個 :ref:`Viewport "
"<class_Viewport>` 的子節點將呈現給它生成的圖像. 即使對於 \"目前\" 場景之外的"
"節點, 這也適用. Autoloads屬於這一類, 但是一個實例在運作時新增到樹中的場景也是"
"如此:"

msgid ""
"To complete the cycle and swap out the new scene with the old one, "
"developers have a choice to make. Many strategies exist for removing a scene "
"from view of the :ref:`Viewport <class_Viewport>`. The tradeoffs involve "
"balancing operation speed and memory consumption as well as balancing data "
"access and integrity."
msgstr ""
"要完成迴圈並將舊場景替換為舊場景, 開發人員可以選擇製作. 從視圖中刪除場景有很"
"多策略 :ref:`Viewport <class_Viewport>`. 權衡涉及平衡操作速度和記憶體消耗以及"
"平衡資料存取和完整性."

msgid ""
"**We can delete the existing scene.** :ref:`SceneTree.change_scene_to_file() "
"<class_SceneTree_method_change_scene_to_file>` and :ref:`SceneTree."
"change_scene_to_packed() <class_SceneTree_method_change_scene_to_packed>` "
"will delete the current scene immediately. Developers can also delete the "
"main scene though. Assuming the root node's name is \"Main\", one could do "
"``get_node(\"/root/Main\").free()`` to delete the whole scene."
msgstr ""
"**我們可以刪除現有場景.** :ref:`SceneTree.change_scene() "
"<class_SceneTree_method_change_scene>` 和 :ref:`SceneTree.change_scene_to() "
"<class_SceneTree_method_change_scene_to>` 會立即刪除目前場景. 不過開發者也可"
"以刪除主場景. 假設根節點的名字是 \"Main\", 可以執行 ``get_node(\"/root/"
"Main\").free()`` 來刪除整個場景."

msgid "Unloads memory."
msgstr "解除安裝記憶體."

msgid "Pro: RAM is no longer dragging the dead weight."
msgstr "好處: RAM不再拖累自重."

msgid ""
"Con: Returning to that scene is now more expensive since it must be loaded "
"back into memory again (takes time AND memory). Not a problem if returning "
"soon is unnecessary."
msgstr ""
"壞處: 回到那個場景現在更加昂貴, 因為它必須再次載入回記憶體(需要時間和記憶"
"體). 如果不久就回來是不必要的."

msgid ""
"Con: No longer have access to that scene's data. Not a problem if using that "
"data soon is unnecessary."
msgstr "壞處: 無法再存取該場景的資料. 如果不久就使用這些資料就不成問題了."

msgid ""
"Note: It can be useful to preserve the data in a soon-to-be-deleted scene by "
"re-attaching one or more of its nodes to a different scene, or even directly "
"to the :ref:`SceneTree <class_SceneTree>`."
msgstr ""
"注意: 通過將一個或多個節點重新附加到不同的場景, 甚至直接將其重新附加到 :ref:"
"`SceneTree <class_SceneTree>`, 可以將資料保存在即將刪除的場景中."

msgid "Processing stops."
msgstr "處理停止."

msgid ""
"Pro: No nodes means no process, physics process, or input handling. The CPU "
"is available to work on the new scene's contents."
msgstr ""
"好處: 沒有節點意味著沒有程序, 物理過程或輸入處理. CPU可用於處理新場景的內容."

msgid ""
"Con: Those nodes' processing and input handling no longer operate. Not a "
"problem if using the updated data is unnecessary."
msgstr ""
"壞處: 這些節點的處理和輸入處理不再運作. 如果不需要使用更新的資料, 則不成問題."

msgid ""
"**We can hide the existing scene.** By changing the visibility or collision "
"detection of the nodes, we can hide the entire node sub-tree from the "
"player's perspective."
msgstr ""
"**我們可以隱藏現有場景.** 通過更改節點的可見性或碰撞偵測, 我們可以從遊戲角色"
"的角度隱藏整個節點子樹."

msgid "Memory still exists."
msgstr "記憶仍然存在."

msgid "Pro: One can still access the data if need be."
msgstr "好處: 如果需要, 仍然可以存取資料."

msgid "Pro: There's no need to move any more nodes around to save data."
msgstr "好處: 無需再移動任何節點來保存資料."

msgid ""
"Con: More data is being kept in memory which will be become a problem on "
"memory-sensitive platforms like web or mobile."
msgstr ""
"壞處: 更多資料被保存在記憶體中, 這將成為對記憶體敏感平臺(如Web或移動裝置)的問"
"題."

msgid "Processing continues."
msgstr "處理繼續."

msgid ""
"Pro: Data continues to receive processing updates, so the scene will keep "
"updated any data within it that relies on delta time or frame data."
msgstr ""
"好處: 資料繼續接收處理更新, 因此場景將不斷更新其中依賴於差異量時間或影格資料"
"的任何資料."

msgid ""
"Pro: Nodes are still members of groups (since groups belong to the :ref:"
"`SceneTree <class_SceneTree>`)."
msgstr ""
"Pro: 節點仍然是組的成員(因為組屬於 :ref:`SceneTree <class_SceneTree>`)."

msgid ""
"Con: The CPU's attention is now divided between both scenes. Too much load "
"could result in low frame rates. One should be sure to test performance as "
"they go to ensure the target platform can support the load they are giving "
"it."
msgstr ""
"壞處: 現在CPU的注意力分散在兩個場景之間. 負載過大可能導致畫面播放速率降低. 應"
"該確保測試性能, 以確保目標平臺能夠支援它們提供的負載."

msgid ""
"**We can remove the existing scene from the tree.** Assign a variable to the "
"existing scene's root node. Then use :ref:`Node.remove_child(Node) "
"<class_Node_method_remove_child>` to detach the entire scene from the tree."
msgstr ""
"**我們可以從樹上刪除現有的場景.** 給現有場景的根節點分配一個變數. 然後使用 :"
"ref:`Node.remove_child(Node) <class_Node_method_remove_child>` 來將整個場景從"
"樹上分離."

msgid "Memory still exists (similar pros/cons as with hiding it from view)."
msgstr "記憶仍然存在(與從視圖中隱藏它相似的優點/缺點)."

msgid "Processing stops (similar pros/cons as with deleting it completely)."
msgstr "處理停止(類似於完全刪除它的優點/缺點)."

msgid ""
"Pro: This variation of \"hiding\" it is much easier to show/hide. Rather "
"than potentially keeping track of multiple changes to the scene, one must "
"only call the one method add/remove_child pair of methods. It is similar to "
"disabling game objects in other engines."
msgstr ""
"好處：這種形式的“隱藏”更容易進行顯示/隱藏。人們必須只呼叫一個方法 add / "
"remove_child 方法，而不是潛在地追蹤場景的多個變化。它類似於在其他引擎中禁用遊"
"戲物件。"

msgid ""
"Con: Unlike with hiding it from view only, the data contained within the "
"scene will become stale if it relies on delta time, input, groups, or other "
"data that is derived from :ref:`SceneTree <class_SceneTree>` access."
msgstr ""
"壞處：與僅從視圖中隱藏它不同，如果場景中包含的資料依賴於時間差異量、輸入、群"
"組或其他通過存取 :ref:`SceneTree <class_SceneTree>` 才能得到的資料，則它將變"
"為陳舊。"

msgid ""
"There are also cases where one may wish to have many scenes present at the "
"same time. Perhaps one is adding their own singleton at runtime, or "
"preserving a a scene's data between scene changes (adding the scene to the "
"root node)."
msgstr ""
"在有些情況下, 人們可能希望有許多場景同時存在. 也許人們在運作時新增他們自己的"
"單例, 或者在場景變化之間保留一個場景的資料(將場景新增到根節點)."

msgid ""
"Perhaps instead they wish to display multiple scenes at the same time using :"
"ref:`SubViewportContainers <class_SubViewportContainer>`. This is optimal in "
"cases where the intent is to render different content in different parts of "
"the screen. Minimaps and split-screen multiplayer are good examples."
msgstr ""
"也許他們希望使用 :ref:`ViewportContainers <class_ViewportContainer>` 來同時顯"
"示多個場景。這意圖是在螢幕的不同部分算繪不同內容的情況下是最理想的。迷你地圖"
"和多人分屏遊戲就是很好的例子。"

msgid ""
"Each option will have cases where it is best appropriate, so one must "
"examine the effects of each and determine what path best fits their unique "
"situation."
msgstr ""
"每個選項都有最合適的情況, 因此必須檢查每個選項的效果並確定最適合其獨特情況的"
"路徑."

msgid "Translation status"
msgstr "翻譯狀態"
