# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Nodes and scene instances"
msgstr "節點與資源"

msgid ""
"This guide explains how to get nodes, create nodes, add them as a child, and "
"instantiate scenes from code."
msgstr ""
"本指南將介紹如何獲取節點、建立節點、將節點新增為子項、使用程式碼產生實體場"
"景。"

msgid "Getting nodes"
msgstr "建立節點"

msgid ""
"You can get a reference to a node by calling the :ref:`Node.get_node() "
"<class_Node_method_get_node>` method. For this to work, the child node must "
"be present in the scene tree. Getting it in the parent node's ``_ready()`` "
"function guarantees that."
msgstr ""
"你可以通過呼叫 :ref:`Node.get_node() <class_Node_method_get_node>` 方法來獲取"
"節點的引用。子節點必須在場景樹中才能成功。在父節點的 ``_ready()`` 函式中獲取"
"就可以保證這一點。"

msgid ""
"If, for example,  you have a scene tree like this, and you want to get a "
"reference to the Sprite2D and Camera2D nodes to access them in your script."
msgstr ""
"打個比方，如果你的場景樹是這樣的，並且你想要在腳本中獲取 Sprite 和 Camera2D "
"節點的引用。"

msgid "To do so, you can use the following code."
msgstr "有下列事項需注意："

msgid ""
"Note that you get nodes using their name, not their type. Above, "
"\"Sprite2D\" and \"Camera2D\" are the nodes' names in the scene."
msgstr ""
"請注意，你是通過名稱來獲取節點的，和型別無關。上面的“Sprite”和“Camera2D”都是"
"這些節點在場景中的名字。"

msgid ""
"If you rename the Sprite2D node as Skin in the Scene dock, you have to "
"change the line that gets the node to ``get_node(\"Skin\")`` in the script."
msgstr ""
"如果你在“場景”面板中將 Sprite 節點重命名為“Skin”，那就必須在腳本裡把獲得節點"
"的那一行敘述寫成 ``get_node(\"Skin\")``。"

msgid "Node paths"
msgstr "Node paths"

msgid ""
"When getting a reference to a node, you're not limited to getting a direct "
"child. The ``get_node()`` function supports paths, a bit like when working "
"with a file browser. Add a slash to separate nodes."
msgstr ""
"獲取節點的引用時，並不僅限於直接子節點。``get_node()`` 函式支援使用路徑，有點"
"類似檔瀏覽器裡的路徑。可以用斜杠分隔節點。"

msgid ""
"Take the following example scene, with the script attached to the "
"UserInterface node."
msgstr "在下面這個實例場景中，腳本是附加在 UserInterface 節點上的。"

msgid "To get the AnimationPlayer node, you would use the following code."
msgstr "有下列事項需注意："

msgid ""
"As with file paths, you can use \"..\" to get a parent node. The best "
"practice is to avoid doing that though not to break encapsulation. You can "
"also start the path with a forward slash to make it absolute, in which case "
"your topmost node would be \"/root\", the application's predefined root "
"viewport."
msgstr ""
"和檔路徑一樣，你可以使用“..”來獲取父節點。最佳實踐是不要這麼做，避免破壞封"
"裝。你還可以讓路徑以斜杠開頭，這樣的路徑是絕對路徑，最上層的節點就是“/root”，"
"即程式的預定義根視口。"

msgid "Syntactic sugar"
msgstr "語法糖"

msgid ""
"You can use two shorthands to shorten your code in GDScript. Firstly, "
"putting the ``@onready`` annotation before a member variable makes it "
"initialize right before the ``_ready()`` callback."
msgstr ""
"GDScript 中有兩個速寫法可以用來縮短程式碼。首先是在成員變數之前寫 "
"``onready`` 關鍵字，這樣這個變數就會剛好在 ``_ready()`` 回呼函式之前初始化。"

msgid ""
"There is also a short notation for ``get_node()``: the dollar sign, \"$\". "
"You place it before the name or path of the node you want to get."
msgstr ""
"還有一個 ``get_node()`` 的速記法：美元符號“$”。可以把它放在想要獲取的名稱或者"
"節點路徑之前。"

msgid "Creating nodes"
msgstr "建立節點"

msgid ""
"To create a node from code, call its ``new()`` method like for any other "
"class-based datatype."
msgstr ""
"與其他以類別為基礎的資料型別一樣，可以呼叫 ``.new()`` 方法來用程式碼建立節"
"點。例如："

msgid ""
"You can store the newly created node's reference in a variable and call "
"``add_child()`` to add it as a child of the node to which you attached the "
"script."
msgstr ""
"你可以將新建立的節點的引用保存在一個變數中，然後呼叫 ``add_child()`` 將其新增"
"為腳本所在節點的子項。"

msgid ""
"To delete a node and free it from memory, you can call its ``queue_free()`` "
"method. Doing so queues the node for deletion at the end of the current "
"frame after it has finished processing. At that point, the engine removes "
"the node from the scene and frees the object in memory."
msgstr ""
"要刪除節點、將其從內容中釋放，你可以呼叫其 ``queue_free()`` 方法。這樣該節點"
"的刪除工作就會被新增到佇列中，在目前影格完成處理後就會執行。刪除時，引擎會把"
"該節點從場景中刪除，然後釋放物件記憶體中的物件。"

msgid ""
"Before calling ``sprite2d.queue_free()``, the remote scene tree looks like "
"this."
msgstr "在呼叫 ``sprite.queue_free()`` 之前，遠端場景樹是類似這樣的。"

msgid ""
"After the engine freed the node, the remote scene tree doesn't display the "
"sprite anymore."
msgstr "在引擎釋放節點後，遠端場景樹就不會再現實這個精靈了。"

msgid ""
"You can alternatively call ``free()`` to immediately destroy the node. You "
"should do this with care as any reference to it will instantly become "
"``null``. We recommend using ``queue_free()`` unless you know what you're "
"doing."
msgstr ""
"你也可以呼叫 ``free()`` 來立即刪除該節點。呼叫時需要小心，因為所有對它的引用"
"都會立即變成 ``null``。除非你知道自己在幹什麼，否則我們建議使用 "
"``queue_free()``。"

msgid ""
"When you free a node, it also frees all its children. Thanks to this, to "
"delete an entire branch of the scene tree, you only have to free the topmost "
"parent node."
msgstr ""
"釋放節點時也會釋放它的所有子項。多虧如此，只需刪除最頂端的父節點，就可以刪除"
"整個場景樹分支了。"

msgid "Instancing scenes"
msgstr "實體化場景"

msgid ""
"Scenes are templates from which you can create as many reproductions as "
"you'd like. This operation is called instancing, and doing it from code "
"happens in two steps:"
msgstr ""
"場景就是範本，你可以用來來建立任意數量的複製品。這樣的操作叫作產生實體"
"（instancing），在程式碼中進行產生實體總共分兩步："

msgid "Loading the scene from the local drive."
msgstr "在程式碼中載入資源"

msgid ""
"Creating an instance of the loaded :ref:`PackedScene <class_PackedScene>` "
"resource."
msgstr ""
"要取得場景的實體，則必須使用 :ref:`PackedScene.instance() "
"<class_PackedScene_method_instance>` 方法。"

msgid ""
"Preloading the scene can improve the user's experience as the load operation "
"happens when the compiler reads the script and not at runtime. This feature "
"is only available with GDScript."
msgstr ""
"預載入場景可以提升使用者體驗，因為載入操作發生在編譯器讀取腳本時，而非運作"
"時。這個功能是 GDScript 獨有的。"

msgid ""
"At that point, ``scene`` is a packed scene resource, not a node. To create "
"the actual node, you need to call :ref:`PackedScene.instantiate() "
"<class_PackedScene_method_instantiate>`. It returns a tree of nodes that you "
"can use as a child of your current node."
msgstr ""
"但 ``scene`` (場景) 還不是節點，目前還打包在一個叫做 :ref:`PackedScene "
"<class_PackedScene>` (打包場景) 的特殊資源內。要真正建立節點，必須呼叫 :ref:"
"`PackedScene.instance()` 函式。這個函式會回傳一個可以被新增到有效場景內的節點"
"樹："

msgid ""
"The advantage of this two-step process is you can keep a packed scene loaded "
"and create new instances on the fly. For example, to quickly instance "
"several enemies or bullets."
msgstr ""
"拆成「載入 - 實體化」兩個步驟的優點是，載入過打包場景後就可以維持已載入的狀"
"態，隨時拿來使用。這樣一來我們就可以根據需要建立任意數量的實體。特別適用於需"
"要在有效場景內快速實體化多個敵人、子彈或是其他實體的情況。"

msgid "Translation status"
msgstr "翻譯狀態"
