# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Idle and Physics Processing"
msgstr "空閒處理與物理處理"

#, fuzzy
msgid ""
"Games run in a loop. Each frame, you need to update the state of your game "
"world before drawing it on screen. Godot provides two virtual methods in the "
"Node class to do so: :ref:`Node._process() "
"<class_Node_private_method__process>` and :ref:`Node._physics_process() "
"<class_Node_private_method__physics_process>`. If you define either or both "
"in a script, the engine will call them automatically."
msgstr ""
"遊戲是使用迴圈來運作的。每一影格，你都需要先更新遊戲世界的狀態，然後再把它畫"
"到螢幕上。Godot 在 Node 類中提供了兩個虛方法來完成這項工作：:ref:`Node."
"_process() <class_Node_method__process>` 和 :ref:`Node._physics_process() "
"<class_Node_method__physics_process>`。如果你在腳本中定義了其中之一或者兩者都"
"定義了，引擎就會自動進行呼叫。"

msgid "There are two types of processing available to you:"
msgstr "Godot 中需要的圖示有兩種型別："

msgid ""
"**Idle processing** allows you to run code that updates a node every frame, "
"as often as possible."
msgstr ""
"**空閒處理**（Idle processing）可以用來執行每影格更新節點的程式碼，執行頻率會"
"盡可能地快。"

msgid ""
"**Physics processing** happens at a fixed rate, 60 times per second by "
"default. This is independent of your game's actual framerate, and keeps "
"physics running smoothly. You should use it for anything that involves the "
"physics engine, like moving a body that collides with the environment."
msgstr ""
"**物理處理**（Physics processing）的頻率是固定的，預設為每秒 60 次。它和遊戲"
"的實際影格率無關，可以讓物理平滑執行。任何與物理引擎相關的東西都應該用它，比"
"如移動可能與環境相碰撞的實體。"

msgid ""
"You can activate idle processing by defining the ``_process()`` method in a "
"script. You can turn it off and back on by calling :ref:`Node.set_process() "
"<class_Node_method_set_process>`."
msgstr ""
"閒置處理會在腳本中有 :ref:`Node._process() <class_Node_method__process>`方法"
"時候啟動。可以通過 :ref:`Node.set_process() <class_Node_method_set_process>` "
"方法來開啟或關閉閒置處理。"

msgid "The engine calls this method every time it draws a frame:"
msgstr "每次引擎需要繪製一影格的時候就會呼叫該方法："

msgid ""
"Keep in mind that the frequency at which the engine calls ``_process()`` "
"depends on your application's framerate, which varies over time and across "
"devices."
msgstr ""
"有一點很重要的是， ``_process()`` 的呼叫頻率會依據應用程式在執行時的 FPS "
"(Frames Per Second，每秒影格數) 而定。這個頻率在不同裝置下可能會不同。"

msgid ""
"The function's ``delta`` parameter is the time elapsed in seconds since the "
"previous call to ``_process()``. Use this parameter to make calculations "
"independent of the framerate. For example, you should always multiply a "
"speed value by ``delta`` to animate a moving object."
msgstr ""
"函式的參數 ``delta`` 是從上一次呼叫 ``_process()`` 開始所經過的秒數。借助這個"
"參數就可以進行與影格率無關的計算。例如，為移動物理做動畫時，應該始終將速度值"
"乘上 ``delta``。"

msgid ""
"Physics processing works with a similar virtual function: "
"``_physics_process()``. Use it for calculations that must happen before each "
"physics step, like moving a character that collides with the game world. As "
"mentioned above, ``_physics_process()`` runs at fixed time intervals as much "
"as possible to keep the physics interactions stable. You can change the "
"interval between physics steps in the Project Settings, under Physics -> "
"Common -> Physics Fps. By default, it's set to run 60 times per second."
msgstr ""
"使用 ``_physics_process()`` 來進行物理處理，但物理處理是在每個物理步驟前使用"
"的，如控制角色。物理處理永遠都在物理步驟之前執行，而且會以相同的間隔呼叫，預"
"設為每秒 60 次。可以在專案設定中的 [Physics] -> [Common] -> [Physics FPS] 來"
"更改這個間隔。"

msgid "The engine calls this method before every physics step:"
msgstr "每次引擎需要繪製一影格的時候就會呼叫該方法："

msgid ""
"The function ``_process()`` is not synchronized with physics. Its rate "
"depends on hardware and game optimization. It also runs after the physics "
"step in single-threaded games."
msgstr ""
"然而，``_process()`` 函式並不與物理處理同步。_process() 的影格率並不固定，且"
"會根據硬體與遊戲的最佳化而有所不同。在單一執行緒的遊戲上，_process() 會在物理"
"步驟後才被執行。"

msgid ""
"You can see the ``_process()`` function at work by creating a scene with a "
"single Label node, with the following script attached to it:"
msgstr ""
"有一個簡單的方法可以讓我們瞭解 ``_process()``。先建立一個有 Label 節點的場"
"景，然後使用下列腳本："

msgid "When you run the scene, you should see a counter increasing each frame."
msgstr "這樣就會顯示一個每一影格都會增加的計數器。"

msgid "Translation status"
msgstr "翻譯狀態"
