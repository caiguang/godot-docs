# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Input examples"
msgstr "輸入範例"

msgid "Introduction"
msgstr "前言"

msgid ""
"In this tutorial, you'll learn how to use Godot's :ref:`InputEvent "
"<class_InputEvent>` system to capture player input. There are many different "
"types of input your game may use - keyboard, gamepad, mouse, etc. - and many "
"different ways to turn those inputs into actions in your game. This document "
"will show you some of the most common scenarios, which you can use as "
"starting points for your own projects."
msgstr ""
"在本教學中, 您將學習如何使用Godot的 :ref:`輸入事件 <class_InputEvent>` 系統捕"
"獲玩家輸入. 您的遊戲可以使用多種不同型別的輸入——鍵盤, 遊戲手柄, 滑鼠等等. 還"
"有許多不同的方法, 將這些輸入轉化為遊戲中的動作. 本文將向您展示一些最常見的場"
"景, 您可以將其作為您自己專案的起點."

msgid ""
"For a detailed overview of how Godot's input event system works, see :ref:"
"`doc_inputevent`."
msgstr ""
"要詳細瞭解 Godot 的輸入事件系統是如何工作的，請參閱 :ref:`doc_inputevent`。"

msgid "Events versus polling"
msgstr "事件和輪詢"

msgid ""
"Sometimes you want your game to respond to a certain input event - pressing "
"the \"jump\" button, for example. For other situations, you might want "
"something to happen as long as a key is pressed, such as movement. In the "
"first case, you can use the ``_input()`` function, which will be called "
"whenever an input event occurs. In the second case, Godot provides the :ref:"
"`Input <class_Input>` singleton, which you can use to query the state of an "
"input."
msgstr ""
"有時你想讓你的遊戲對某一輸入事件作出反應--例如按下 \"跳躍\" 按鈕. 在其他情況"
"下, 你可能希望只要有一個鍵被按下就會發生一些事情, 比如移動. 在第一種情況下, "
"你可以使用 ``_input()`` 函式, 只要有輸入事件發生就會呼叫該函式. 在第二種情況"
"下,Godot提供了 :ref:`Input <class_Input>` 單例, 你可以用它來查詢一個輸入的狀"
"態."

msgid "Examples:"
msgstr "範例："

msgid ""
"This gives you the flexibility to mix-and-match the type of input processing "
"you do."
msgstr "這使您能夠靈活地混合和配對所執行輸入的處理型別."

msgid ""
"For the remainder of this tutorial, we'll focus on capturing individual "
"events in ``_input()``."
msgstr "對於本教學的其餘部分, 我們將專注於使用 ``_input ()`` 捕捉單個事件."

msgid "Input events"
msgstr "輸入事件"

msgid ""
"Input events are objects that inherit from :ref:`InputEvent "
"<class_InputEvent>`. Depending on the event type, the object will contain "
"specific properties related to that event. To see what events actually look "
"like, add a Node and attach the following script:"
msgstr ""
"輸入事件是繼承自 :ref:`輸入事件 <class_InputEvent>` 的物件. 根據事件型別, 物"
"件將包含與該事件相關的特定屬性. 為了瞭解事件的實際情況, 新增一個節點並附加以"
"下腳本:"

msgid ""
"As you press keys, move the mouse, and perform other inputs, you'll see each "
"event scroll by in the output window. Here's an example of the output:"
msgstr ""
"當你按下按鍵, 移動滑鼠, 並執行其他輸入, 您會在輸出視窗中看到每個事件滾動. 下"
"面是輸出的一個例子:"

msgid ""
"As you can see, the results are very different for the different types of "
"input. Key events are even printed as their key symbols. For example, let's "
"consider :ref:`InputEventMouseButton <class_InputEventMouseButton>`. It "
"inherits from the following classes:"
msgstr ""
"如你所見, 對於不同型別的輸入, 結果是非常不同的. 按鍵事件甚至被列印為按鍵符"
"號. 例如, 讓我們考慮 :ref:`滑鼠按鈕輸入事件 <class_InputEventMouseButton>` . "
"它繼承自以下類:"

msgid ""
":ref:`InputEvent <class_InputEvent>` - the base class for all input events"
msgstr ":ref:`InputEvent <class_InputEvent>` - 所有輸入事件的基底類別"

msgid ""
":ref:`InputEventWithModifiers <class_InputEventWithModifiers>` - adds the "
"ability to check if modifiers are pressed, such as :kbd:`Shift` or :kbd:"
"`Alt`."
msgstr ""
":ref:`InputEventWithModifiers <class_InputEventWithModifiers>` - 增加了檢查是"
"否按下修飾按鍵, 如 :kbd:`Shift` 或 :kbd:`Alt` ."

msgid ""
":ref:`InputEventMouse <class_InputEventMouse>` - adds mouse event "
"properties, such as ``position``"
msgstr ""
":ref:`InputEventMouse <class_InputEventMouse>` - 增加滑鼠事件屬性, 如 "
"``position``"

msgid ""
":ref:`InputEventMouseButton <class_InputEventMouseButton>` - contains the "
"index of the button that was pressed, whether it was a double-click, etc."
msgstr ""
":ref:`滑鼠按鈕輸入事件 <class_InputEventMouseButton>` 包含按下的按鈕的索引, "
"無論是按兩下, 或是其他."

msgid ""
"It's a good idea to keep the class reference open while you're working with "
"events so you can check the event type's available properties and methods."
msgstr ""
"在處理事件時, 打開類引用是一個好主意, 這樣可以檢查事件型別的可用屬性和方法."

msgid ""
"You can encounter errors if you try to access a property on an input type "
"that doesn't contain it - calling ``position`` on ``InputEventKey`` for "
"example. To avoid this, make sure to test the event type first:"
msgstr ""
"如果您嘗試存取不包含屬性的輸入型別上的屬性, 則可能會遇到錯誤-例如, 對 "
"``InputEventKey`` 呼叫 ``Position`` . 要避免這種情況, 請確保首先測試事件型別:"

msgid "InputMap"
msgstr "InputMap"

msgid ""
"The :ref:`InputMap <class_InputMap>` is the most flexible way to handle a "
"variety of inputs. You use this by creating named input *actions*, to which "
"you can assign any number of input events, such as keypresses or mouse "
"clicks. To see them, and to add your own, open Project -> Project Settings "
"and select the InputMap tab:"
msgstr ""
":ref:`事件表 <class_InputMap>` 是處理各種輸入的最靈活的方法. 您可以通過建立命"
"名的輸入 *動作* 來使用它, 可以為它分配任意數量的輸入事件, 例如按鍵或滑鼠點"
"擊. 一個新的Godot專案已經包含許多預設定義操作. 看看它們, 然後新增你自己的, 打"
"開專案->專案設定, 並選擇事件表分頁:"

msgid ""
"A new Godot project includes a number of default actions already defined. To "
"see them, turn on ``Show Built-in Actions`` in the InputMap dialog."
msgstr ""
"新的 Godot 專案包含許多已定義的預設操作。若要查看它們，請在“InputMap”對話方塊"
"中開啟“顯示內建操作”。"

msgid "Capturing actions"
msgstr "建立內容"

msgid ""
"Once you've defined your actions, you can process them in your scripts using "
"``is_action_pressed()`` and ``is_action_released()`` by passing the name of "
"the action you're looking for:"
msgstr ""
"一旦你定義了動作, 可以在腳本中使用 ``is_action_pressed()`` 和 "
"``is_action_released ()`` 處理它們. 通過名稱搜尋回應的動作:"

msgid "Keyboard events"
msgstr "鍵盤事件"

msgid ""
"Keyboard events are captured in :ref:`InputEventKey <class_InputEventKey>`. "
"While it's recommended to use input actions instead, there may be cases "
"where you want to specifically look at key events. For this example, let's "
"check for the :kbd:`T`:"
msgstr ""
"鍵盤事件在 :ref:`InputEventKey <class_InputEventKey>` 中被捕獲. 雖然建議使用"
"輸入動作來代替, 但在某些情況下, 你可能會想專門查看按鍵事件. 對於目前範例, 來"
"檢查一下 :kbd:`T` :"

msgid ""
"See :ref:`@GlobalScope_Key <enum_@GlobalScope_Key>` for a list of keycode "
"constants."
msgstr ""
"詳見 :ref:`全域範圍_鍵位列表 <enum_@GlobalScope_KeyList>` 獲取掃描程式碼常數"
"列表."

msgid ""
"Due to *keyboard ghosting*, not all key inputs may be registered at a given "
"time if you press too many keys at once. Due to their location on the "
"keyboard, certain keys are more prone to ghosting than others. Some "
"keyboards feature antighosting at a hardware level, but this feature is "
"generally not present on low-end keyboards and laptop keyboards."
msgstr ""
"由於*鍵盤衝突*，如果你一次性按下了太多的鍵，那麼在特定時間點，可能是無法將所"
"有按鍵輸入都進行註冊的。根據按鍵在鍵盤上位置的不同，某些按鍵產生衝突的可能性"
"會比其他的要高。有些鍵盤在硬體層面會提供抗衝突功能，不過在低端鍵盤和筆記本鍵"
"盤上很少見。"

msgid ""
"As a result, it's recommended to use a default keyboard layout that is "
"designed to work well on a keyboard without antighosting. See `this Gamedev "
"Stack Exchange question <https://gamedev.stackexchange.com/a/109002>`__ for "
"more information."
msgstr ""
"因此，建議使用能夠在不具備抗衝突功能的鍵盤上也能正常工作的預設鍵盤配置。詳情"
"請參閱`這個 Gamedev Stack Exchange 問題 <https://gamedev.stackexchange.com/"
"a/109002>`__。"

msgid "Keyboard modifiers"
msgstr "鍵盤修飾鍵"

msgid ""
"Modifier properties are inherited from :ref:`InputEventWithModifiers "
"<class_InputEventWithModifiers>`. This allows you to check for modifier "
"combinations using boolean properties. Let's imagine you want one thing to "
"happen when the :kbd:`T` is pressed, but something different when it's :kbd:"
"`Shift + T`:"
msgstr ""
"修飾鍵屬性繼承自 :ref:`InputEventWithModifiers "
"<class_InputEventWithModifiers>` ，可使用布林屬性檢查修飾鍵的組合。試想，如果"
"需要在按下 :kbd:`T` 時發生一件事，而按下 :kbd:`Shift + T` 時發生不同的事："

msgid "Mouse events"
msgstr "滑鼠事件"

msgid ""
"Mouse events stem from the :ref:`InputEventMouse <class_InputEventMouse>` "
"class, and are separated into two types: :ref:`InputEventMouseButton "
"<class_InputEventMouseButton>` and :ref:`InputEventMouseMotion "
"<class_InputEventMouseMotion>`. Note that this means that all mouse events "
"will contain a ``position`` property."
msgstr ""
"滑鼠事件繼承自 :ref:`InputEventMouse <class_InputEventMouse>` 並被分成 :ref:"
"`InputEventMouseButton <class_InputEventMouseButton>` 和 :ref:"
"`InputEventMouseMotion <class_InputEventMouseMotion>` 兩種型別。注意，這意味"
"著所有滑鼠事件都包含 ``position`` 屬性。"

msgid "Mouse buttons"
msgstr "滑鼠按鈕"

msgid ""
"Capturing mouse buttons is very similar to handling key events. :ref:"
"`@GlobalScope_MouseButton <enum_@GlobalScope_MouseButton>` contains a list "
"of ``MOUSE_BUTTON_*`` constants for each possible button, which will be "
"reported in the event's ``button_index`` property. Note that the scrollwheel "
"also counts as a button - two buttons, to be precise, with both "
"``MOUSE_BUTTON_WHEEL_UP`` and ``MOUSE_BUTTON_WHEEL_DOWN`` being separate "
"events."
msgstr ""
"捕獲滑鼠按鈕與處理按鍵事件非常相似。:ref:`@GlobalScope_ButtonList "
"<enum_@GlobalScope_ButtonList>` 包含每個可能按鈕的 `BUTTON_*` 常數列表，它將"
"在事件的 ``button_index`` 屬性中報告。注意，滑鼠滾輪也可以算作一個按鈕——準確"
"地說是兩個按鈕，``BUTTON_WHEEL_UP``（滾輪鍵向上）和 ``BUTTON_WHEEL_DOWN``（滾"
"輪鍵向上）都是獨立的事件。"

msgid "Mouse motion"
msgstr "滑鼠行為"

msgid ""
":ref:`InputEventMouseMotion <class_InputEventMouseMotion>` events occur "
"whenever the mouse moves. You can find the move's distance with the "
"``relative`` property."
msgstr ""
":ref:`InputEventMouseMotion <class_InputEventMouseMotion>` 只要滑鼠移動就會發"
"生事件. 可以通過 ``relative`` 屬性找到移動的距離."

msgid ""
"Here's an example using mouse events to drag-and-drop a :ref:`Sprite2D "
"<class_Sprite2D>` node:"
msgstr "下面是一個使用滑鼠事件拖放 :ref:`Sprite <class_Sprite>` 節點的例子："

msgid "Touch events"
msgstr "觸摸事件"

msgid ""
"If you are using a touchscreen device, you can generate touch events. :ref:"
"`InputEventScreenTouch <class_InputEventScreenTouch>` is equivalent to a "
"mouse click event, and :ref:`InputEventScreenDrag "
"<class_InputEventScreenDrag>` works much the same as mouse motion."
msgstr ""
"如果你使用的是觸控式螢幕裝置，就可以生成觸摸事件。:ref:"
"`InputEventScreenTouch <class_InputEventScreenTouch>` 相當於滑鼠點擊事件，"
"而 :ref:`InputEventScreenDrag <class_InputEventScreenDrag>` 的工作原理與滑鼠"
"移動一致。"

msgid ""
"To test your touch events on a non-touchscreen device, open Project Settings "
"and go to the \"Input Devices/Pointing\" section. Enable \"Emulate Touch "
"From Mouse\" and your project will interpret mouse clicks and motion as "
"touch events."
msgstr ""
"要在非觸控式螢幕裝置上測試觸摸事件，請打開“專案設定”，進入“Input Devices/"
"Pointing”（輸入裝置/觸點）部分。啟用“Emulate Touch From Mouse”（根據滑鼠類比"
"觸摸），您的專案將把滑鼠按一下和移動解釋為觸摸事件。"

msgid "Translation status"
msgstr "翻譯狀態"
