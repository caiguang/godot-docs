# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Controllers, gamepads, and joysticks"
msgstr "控制器、手柄和搖桿"

msgid ""
"Godot supports hundreds of controller models thanks to the community-sourced "
"`SDL game controller database <https://github.com/gabomdq/"
"SDL_GameControllerDB>`__."
msgstr ""
"Godot支援數百種控制器模型，這要歸功於社區提供的 `SDL遊戲控制器資料庫 "
"<https://github.com/gabomdq/SDL_GameControllerDB>`__ 。"

msgid ""
"Controllers are supported on Windows, macOS, Linux, Android, iOS, and HTML5."
msgstr "控制器支援Windows、macOS、Linux、Android、iOS和HTML5。"

msgid ""
"Note that more specialized devices such as steering wheels, rudder pedals "
"and `HOTAS <https://en.wikipedia.org/wiki/HOTAS>`__ are less tested and may "
"not always work as expected. Overriding force feedback for those devices is "
"also not implemented yet. If you have access to one of those devices, don't "
"hesitate to `report bugs on GitHub <https://github.com/godotengine/godot/"
"blob/master/CONTRIBUTING.md#reporting-bugs>`__."
msgstr ""
"請注意，諸如方向盤、方向盤踏板和 `HOTAS <https://en.wikipedia.org/wiki/"
"HOTAS>`__ 等更專業的裝置測試較少，可能並不總是按照預期工作。目前尚未實作在這"
"些裝置上的力回饋覆蓋。如果你有機會使用這些裝置，請不要猶豫，`在 GitHub "
"<https://github.com/godotengine/godot/blob/master/CONTRIBUTING.md#reporting-"
"bugs>`__ 上報告錯誤。"

msgid "In this guide, you will learn:"
msgstr "在本指南中，我們將學到："

msgid ""
"**How to write your input logic to support both keyboard and controller "
"inputs.**"
msgstr "**如何編寫你的輸入邏輯，從而支援鍵盤和控制器輸入。**"

msgid "**How controllers can behave differently from keyboard/mouse input.**"
msgstr "**控制器的行為如何與鍵盤/滑鼠輸入不同。**"

msgid "**Troubleshooting issues with controllers in Godot.**"
msgstr "**解決 Godot 中控制器的問題。**"

msgid "Supporting universal input"
msgstr "為通用 Windows 平台(UWP) 匯出"

msgid ""
"Thanks to Godot's input action system, Godot makes it possible to support "
"both keyboard and controller input without having to write separate code "
"paths. Instead of hardcoding keys or controller buttons in your scripts, you "
"should create *input actions* in the Project Settings which will then refer "
"to specified key and controller inputs."
msgstr ""
"得益於 Godot 的輸入動作系統，Godot 可以同時支援鍵盤和控制器輸入，而不需要編寫"
"單獨的程式碼路徑。你不應該在腳本中對控制器的按鍵進行硬編碼，應該在專案設定中"
"建立*輸入動作*，這些動作引用按鍵和控制器輸入。"

msgid ""
"Input actions are explained in detail on the :ref:`doc_inputevent` page."
msgstr "輸入動作在 :ref:`doc_inputevent` 頁面上有詳細解釋。"

msgid ""
"Unlike keyboard input, supporting both mouse and controller input for an "
"action (such as looking around in a first-person game) will require "
"different code paths since these have to be handled separately."
msgstr ""
"與鍵盤輸入不同，支援滑鼠和控制器輸入的動作將需要不同的程式碼路徑，例如在第一"
"人稱遊戲中四處查看，因為這些必須被分開處理。"

msgid "Which Input singleton method should I use?"
msgstr "GDScript是什麼？為什麼我要用它？"

msgid "There are 3 ways to get input in an analog-aware way:"
msgstr "有3種方式可以以類比感知的方式獲得輸入:"

msgid ""
"When you have two axes (such as joystick or WASD movement) and want both "
"axes to behave as a single input, use ``Input.get_vector()``:"
msgstr ""
"當你有兩個軸，如操縱桿或WASD運動，並希望兩個軸都表現為單一輸入時，使用 "
"``Input.get_vector()`` :"

msgid ""
"When you have one axis that can go both ways (such as a throttle on a flight "
"stick), or when you want to handle separate axes individually, use ``Input."
"get_axis()``:"
msgstr ""
"當你有一個軸可以雙向移動時，比如飛行操縱桿上的油門，或者你想單獨處理不同的軸"
"時，使用 ``Input.get_axis()`` :"

msgid ""
"For other types of analog input, such as handling a trigger or handling one "
"direction at a time, use ``Input.get_action_strength()``:"
msgstr ""
"對於其他型別的模擬輸入，例如處理一個觸發器或一次處理一個方向，使用 ``Input."
"get_action_strength()`` :"

msgid ""
"For non-analog digital/boolean input (only \"pressed\" or \"not pressed\" "
"values), such as controller buttons, mouse buttons or keyboard keys, use "
"``Input.is_action_pressed()``:"
msgstr ""
"對於非類比數位/布林輸入（只有 \"按下 \" 或 \"未按下 \" 的值），如控制器按鈕、"
"滑鼠按鈕或鍵盤按鍵，使用 ``Input.is_action_pressed()`` :"

msgid ""
"If you need to know whether an input was *just* pressed in the previous "
"frame, use ``Input.is_action_just_pressed()`` instead of ``Input."
"is_action_pressed()``. Unlike ``Input.is_action_pressed()`` which returns "
"``true`` as long as the input is held, ``Input.is_action_just_pressed()`` "
"will only return ``true`` for one frame after the button has been pressed."
msgstr ""
"如果您需要知道某個輸入是否在前一影格中「剛剛」被按下，請使用「Input."
"is_action_just_pressed()」而不是「Input.is_action_pressed()」。與只要保持輸入"
"就回傳 true 的「Input.is_action_pressed()」不同，「Input."
"is_action_just_pressed()」只會在按鈕按下後一影格返回「true」按下。"

msgid ""
"In Godot versions before 3.4, such as 3.3, ``Input.get_vector()`` and "
"``Input.get_axis()`` aren't available. Only ``Input.get_action_strength()`` "
"and ``Input.is_action_pressed()`` are available in Godot 3.3."
msgstr ""
"在3.4之前的Godot版本，如3.3， ``Input.get_vector()`` 和 ``Input.get_axis()`` "
"不可用。只有 ``Input.get_action_strength()`` 和 ``Input."
"is_action_pressed()`` 在Godot 3.3中可用。"

msgid "Vibration"
msgstr "減法"

msgid ""
"Vibration (also called *haptic feedback*) can be used to enhance the feel of "
"a game. For instance, in a racing game, you can convey the surface the car "
"is currently driving on through vibration, or create a sudden vibration on a "
"crash."
msgstr ""
"振動（也稱為*觸覺回饋*）可用於增強遊戲的感覺。例如，在賽車遊戲中，您可以透過"
"振動傳達汽車目前行駛的表面，或在碰撞時產生突然的振動。"

msgid ""
"Use the Input singleton's :ref:"
"`start_joy_vibration<class_Input_method_start_joy_vibration>` method to "
"start vibrating a gamepad. Use :ref:"
"`stop_joy_vibration<class_Input_method_stop_joy_vibration>` to stop "
"vibration early (useful if no duration was specified when starting)."
msgstr ""
"使用輸入單例的 start_joy_vibration<class_Input_method_start_joy_vibration>` "
"方法開始振動遊戲手把。使用 "
"stop_joy_vibration<class_Input_method_stop_joy_vibration>` 提前停止振動（如果"
"啟動時未指定持續時間，則很有用）。"

msgid ""
"On mobile devices, you can also use :ref:"
"`vibrate_handheld<class_Input_method_vibrate_handheld>` to vibrate the "
"device itself (independently from the gamepad). On Android, this requires "
"the ``VIBRATE`` permission to be enabled in the Android export preset before "
"exporting the project."
msgstr ""
"在行動裝置上，您也可以使用 "
"vibrate_handheld<class_Input_method_vibrate_handheld> 來振動裝置本身（獨立於"
"遊戲手把）。在 Android 上，這需要在匯出專案之前在 Android 匯出預設中啟用"
"「VIBRATE」權限。"

msgid ""
"Vibration can be uncomfortable for certain players. Make sure to provide an "
"in-game slider to disable vibration or reduce its intensity."
msgstr ""
"振動可能會讓某些玩家感到不舒服。確保提供遊戲內滑桿來停用振動或降低其強度。"

msgid "Differences between keyboard/mouse and controller input"
msgstr "鍵盤/滑鼠和控制器輸入之間的差異"

msgid ""
"If you're used to handling keyboard and mouse input, you may be surprised by "
"how controllers handle specific situations."
msgstr ""
"如果您習慣於處理鍵盤和滑鼠輸入，可能會對控制器處理特定情況的方式感到驚訝。"

msgid "Dead zone"
msgstr "死區"

msgid ""
"Unlike keyboards and mice, controllers offer axes with *analog* inputs. The "
"upside of analog inputs is that they offer additional flexibility for "
"actions. Unlike digital inputs which can only provide strengths of ``0.0`` "
"and ``1.0``, an analog input can provide *any* strength between ``0.0`` and "
"``1.0``. The downside is that without a deadzone system, an analog axis' "
"strength will never be equal to ``0.0`` due to how the controller is "
"physically built. Instead, it will linger at a low value such as ``0.062``. "
"This phenomenon is known as *drifting* and can be more noticeable on old or "
"faulty controllers."
msgstr ""
"與鍵盤和滑鼠不同，控制器提供帶有*模擬*輸入的軸。模擬輸入的好處是它們為動作提"
"供了額外的靈活性。不像數位輸入只能提供 ``0.0`` 和 ``1.0`` 的強度，模擬輸入可"
"以提供 ``0.0`` 和 ``1.0`` 之間的*任何*強度。缺點是沒有死區系統，由於控制器的"
"物理結構，類比軸的強度永遠不會等於 ``0.0``。相反，它將徘徊在一個低值，如 "
"``0.062``。這種現象被稱為*漂移*，在舊的或有問題的控制器上會更加明顯。"

msgid ""
"Let's take a racing game as a real-world example. Thanks to analog inputs, "
"we can steer the car slowly in one direction or another. However, without a "
"deadzone system, the car would slowly steer by itself even if the player "
"isn't touching the joystick. This is because the directional axis strength "
"won't be equal to ``0.0`` when we expect it to. Since we don't want our car "
"to steer by itself in this case, we define a \"dead zone\" value of ``0.2`` "
"which will ignore all input whose strength is lower than ``0.2``. An ideal "
"dead zone value is high enough to ignore the input caused by joystick "
"drifting, but is low enough to not ignore actual input from the player."
msgstr ""
"讓我們把賽車遊戲作為一個現實世界的例子。由於有了模擬輸入，我們可以將汽車慢慢"
"地轉向一個或另一個方向。然而，如果沒有死區系統，即使玩家不接觸操縱桿，汽車也"
"會自己慢慢轉向。這是因為方向軸的強度在我們期望的時候不會等於 ``0.0``。因為我"
"們不希望我們的車在這種情況下自動轉向，我們定義了一個“死區”值 ``0.2``，它將忽"
"略所有強度低於 ``0.2`` 的輸入。一個理想的死區值是足夠高的，可以忽略操縱桿漂移"
"引起的輸入，但又足夠低，不會忽略玩家的實際輸入。"

msgid ""
"Godot features a built-in deadzone system to tackle this problem. The "
"default value is ``0.5``, but you can adjust it on a per-action basis in the "
"Project Settings' Input Map tab. For ``Input.get_vector()``, the deadzone "
"can be specified as an optional 5th parameter. If not specified, it will "
"calculate the average deadzone value from all of the actions in the vector."
msgstr ""
"Godot 有一個內建的死區系統來解決這個問題。預設值是 ``0.2``，但你可以在“專案設"
"定”的“按鍵對應”分頁中根據每個動作增加或減少它。對於 ``Input.get_vector()``，"
"可以指定死區，否則它將從向量中的所有動作計算出平均死區值。"

msgid "\"Echo\" events"
msgstr "“回聲”事件"

msgid ""
"Unlike keyboard input, holding down a controller button such as a D-pad "
"direction will **not** generate repeated input events at fixed intervals "
"(also known as \"echo\" events). This is because the operating system never "
"sends \"echo\" events for controller input in the first place."
msgstr ""
"與鍵盤輸入不同，按住一個控制器按鈕，如十字方向鍵，**不會**產生固定間隔的重複"
"輸入事件（也被稱為“回聲”事件）。這是因為作業系統首先不會為控制器輸入發送“回"
"聲”事件。"

msgid ""
"If you want controller buttons to send echo events, you will have to "
"generate :ref:`class_InputEvent` objects by code and parse them using :ref:"
"`Input.parse_input_event() <class_Input_method_parse_input_event>` at "
"regular intervals. This can be accomplished with the help of a :ref:"
"`class_Timer` node."
msgstr ""
"如果你想讓控制器按鈕發送回聲事件，你將不得不通過程式碼生成 :ref:"
"`class_InputEvent` 物件，並使用 :ref:`Input.parse_input_event() "
"<class_Input_method_parse_input_event>` 定期解析它們。這可以在 :ref:"
"`class_Timer` 節點的幫助下完成。"

msgid "Window focus"
msgstr "Windows"

msgid ""
"Unlike keyboard input, controller inputs can be seen by **all** windows on "
"the operating system, including unfocused windows."
msgstr ""
"與鍵盤輸入不同，作業系統上的**所有**視窗都可以看到控制器輸入，包括未聚焦的視"
"窗。"

msgid ""
"While this is useful for `third-party split screen functionality <https://"
"nucleus-coop.github.io/>`__, it can also have adverse effects. Players may "
"accidentally send controller inputs to the running project while interacting "
"with another window."
msgstr ""
"雖然這對於「第三方分割畫面功能 <https://nucleus-coop.github.io/>`__ 很有用，"
"但它也可能產生不利影響。玩家在與另一個視窗互動時可能會意外地將控制器輸入傳送"
"到正在執行的專案。"

msgid ""
"If you wish to ignore events when the project window isn't focused, you will "
"need to create an :ref:`autoload <doc_singletons_autoload>` called ``Focus`` "
"with the following script and use it to check all your inputs:"
msgstr ""
"如果您希望在專案視窗未聚焦時忽略事件，則需要使用以下腳本建立名為「Focus」的自"
"動載入 <doc_singletons_autoload>` 並使用它來檢查所有輸入："

msgid ""
"Then, instead of using ``Input.is_action_pressed(action)``, use ``Focus."
"input_is_action_pressed(action)`` where ``action`` is the name of the input "
"action. Also, instead of using ``event.is_action_pressed(action)``, use "
"``Focus.event_is_action_pressed(event, action)`` where ``event`` is an "
"InputEvent reference and ``action`` is the name of the input action."
msgstr ""
"然後，不要使用“Input.is_action_pressed(action)”，而是使用“Focus."
"input_is_action_pressed(action)”，其中“action”是輸入操作的名稱。另外，不要使"
"用“event.is_action_pressed(action)”，而是使用“Focus."
"event_is_action_pressed(event, action)”，其中“event”是InputEvent引"
"用，“action”是事件的名稱。輸入動作。"

msgid "Power saving prevention"
msgstr "防止省電模式"

msgid ""
"Unlike keyboard and mouse input, controller inputs do **not** inhibit sleep "
"and power saving measures (such as turning off the screen after a certain "
"amount of time has passed)."
msgstr ""
"與鍵盤和滑鼠輸入不同，控制器輸入**不會**抑制睡眠和省電措施（例如在經過一定時"
"間後關閉螢幕）。"

msgid ""
"To combat this, Godot enables power saving prevention by default when a "
"project is running. If you notice the system is turning off its display when "
"playing with a gamepad, check the value of **Display > Window > Energy "
"Saving > Keep Screen On** in the Project Settings."
msgstr ""
"為了解決這個問題，Godot 在專案運作時預設啟用節能預防。如果您注意到系統在玩遊"
"戲手把時關閉了顯示屏，請檢查專案設定中的 **顯示 > 視窗 > 節能 > 保持螢幕開啟"
"** 的值。"

msgid ""
"On Linux, power saving prevention requires the engine to be able to use D-"
"Bus. Check whether D-Bus is installed and reachable if running the project "
"within a Flatpak, as sandboxing restrictions may make this impossible by "
"default."
msgstr ""
"在 Linux 上，節能預防要求引擎能夠使用 D-Bus。如果在 Flatpak 中運作專案，請檢"
"查 D-Bus 是否已安裝且可存取，因為沙盒限制可能會導致預設無法實作此操作。"

msgid "Troubleshooting"
msgstr "疑難排解"

msgid ""
"You can view a list of `known issues with controller support <https://github."
"com/godotengine/godot/issues?"
"q=is%3Aopen+is%3Aissue+label%3Atopic%3Ainput+gamepad>`__ on GitHub."
msgstr ""
"請瀏覽 `GitHub 上的 HTML5 問題列表 <https://github.com/godotengine/godot/"
"issues?q=is:open+is:issue+label:platform:html5>`__ 以瞭解您有興趣的功能目前是"
"否有問題。若列表上沒有，可以開啟 Issue 來與大家交流。"

msgid "My controller isn't recognized by Godot."
msgstr "Godot 無法識別我的控制器。"

msgid ""
"First, check that your controller is recognized by other applications. You "
"can use the `Gamepad Tester <https://gamepad-tester.com/>`__ website to "
"confirm that your controller is recognized."
msgstr ""
"首先，檢查你的控制器是否被其他應用程式識別。你可以使用 `Gamepad Tester "
"<https://gamepad-tester.com/>`__ 網站來確認你的控制器被識別。"

msgid ""
"On Windows Godot only supports up to 4 controllers at a time. This is "
"because Godot uses the XInput API, which is limited to supporting 4 "
"controllers at once. Additional controllers above this limit are ignored by "
"Godot."
msgstr ""

msgid "My controller has incorrectly mapped buttons or axes."
msgstr "我的控制器的按鈕或軸對應不正確。"

msgid ""
"First, if your controller provides some kind of firmware update utility, "
"make sure to run it to get the latest fixes from the manufacturer. For "
"instance, Xbox One and Xbox Series controllers can have their firmware "
"updated using the `Xbox Accessories app <https://www.microsoft.com/en-us/p/"
"xbox-accessories/9nblggh30xj3>`__. (This application only runs on Windows, "
"so you have to use a Windows machine or a Windows virtual machine with USB "
"support to update the controller's firmware.) After updating the "
"controller's firmware, unpair the controller and pair it again with your PC "
"if you are using the controller in wireless mode."
msgstr ""
"首先，如果您的控制器提供某種韌體更新實用程式，請確保運作它以從製造商處獲取最"
"新修復程式。例如，Xbox One 和 Xbox Series 控制器可以使用「Xbox Accessories 應"
"用程式 <https://www.microsoft.com/en-us/p/xbox-accessories/9nblggh30xj3>」更"
"新其韌體。 （此應用程式僅在Windows 上執行，因此您必須使用Windows 電腦或支援"
"USB 的Windows 虛擬機器來更新控制器的韌體。）更新控制器的韌體後，請取消控制器"
"配對，然後再次將其與PC配對（如果您是這樣）在無線模式下使用控制器。"

msgid ""
"If buttons are incorrectly mapped, this may be due to an erroneous mapping "
"from the `SDL game controller database <https://github.com/gabomdq/"
"SDL_GameControllerDB>`__. You can contribute an updated mapping to be "
"included in the next Godot version by opening a pull request on the linked "
"repository."
msgstr ""
"如果按鈕存在對應錯誤，可能是由於來自 `SDL 遊戲控制器資料庫 <https://github."
"com/gabomdq/SDL_GameControllerDB>`__的錯誤的對應。你可以在連結的倉庫中提交拉"
"取請求，為下一個 Godot 版本提供對應更新。"

msgid ""
"There are many ways to create mappings. One option is to use the mapping "
"wizard in the `official Joypads demo <https://godotengine.org/asset-library/"
"asset/140>`__. Once you have a working mapping for your controller, you can "
"test it by defining the ``SDL_GAMECONTROLLERCONFIG`` environment variable "
"before running Godot:"
msgstr ""
"有很多方法來建立對應。一個選擇是使用 `官方Joypads演示 <https://godotengine."
"org/asset-library/asset/140>`__ 中的對應嚮導。一旦你有了控制器可工作的對應，"
"你可以在運作Godot之前通過定義 ``SDL_GAMECONTROLLERCONFIG`` 環境變數來測試它:"

msgid ""
"To test mappings on non-desktop platforms or to distribute your project with "
"additional controller mappings, you can add them by calling :ref:`Input."
"add_joy_mapping() <class_Input_method_add_joy_mapping>` as early as possible "
"in a script's ``_ready()`` function."
msgstr ""
"要在非桌面平臺上測試對應，或者用額外的控制器對應來分發你的專案，你可以通過呼"
"叫 :ref:`Input.add_joy_mapping() <class_Input_method_add_joy_mapping>` 儘早在"
"腳本的 ``_ready()`` 函式中新增它們。"

msgid "My controller works on a given platform, but not on another platform."
msgstr "我的控制器在特定的平臺上工作，但在另一個平臺上卻不能。"

msgid "Linux"
msgstr "Linux"

msgid ""
"If you're using a self-compiled engine binary, make sure it was compiled "
"with udev support. This is enabled by default, but it is possible to disable "
"udev support by specifying ``udev=no`` on the SCons command line. If you're "
"using an engine binary supplied by a Linux distribution, double-check "
"whether it was compiled with udev support."
msgstr ""
"如果您使用自編譯引擎二進位檔案，請確保它是使用 udev 支援進行編譯的。預設啟用"
"此功能，但可以透過在 SCons 命令列上指定「udev=no」來停用 udev 支援。如果您使"
"用的是 Linux 發行版提供的引擎二進位檔案，請仔細檢查它是否是使用 udev 支援進行"
"編譯的。"

msgid ""
"Controllers can still work without udev support, but it is less reliable as "
"regular polling must be used to check for controllers being connected or "
"disconnected during gameplay (hotplugging)."
msgstr ""
"控制器在沒有 udev 支援的情況下仍然可以工作，但可靠性較低，因為必須使用定期輪"
"詢來檢查遊戲期間控制器的連接或斷開連接（熱插拔）。"

msgid "HTML5"
msgstr "HTML5"

msgid ""
"HTML5 controller support is often less reliable compared to \"native\" "
"platforms. The quality of controller support tends to vary wildly across "
"browsers. As a result, you may have to instruct your players to use a "
"different browser if they can't get their controller to work."
msgstr ""
"與 \"本地\" 平臺相比，HTML5 控制器的支援通常不太可靠。各個瀏覽器對控制器的支"
"援品質往往相差甚遠。因此，如果玩家無法使用他們的控制器，你可能不得不指示他們"
"使用不同的瀏覽器。"

msgid "Translation status"
msgstr "翻譯狀態"
