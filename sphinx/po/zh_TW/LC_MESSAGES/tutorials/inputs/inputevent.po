# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using InputEvent"
msgstr "使用 InputEvent"

msgid "What is it?"
msgstr "它是什麼？"

msgid ""
"Managing input is usually complex, no matter the OS or platform. To ease "
"this a little, a special built-in type is provided, :ref:`InputEvent "
"<class_InputEvent>`. This datatype can be configured to contain several "
"types of input events. Input events travel through the engine and can be "
"received in multiple locations, depending on the purpose."
msgstr ""
"無論是在作業系統或平臺上, 管理輸入通常很複雜. 為了簡化輸入管理, 引擎提供了一"
"個特殊的內建型別 :ref:`InputEvent <class_InputEvent>`. 此型別可被設定成包含多"
"種型別的輸入事件. 輸入事件通過引擎傳遞, 可在多個位置接收, 具體位置取決於目的."

msgid "Here is a quick example, closing your game if the escape key is hit:"
msgstr "這裡有一個簡單的範例，按下 ESC 鍵時關閉您的遊戲："

msgid ""
"However, it is cleaner and more flexible to use the provided :ref:`InputMap "
"<class_InputMap>` feature, which allows you to define input actions and "
"assign them different keys. This way, you can define multiple keys for the "
"same action (e.g. the keyboard escape key and the start button on a "
"gamepad). You can then more easily change this mapping in the project "
"settings without updating your code, and even build a key mapping feature on "
"top of it to allow your game to change the key mapping at runtime!"
msgstr ""
"但是，使用所提供的 :ref:`InputMap <class_InputMap>` 功能更簡潔靈活，它允許您"
"定義輸入操作並分配不同的鍵。這樣，您可以定義多個鍵的相同動作，例如鍵盤ESC鍵和"
"遊戲手柄上的啟動按鈕。然後，你可以在不更新程式碼的情況下輕鬆更改專案設定中的"
"此對應，甚至在上面建構鍵對應功能，以便您的遊戲在運作時更改鍵值對應！"

msgid ""
"You can set up your InputMap under **Project > Project Settings > Input "
"Map** and then use those actions like this:"
msgstr ""
"您可以在**專案 > 專案設定 > 按鍵對應**下設定您的輸入對應，這些動作的使用方法"
"如下："

msgid "How does it work?"
msgstr "工作原理是怎樣的？"

msgid ""
"Every input event is originated from the user/player (though it's possible "
"to generate an InputEvent and feed them back to the engine, which is useful "
"for gestures). The DisplayServer for each platform will read events from the "
"operating system, then feed them to the root :ref:`Window <class_Window>`."
msgstr ""
"每個輸入事件都來源於使用者/玩家（雖然也可以自己生成 InputEvent 並提供給引擎，"
"多用於手勢）。各個平臺的 DisplayServer 都會從作業系統讀取事件，然後提供給根 :"
"ref:`Window <class_Window>`。"

msgid ""
"The window's :ref:`Viewport <class_Viewport>` does quite a lot of stuff with "
"the received input, in order:"
msgstr ""
"視窗的 :ref:`Viewport <class_Viewport>` 會對收到的輸入進行很多處理，依次為："

msgid ""
"If the Viewport is embedding Windows, the Viewport tries to interpret the "
"event in its capability as a Window-Manager (e.g. for resizing or moving "
"Windows)."
msgstr ""
"如果該 Viewport 內嵌了 Window，則該 Viewport 會嘗試以視窗管理器的身份解釋事件"
"（例如對 Window 進行大小調整和移動）。"

msgid ""
"Next if an embedded Window is focused, the event is sent to that Window and "
"processed in the Windows Viewport and afterwards treated as handled. If no "
"embedded Window is focused, the event is sent to the nodes of the current "
"viewport in the following order."
msgstr ""
"接下來，如果存在聚焦的內嵌 Window，則會將事件發送給該 Window，在該視窗的 "
"Viewport 中進行處理，然後將事件標記為已處理。如果不存在聚焦的內嵌 Window，則"
"會將事件發送給目前視口中的節點，順序如下。"

#, fuzzy
msgid ""
"First of all, the standard :ref:`Node._input() "
"<class_Node_private_method__input>` function will be called in any node that "
"overrides it (and hasn't disabled input processing with :ref:`Node."
"set_process_input() <class_Node_method_set_process_input>`). If any function "
"consumes the event, it can call :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>`, and the event will not spread "
"any more. This ensures that you can filter all events of interest, even "
"before the GUI. For gameplay input, :ref:`Node._unhandled_input() "
"<class_Node_private_method__unhandled_input>` is generally a better fit, "
"because it allows the GUI to intercept the events."
msgstr ""
"首先會呼叫標準的 :ref:`Node._input() <class_Node_method__input>` 函式，呼叫只"
"會發生在覆蓋了這個函式（並且沒有通過 :ref:`Node.set_process_input() "
"<class_Node_method_set_process_input>` 禁用）的節點上。如果某個函式消耗了該事"
"件，就可以呼叫 :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>`，事件就不會再繼續傳播。這樣就保"
"證了你可以在 GUI 之前篩選自己感興趣的事件。對於遊戲輸入，:ref:`Node."
"_unhandled_input() <class_Node_method__unhandled_input>` 通常更合適，因為這個"
"函式能夠讓 GUI 攔截事件。"

#, fuzzy
msgid ""
"Second, it will try to feed the input to the GUI, and see if any control can "
"receive it. If so, the :ref:`Control <class_Control>` will be called via the "
"virtual function :ref:`Control._gui_input() "
"<class_Control_private_method__gui_input>` and the signal \"gui_input\" will "
"be emitted (this function is re-implementable by script by inheriting from "
"it). If the control wants to \"consume\" the event, it will call :ref:"
"`Control.accept_event() <class_Control_method_accept_event>` and the event "
"will not spread any more. Use the :ref:`Control.mouse_filter "
"<class_Control_property_mouse_filter>` property to control whether a :ref:"
"`Control <class_Control>` is notified of mouse events via :ref:`Control."
"_gui_input() <class_Control_private_method__gui_input>` callback, and "
"whether these events are propagated further."
msgstr ""
"然後，它會嘗試將輸入提供給 GUI，並查看是否有任何控制項可以接收它。如果有，:"
"ref:`Control <class_Control>` 將通過虛函式 :ref:`Control._gui_input() "
"<class_Control_method__gui_input>` 被呼叫並行出“gui_input”訊號（此函式可通過"
"繼承它的腳本重新實作）。如果控制項想“消耗”該事件，它將呼叫 :ref:`Control."
"accept_event() <class_Control_method_accept_event>` 阻止事件的傳播。請使用 :"
"ref:`Control.mouse_filter <class_Control_property_mouse_filter>` 屬性來控制 :"
"ref:`Control <class_Control>` 是否通過 :ref:`Control._gui_input() "
"<class_Control_method__gui_input>` 回呼函式接收滑鼠事件的通知，以及是否進一步"
"傳播這些事件。"

#, fuzzy
msgid ""
"If so far no one consumed the event, the :ref:`Node._shortcut_input() "
"<class_Node_private_method__shortcut_input>` callback will be called if "
"overridden (and not disabled with :ref:`Node.set_process_shortcut_input() "
"<class_Node_method_set_process_shortcut_input>`). This happens only for :ref:"
"`InputEventKey <class_InputEventKey>`, :ref:`InputEventShortcut "
"<class_InputEventShortcut>` and :ref:`InputEventJoypadButton "
"<class_InputEventJoypadButton>`. If any function consumes the event, it can "
"call :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>`, and the event will not spread "
"any more. The shortcut input callback is ideal for treating events that are "
"intended as shortcuts."
msgstr ""
"如果事件到目前為止還沒有被消耗，並且覆蓋了 :ref:`Node._shortcut_input() "
"<class_Node_method__shortcut_input>` 函式（並且沒有通過 :ref:`Node."
"set_process_shortcut_input() <class_Node_method_set_process_shortcut_input>` "
"禁用），那麼就會呼叫這個回呼函式。只有 :ref:`InputEventKey "
"<class_InputEventKey>`、:ref:`InputEventShortcut <class_InputEventShortcut>` "
"和 :ref:`InputEventJoypadButton <class_InputEventJoypadButton>` 才有這一步。"
"如果某個函式消耗了該事件，就可以呼叫 :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>`，事件就不會再繼續傳播。快捷鍵輸"
"入回呼函式主要用於處理快捷鍵相關的事件。"

#, fuzzy
msgid ""
"If so far no one consumed the event, the :ref:`Node._unhandled_key_input() "
"<class_Node_private_method__unhandled_key_input>` callback will be called if "
"overridden (and not disabled with :ref:`Node."
"set_process_unhandled_key_input() "
"<class_Node_method_set_process_unhandled_key_input>`). This happens only if "
"the event is a :ref:`InputEventKey <class_InputEventKey>`. If any function "
"consumes the event, it can call :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>`, and the event will not spread "
"any more. The unhandled key input callback is ideal for key events."
msgstr ""
"如果事件到目前為止還沒有被消耗，並且覆蓋了 :ref:`Node._unhandled_key_input() "
"<class_Node_method__unhandled_key_input>` 函式（並且沒有通過 :ref:`Node."
"set_process_unhandled_key_input() "
"<class_Node_method_set_process_unhandled_key_input>` 禁用），那麼就會呼叫這個"
"回呼函式。只有 :ref:`InputEventKey <class_InputEventKey>` 才有這一步。如果某"
"個函式消耗了該事件，就可以呼叫 :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>`，事件就不會再繼續傳播。未處理按"
"鍵輸入回呼函式主要用於處理按鍵相關的事件。"

#, fuzzy
msgid ""
"If so far no one consumed the event, the :ref:`Node._unhandled_input() "
"<class_Node_private_method__unhandled_input>` callback will be called if "
"overridden (and not disabled with :ref:`Node.set_process_unhandled_input() "
"<class_Node_method_set_process_unhandled_input>`). If any function consumes "
"the event, it can call :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>`, and the event will not spread "
"any more. The unhandled input callback is ideal for full-screen gameplay "
"events, so they are not received when a GUI is active."
msgstr ""
"如果事件到目前為止還沒有被消耗，並且覆蓋了 :ref:`Node._unhandled_input() "
"<class_Node_method__unhandled_input>` 函式（並且沒有通過 :ref:`Node."
"set_process_unhandled_input() "
"<class_Node_method_set_process_unhandled_input>` 禁用），那麼就會呼叫這個回呼"
"函式。如果某個函式消耗了該事件，就可以呼叫 :ref:`Viewport."
"set_input_as_handled() <class_Viewport_method_set_input_as_handled>`，事件就"
"不會再繼續傳播。未處理輸入回呼函式主要用於處理全屏遊戲事件，GUI 處於活動狀態"
"時不會收到。"

#, fuzzy
msgid ""
"If no one wanted the event so far, and :ref:`Object Picking "
"<class_viewport_property_physics_object_picking>` is turned on, the event is "
"used for object picking. For the root viewport, this can also be enabled in :"
"ref:`Project Settings <class_ProjectSettings_property_physics/common/"
"enable_object_picking>`. In the case of a 3D scene if a :ref:`Camera3D "
"<class_Camera3D>` is assigned to the Viewport, a ray to the physics world "
"(in the ray direction from the click) will be cast. If this ray hits an "
"object, it will call the :ref:`CollisionObject3D._input_event() "
"<class_CollisionObject3D_private_method__input_event>` function in the "
"relevant physics object. In the case of a 2D scene, conceptually the same "
"happens with :ref:`CollisionObject2D._input_event() "
"<class_CollisionObject2D_private_method__input_event>`."
msgstr ""
"如果到目前為止沒有人想要這個事件，並且 Viewport 中分配的 :ref:`Camera "
"<class_Camera>` 啟用了:ref:`物件拾取 "
"<class_viewport_property_physics_object_picking>`，就會（從點擊的射線方向）往"
"物理世界中投射一條射線。（如果是根視圖，則是在:ref:`專案設定 "
"<class_ProjectSettings_property_physics/common/enable_object_picking>`中啟"
"用。）如果這條射線命中了某個物件，就會呼叫相關物理物件的 :ref:"
"`CollisionObject._input_event() <class_CollisionObject_method__input_event>` "
"函式（物理實體預設接受這個回呼函式，區域則不會。可以使用 :ref:`Area "
"<class_Area>` 的屬性進行設定）。"

msgid ""
"When sending events to its child and descendant nodes, the viewport will do "
"so, as depicted in the following graphic, in a reverse depth-first order, "
"starting with the node at the bottom of the scene tree, and ending at the "
"root node. Excluded from this process are Windows and SubViewports."
msgstr ""
"將事件發送到場景中的所有偵聽節點時, 視口將以反向深度優先循序執行: 從場景樹底"
"部的節點開始, 到根節點結束。"

#, fuzzy
msgid ""
"This order doesn't apply to :ref:`Control._gui_input() "
"<class_Control_private_method__gui_input>`, which uses a different method "
"based on event location or focused Control."
msgstr ""
"這個函式 :ref:`Control._gui_input() <class_Control_method__gui_input>` . 只需"
"在你的控制項中重寫它. 不需要設定處理."

msgid ""
"Since Viewports don't send events to other :ref:`SubViewports "
"<class_SubViewport>`, one of the following methods has to be used:"
msgstr ""
"由於視窗不會將事件傳送到其他 SubViewports <class_SubViewport>`，因此必須使用"
"下列方法之一："

#, fuzzy
msgid ""
"Use a :ref:`SubViewportContainer <class_SubViewportContainer>`, which "
"automatically sends events to its child :ref:`SubViewports "
"<class_SubViewport>` after :ref:`Node._input() "
"<class_Node_private_method__input>` or :ref:`Control._gui_input() "
"<class_Control_private_method__gui_input>`."
msgstr ""
"使用 SubViewportContainer <class_SubViewportContainer>`，它會在 Node."
"_input() <class_Node_method__input>` 或 Control._gui_input 之後自動將事件傳送"
"至其子 SubViewports <class_SubViewport>` () <class_Control_method__gui_"

msgid "Implement event propagation based on the individual requirements."
msgstr "根據個人需求實作事件傳播。"

msgid ""
"GUI events also travel up the scene tree but, since these events target "
"specific Controls, only direct ancestors of the targeted Control node "
"receive the event."
msgstr ""
"GUI事件也在場景樹上傳播，但由於這些事件針對的是特定的控制項，所以只有目標控制"
"項節點的第一個父節點才會收到該事件。"

msgid ""
"In accordance with Godot's node-based design, this enables specialized child "
"nodes to handle and consume particular events, while their ancestors, and "
"ultimately the scene root, can provide more generalized behavior if needed."
msgstr ""
"根據Godot基於節點的設計, 這使得專門的子節點能夠處理和消費特定的事件, 而它們的"
"父級節點, 以及最終的場景根節點, 可以在需要時提供更通用的行為."

msgid "Anatomy of an InputEvent"
msgstr "InputEvent 剖析"

msgid ""
":ref:`InputEvent <class_InputEvent>` is just a base built-in type, it does "
"not represent anything and only contains some basic information, such as "
"event ID (which is increased for each event), device index, etc."
msgstr ""
":ref:`InputEvent <class_InputEvent>` 只是一個基本的內建型別, 它不代表任何東"
"西, 只包含一些基本資訊, 如事件ID(每個事件增加), 裝置索引等."

msgid ""
"There are several specialized types of InputEvent, described in the table "
"below:"
msgstr "InputEvent有幾種專門的型別, 如下表所述:"

msgid "Event"
msgstr "事件"

msgid "Description"
msgstr "說明"

msgid ":ref:`InputEvent <class_InputEvent>`"
msgstr ":ref:`InputEvent <class_InputEvent>`"

msgid "Empty Input Event."
msgstr "空輸入事件."

msgid ":ref:`InputEventKey <class_InputEventKey>`"
msgstr ":ref:`InputEventKey <class_InputEventKey>`"

msgid "Contains a keycode and Unicode value, as well as modifiers."
msgstr "包含一個鍵盤掃描碼和Unicode值, 以及修飾鍵."

msgid ":ref:`InputEventMouseButton <class_InputEventMouseButton>`"
msgstr ":ref:`InputEventMouseButton <class_InputEventMouseButton>`"

msgid "Contains click information, such as button, modifiers, etc."
msgstr "包含點擊資訊, 例如按鈕, 修飾鍵等."

msgid ":ref:`InputEventMouseMotion <class_InputEventMouseMotion>`"
msgstr ":ref:`InputEventMouseMotion <class_InputEventMouseMotion>`"

msgid ""
"Contains motion information, such as relative and absolute positions and "
"speed."
msgstr "包含運動資訊, 例如相對位置, 絕對位置和速度."

msgid ":ref:`InputEventJoypadMotion <class_InputEventJoypadMotion>`"
msgstr ":ref:`InputEventJoypadMotion <class_InputEventJoypadMotion>`"

msgid "Contains Joystick/Joypad analog axis information."
msgstr "包含操縱桿/ Joypad類比軸資訊."

msgid ":ref:`InputEventJoypadButton <class_InputEventJoypadButton>`"
msgstr ":ref:`InputEventJoypadButton <class_InputEventJoypadButton>`"

msgid "Contains Joystick/Joypad button information."
msgstr "包含操縱桿/ Joypad按鈕資訊."

msgid ":ref:`InputEventScreenTouch <class_InputEventScreenTouch>`"
msgstr ":ref:`InputEventScreenTouch <class_InputEventScreenTouch>`"

msgid ""
"Contains multi-touch press/release information. (only available on mobile "
"devices)"
msgstr "包含多點觸控按下/釋放資訊. (僅適用於移動裝置)"

msgid ":ref:`InputEventScreenDrag <class_InputEventScreenDrag>`"
msgstr ":ref:`InputEventScreenDrag <class_InputEventScreenDrag>`"

msgid ""
"Contains multi-touch drag information. (only available on mobile devices)"
msgstr "包含多點觸控拖動資訊. (僅適用於移動裝置)"

msgid ":ref:`InputEventMagnifyGesture <class_InputEventMagnifyGesture>`"
msgstr ":ref:`InputEvent <class_InputEvent>`"

msgid "Contains a position, a factor as well as modifiers."
msgstr "包含一個鍵盤掃描碼和Unicode值, 以及修飾鍵."

msgid ":ref:`InputEventPanGesture <class_InputEventPanGesture>`"
msgstr ":ref:`InputEvent <class_InputEvent>`"

msgid "Contains a position, a delta as well as modifiers."
msgstr "包含一個鍵盤掃描碼和Unicode值, 以及修飾鍵."

msgid ":ref:`InputEventMIDI <class_InputEventMIDI>`"
msgstr ":ref:`int <class_int>`"

msgid "Contains MIDI-related information."
msgstr "包含操縱桿/ Joypad按鈕資訊."

msgid ":ref:`InputEventShortcut <class_InputEventShortcut>`"
msgstr ":ref:`InputEvent <class_InputEvent>`"

msgid "Contains a shortcut."
msgstr "容器佈局。"

msgid ":ref:`InputEventAction <class_InputEventAction>`"
msgstr ":ref:`InputEventAction <class_InputEventAction>`"

msgid ""
"Contains a generic action. These events are often generated by the "
"programmer as feedback. (more on this below)"
msgstr "包含一般動作. 這些事件通常由程式師作為回饋生成. (以下更多內容)"

msgid "Actions"
msgstr "動作"

msgid ""
"Actions are a grouping of zero or more InputEvents into a commonly "
"understood title (for example, the default \"ui_left\" action grouping both "
"joypad-left input and a keyboard's left arrow key). They are not required to "
"represent an InputEvent but are useful because they abstract various inputs "
"when programming the game logic."
msgstr ""
"動作是將零個或多個輸入事件群組為通常理解的標題（例如，預設的「ui_left」動作將"
"手柄左輸入和鍵盤左箭頭鍵群組）。它們不需要表示輸入事件，但很有用，因為它們在"
"編寫遊戲邏輯時抽象化了各種輸入。"

msgid "This allows for:"
msgstr "這樣的做法有許多優點："

msgid ""
"The same code to work on different devices with different inputs (e.g., "
"keyboard on PC, Joypad on console)."
msgstr ""
"相同的程式碼可以在具有不同輸入的不同裝置上工作(例如,PC上的鍵盤, 控制台上的"
"Joypad)."

msgid "Input to be reconfigured at run-time."
msgstr "輸入要在運作時重新配置."

msgid "Actions to be triggered programmatically at run-time."
msgstr "輸入要在運作時重新配置."

msgid ""
"Actions can be created from the Project Settings menu in the **Input Map** "
"tab and assigned input events."
msgstr "動作可以在“專案設定”功能表的“動作”分頁中建立。"

msgid ""
"Any event has the methods :ref:`InputEvent.is_action() "
"<class_InputEvent_method_is_action>`, :ref:`InputEvent.is_pressed() "
"<class_InputEvent_method_is_pressed>` and :ref:`InputEvent "
"<class_InputEvent>`."
msgstr ""
"任何事件都有方法 :ref:`InputEvent.is_action() "
"<class_InputEvent_method_is_action>`, :ref:`InputEvent.is_pressed() "
"<class_InputEvent_method_is_pressed>` and :ref:`InputEvent "
"<class_InputEvent>`."

msgid ""
"Alternatively, it may be desired to supply the game back with an action from "
"the game code (a good example of this is detecting gestures). The Input "
"singleton has a method for this: :ref:`Input.parse_input_event() "
"<class_input_method_parse_input_event>`. You would normally use it like this:"
msgstr ""
"或者, 可能希望從遊戲程式碼中向遊戲提供一個動作, 一個很好的例子是偵測手勢."
"Input單例有一個方法來實作這個功能 :ref:`Input.parse_input_event() "
"<class_input_method_parse_input_event>` . 通常這樣使用它:"

msgid "InputMap"
msgstr "InputMap"

msgid ""
"Customizing and re-mapping input from code is often desired. If your whole "
"workflow depends on actions, the :ref:`InputMap <class_InputMap>` singleton "
"is ideal for reassigning or creating different actions at run-time. This "
"singleton is not saved (must be modified manually) and its state is run from "
"the project settings (project.godot). So any dynamic system of this type "
"needs to store settings in the way the programmer best sees fit."
msgstr ""
"經常需要的從程式碼中定制和重新對應輸入. 如果你的整個運作流程依賴於動作, 那"
"麼 :ref:`InputMap <class_InputMap>` 單例是在運作時重新分配或建立不同動作的理"
"想選擇. 這個單例不被保存(必須手動修改), 其狀態從專案設定進行(project.godot). "
"所以任何這種型別的動態系統, 都需要以程式師認為最合適的方式來儲存設定."

msgid "Translation status"
msgstr "翻譯狀態"
