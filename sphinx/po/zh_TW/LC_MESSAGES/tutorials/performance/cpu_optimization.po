# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "CPU optimization"
msgstr "最佳化"

msgid "Measuring performance"
msgstr "效能"

msgid ""
"We have to know where the \"bottlenecks\" are to know how to speed up our "
"program. Bottlenecks are the slowest parts of the program that limit the "
"rate that everything can progress. Focusing on bottlenecks allows us to "
"concentrate our efforts on optimizing the areas which will give us the "
"greatest speed improvement, instead of spending a lot of time optimizing "
"functions that will lead to small performance improvements."
msgstr ""
"我們必須知道“瓶頸”在哪裡，才能知道如何加快我們的程式。瓶頸是指程式中最慢的部"
"分，限制了所有事情的進展速度。專注於瓶頸，可以讓我們集中精力優化能給我們帶來"
"最大速度提升的地方，而不是花大量時間去優化那些能帶來微小性能提升的功能。"

msgid ""
"For the CPU, the easiest way to identify bottlenecks is to use a profiler."
msgstr "對於 CPU 來說，找出瓶頸的最簡單方法就是使用性能剖析器。"

msgid "CPU profilers"
msgstr "分析工具"

msgid ""
"Profilers run alongside your program and take timing measurements to work "
"out what proportion of time is spent in each function."
msgstr ""
"剖析器與您的程式一起運作, 並進行時間測量, 以計算出每個功能所花費的時間比例."

msgid ""
"The Godot IDE conveniently has a built-in profiler. It does not run every "
"time you start your project: it must be manually started and stopped. This "
"is because, like most profilers, recording these timing measurements can "
"slow down your project significantly."
msgstr ""
"Godot整合式開發環境有一個方便的內建剖析器. 它不會在每次啟動專案時運作: 必須手"
"動啟動和停止. 這是因為, 與大多數剖析器一樣, 記錄這些時序測量會大大減慢你的專"
"案速度."

msgid "After profiling, you can look back at the results for a frame."
msgstr "剖析後, 你可以回看一影格的結果."

msgid "Screenshot of the Godot profiler"
msgstr "使用現有的 Godot 材質"

msgid "Results of a profile of one of the demo projects."
msgstr "其中一個演示專案的簡介結果."

msgid ""
"We can see the cost of built-in processes such as physics and audio, as well "
"as seeing the cost of our own scripting functions at the bottom."
msgstr ""
"我們可以看到物理, 音訊等內建流程的消耗, 也可以在底部看到自己腳本功能的消耗."

msgid ""
"Time spent waiting for various built-in servers may not be counted in the "
"profilers. This is a known bug."
msgstr "等待各種內建伺服器的時間可能不會被計算在剖析器中. 這是一個已知的錯誤."

msgid ""
"When a project is running slowly, you will often see an obvious function or "
"process taking a lot more time than others. This is your primary bottleneck, "
"and you can usually increase speed by optimizing this area."
msgstr ""
"當一個專案運作緩慢時, 你經常會看到一個明顯的功能或流程比其他功能或流程花費更"
"多的時間. 這是你的主要瓶頸, 你通常可以通過優化這個領域來提高速度."

msgid ""
"For more info about using Godot's built-in profiler, see :ref:"
"`doc_debugger_panel`."
msgstr "更多有關光照烘焙的資訊，請參考 :ref:`doc_baked_lightmaps` 。"

msgid "External profilers"
msgstr "External Files - 外部檔案"

msgid ""
"Although the Godot IDE profiler is very convenient and useful, sometimes you "
"need more power, and the ability to profile the Godot engine source code "
"itself."
msgstr ""
"雖然Godot IDE剖析器非常方便有用, 但有時你需要更強大的功能, 以及對Godot引擎原"
"始程式碼本身進行剖析的能力."

msgid ""
"You can :ref:`use a number of third-party C++ profilers "
"<doc_using_cpp_profilers>` to do this."
msgstr ""
"你可以 :ref:`使用若干個協力廠商 C++ 分析器 <doc_using_cpp_profilers>` 來實"
"作。"

msgid "Screenshot of Callgrind"
msgstr "Callgrind 的截圖"

msgid "Example results from Callgrind, which is part of Valgrind."
msgstr "例子結果來自Callgrind, 這是Valgrind的一部分."

msgid ""
"From the left, Callgrind is listing the percentage of time within a function "
"and its children (Inclusive), the percentage of time spent within the "
"function itself, excluding child functions (Self), the number of times the "
"function is called, the function name, and the file or module."
msgstr ""
"從左邊開始,Callgrind正在列出函式及其子函式內的時間百分比(Inclusive), 函式本身"
"(不包括子函式)內的時間百分比(Self), 函式被呼叫的次數, 函式名稱以及檔或模組."

msgid ""
"In this example, we can see nearly all time is spent under the ``Main::"
"iteration()`` function. This is the master function in the Godot source code "
"that is called repeatedly. It causes frames to be drawn, physics ticks to be "
"simulated, and nodes and scripts to be updated. A large proportion of the "
"time is spent in the functions to render a canvas (66%), because this "
"example uses a 2D benchmark. Below this, we see that almost 50% of the time "
"is spent outside Godot code in ``libglapi`` and ``i965_dri`` (the graphics "
"driver). This tells us the a large proportion of CPU time is being spent in "
"the graphics driver."
msgstr ""
"在這個例子中，我們可以看到幾乎所有的時間都花在 `Main::iter()` 函式下。這是 "
"Godot 原始程式碼中被反復呼叫的主函式。它導致影格被繪製、物理週期被類比、節點"
"和腳本被更新。很大一部分時間是花在算繪畫布的函式中（66%），因為這個例子使用的"
"是 2D 基準。下面，我們看到幾乎 50% 的時間都花在了 Godot 程式碼之外的 "
"``libglapi`` 和 ``i965_dri``（圖形驅動）中。這告訴我們，很大一部分 CPU 時間都"
"花在了圖形驅動上。"

msgid ""
"This is actually an excellent example because, in an ideal world, only a "
"very small proportion of time would be spent in the graphics driver. This is "
"an indication that there is a problem with too much communication and work "
"being done in the graphics API. This specific profiling led to the "
"development of 2D batching, which greatly speeds up 2D rendering by reducing "
"bottlenecks in this area."
msgstr ""
"這其實是一個很好的例子, 因為在理想的世界裡, 只有很小一部分時間會花在圖形驅動"
"上. 這說明存在一個問題, 就是在圖形API中進行了太多的交流和工作. 這種特殊的剖析"
"導致了2D批次處理的發展, 通過減少這方面的瓶頸, 大大加快了2D算繪的速度."

msgid "Manually timing functions"
msgstr "數學函式"

msgid ""
"Another handy technique, especially once you have identified the bottleneck "
"using a profiler, is to manually time the function or area under test. The "
"specifics vary depending on the language, but in GDScript, you would do the "
"following:"
msgstr ""
"另一個方便的技術, 特別是當你使用分析器確定了瓶頸後, 就是手動為功能或被測區域"
"計時. 具體細節因語言而異, 但在GDScript中, 你可以做如下操作:"

msgid ""
"When manually timing functions, it is usually a good idea to run the "
"function many times (1,000 or more times), instead of just once (unless it "
"is a very slow function). The reason for doing this is that timers often "
"have limited accuracy. Moreover, CPUs will schedule processes in a haphazard "
"manner. Therefore, an average over a series of runs is more accurate than a "
"single measurement."
msgstr ""
"當手動為函式計時時, 通常最好是多次(1000次或更多次)運作該函式, 而不是只運作一"
"次(除非是非常慢的函式). 這樣做的原因是, 計時器的精度往往有限. 此外,CPU會以一"
"種無序的方式調度程序. 因此, 一系列運作的平均值比單次測量更準確."

msgid ""
"As you attempt to optimize functions, be sure to either repeatedly profile "
"or time them as you go. This will give you crucial feedback as to whether "
"the optimization is working (or not)."
msgstr ""
"當你嘗試優化功能時, 一定要反復對它們進行剖析或計時. 這將為您提供關鍵的回饋, "
"說明優化是否有效(或無效)."

msgid "Caches"
msgstr "快取"

msgid ""
"CPU caches are something else to be particularly aware of, especially when "
"comparing timing results of two different versions of a function. The "
"results can be highly dependent on whether the data is in the CPU cache or "
"not. CPUs don't load data directly from the system RAM, even though it's "
"huge in comparison to the CPU cache (several gigabytes instead of a few "
"megabytes). This is because system RAM is very slow to access. Instead, CPUs "
"load data from a smaller, faster bank of memory called cache. Loading data "
"from cache is very fast, but every time you try and load a memory address "
"that is not stored in cache, the cache must make a trip to main memory and "
"slowly load in some data. This delay can result in the CPU sitting around "
"idle for a long time, and is referred to as a \"cache miss\"."
msgstr ""
"CPU快取是另外一個需要特別注意的東西, 特別是在比較一個函式的兩個不同版本的時序"
"結果時. 其結果可能高度依賴於資料是否在CPU快取中.CPU不會直接從系統RAM中載入資"
"料, 儘管它與CPU快取相比非常巨大(幾千百萬位元組而不是幾百萬位元組). 這是因為系"
"統RAM的存取速度非常慢. 相反,CPU從一個較小, 較快的記憶體庫中載入資料, 稱為"
"cache. 從快取中載入資料的速度非常快, 但每次你試圖載入一個沒有儲存在快取中的記"
"憶體位址時, 快取必須前往主記憶體並緩慢地載入一些資料. 這種延遲會導致CPU長時間"
"閒置, 被稱為 \"cache miss\"."

msgid ""
"This means that the first time you run a function, it may run slowly because "
"the data is not in the CPU cache. The second and later times, it may run "
"much faster because the data is in the cache. Due to this, always use "
"averages when timing, and be aware of the effects of cache."
msgstr ""
"這意味著, 第一次運作一個函式時, 由於資料不在CPU快取中, 它可能運作得很慢. 第二"
"次和以後的時間, 可能運作得更快, 因為資料在快取中. 由於這個原因, 在計時時一定"
"要使用平均數, 並且要注意快取的影響."

msgid ""
"Understanding caching is also crucial to CPU optimization. If you have an "
"algorithm (routine) that loads small bits of data from randomly spread out "
"areas of main memory, this can result in a lot of cache misses, a lot of the "
"time, the CPU will be waiting around for data instead of doing any work. "
"Instead, if you can make your data accesses localised, or even better, "
"access memory in a linear fashion (like a continuous list), then the cache "
"will work optimally and the CPU will be able to work as fast as possible."
msgstr ""
"瞭解快取對於CPU優化也是至關重要的. 如果你有一個演算法(常式), 從主記憶體隨機分"
"佈的區域載入小資料位元, 這可能會導致大量的快取失誤, 很多時候,CPU會在附近等待"
"資料, 而不是做別的工作. 相反, 如果你能使你的資料存取當地語系化, 或者更好的是"
"以線性方式存取記憶體(像一個連續的列表), 那麼快取將以最佳方式工作,CPU將能夠盡"
"可能快地工作."

msgid ""
"Godot usually takes care of such low-level details for you. For example, the "
"Server APIs make sure data is optimized for caching already for things like "
"rendering and physics. Still, you should be especially aware of caching when "
"writing GDExtensions."
msgstr ""
"Godot通常會為你處理這些低級的細節. 例如, 伺服器API確保資料已經為算繪和物理學"
"等方面的快取進行了優化. 不過, 在使用 :ref:`GDNative <toc-tutorials-"
"gdnative>` 時, 你還是要特別注意快取問題."

msgid "Languages"
msgstr "語言"

msgid ""
"Godot supports a number of different languages, and it is worth bearing in "
"mind that there are trade-offs involved. Some languages are designed for "
"ease of use at the cost of speed, and others are faster but more difficult "
"to work with."
msgstr ""
"Godot支援多種不同的語言, 值得注意的是, 其中有一些折衷. 有些語言是以速度為代價"
"而設計的, 便於使用, 而另一些語言速度更快, 但更難使用."

msgid ""
"Built-in engine functions run at the same speed regardless of the scripting "
"language you choose. If your project is making a lot of calculations in its "
"own code, consider moving those calculations to a faster language."
msgstr ""
"無論你選擇哪種指令碼語言, 內建的引擎函式都以同樣的速度運作. 如果你的專案在自"
"己的程式碼中進行了大量的計算, 可以考慮將這些計算轉移到更快的語言中."

msgid "GDScript"
msgstr "GDScript"

msgid ""
":ref:`GDScript <toc-learn-scripting-gdscript>` is designed to be easy to use "
"and iterate, and is ideal for making many types of games. However, in this "
"language, ease of use is considered more important than performance. If you "
"need to make heavy calculations, consider moving some of your project to one "
"of the other languages."
msgstr ""
":ref:`GDScript <toc-learn-scripting-gdscript>` 被設計成易於使用和反覆運算的語"
"言, 是製作多種型別遊戲的理想選擇. 然而, 在這種語言中, 易用性被認為比性能更重"
"要. 如果您需要進行繁重的計算, 請考慮將您的一些專案轉移到其他語言中."

msgid "C#"
msgstr "C#"

msgid ""
":ref:`C# <toc-learn-scripting-C#>` is popular and has first-class support in "
"Godot. It offers a good compromise between speed and ease of use. Beware of "
"possible garbage collection pauses and leaks that can occur during gameplay, "
"though. A common approach to workaround issues with garbage collection is to "
"use *object pooling*, which is outside the scope of this guide."
msgstr ""
":ref:`C # <toc-learn-scripting-C#>` 很受歡迎, 在Godot中得到了一流的支援. 它在"
"速度和易用性之間提供了一個很好的折中. 不過要注意遊戲過程中可能出現的垃圾收集"
"暫停和洩漏. 解決垃圾收集問題的一個常見方法是使用 *物件集區*, 這不在本指南的範"
"圍內."

msgid "Other languages"
msgstr "設計語言"

msgid ""
"Third parties provide support for several other languages, including `Rust "
"<https://github.com/godot-rust/gdext>`_."
msgstr ""
"協力廠商提供對其他幾種語言的支援，包括 `Rust <https://github.com/godot-rust/"
"godot-rust>`_ 和 `Javascript <https://github.com/GodotExplorer/"
"ECMAScript>`_。"

msgid "C++"
msgstr "C++"

msgid ""
"Godot is written in C++. Using C++ will usually result in the fastest code. "
"However, on a practical level, it is the most difficult to deploy to end "
"users' machines on different platforms. Options for using C++ include "
"GDExtensions and :ref:`custom modules <doc_custom_modules_in_cpp>`."
msgstr ""
"Godot是用C++編寫的. 使用C++通常會帶來最快的程式碼. 然而, 在實際操作層面上, 它"
"是最難在不同平臺上部署到終端使用者的機器上的. 使用C++的選項包括 :ref:"
"`GDNative <toc-tutorials-gdnative>` 和 :ref:`custom modules "
"<doc_custom_modules_in_c++>` ."

msgid "Threads"
msgstr "執行緒"

msgid ""
"Consider using threads when making a lot of calculations that can run in "
"parallel to each other. Modern CPUs have multiple cores, each one capable of "
"doing a limited amount of work. By spreading work over multiple threads, you "
"can move further towards peak CPU efficiency."
msgstr ""
"在進行大量的計算時, 考慮使用執行緒, 這些計算可以相互並行運作. 現代CPU有多個核"
"心, 每個核心能做的工作量有限. 通過將工作分散在多個執行緒上, 你可以進一步向CPU"
"的峰值效率邁進."

msgid ""
"The disadvantage of threads is that you have to be incredibly careful. As "
"each CPU core operates independently, they can end up trying to access the "
"same memory at the same time. One thread can be reading to a variable while "
"another is writing: this is called a *race condition*. Before you use "
"threads, make sure you understand the dangers and how to try and prevent "
"these race conditions. Threads can make debugging considerably more "
"difficult."
msgstr ""
"執行緒的缺點是，你必須非常小心。由於每個 CPU 核心都是獨立運作的，它們最終可能"
"會在同一時間試圖存取相同的記憶體。一個執行緒可以在另一個執行緒在寫的時候讀取"
"一個變數：這被稱為*競態條件*。在你使用執行緒之前，請確保你瞭解這些危險以及如"
"何嘗試和防止這些競態條件。"

msgid "For more information on threads, see :ref:`doc_using_multiple_threads`."
msgstr "更多有關光照烘焙的資訊，請參考 :ref:`doc_baked_lightmaps` 。"

msgid "SceneTree"
msgstr "SceneTree"

msgid ""
"Although Nodes are an incredibly powerful and versatile concept, be aware "
"that every node has a cost. Built-in functions such as ``_process()`` and "
"``_physics_process()`` propagate through the tree. This housekeeping can "
"reduce performance when you have a very large numbers of nodes (how many "
"exactly depends on the target platform and can range from thousands to tens "
"of thousands so ensure that you profile performance on all target platforms "
"during development)."
msgstr ""
"雖然節點是一個非常強大和通用的概念, 但請注意, 每個節點都是有代價的. 內建的函"
"式, 如 `_process()` 和 `_physics_process()` 會在樹中傳播. 當你有非常多的節點"
"(通常是成千上萬的節點)時, 這種內務管理會降低性能."

msgid ""
"Each node is handled individually in the Godot renderer. Therefore, a "
"smaller number of nodes with more in each can lead to better performance."
msgstr ""
"在Godot算繪器中, 每個節點都是單獨處理的. 因此, 較少的節點數量與較多的每個節點"
"可以帶來更好的性能."

msgid ""
"One quirk of the :ref:`SceneTree <class_SceneTree>` is that you can "
"sometimes get much better performance by removing nodes from the SceneTree, "
"rather than by pausing or hiding them. You don't have to delete a detached "
"node. You can for example, keep a reference to a node, detach it from the "
"scene tree using :ref:`Node.remove_child(node) "
"<class_Node_method_remove_child>`, then reattach it later using :ref:`Node."
"add_child(node) <class_Node_method_add_child>`. This can be very useful for "
"adding and removing areas from a game, for example."
msgstr ""
":ref:`SceneTree <class_SceneTree>` 的一個怪癖是, 你有時可以通過從SceneTree中"
"刪除節點, 而不是通過暫停或隱藏節點來獲得更好的性能. 您不一定要刪除一個分離的"
"節點. 例如, 您可以保留一個節點的引用, 使用 :ref:`Node.remove_child(node) "
"<class_Node_method_remove_child>` 將其從場景樹中分離出來, 然後使用 :ref:"
"`Node.add_child(node) <class_Node_method_add_child>` 將其重新連接. 例如, 這對"
"於在遊戲中新增和刪除區域是非常有用的."

msgid ""
"You can avoid the SceneTree altogether by using Server APIs. For more "
"information, see :ref:`doc_using_servers`."
msgstr ""
"你可以通過使用伺服器API來完全避免使用SceneTree. 更多資訊, 請參見 :ref:"
"`doc_using_servers` ."

msgid "Physics"
msgstr "物理"

msgid ""
"In some situations, physics can end up becoming a bottleneck. This is "
"particularly the case with complex worlds and large numbers of physics "
"objects."
msgstr ""
"在某些情況下, 物理學最終會成為一個瓶頸. 尤其是在複雜的世界和大量物理物件的情"
"況下, 更是如此."

msgid "Here are some techniques to speed up physics:"
msgstr "有幾點需要注意："

msgid ""
"Try using simplified versions of your rendered geometry for collision "
"shapes. Often, this won't be noticeable for end users, but can greatly "
"increase performance."
msgstr ""
"嘗試使用簡化版本的算繪幾何圖形來處理碰撞形狀. 通常情況下, 這對終端使用者來說"
"並不明顯, 但可以大大提高性能."

msgid ""
"Try removing objects from physics when they are out of view / outside the "
"current area, or reusing physics objects (maybe you allow 8 monsters per "
"area, for example, and reuse these)."
msgstr ""
"試著從物理學中移除物體, 當它們不在視野中/在目前區域之外時, 或者重新使用物理學"
"物件(例如, 也許你允許每個區域有8個怪物, 並重新使用這些怪物)."

msgid ""
"Another crucial aspect to physics is the physics tick rate. In some games, "
"you can greatly reduce the tick rate, and instead of for example, updating "
"physics 60 times per second, you may update them only 30 or even 20 times "
"per second. This can greatly reduce the CPU load."
msgstr ""
"物理的另一個關鍵方面是物理週期率。在一些遊戲中，你可以大大降低週期率，比如"
"說，你可以不用每秒更新物理 60 次，而只需每秒更新 30 次甚至 20 次。這樣可以大"
"大降低 CPU 的負載。"

msgid ""
"The downside of changing physics tick rate is you can get jerky movement or "
"jitter when the physics update rate does not match the frames per second "
"rendered. Also, decreasing the physics tick rate will increase input lag. "
"It's recommended to stick to the default physics tick rate (60 Hz) in most "
"games that feature real-time player movement."
msgstr ""
"改變物理週期率的缺點是，當物理學更新速率與每秒算繪的影格數不配對時，你可能會"
"出現運動抖動或抖動。另外，降低物理週期率會增加輸入延遲。建議在大多數以玩家即"
"時移動為特色的遊戲中，堅持使用預設的物理週期率（60 Hz）。"

msgid ""
"The solution to jitter is to use *fixed timestep interpolation*, which "
"involves smoothing the rendered positions and rotations over multiple frames "
"to match the physics. You can either implement this yourself or use a `third-"
"party addon <https://github.com/lawnjelly/smoothing-addon>`__. Performance-"
"wise, interpolation is a very cheap operation compared to running a physics "
"tick. It's orders of magnitude faster, so this can be a significant "
"performance win while also reducing jitter."
msgstr ""
"解決抖動的方法是使用*固定時間步長插值*，這涉及到平滑多個影格的算繪位置和旋"
"轉，以配對物理。你可以自己實作，或者使用`協力廠商外掛程式 <https://github."
"com/lawnjelly/smoothing-addon>`__ 。從性能上來說，與運作物理週期相比，插值是"
"一個非常廉價的操作。它的速度快了好幾個數量級，所以這在減少抖動的同時也帶來了"
"部分顯著的性能提升。"

msgid "Translation status"
msgstr "翻譯狀態"
