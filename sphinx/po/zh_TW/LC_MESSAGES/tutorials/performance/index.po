# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Performance"
msgstr "效能"

msgid "Introduction"
msgstr "前言"

msgid ""
"Godot follows a balanced performance philosophy. In the performance world, "
"there are always tradeoffs, which consist of trading speed for usability and "
"flexibility. Some practical examples of this are:"
msgstr ""
"Godot遵循平衡的表現理念. 在效率表現中, 總是有需要權衡交易的東西, 可用性和靈活"
"性. 一些實際的範例是:"

msgid ""
"Rendering large amounts of objects efficiently is easy, but when a large "
"scene must be rendered, it can become inefficient. To solve this, visibility "
"computation must be added to the rendering. This makes rendering less "
"efficient, but at the same time, fewer objects are rendered. Therefore, the "
"overall rendering efficiency is improved."
msgstr ""
"有效地算繪大量的物體是很容易的, 但是當必須算繪一個大的場景時, 效率就會變得很"
"低. 為了解決這個問題, 必須在算繪時加入可見性計算. 這使得算繪的效率降低, 但同"
"時, 被算繪的對象也減少了. 因此, 整體的算繪效率得到了提高."

msgid ""
"Configuring the properties of every material for every object that needs to "
"be rendered is also slow. To solve this, objects are sorted by material to "
"reduce the costs. At the same time, sorting has a cost."
msgstr ""
"為每個需要算繪的物件配置每個材質的屬性也很慢. 為了解決這個問題, 物體被按材質"
"分類以減少成本. 同時, 排序也是有成本的."

msgid ""
"In 3D physics, a similar situation happens. The best algorithms to handle "
"large amounts of physics objects (such as SAP) are slow at insertion/removal "
"of objects and raycasting. Algorithms that allow faster insertion and "
"removal, as well as raycasting, will not be able to handle as many active "
"objects."
msgstr ""
"在3D物理中, 也有類似的情況發生. 處理大量物理物件的最佳演算法(如SAP)在插入/移"
"除物件和射線傳輸方面都很慢. 允許更快的插入和移除以及射線傳輸的演算法, 將無法"
"處理那麼多的活動物件."

msgid ""
"And there are many more examples of this! Game engines strive to be general-"
"purpose in nature. Balanced algorithms are always favored over algorithms "
"that might be fast in some situations and slow in others, or algorithms that "
"are fast but are more difficult to use."
msgstr ""
"而這樣的例子還有很多!遊戲引擎在本質上努力成為通用的. 平衡的演算法總是受到青"
"睞, 而不是那些在某些情況下可能很快而在另一些情況下很慢的演算法, 或者那些快但"
"更難使用的演算法."

msgid ""
"Godot is not an exception to this. While it is designed to have backends "
"swappable for different algorithms, the default backends prioritize balance "
"and flexibility over performance."
msgstr ""
"Godot在這方面也不例外. 雖然它被設計成可以為不同的演算法交換後端, 但預設的後端"
"將平衡和靈活性置於性能之上."

msgid ""
"With this clear, the aim of this tutorial section is to explain how to get "
"the maximum performance out of Godot. While the tutorials can be read in any "
"order, it is a good idea to start from :ref:`doc_general_optimization`."
msgstr ""
"明確了這一點後, 本教學部分的目的是解釋如何從Godot中獲得最大的性能. 雖然這些教"
"學可以按任何順序閱讀, 但最好從 :ref:`doc_general_optimization` 開始."

msgid "Common"
msgstr "常見"

msgid "CPU"
msgstr "CPU"

msgid "GPU"
msgstr "GPU"

msgid "3D"
msgstr "3D"

msgid "Threads"
msgstr "執行緒"

msgid "Translation status"
msgstr "翻譯狀態"
