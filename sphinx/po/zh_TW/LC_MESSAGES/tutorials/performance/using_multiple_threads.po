# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using multiple threads"
msgstr "使用多執行緒"

msgid "Threads"
msgstr "執行緒"

msgid ""
"Threads allow simultaneous execution of code. It allows off-loading work "
"from the main thread."
msgstr "執行緒允許同時執行程式碼。它允許從主執行緒解除安裝工作。"

msgid "Godot supports threads and provides many handy functions to use them."
msgstr "Godot 支援執行緒，並提供了許多方便使用的功能。"

msgid ""
"If using other languages (C#, C++), it may be easier to use the threading "
"classes they support."
msgstr "如果使用其他語言（C#、C++），它們支援的執行緒類可能會更容易使用。"

msgid ""
"Before using a built-in class in a thread, read :ref:`doc_thread_safe_apis` "
"first to check whether it can be safely used in a thread."
msgstr ""
"在執行緒中使用內建類之前，請先閱讀 :ref:`doc_thread_safe_apis`，檢查在執行緒"
"中使用是否安全。"

msgid "Creating a Thread"
msgstr "建立內容"

msgid "To create a thread, use the following code:"
msgstr "有下列事項需注意："

msgid ""
"Your function will, then, run in a separate thread until it returns. Even if "
"the function has returned already, the thread must collect it, so call :ref:"
"`Thread.wait_to_finish()<class_Thread_method_wait_to_finish>`, which will "
"wait until the thread is done (if not done yet), then properly dispose of it."
msgstr ""
"然後, 你的函式將在一個單獨的執行緒中運作, 直到它返回. 即使函式已經返回, 執行"
"緒也必須收集它, 所以呼叫 :ref:`Thread."
"wait_to_finish()<class_Thread_method_wait_to_finish>` , 它將等待中的執行緒完"
"成(如果還沒有完成), 然後妥善處理它."

msgid ""
"Creating threads at run-time is slow on Windows and should be avoided to "
"prevent stuttering. Semaphores, explained later on this page, should be used "
"instead."
msgstr ""
"在 Windows 上，在執行時間建立執行緒速度很慢，應該避免，以防止卡頓出現。應改用"
"訊號量（本頁稍後將對此進行解釋）。"

msgid "Mutexes"
msgstr "Mutex"

msgid ""
"Accessing objects or data from multiple threads is not always supported (if "
"you do it, it will cause unexpected behaviors or crashes). Read the :ref:"
"`doc_thread_safe_apis` documentation to understand which engine APIs support "
"multiple thread access."
msgstr ""
"並不總是支援從多個執行緒存取物件或資料(如果你這樣做, 會導致意外行為或當機). "
"請閱讀 :ref:`doc_thread_safe_apis` 文件, 瞭解哪些引擎API支援多執行緒存取."

msgid ""
"When processing your own data or calling your own functions, as a rule, try "
"to avoid accessing the same data directly from different threads. You may "
"run into synchronization problems, as the data is not always updated between "
"CPU cores when modified. Always use a :ref:`Mutex<class_Mutex>` when "
"accessing a piece of data from different threads."
msgstr ""
"在處理自己的資料或呼叫自己的函式時, 通常情況下, 儘量避免從不同的執行緒直接存"
"取相同的資料. 你可能會遇到同步問題, 因為資料被修改後,CPU核之間並不總是更新. "
"當從不同執行緒存取一個資料時, 一定要使用 :ref:`Mutex<class_Mutex>` ."

msgid ""
"When calling :ref:`Mutex.lock()<class_Mutex_method_lock>`, a thread ensures "
"that all other threads will be blocked (put on suspended state) if they try "
"to *lock* the same mutex. When the mutex is unlocked by calling :ref:`Mutex."
"unlock()<class_Mutex_method_unlock>`, the other threads will be allowed to "
"proceed with the lock (but only one at a time)."
msgstr ""
"當呼叫 :ref:`Mutex.lock()<class_Mutex_method_lock>` 時, 一個執行緒確保所有其"
"他執行緒如果試圖 *鎖* 同一個mutex, 就會被阻塞(進入暫停狀態). 當通過呼叫 :ref:"
"`Mutex.unlock()<class_Mutex_method_unlock>` 來解鎖該mutex時, 其他執行緒將被允"
"許繼續鎖定(但每次只能鎖定一個)."

msgid "Here is an example of using a Mutex:"
msgstr "下面是一個使用 Mutex 的例子:"

msgid "Semaphores"
msgstr "Semaphore"

msgid ""
"Sometimes you want your thread to work *\"on demand\"*. In other words, tell "
"it when to work and let it suspend when it isn't doing anything. For this, :"
"ref:`Semaphores<class_Semaphore>` are used. The function :ref:`Semaphore."
"wait()<class_Semaphore_method_wait>` is used in the thread to suspend it "
"until some data arrives."
msgstr ""
"有時你希望你的執行緒能“按需”工作。換句話說，告訴它什麼時候工作，讓它在不工作"
"的時候暫停。為此，可以使用訊號量 :ref:`Semaphore <class_Semaphore>`。執行緒中"
"使用函式 :ref:`Semaphore.wait()<class_Semaphore_method_wait>` 來暫停它的工"
"作，直到有資料到達。"

msgid ""
"The main thread, instead, uses :ref:`Semaphore."
"post()<class_Semaphore_method_post>` to signal that data is ready to be "
"processed:"
msgstr ""
"而主執行緒則使用 :ref:`Semaphore.post()<class_Semaphore_method_post>` 來表示"
"資料已經準備好被處理:"

msgid "Translation status"
msgstr "翻譯狀態"
