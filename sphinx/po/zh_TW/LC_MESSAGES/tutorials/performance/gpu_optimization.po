# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "GPU optimization"
msgstr "最佳化"

msgid "Introduction"
msgstr "前言"

msgid ""
"The demand for new graphics features and progress almost guarantees that you "
"will encounter graphics bottlenecks. Some of these can be on the CPU side, "
"for instance in calculations inside the Godot engine to prepare objects for "
"rendering. Bottlenecks can also occur on the CPU in the graphics driver, "
"which sorts instructions to pass to the GPU, and in the transfer of these "
"instructions. And finally, bottlenecks also occur on the GPU itself."
msgstr ""
"對新的圖形功能和進步的需求幾乎可以保證你必會遇到圖形瓶頸. 有些瓶頸可能出現在"
"CPU端, 例如在Godot引擎內部的計算中, 為算繪準備對象. 瓶頸也可能發生在CPU上的圖"
"形驅動中, 它將指令分類傳遞給GPU, 以及這些指令的傳輸過程. 最後, 瓶頸也會發生在"
"GPU本身."

msgid ""
"Where bottlenecks occur in rendering is highly hardware-specific. Mobile "
"GPUs in particular may struggle with scenes that run easily on desktop."
msgstr ""
"算繪中的瓶頸發生在哪裡, 高度依賴於硬體. 特別是移動GPU可能會在桌面上輕鬆運作的"
"場景中掙扎."

msgid ""
"Understanding and investigating GPU bottlenecks is slightly different to the "
"situation on the CPU. This is because, often, you can only change "
"performance indirectly by changing the instructions you give to the GPU. "
"Also, it may be more difficult to take measurements. In many cases, the only "
"way of measuring performance is by examining changes in the time spent "
"rendering each frame."
msgstr ""
"瞭解和調查GPU瓶頸與CPU上的情況略有不同. 這是因為, 通常情況下, 你只能通過改變"
"你給GPU的指令來間接改變性能. 另外, 測量起來可能更困難. 在許多情況下, 衡量性能"
"的唯一方法是通過檢查每影格算繪時間的變化."

msgid "Draw calls, state changes, and APIs"
msgstr "繪製呼叫、狀態更變、API"

msgid ""
"The following section is not relevant to end-users, but is useful to provide "
"background information that is relevant in later sections."
msgstr "以下部分與最終使用者無關, 但對於提供與後面章節相關的背景資訊是有用的."

msgid ""
"Godot sends instructions to the GPU via a graphics API (Vulkan, OpenGL, "
"OpenGL ES or WebGL). The communication and driver activity involved can be "
"quite costly, especially in OpenGL, OpenGL ES and WebGL. If we can provide "
"these instructions in a way that is preferred by the driver and GPU, we can "
"greatly increase performance."
msgstr ""
"Godot通過圖形API(OpenGL, OpenGL ES或Vulkan)向GPU發送指令. 所涉及的通信和驅動"
"活動可能非常昂貴, 尤其是在OpenGL和OpenGL ES中. 如果我們能以驅動和GPU喜歡的方"
"式提供這些指令, 就能大大提高性能."

msgid ""
"Nearly every API command in OpenGL requires a certain amount of validation "
"to make sure the GPU is in the correct state. Even seemingly simple commands "
"can lead to a flurry of behind-the-scenes housekeeping. Therefore, the goal "
"is to reduce these instructions to a bare minimum and group together similar "
"objects as much as possible so they can be rendered together, or with the "
"minimum number of these expensive state changes."
msgstr ""
"OpenGL中幾乎每一個API命令都需要一定的驗證, 以確保GPU處於正確的狀態. 即使是看"
"似簡單的命令, 也會導致一連串的幕後工作. 因此, 我們的目標是將這些指令減少到最"
"低限度, 並盡可能地將相似的物件群組, 以便它們可以一起算繪, 或者以最少的數量進"
"行這些昂貴的狀態變化."

msgid "2D batching"
msgstr "2D 批次處理"

msgid ""
"In 2D, the costs of treating each item individually can be prohibitively "
"high - there can easily be thousands of them on the screen. This is why 2D "
"*batching* is used with OpenGL-based rendering methods. Multiple similar "
"items are grouped together and rendered in a batch, via a single draw call, "
"rather than making a separate draw call for each item. In addition, this "
"means state changes, material and texture changes can be kept to a minimum."
msgstr ""
"在2D中, 單獨處理每個專案的成本可能會非常高--螢幕上很容易有成千上萬的專案. 這"
"就是為什麼使用2D *批次處理* 的原因. 多個類似的專案被歸為一組, 並通過一個單一"
"的繪製呼叫進行批量算繪, 而不是對每個專案進行單獨的繪製呼叫. 此外, 這意味著狀"
"態變化, 材質和紋理變化可以保持在最低限度."

msgid ""
"Vulkan-based rendering methods do not use 2D batching yet. Since draw calls "
"are much cheaper with Vulkan compared to OpenGL, there is less of a need to "
"have 2D batching (although it can still be beneficial in some cases)."
msgstr ""
"基於 Vulkan 的算繪方法尚不使用 2D 批次。由於與 OpenGL 相比，Vulkan 的繪製呼叫"
"要便宜得多，因此不太需要 2D 批次（儘管在某些情況下它仍然是有益的）。"

msgid "3D batching"
msgstr "3D 批次處理"

msgid ""
"In 3D, we still aim to minimize draw calls and state changes. However, it "
"can be more difficult to batch together several objects into a single draw "
"call. 3D meshes tend to comprise hundreds or thousands of triangles, and "
"combining large meshes in real-time is prohibitively expensive. The costs of "
"joining them quickly exceeds any benefits as the number of triangles grows "
"per mesh. A much better alternative is to **join meshes ahead of time** "
"(static meshes in relation to each other). This can be done by artists, or "
"programmatically within Godot using an add-on."
msgstr ""
"在3D中, 我們的目標仍然是儘量減少繪製呼叫和狀態變化. 然而, 將多個物件批量合併"
"到一個繪圖呼叫中可能比較困難.3D網格往往由數百個或數千個三角形組成, 而即時組合"
"大型網格的成本非常高. 隨著每個網格的三角形數量的增加, 加入它們的成本很快就超"
"過了帶來的好處. 一個更好的選擇是 **提前加入網格** (靜態網格之間的關係). 這可"
"以由設計師完成, 或者在Godot中以程式設計方式完成."

msgid ""
"There is also a cost to batching together objects in 3D. Several objects "
"rendered as one cannot be individually culled. An entire city that is off-"
"screen will still be rendered if it is joined to a single blade of grass "
"that is on screen. Thus, you should always take objects' location and "
"culling into account when attempting to batch 3D objects together. Despite "
"this, the benefits of joining static objects often outweigh other "
"considerations, especially for large numbers of distant or low-poly objects."
msgstr ""
"在3D中把物體批次處理在一起也是有成本的. 幾個物件算繪成一個, 就不能單獨剔除. "
"如果將螢幕外的整座城市與螢幕上的一片草地連接在一起, 那麼它仍然會被算繪. 因"
"此, 當試圖將3D物件批量連接在一起時, 應該始終考慮到對象的位置和剔除. 儘管如"
"此, 加入靜態物件的好處往往大於其他考慮因素, 特別是對於大量的遠距離或低多邊形"
"物體."

msgid ""
"For more information on 3D specific optimizations, see :ref:"
"`doc_optimizing_3d_performance`."
msgstr "更多有關光照烘焙的資訊，請參考 :ref:`doc_baked_lightmaps` 。"

msgid "Reuse shaders and materials"
msgstr "重複使用著色器和材質"

msgid ""
"The Godot renderer is a little different to what is out there. It's designed "
"to minimize GPU state changes as much as possible. :ref:`StandardMaterial3D "
"<class_StandardMaterial3D>` does a good job at reusing materials that need "
"similar shaders. If custom shaders are used, make sure to reuse them as much "
"as possible. Godot's priorities are:"
msgstr ""
"Godot 算繪器和其它的算繪器不同，是以儘量減少 GPU 狀態更改為目標的。 :ref:"
"`SpatialMaterial <class_SpatialMaterial>` 可以在所需著色器相似時很好地複用材"
"質。如果是用自訂著色器，那麼請儘量進行複用。Godot 的優先順序是："

msgid ""
"**Reusing Materials:** The fewer different materials in the scene, the "
"faster the rendering will be. If a scene has a huge amount of objects (in "
"the hundreds or thousands), try reusing the materials. In the worst case, "
"use atlases to decrease the amount of texture changes."
msgstr ""
"**複用材質：**場景中不同的材質越少, 算繪的速度就越快. 如果一個場景有大量的物"
"體(數以百計或數以千計), 可以嘗試重複使用這些材質. 在最壞的情況下, 使用合集來"
"減少紋理變化的數量."

#, fuzzy
msgid ""
"**Reusing Shaders:** If materials can't be reused, at least try to reuse "
"shaders. Note: shaders are automatically reused between StandardMaterial3Ds "
"that share the same configuration (features that are enabled or disabled "
"with a check box) even if they have different parameters."
msgstr ""
"**複用著色器：**如果材質不能被重複使用，至少要嘗試重用著色器。注意：在共用相"
"同配置（可用核取方塊啟用或禁用該功能）的SpatialMaterials之間會自動重用著色"
"器，即使它們有不同的參數。"

msgid ""
"If a scene has, for example, 20,000 objects with 20,000 different materials "
"each, rendering will be slow. If the same scene has 20,000 objects, but only "
"uses 100 materials, rendering will be much faster."
msgstr ""
"例如, 如果一個場景有 ``20,000`` 個物體, 每個物體有 ``20,000`` 種不同的材質, "
"算繪會很慢. 如果同一個場景有 ``20,000`` 個物體, 但只使用 ``100`` 種材料, 算繪"
"就會快很多."

msgid "Pixel cost versus vertex cost"
msgstr "像素成本與頂點成本"

msgid ""
"You may have heard that the lower the number of polygons in a model, the "
"faster it will be rendered. This is *really* relative and depends on many "
"factors."
msgstr ""
"你可能聽說過, 一個模型中的多邊形數量越少, 它的算繪速度就越快. 這其實是 *相對"
"的* , 取決於許多因素."

msgid ""
"On a modern PC and console, vertex cost is low. GPUs originally only "
"rendered triangles. This meant that every frame:"
msgstr "在現代PC和控制台, 頂點成本很低.GPU最初只算繪三角形. 這意味著每一影格:"

msgid "All vertices had to be transformed by the CPU (including clipping)."
msgstr "所有頂點都必須由 CPU 進行轉換（包括剪裁）。"

msgid "All vertices had to be sent to the GPU memory from the main RAM."
msgstr "所有頂點都必須從主 RAM 發送到 GPU 記憶體。"

msgid ""
"Nowadays, all this is handled inside the GPU, greatly increasing "
"performance. 3D artists usually have the wrong feeling about polycount "
"performance because 3D modeling software (such as Blender, 3ds Max, etc.) "
"need to keep geometry in CPU memory for it to be edited, reducing actual "
"performance. Game engines rely on the GPU more, so they can render many "
"triangles much more efficiently."
msgstr ""
"現在, 所有這些都在GPU內部處理, 大大提高了性能. 三維藝術家通常對多維性能有錯誤"
"的感覺, 因為三維DCC(如Blender, Max等)需要將幾何圖形保存在CPU記憶體中進行編"
"輯, 從而降低了實際性能. 遊戲引擎更依賴GPU, 所以它們可以更有效地算繪許多三角"
"形."

msgid ""
"On mobile devices, the story is different. PC and console GPUs are brute-"
"force monsters that can pull as much electricity as they need from the power "
"grid. Mobile GPUs are limited to a tiny battery, so they need to be a lot "
"more power efficient."
msgstr ""
"在移動裝置上, 情況則不同. 個人電腦和控制台的GPU是粗暴的怪物, 可以從電網中獲取"
"所需的電力. 移動GPU被限制在一個很小的電池裡, 所以它們需要更高的功率效率."

msgid ""
"To be more efficient, mobile GPUs attempt to avoid *overdraw*. Overdraw "
"occurs when the same pixel on the screen is being rendered more than once. "
"Imagine a town with several buildings. GPUs don't know what is visible and "
"what is hidden until they draw it. For example, a house might be drawn and "
"then another house in front of it (which means rendering happened twice for "
"the same pixel). PC GPUs normally don't care much about this and just throw "
"more pixel processors to the hardware to increase performance (which also "
"increases power consumption)."
msgstr ""
"為了提高工作效率, 移動GPU試圖避免 *overdraw* . 當螢幕上的同一個像素被算繪了不"
"止一次時, 就會出現Overdraw. 想像一下, 一個有幾座建築的小鎮. 在繪製之前,GPU不"
"知道哪些是可見的, 哪些是隱藏的. 例如, 一棟房子可能被畫出來, 然後在它前面又畫"
"了一棟房子(這意味著同一像素的算繪發生了兩次).PC GPU通常不怎麼關心這個問題, 只"
"是把更多的像素處理扔給硬體以提高性能(這也會增加功耗)."

msgid ""
"Using more power is not an option on mobile so mobile devices use a "
"technique called *tile-based rendering* which divides the screen into a "
"grid. Each cell keeps the list of triangles drawn to it and sorts them by "
"depth to minimize *overdraw*. This technique improves performance and "
"reduces power consumption, but takes a toll on vertex performance. As a "
"result, fewer vertices and triangles can be processed for drawing."
msgstr ""
"在移動裝置上使用更多的電力是不可能的，所以移動裝置使用一種叫做*基於圖塊的算繪"
"*的技術，將螢幕劃分為一個網格。每個儲存格都保存著繪製的三角形列表，並按深度進"
"行排序，以儘量減少*過度繪製*。這種技術提高了性能，降低了功耗，但對頂點性能造"
"成了影響。因此，可以處理更少的頂點和三角形進行繪製。"

msgid ""
"Additionally, tile-based rendering struggles when there are small objects "
"with a lot of geometry within a small portion of the screen. This forces "
"mobile GPUs to put a lot of strain on a single screen tile, which "
"considerably decreases performance as all the other cells must wait for it "
"to complete before displaying the frame."
msgstr ""
"一般來說, 這並不是那麼糟糕, 但在移動裝置上有一個必須避免的特殊情況, 即在螢幕"
"的一小部分內具有大量幾何形狀的小物體. 這迫使移動GPU在單個螢幕單元上用很大的力"
"氣, 大大降低了性能(因為所有其他單元必須等待它完成才能顯示該影格)."

msgid ""
"To summarize, don't worry about vertex count on mobile, but **avoid "
"concentration of vertices in small parts of the screen**. If a character, "
"NPC, vehicle, etc. is far away (which means it looks tiny), use a smaller "
"level of detail (LOD) model. Even on desktop GPUs, it's preferable to avoid "
"having triangles smaller than the size of a pixel on screen."
msgstr ""
"總而言之, 在移動端不要擔心頂點數量, 但 **避免頂點集中在螢幕的一小部分** . 如"
"果一個角色, NPC, 車輛等離得很遠(這意味著它看起來很小), 就使用一個較小的細節級"
"別模型(LOD). 即使在桌面GPU上, 最好也不要讓三角形小於螢幕上一個像素的大小."

msgid "Pay attention to the additional vertex processing required when using:"
msgstr "使用時要注意額外的頂點處理："

msgid "Skinning (skeletal animation)"
msgstr "蒙皮（骨骼動畫）"

msgid "Morphs (shape keys)"
msgstr "變形（形態鍵）"

msgid "Pixel/fragment shaders and fill rate"
msgstr "像素/片段著色器和填充速率"

msgid ""
"In contrast to vertex processing, the costs of fragment (per-pixel) shading "
"have increased dramatically over the years. Screen resolutions have "
"increased: the area of a 4K screen is 8,294,400 pixels, versus 307,200 for "
"an old 640×480 VGA screen. That is 27 times the area! Also, the complexity "
"of fragment shaders has exploded. Physically-based rendering requires "
"complex calculations for each fragment."
msgstr ""
"與頂點處理相比, 片段著色器(每像素)的成本在這些年裡急劇增加. 螢幕解析度提高了"
"(4K螢幕的面積是829400像素, 而老式640×480 VGA螢幕的面積是307200, 是27倍), 但片"
"段著色器的複雜度也爆炸式增長. 基於物理的算繪需要對每個片段進行複雜的計算."

msgid ""
"You can test whether a project is fill rate-limited quite easily. Turn off V-"
"Sync to prevent capping the frames per second, then compare the frames per "
"second when running with a large window, to running with a very small "
"window. You may also benefit from similarly reducing your shadow map size if "
"using shadows. Usually, you will find the FPS increases quite a bit using a "
"small window, which indicates you are to some extent fill rate-limited. On "
"the other hand, if there is little to no increase in FPS, then your "
"bottleneck lies elsewhere."
msgstr ""
"你可以很容易地測試一個專案是否受到填充率限制. 關閉V-Sync以防止每秒影格數的上"
"限, 然後比較使用大視窗運作時的每秒影格數和使用非常小的視窗運作時的影格數. 如"
"果使用陰影, 你也可以從同樣減少陰影貼圖大小中獲益. 通常, 你會發現使用小視窗的"
"FPS會增加不少, 這說明你在某種程度上受到了填充率的限制. 另一方面, 如果FPS幾乎"
"沒有增加, 那麼你的瓶頸就在其他地方."

msgid ""
"You can increase performance in a fill rate-limited project by reducing the "
"amount of work the GPU has to do. You can do this by simplifying the shader "
"(perhaps turn off expensive options if you are using a :ref:"
"`StandardMaterial3D <class_StandardMaterial3D>`), or reducing the number and "
"size of textures used. Also, when using non-unshaded particles, consider "
"forcing vertex shading in their material to decrease the shading cost."
msgstr ""
"你可以通過減少 GPU 的工作量來提高填充率限制專案的性能。你可以通過簡化著色器"
"（如果你使用的是 :ref:`SpatialMaterial <class_SpatialMaterial>`，也許可以關閉"
"昂貴的選項），或者減少使用的紋理數量和大小來實作。"

msgid ""
"On supported hardware, :ref:`doc_variable_rate_shading` can be used to "
"reduce shading processing costs without impacting the sharpness of edges on "
"the final image."
msgstr ""
"在支援的硬體上，可以使用 :ref:`doc_variable_rate_shading` 降低著色過程的損"
"耗，並且不影響最終圖片邊緣的銳度。"

msgid ""
"**When targeting mobile devices, consider using the simplest possible "
"shaders you can reasonably afford to use.**"
msgstr "**在針對移動裝置時, 考慮使用你能合理負擔得起的最簡單的著色器.**"

msgid "Reading textures"
msgstr "匯入紋理"

msgid ""
"The other factor in fragment shaders is the cost of reading textures. "
"Reading textures is an expensive operation, especially when reading from "
"several textures in a single fragment shader. Also, consider that filtering "
"may slow it down further (trilinear filtering between mipmaps, and "
"averaging). Reading textures is also expensive in terms of power usage, "
"which is a big issue on mobiles."
msgstr ""
"片段著色器的另一個因素是讀取紋理的成本。讀取紋理是一項昂貴的操作，尤其是在一"
"個片段著色器中從多個紋理中讀取時。另外，考慮到篩選可能會進一步減慢它的速度"
"（mipmap 之間的三線性篩選，以及平均）。讀取紋理在功耗方面也很昂貴，這在手機上"
"是個大問題。"

msgid ""
"**If you use third-party shaders or write your own shaders, try to use "
"algorithms that require as few texture reads as possible.**"
msgstr ""
"**如果您使用協力廠商著色器或編寫自己的著色器, 請儘量使用需要盡可能少的紋理讀"
"取的演算法.**"

msgid "Texture compression"
msgstr "紋理壓縮"

msgid ""
"By default, Godot compresses textures of 3D models when imported using video "
"RAM (VRAM) compression. Video RAM compression isn't as efficient in size as "
"PNG or JPG when stored, but increases performance enormously when drawing "
"large enough textures."
msgstr ""
"預設情況下,Godot在匯入3D模型時使用影片RAM(VRAM)壓縮來壓縮紋理. 影片RAM壓縮在"
"儲存時不如PNG或JPG有效, 但在繪製足夠大的紋理時, 會極大地提高性能."

msgid ""
"This is because the main goal of texture compression is bandwidth reduction "
"between memory and the GPU."
msgstr "這是因為紋理壓縮的主要目標是在記憶體和GPU之間減少頻寬."

msgid ""
"In 3D, the shapes of objects depend more on the geometry than the texture, "
"so compression is generally not noticeable. In 2D, compression depends more "
"on shapes inside the textures, so the artifacts resulting from 2D "
"compression are more noticeable."
msgstr ""
"在3D中, 物體的形狀更多地取決於幾何體而不是紋理, 所以壓縮一般不明顯. 在2D中, "
"壓縮更多的是取決於紋理內部的形狀, 所以2D壓縮產生的偽影比較明顯."

msgid ""
"As a warning, most Android devices do not support texture compression of "
"textures with transparency (only opaque), so keep this in mind."
msgstr ""
"作為警告, 大多數Android裝置不支援具有透明度的紋理的紋理壓縮(僅不透明), 因此請"
"記住這一點."

msgid ""
"Even in 3D, \"pixel art\" textures should have VRAM compression disabled as "
"it will negatively affect their appearance, without improving performance "
"significantly due to their low resolution."
msgstr ""
"即便在 3D 中，“像素畫”紋理也應該禁用 VRAM 壓縮，因為壓縮會對外觀產生負面影"
"響，較低的解析度也無法得到顯著的性能提升。"

msgid "Post-processing and shadows"
msgstr "**後處理：**"

msgid ""
"Post-processing effects and shadows can also be expensive in terms of "
"fragment shading activity. Always test the impact of these on different "
"hardware."
msgstr ""
"就片段著色活動而言, 後期處理效果和陰影也可能很昂貴. 始終測試這些對不同硬體的"
"影響."

msgid ""
"**Reducing the size of shadowmaps can increase performance**, both in terms "
"of writing and reading the shadowmaps. On top of that, the best way to "
"improve performance of shadows is to turn shadows off for as many lights and "
"objects as possible. Smaller or distant OmniLights/SpotLights can often have "
"their shadows disabled with only a small visual impact."
msgstr ""
"**減少陰影圖的大小可以提高性能** , 無論是在寫還是讀取陰影貼圖方面. 除此之外, "
"提高陰影性能的最好方法是關閉盡可能多的燈光和物體的陰影. 較小或較遠的"
"OmniLights/SpotLights通常可以禁用它們的陰影, 而對視覺影響很小."

msgid "Transparency and blending"
msgstr "透明度和混合"

msgid ""
"Transparent objects present particular problems for rendering efficiency. "
"Opaque objects (especially in 3D) can be essentially rendered in any order "
"and the Z-buffer will ensure that only the front most objects get shaded. "
"Transparent or blended objects are different. In most cases, they cannot "
"rely on the Z-buffer and must be rendered in \"painter's order\" (i.e. from "
"back to front) to look correct."
msgstr ""
"透明物體對算繪效率帶來了特殊的問題. 不透明的物件(尤其是在3D中)基本上可以以任"
"意順序算繪,Z-緩衝區將確保只有最前面的物件得到陰影. 透明或混合物件則不同, 在大"
"多數情況下, 它們不能依賴Z-緩衝區, 必須以 \"畫家順序\"(即從後到前)算繪才能看起"
"來正確."

msgid ""
"Transparent objects are also particularly bad for fill rate, because every "
"item has to be drawn even if other transparent objects will be drawn on top "
"later on."
msgstr ""
"透明物件的填充率也特別差, 因為每一個專案都要繪製, 即使之面會在上面繪製其他透"
"明物件."

msgid ""
"Opaque objects don't have to do this. They can usually take advantage of the "
"Z-buffer by writing to the Z-buffer only first, then only performing the "
"fragment shader on the \"winning\" fragment, the object that is at the front "
"at a particular pixel."
msgstr ""
"不透明的物件不需要這樣做. 它們通常可以利用Z-緩衝區, 只先向Z-緩衝區寫入資料, "
"然後只在 \"勝利\" 的片段上執行片段著色器, 也就是在某一像素處處於前面的物件."

msgid ""
"Transparency is particularly expensive where multiple transparent objects "
"overlap. It is usually better to use transparent areas as small as possible "
"to minimize these fill rate requirements, especially on mobile, where fill "
"rate is very expensive. Indeed, in many situations, rendering more complex "
"opaque geometry can end up being faster than using transparency to \"cheat\"."
msgstr ""
"在多個透明物件重疊的情況下, 透明度特別昂貴. 通常情況下, 使用透明區域越小越"
"好, 以儘量降低這些填充率要求, 尤其是在移動端. 事實上, 在很多情況下, 算繪更複"
"雜的不透明幾何體最終可能比使用透明度來 \"作弊\" 更快."

msgid "Multi-platform advice"
msgstr "多執行緒"

msgid ""
"If you are aiming to release on multiple platforms, test *early* and test "
"*often* on all your platforms, especially mobile. Developing a game on "
"desktop but attempting to port it to mobile at the last minute is a recipe "
"for disaster."
msgstr ""
"如果您的目標是在多個平臺上發行, 請在您的所有平臺上(尤其是移動平臺)上進行 *早"
"期* 並 *經常* 性測試. 在桌面上開發遊戲, 但試圖在最後一刻將其移植到移動裝置, "
"這是災難的根源."

msgid ""
"In general, you should design your game for the lowest common denominator, "
"then add optional enhancements for more powerful platforms. For example, you "
"may want to use the Compatibility rendering method for both desktop and "
"mobile platforms where you target both."
msgstr ""
"一般來說, 你應該從最底的共性設計你的遊戲, 然後為更強大的平臺新增可選的增強功"
"能. 例如, 你可能希望在同時針對桌面和移動平臺的情況下, 同時使用GLES2後臺."

msgid "Mobile/tiled renderers"
msgstr "移動端和圖塊算繪"

msgid ""
"As described above, GPUs on mobile devices work in dramatically different "
"ways from GPUs on desktop. Most mobile devices use tile renderers. Tile "
"renderers split up the screen into regular-sized tiles that fit into super "
"fast cache memory, which reduces the number of read/write operations to the "
"main memory."
msgstr ""
"如上所述, 移動裝置上的GPU與桌面上的GPU工作方式有很大不同. 大多數移動裝置都使"
"用圖塊算繪器. 圖塊算繪器將螢幕分割成規則大小的圖塊, 這些圖塊可以放入超快的快"
"取中, 從而減少了對主記憶體的讀和寫操作次數."

msgid ""
"There are some downsides though. Tiled rendering can make certain techniques "
"much more complicated and expensive to perform. Tiles that rely on the "
"results of rendering in different tiles or on the results of earlier "
"operations being preserved can be very slow. Be very careful to test the "
"performance of shaders, viewport textures and post processing."
msgstr ""
"不過也有一些缺點. 圖塊算繪會讓某些技術變得更加複雜, 執行起來也更加昂貴. 依賴"
"於不同圖塊算繪的結果, 或者依賴於早期操作的結果被保存的圖塊可能會非常慢. 要非"
"常小心地測試著色器, 視圖紋理和後期處理的性能."

msgid "Translation status"
msgstr "翻譯狀態"
