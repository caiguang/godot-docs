# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "optimization"
msgstr "動畫"

msgid "Optimizing 3D performance"
msgstr "優化 3D 性能"

msgid "Culling"
msgstr "編譯"

msgid ""
"Godot will automatically perform view frustum culling in order to prevent "
"rendering objects that are outside the viewport. This works well for games "
"that take place in a small area, however things can quickly become "
"problematic in larger levels."
msgstr ""
"Godot會自動執行視圖視錐剔除, 以防止算繪視口外的物體. 這對於發生在小範圍內的遊"
"戲來說效果很好, 然而在較大的關卡中, 事情很快就會變得很麻煩."

msgid "Occlusion culling"
msgstr "遮擋剔除"

msgid ""
"Walking around a town for example, you may only be able to see a few "
"buildings in the street you are in, as well as the sky and a few birds "
"flying overhead. As far as a naive renderer is concerned however, you can "
"still see the entire town. It won't just render the buildings in front of "
"you, it will render the street behind that, with the people on that street, "
"the buildings behind that. You quickly end up in situations where you are "
"attempting to render 10× or 100× more than what is visible."
msgstr ""
"比如走在一個小鎮上, 你可能只能看到你所在的街道上的幾棟建築, 以及天空和幾隻飛"
"過頭頂的鳥. 然而就一個天真的算繪器而言, 你仍然可以看到整個小鎮. 它不會只算繪"
"你前面的建築, 它會算繪那後面的街道, 與那條街上的人, 那後面的建築. 你很快就會"
"遇到這樣的情況: 你試圖算繪比可見的東西多10倍或100倍的東西."

msgid ""
"Things aren't quite as bad as they seem, because the Z-buffer usually allows "
"the GPU to only fully shade the objects that are at the front. This is "
"called *depth prepass* and is enabled by default in Godot when using the "
"Forward+ or Compatibility rendering methods. However, unneeded objects are "
"still reducing performance."
msgstr ""
"事情並沒有看上去那麼糟糕，因為 Z 緩衝通常只允許 GPU 完全遮擋在前面的物體。這"
"被稱為*深度預處理*（depth prepass），在使用 GLES3 算繪器時，Godot 預設啟用。"
"然而，不需要的物件仍然在降低性能。"

msgid ""
"One way we can potentially reduce the amount to be rendered is to **take "
"advantage of occlusion**. Godot 4.0 and later offers a new approach to "
"occlusion culling using occluder nodes. See :ref:`doc_occlusion_culling` for "
"instructions on setting up occlusion culling in your scene."
msgstr ""
"我們可以減少算繪量的一種方法是**利用遮蔽**。 Godot 4.0 及更高版本提供了一種使"
"用遮擋器節點進行遮蔽剔除的新方法。有關在場景中設定遮蔽剔除的說明，請參閱 "
"doc_occlusion_culling`。"

msgid ""
"In some cases, you may have to adapt your level design to add more occlusion "
"opportunities. For example, you may have to add more walls to prevent the "
"player from seeing too far away, which would decrease performance due to the "
"lost opportunities for occlusion culling."
msgstr ""
"在某些情況下，你可以通過調整你的關卡設計來增加更多的遮擋機會。例如，你可以增"
"加更多的牆來防止玩家看得太遠，否則就會因為失去了遮擋機會而降低性能。"

msgid "Transparent objects"
msgstr "透明物體"

msgid ""
"Godot sorts objects by :ref:`Material <class_Material>` and :ref:`Shader "
"<class_Shader>` to improve performance. This, however, can not be done with "
"transparent objects. Transparent objects are rendered from back to front to "
"make blending with what is behind work. As a result, **try to use as few "
"transparent objects as possible**. If an object has a small section with "
"transparency, try to make that section a separate surface with its own "
"material."
msgstr ""
"Godot通過 :ref:`Material <class_Material>` 和 :ref:`Shader <class_Shader>` 對"
"對象進行排序以提高性能. 然而, 這對透明物體來說是不可能的. 透明物體從後往前算"
"繪, 以便與後面的物體混合. 因此, **儘量少使用透明物件** . 如果一個物體有一小部"
"分是透明的, 儘量讓這部分成為一個獨立的表面, 有自己的材質."

msgid ""
"For more information, see the :ref:`GPU optimizations "
"<doc_gpu_optimization>` doc."
msgstr "更多資訊請參考 :ref:`doc_c_sharp_differences` 一頁。"

msgid "Level of detail (LOD)"
msgstr "細節程度（LOD）"

msgid ""
"In some situations, particularly at a distance, it can be a good idea to "
"**replace complex geometry with simpler versions**. The end user will "
"probably not be able to see much difference. Consider looking at a large "
"number of trees in the far distance. There are several strategies for "
"replacing models at varying distance. You could use lower poly models, or "
"use transparency to simulate more complex geometry."
msgstr ""
"在某些情況下, 特別是在遠處, 用簡單的版本**代替複雜的幾何圖形可能是個好主意. "
"最終使用者可能看不出什麼區別. 考慮看看遠處的大量樹木. 有幾種策略可以替換不同"
"距離的模型. 您可以使用較低的多邊形模型, 或者使用透明度來模擬更複雜的幾何體."

msgid "Godot 4 offers several ways to control level of detail:"
msgstr "Godot 4 提供了多種控制細節等級的方法："

msgid "An automatic approach on mesh import using :ref:`doc_mesh_lod`."
msgstr "使用 doc_mesh_lod 進行網格匯入的自動方法。"

msgid ""
"A manual approach configured in the 3D node using :ref:"
"`doc_visibility_ranges`."
msgstr "使用 doc_visibility_ranges 在 3D 節點中配置的手動方法。"

msgid ""
":ref:`Decals <doc_using_decals>` and :ref:`lights <doc_lights_and_shadows>` "
"can also benefit from level of detail using their respective **Distance "
"Fade** properties."
msgstr ""
"貼紙 <doc_using_decals>` 和燈光 <doc_lights_and_shadows>` 也可以使用各自的 **"
"距離淡入淡出** 屬性從細節等級中受益。"

msgid ""
"While they can be used independently, these approaches are most effective "
"when used together. For example, you can set up visibility ranges to hide "
"particle effects that are too far away from the player to notice. At the "
"same time, you can rely on mesh LOD to make the particle effect's meshes "
"rendered with less detail at a distance."
msgstr ""
"雖然它們可以單獨使用，但一起使用時這些方法最有效。例如，您可以設定可見範圍來"
"隱藏距離玩家太遠而無法注意到的粒子效果。同時，您可以依靠網格 LOD 來使粒子效果"
"的網格在遠處算繪時細節較少。"

msgid ""
"Visibility ranges are also a good way to set up *impostors* for distant "
"geometry (see below)."
msgstr "可見範圍也是為遠處幾何體設定「冒充者」的好方法（見下文）。"

msgid "Billboards and imposters"
msgstr "Billboard 和 imposter"

msgid ""
"The simplest version of using transparency to deal with LOD is billboards. "
"For example, you can use a single transparent quad to represent a tree at "
"distance. This can be very cheap to render, unless of course, there are many "
"trees in front of each other. In this case, transparency may start eating "
"into fill rate (for more information on fill rate, see :ref:"
"`doc_gpu_optimization`)."
msgstr ""
"使用透明度來處理LOD的最簡單版本是看板. 例如, 你可以用一個單一的透明四邊形來表"
"示一棵樹的距離. 這可以是非常便宜的算繪, 當然, 除非前面有很多樹. 在這種情況"
"下, 透明度可能會開始吞噬填充率(關於填充率的更多資訊, 請參見 :ref:"
"`doc_gpu_optimization`)."

msgid ""
"An alternative is to render not just one tree, but a number of trees "
"together as a group. This can be especially effective if you can see an area "
"but cannot physically approach it in a game."
msgstr ""
"另一種方法是不只算繪一棵樹, 而是將一些樹作為一組來算繪. 如果你能看到一個區"
"域, 但在遊戲中不能實際接近它, 這可能是特別有效的."

msgid ""
"You can make imposters by pre-rendering views of an object at different "
"angles. Or you can even go one step further, and periodically re-render a "
"view of an object onto a texture to be used as an imposter. At a distance, "
"you need to move the viewer a considerable distance for the angle of view to "
"change significantly. This can be complex to get working, but may be worth "
"it depending on the type of project you are making."
msgstr ""
"你可以通過預先算繪物件的不同角度的視圖來製作冒牌貨. 或者你甚至可以更進一步, "
"週期性地將一個物體的視圖重新算繪到一個紋理上, 作為一個冒牌貨使用. 在遠處, 你"
"需要將觀察者移動相當長的距離, 視角才會發生顯著變化. 這可能是複雜的工作, 但可"
"能是值得的, 這取決於你正在製作的專案型別."

msgid "Use instancing (MultiMesh)"
msgstr "使用產生實體（MultiMesh）"

msgid ""
"If several identical objects have to be drawn in the same place or nearby, "
"try using :ref:`MultiMesh <class_MultiMesh>` instead. MultiMesh allows the "
"drawing of many thousands of objects at very little performance cost, making "
"it ideal for flocks, grass, particles, and anything else where you have "
"thousands of identical objects."
msgstr ""
"如果必須在同一地點或附近繪製多個相同的物件, 請嘗試使用 :ref:`MultiMesh "
"<class_MultiMesh>` 來代替.MultiMesh允許以很小的性能代價來繪製成千上萬的對象, "
"這使得它非常適合用於繪製羊群, 草地, 粒子以及其他任何有成千上萬相同物件的地方."

msgid ""
"See also the :ref:`Using MultiMesh <doc_using_multimesh>` documentation."
msgstr "另請參閱 :ref:`Using MultiMesh <doc_using_multimesh>` 文件."

msgid "Bake lighting"
msgstr "烘焙照明"

msgid ""
"Lighting objects is one of the most costly rendering operations. Realtime "
"lighting, shadows (especially multiple lights), and :ref:`global "
"illumination <doc_introduction_to_global_illumination>` are especially "
"expensive. They may simply be too much for lower power mobile devices to "
"handle."
msgstr ""
"對物體進行照明是最昂貴的算繪操作之一. 即時光照, 陰影(尤其是很多燈光)和 GI 都"
"特別昂貴. 對於低功率的移動裝置來說, 它們可能根本無法處理."

msgid ""
"**Consider using baked lighting**, especially for mobile. This can look "
"fantastic, but has the downside that it will not be dynamic. Sometimes, this "
"is a tradeoff worth making."
msgstr ""
"**考慮使用烘焙照明** , 尤其是移動端, 這看起來很棒, 但有一個缺點, 那就是它不是"
"動態的, 有時, 這需要做出的權衡."

msgid ""
"See :ref:`doc_using_lightmap_gi` for instructions on using baked lightmaps. "
"For best performance, you should set lights' bake mode to **Static** as "
"opposed to the default **Dynamic**, as this will skip real-time lighting on "
"meshes that have baked lighting."
msgstr ""
"有關使用烘焙光照貼圖的說明，請參閱 doc_using_lightmap_gi。為了獲得最佳性能，"
"您應該將燈光的烘焙模式設定為**靜態**，而不是預設的**動態**，因為這將跳過具有"
"烘焙光照的網格體上的即時光照。"

msgid ""
"The downside of lights with the **Static** bake mode is that they can't cast "
"shadows onto meshes with baked lighting. This can make scenes with outdoor "
"environments and dynamic objects look flat. A good balance between "
"performance and quality is to keep **Dynamic** for the :ref:"
"`class_DirectionalLight3D` node, and use **Static** for most (if not all) "
"omni and spot lights."
msgstr ""
"使用**靜態**烘焙模式的燈光的缺點是它們無法將陰影投射到具有烘焙光照的網格上。"
"這可以使具有室外環境和動態物件的場景看起來平坦。效能和品質之間的良好平衡是為 "
"class_DirectionalLight3D 節點保持**動態**，並為大多數（如果不是全部）全向燈和"
"聚光燈使用**靜態**。"

msgid "Animation and skinning"
msgstr "Animation - 動畫選項"

msgid ""
"Animation and vertex animation such as skinning and morphing can be very "
"expensive on some platforms. You may need to lower the polycount "
"considerably for animated models, or limit the number of them on screen at "
"any given time. You can also reduce the animation rate for distant or "
"occluded meshes, or pause the animation entirely if the player is unlikely "
"to notice the animation being stopped."
msgstr ""
"在某些平臺上, 動畫和頂點動畫(如換膚和變形)可能非常昂貴. 你可能需要大大降低動"
"畫模型的多邊形數量, 或者任何時候限制螢幕上的模型數量."

msgid ""
"The :ref:`class_VisibleOnScreenEnabler3D` and :ref:"
"`class_VisibleOnScreenNotifier3D` nodes can be useful for this purpose."
msgstr ""
"class_VisibleOnScreenEnabler3D 和 class_VisibleOnScreenNotifier3D 節點可用於"
"此目的。"

msgid "Large worlds"
msgstr "龐大的世界"

msgid ""
"If you are making large worlds, there are different considerations than what "
"you may be familiar with from smaller games."
msgstr "如果您要製作大型遊戲, 則與小型遊戲可能會有所不同."

msgid ""
"Large worlds may need to be built in tiles that can be loaded on demand as "
"you move around the world. This can prevent memory use from getting out of "
"hand, and also limit the processing needed to the local area."
msgstr ""
"大型的世界可能需要用碎片建立, 可以在你在世界中移動時按需載入, 這可以防止記憶"
"體使用失控, 也可以將所需的處理限制在局部區域."

msgid ""
"There may also be rendering and physics glitches due to floating point error "
"in large worlds. This can be resolved using :ref:"
"`doc_large_world_coordinates`. If using large world coordinates is an "
"option, you may be able to use techniques such as orienting the world around "
"the player (rather than the other way around), or shifting the origin "
"periodically to keep things centred around ``Vector3(0, 0, 0)``."
msgstr ""
"在大型世界中, 由於浮點錯誤, 也可能會出現算繪和物理故障, 你可能會使用一些技"
"術, 比如將世界圍繞著玩家的方向(而不是相反), 或者定期移動原點以保持以 "
"``Vector3(0, 0, 0)`` 為中心."

msgid "Translation status"
msgstr "翻譯狀態"
