# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Multiple resolutions"
msgstr "多解析度"

msgid "The problem of multiple resolutions"
msgstr "多解析度問題"

msgid ""
"Developers often have trouble understanding how to best support multiple "
"resolutions in their games. For desktop and console games, this is more or "
"less straightforward, as most screen aspect ratios are 16:9 and resolutions "
"are standard (720p, 1080p, 1440p, 4K, …)."
msgstr ""
"開發人員經常會遇到麻煩, 不知道如何在他們的遊戲中最好地支援多種解析度. 對於桌"
"面和控制台遊戲, 這或多或少是簡單的, 因為大多數螢幕長寬比是16:9, 解析度是標準"
"的720p, 1080p, 1440p, 4K,......."

msgid ""
"For mobile games, at first, it was easy. For many years, the iPhone and iPad "
"used the same resolution. When *Retina* was implemented, they just doubled "
"the pixel density; most developers had to supply assets in default and "
"double resolutions."
msgstr ""
"對於手機遊戲來說，起初，這很容易。許多年來，iPhone 和 iPad 使用相同的解析度。"
"當實行 *Retina* 後，他們只是將像素密度提高了一倍；大多數開發商不得不以預設和"
"雙倍的解析度提供素材。"

msgid ""
"Nowadays, this is no longer the case, as there are plenty of different "
"screen sizes, densities, and aspect ratios. Non-conventional sizes are also "
"becoming increasingly popular, such as ultrawide displays."
msgstr ""
"如今, 情況已不再如此, 因為有很多不同的螢幕尺寸, 密度和長寬比. 非傳統的尺寸也"
"越來越受歡迎, 如超寬顯示幕."

msgid ""
"For 3D games, there is not much of a need to support multiple resolutions "
"(from the aesthetic point of view). The 3D geometry will just fill the "
"screen based on the field of view, disregarding the aspect ratio. The main "
"reason one may want to support this, in this case, is for *performance* "
"reasons (running in lower resolution to increase frames per second)."
msgstr ""
"對於3D遊戲來說, 沒有太大的必要支援多種解析度(從審美角度來看).3D幾何圖形將根據"
"視場填充螢幕, 而不考慮長寬比. 在這種情況下, 人們可能想要支援的主要原因是為了 "
"*性能* 的原因(以較低的解析度運作以增加每秒的影格數)."

msgid ""
"For 2D and game UIs, this is a different matter, as art needs to be created "
"using specific pixel sizes in software such as Photoshop, GIMP or Krita."
msgstr ""
"對於2D和遊戲UI, 這是一個不同的問題, 因為設計需要在Photoshop, GIMP或Krita等軟"
"體中使用特定的像素尺寸來建立."

msgid ""
"Since layouts, aspect ratios, resolutions, and pixel densities can change so "
"much, it is no longer possible to design UIs for every specific screen. "
"Another method must be used."
msgstr ""
"由於佈局, 長寬比, 解析度和像素密度會有很大的變化, 因此不再可能為每個特定的螢"
"幕設計UI. 必須使用另一種方法."

msgid "One size fits all"
msgstr "萬全之策"

msgid ""
"The most common approach is to use a single *base* resolution and then fit "
"it to everything else. This resolution is how most players are expected to "
"play the game (given their hardware). For mobile, Google has useful `stats "
"<https://developer.android.com/about/dashboards>`_ online, and for desktop, "
"Steam `also does <https://store.steampowered.com/hwsurvey/>`_."
msgstr ""
"最常見的方法是使用一個單一的 *基礎* 解析度, 然後將其適用於其他所有情況. 這個"
"解析度是大多數玩家預期的玩遊戲的方式, 鑒於他們的硬體. 對於移動裝置, 穀歌在網"
"上有有用的 `統計資料 <https://developer.android.com/about/dashboards>`__ , 對"
"於桌面裝置,Steam `也有 <https://store.steampowered.com/hwsurvey/>`__ ."

msgid ""
"As an example, Steam shows that the most common *primary display resolution* "
"is 1920×1080, so a sensible approach is to develop a game for this "
"resolution, then handle scaling for different sizes and aspect ratios."
msgstr ""
"舉個例子,Steam顯示最常見的 *主要顯示解析度是* 1920×1080, 所以明智的做法是為這"
"個解析度開發一個遊戲, 然後期處理不同尺寸和長寬比的縮放."

msgid "Godot provides several useful tools to do this easily."
msgstr "Godot 還提供了一系列通用的容器."

msgid ""
"You can see how Godot's support for multiple resolutions works in action "
"using the `Multiple Resolutions and Aspect Ratios demo project <https://"
"github.com/godotengine/godot-demo-projects/tree/master/gui/"
"multiple_resolutions>`__."
msgstr ""
"除了這份說明文件，你可能也會想看看 `Godot Demo 專案 <https://github.com/"
"godotengine/godot-demo-projects>`_ 。"

msgid "Base size"
msgstr "基本大小"

msgid ""
"A base size for the window can be specified in the Project Settings under "
"**Display → Window**."
msgstr "視窗的基本尺寸可以在專案設定中的 **Display → Window** 下指定."

msgid ""
"However, what it does is not completely obvious; the engine will *not* "
"attempt to switch the monitor to this resolution. Rather, think of this "
"setting as the \"design size\", i.e. the size of the area that you work with "
"in the editor. This setting corresponds directly to the size of the blue "
"rectangle in the 2D editor."
msgstr ""
"然而, 它的作用並不完全明顯; 引擎將 *不* 嘗試將顯示器切換到此解析度. 相反, 將"
"此設定視為 \"設計大小\", 即您在編輯器中使用的區域的大小. 此設定直接對應於2D編"
"輯器中藍色矩形的大小."

msgid ""
"There is often a need to support devices with screen and window sizes that "
"are different from this base size. Godot offers many ways to control how the "
"viewport will be resized and stretched to different screen sizes."
msgstr ""
"通常需要支援具有與該基本大小不同的螢幕和視窗大小的裝置. Godot提供了許多方法來"
"控制視口的大小調整和拉伸到不同的螢幕大小."

msgid ""
"To configure the stretch base size at runtime from a script, use the "
"``get_tree().root.content_scale_size`` property (see :ref:`Window."
"content_scale_size <class_Window_property_content_scale_size>`). Changing "
"this value can indirectly change the size of 2D elements. However, to "
"provide an user-accessible scaling option, using :ref:"
"`doc_multiple_resolutions_stretch_scale` is recommended as it's easier to "
"adjust."
msgstr ""
"若要在執行時間從腳本配置伸展基本尺寸，請使用「get_tree().root."
"content_scale_size」屬性（請參閱 :ref:`Window.content_scale_size "
"<class_Window_property_content_scale_size>`）。更改此值可以間接更改 2D 元素的"
"大小。但是，為了提供使用者可存取的縮放選項，建議使用 "
"doc_multiple_resolutions_stretch_scale`，因為它更容易調整。"

msgid ""
"Godot follows a modern approach to multiple resolutions. The engine will "
"never change the monitor's resolution on its own. While changing the "
"monitor's resolution is the most efficient approach, it's also the least "
"reliable approach as it can leave the monitor stuck on a low resolution if "
"the game crashes. This is especially common on macOS or Linux which don't "
"handle resolution changes as well as Windows."
msgstr ""
"Godot遵循了現代多種解析度的方法. 引擎永遠不會自行改變顯示器的解析度. 雖然改變"
"顯示器的解析度是最有效的方法, 但這也是最不可靠的方法, 因為如果遊戲當機, 它可"
"能會讓顯示器卡在一個低解析度上. 這在macOS或Linux上很常見, 因為它們對解析度變"
"化的處理不如Windows."

msgid ""
"Changing the monitor's resolution also removes any control from the game "
"developer over filtering and aspect ratio stretching, which can be important "
"to ensure correct display for pixel art games."
msgstr ""
"更改顯示器的解析度還會取消遊戲開發者對篩選和縱橫比拉伸的控制, 這對於確保像素"
"遊戲的正確顯示畫面非常重要."

msgid ""
"On top of that, changing the monitor's resolution makes alt-tabbing in and "
"out of a game much slower since the monitor has to change resolutions every "
"time this is done."
msgstr ""
"最重要的是, 更改顯示器的解析度會使遊戲的Alt-Tab鍵切換速度變慢, 因為每次切換時"
"顯示器都必須更改解析度."

msgid "Resizing"
msgstr "調整大小"

msgid ""
"There are several types of devices, with several types of screens, which in "
"turn have different pixel density and resolutions. Handling all of them can "
"be a lot of work, so Godot tries to make the developer's life a little "
"easier. The :ref:`Viewport <class_Viewport>` node has several functions to "
"handle resizing, and the root node of the scene tree is always a viewport "
"(scenes loaded are instanced as a child of it, and it can always be accessed "
"by calling ``get_tree().root`` or ``get_node(\"/root\")``)."
msgstr ""
"市面上有著各種各樣的裝置, 擁有各種型別的螢幕, 依次有著不同的像素密度和解析"
"度. 處理所有的型別工作量巨大, 所以Godot試圖讓開發者的生活變得更簡單. :ref:"
"`Viewport <class_Viewport>` 節點提供了幾個處理大小調整的函式, 而場景樹的根節"
"點始終是一個Viewport (場景將作為它的子節點被產生實體, 並且始終可以通過呼叫 "
"``get_tree().get_root()`` 或 ``get_node(\"/root\")`` 來存取它."

msgid ""
"In any case, while changing the root Viewport params is probably the most "
"flexible way to deal with the problem, it can be a lot of work, code and "
"guessing, so Godot provides a set of parameters in the project settings to "
"handle multiple resolutions."
msgstr ""
"在任何情況下，雖然更改根 Viewport 的參數可能是解決問題的最靈活方法，但這樣做"
"的可能包含大量工作、大量程式碼、大量推測過程，因此 Godot 在專案設定中提供了一"
"組簡單的參數來處理多解析度問題。"

msgid "Stretch settings"
msgstr "拉伸設定"

msgid ""
"Stretch settings are located in the project settings and provide several "
"options:"
msgstr "拉伸設定位於專案設定中, 提供了幾個選項:"

msgid "Stretch Mode"
msgstr "拉伸模式"

msgid ""
"The **Stretch Mode** setting defines how the base size is stretched to fit "
"the resolution of the window or screen."
msgstr "**Stretch Mode** 設定定義了基本尺寸如何被伸展以適應視窗或螢幕的解析度."

msgid ""
"The animations below use a \"base size\" of just 16×9 pixels to demonstrate "
"the effect of different stretch modes. A single sprite, also 16×9 pixels in "
"size, covers the entire viewport, and a diagonal :ref:`Line2D "
"<class_Line2D>` is added on top of it:"
msgstr ""
"下面的動畫使用僅16×9像素的 \"基本大小\" 來演示不同拉伸模式的效果. 單個精靈, "
"大小也是16×9像素, 覆蓋整個視口, 並在其上新增一個對角線 :ref:`Line2D "
"<class_Line2D>` :"

msgid ""
"**Stretch Mode = Disabled** (default): No stretching happens. One unit in "
"the scene corresponds to one pixel on the screen. In this mode, the "
"**Stretch Aspect** setting has no effect."
msgstr ""
"**Stretch Mode = Disabled** (預設). 不發生拉伸. 場景中的一個單位對應於螢幕上"
"的一個像素. 在這種模式下, **Stretch Aspect** 設定沒有效果."

msgid ""
"**Stretch Mode = Canvas Items**: In this mode, the base size specified in "
"width and height in the project settings is stretched to cover the whole "
"screen (taking the **Stretch Aspect** setting into account). This means that "
"everything is rendered directly at the target resolution. 3D is unaffected, "
"while in 2D, there is no longer a 1:1 correspondence between sprite pixels "
"and screen pixels, which may result in scaling artifacts."
msgstr ""
"**Stretch Mode = 2D**：在這種模式下，專案設定中所指定的寬高尺寸會被拉伸到覆蓋"
"整個螢幕（會考慮 **Stretch Aspect** 設定）。這意味著所有的東西都直接在目標解"
"析度下進行算繪。3D 不受影響，而在2D中，精靈像素和螢幕像素之間不再有 1:1 的對"
"應關係，這可能會導致縮放的偽影。"

msgid ""
"**Stretch Mode = Viewport**: Viewport scaling means that the size of the "
"root :ref:`Viewport <class_Viewport>` is set precisely to the base size "
"specified in the Project Settings' **Display** section. The scene is "
"rendered to this viewport first. Finally, this viewport is scaled to fit the "
"screen (taking the **Stretch Aspect** setting into account)."
msgstr ""
"**Stretch Mode = Viewport** : 視口縮放意味著根 :ref:`Viewport "
"<class_Viewport>` 的尺寸被精確地設定為在專案設定的 **Display** 部分指定的基本"
"尺寸. 場景首先被算繪到這個視口. 最後, 這個視口被縮放以適應螢幕(考慮 "
"**Stretch Aspect** 的設定)."

msgid ""
"To configure the stretch mode at runtime from a script, use the ``get_tree()."
"root.content_scale_mode`` property (see :ref:`Window.content_scale_mode "
"<class_Window_property_content_scale_mode>` and the :ref:`ContentScaleMode "
"<enum_Window_ContentScaleMode>` enum)."
msgstr ""
"要在運作時從腳本中配置拉伸, 請使用 ``get_tree().set_screen_stretch()`` 方法"
"(見 :ref:`SceneTree.set_screen_stretch() "
"<class_SceneTree_method_set_screen_stretch>` )."

msgid "Stretch Aspect"
msgstr "拉伸比例（Stretch Aspect）"

msgid ""
"The second setting is the stretch aspect. Note that this only takes effect "
"if **Stretch Mode** is set to something other than **Disabled**."
msgstr ""
"第二個設定是拉伸縱橫比. 請注意, 只有在 **Stretch Mode** 被設定為 "
"**Disabled** 以外的情況下, 這才會生效."

msgid ""
"In the animations below, you will notice gray and black areas. The black "
"areas are added by the engine and cannot be drawn into. The gray areas are "
"part of your scene, and can be drawn to. The gray areas correspond to the "
"region outside the blue frame you see in the 2D editor."
msgstr ""
"在下面的動畫中, 您會注意到灰色和黑色區域. 黑色區域由引擎新增, 無法繪製. 灰色"
"區域是場景的一部分, 可以繪製. 灰色區域對應於您在2D編輯器中看到的藍色框架外的"
"區域."

msgid ""
"**Stretch Aspect = Ignore**: Ignore the aspect ratio when stretching the "
"screen. This means that the original resolution will be stretched to exactly "
"fill the screen, even if it's wider or narrower. This may result in "
"nonuniform stretching: things looking wider or taller than designed."
msgstr ""
"**Stretch Aspect = Ignore** : 在拉伸螢幕時忽略長寬比. 這意味著原始解析度將被"
"拉伸以完全填滿螢幕, 即使它更寬或更窄. 這可能會導致不均勻的拉伸, 事物看起來比"
"設計的更寬或更高."

msgid ""
"**Stretch Aspect = Keep**: Keep aspect ratio when stretching the screen. "
"This means that the viewport retains its original size regardless of the "
"screen resolution, and black bars will be added to the top/bottom of the "
"screen (\"letterboxing\") or the sides (\"pillarboxing\")."
msgstr ""
"**Stretch Aspect = Keep** : 在拉伸螢幕的時候保持長寬比. 這意味著無論螢幕解析"
"度如何, 視口都會保留原來的尺寸, 黑條會被新增到螢幕的頂部或底部(\"寬屏模式 \")"
"或側面(\" 豎屏模式\")."

msgid ""
"This is a good option if you know the aspect ratio of your target devices in "
"advance, or if you don't want to handle different aspect ratios."
msgstr ""
"如果您事先知道目標裝置的寬高比, 或者您不想處理不同的寬高比, 這是一個不錯的選"
"擇."

msgid ""
"**Stretch Aspect = Keep Width**: Keep aspect ratio when stretching the "
"screen. If the screen is wider than the base size, black bars are added at "
"the left and right (pillarboxing). But if the screen is taller than the base "
"resolution, the viewport will be grown in the vertical direction (and more "
"content will be visible to the bottom). You can also think of this as "
"\"Expand Vertically\"."
msgstr ""
"**Stretch Aspect = Keep Width** : 在拉伸螢幕時保持長寬比. 如果螢幕比基本尺寸"
"寬, 則會在左右兩邊新增黑條(豎屏模式). 但如果螢幕比基本解析度高, 視口將在垂直"
"方向上增長(更多的內容將在底部可見). 你也可以把它看作是 \"垂直擴充\" ."

msgid ""
"This is usually the best option for creating GUIs or HUDs that scale, so "
"some controls can be anchored to the bottom (:ref:`doc_size_and_anchors`)."
msgstr ""
"這通常是建立可擴充的GUI或HUD的最佳選擇, 因此一些控制項可以錨定到底部( :ref:"
"`doc_size_and_anchors`)."

msgid ""
"**Stretch Aspect = Keep Height**: Keep aspect ratio when stretching the "
"screen. If the screen is taller than the base size, black bars are added at "
"the top and bottom (letterboxing). But if the screen is wider than the base "
"resolution, the viewport will be grown in the horizontal direction (and more "
"content will be visible to the right). You can also think of this as "
"\"Expand Horizontally\"."
msgstr ""
"**Stretch Aspect = Keep Height** : 在拉伸螢幕時保持長寬比. 如果螢幕比基本尺寸"
"高, 則會在頂部和底部新增黑條(寬屏模式). 但如果螢幕比基本解析度寬, 視口將在水"
"平方向上增長(更多的內容將在右邊可見). 你也可以把它看作是 \"水平擴充\" ."

msgid ""
"This is usually the best option for 2D games that scroll horizontally (like "
"runners or platformers)."
msgstr "這通常是水平滾動的2D遊戲的最佳選擇(如跑步者或平臺遊戲者)."

msgid ""
"**Stretch Aspect = Expand**: Keep aspect ratio when stretching the screen, "
"but keep neither the base width nor height. Depending on the screen aspect "
"ratio, the viewport will either be larger in the horizontal direction (if "
"the screen is wider than the base size) or in the vertical direction (if the "
"screen is taller than the original size)."
msgstr ""
"**Stretch Aspect = Expand** : 在拉伸螢幕時保持長寬比, 但既不保持基本寬度也不"
"保持高度. 根據螢幕的長寬比, 視口將在水平方向(如果螢幕比基本尺寸寬)或垂直方向"
"上變大(如果螢幕比原始尺寸高)."

msgid ""
"To support both portrait and landscape mode with a similar automatically "
"determined scale factor, set your project's base resolution to be a *square* "
"(1:1 aspect ratio) instead of a rectangle. For instance, if you wish to "
"design for 1280×720 as the base resolution but wish to support both portrait "
"and landscape mode, use 720×720 as the project's base window size in the "
"Project Settings."
msgstr ""
"為了以類似的自動確定的比例係數支援縱向和橫向模式，請將您的專案的基本解析度設"
"定為 *方形* （1:1長寬比）而不是矩形。例如，如果你希望以1280×720為基本解析度進"
"行設計，但又希望同時支援縱向和橫向模式，那麼在專案設定中使用720×720作為專案的"
"基本視窗尺寸。"

msgid ""
"To allow the user to choose their preferred screen orientation at run-time, "
"remember to set **Display > Window > Handheld > Orientation** to ``sensor``."
msgstr ""
"為了讓使用者在運作時選擇自己喜歡的螢幕方向，記得將**Display > Window > "
"Handheld > Orientation** 設定為 ``sensor`` (感測器)."

msgid ""
"To configure the stretch aspect at runtime from a script, use the "
"``get_tree().root.content_scale_aspect`` property (see :ref:`Window."
"content_scale_aspect <class_Window_property_content_scale_aspect>` and the :"
"ref:`ContentScaleAspect <enum_Window_ContentScaleAspect>` enum)."
msgstr ""
"要在運作時從腳本中配置拉伸, 請使用 ``get_tree().set_screen_stretch()`` 方法"
"(見 :ref:`SceneTree.set_screen_stretch() "
"<class_SceneTree_method_set_screen_stretch>` )."

msgid "Stretch Scale"
msgstr "根縮放"

msgid ""
"The **Scale** setting allows you to add an extra scaling factor on top of "
"what the **Stretch** options above already provide. The default value of "
"``1.0`` means that no additional scaling occurs."
msgstr ""
"**Shrink** 設定允許你在上面的 **Stretch** 選項已經提供的基礎上增加一個額外的"
"縮放係數. 預設值為1意味著不發生縮放."

msgid ""
"For example, if you set **Scale** to ``2.0`` and leave **Stretch Mode** on "
"**Disabled**, each unit in your scene will correspond to 2×2 pixels on the "
"screen. This is a good way to provide scaling options for non-game "
"applications."
msgstr ""
"例如, 如果你將 **Shrink** 設定為4, 並將 **Stretch Mode** 置於 **Disabled** 狀"
"態, 那麼你的場景中的每個單元將對應於螢幕上的4×4像素."

msgid ""
"If **Stretch Mode** is set to **canvas_items**, 2D elements will be scaled "
"relative to the base window size, then multiplied by the **Scale** setting. "
"This can be exposed to players to allow them to adjust the automatically "
"determined scale to their liking, for better accessibility."
msgstr ""
"如果 **拉伸模式** 設定為 **canvas_items**，2D 元素將相對於基本視窗大小進行縮"
"放，然後乘以 **縮放** 設定。這可以公開給玩家，讓他們根據自己的喜好調整自動確"
"定的比例，以獲得更好的可存取性。"

msgid ""
"If **Stretch Mode** is set to **viewport**, the viewport's resolution is "
"divided by **Scale**. This makes pixels look larger and reduces rendering "
"resolution (with a given window size), which can improve performance."
msgstr ""
"如果**拉伸模式**設定為**視口**，則視口的解析度除以**比例**。這使得像素看起來"
"更大並降低算繪解析度（在給定視窗大小的情況下），從而可以提高效能。"

msgid ""
"To configure the stretch scale at runtime from a script, use the "
"``get_tree().root.content_scale_factor`` property (see :ref:`Window."
"content_scale_factor <class_Window_property_content_scale_factor>`)."
msgstr ""
"要在運作時從腳本中配置拉伸, 請使用 ``get_tree().set_screen_stretch()`` 方法"
"(見 :ref:`SceneTree.set_screen_stretch() "
"<class_SceneTree_method_set_screen_stretch>` )."

#, fuzzy
msgid "Stretch Scale Mode"
msgstr "根縮放"

msgid ""
"Since Godot 4.2, the **Stretch Scale Mode** setting allows you to constrain "
"the automatically determined scale factor (as well as the manually specified "
"**Stretch Scale** setting) to integer values. By default, this setting is "
"set to ``fractional``, which allows any scale factor to be applied "
"(including fractional values such as ``2.5``). When set to ``integer``, the "
"value is rounded down to the nearest integer. For example, instead of using "
"a scale factor of ``2.5``, it would be rounded down to ``2.0``. This is "
"useful to prevent distortion when displaying pixel art."
msgstr ""

msgid ""
"Compare this pixel art which is displayed with the ``viewport`` stretch "
"mode, with the stretch scale mode set to ``fractional``:"
msgstr ""

msgid "Fractional scaling example (incorrect pixel art appearance)"
msgstr ""

msgid ""
"Checkerboard doesn't look \"even\". Line widths in the logo and text varies "
"wildly."
msgstr ""

msgid ""
"This pixel art is also displayed with the ``viewport`` stretch mode, but the "
"stretch scale mode is set to ``integer`` this time:"
msgstr ""

msgid "Integer scaling example (correct pixel art appearance)"
msgstr ""

msgid "Checkerboard looks perfectly even. Line widths are consistent."
msgstr ""

msgid ""
"For example, if your viewport base size is 640×360 and the window size is "
"1366×768:"
msgstr ""

msgid ""
"When using ``fractional``, the viewport is displayed at a resolution of "
"1366×768 (scale factor is roughly 2.133×). The entire window space is used. "
"Each pixel in the viewport corresponds to 2.133×2.133 pixels in the "
"displayed area. However, since displays can only display \"whole\" pixels, "
"this will lead to uneven pixel scaling which results in incorrect appearance "
"of pixel art."
msgstr ""

msgid ""
"When using ``integer``, the viewport is displayed at a resolution of "
"1280×720 (scale factor is 2×). The remaining space is filled with black bars "
"on all four sides, so that each pixel in the viewport corresponds to 2×2 "
"pixels in the displayed area."
msgstr ""

msgid ""
"This setting is effective with any stretch mode. However, when using the "
"``disabled`` stretch mode, it will only affect the **Stretch Scale** setting "
"by rounding it *down* to the nearest integer value. This can be used for 3D "
"games that have a pixel art UI, so that the visible area in the 3D viewport "
"doesn't reduce in size (which occurs when using ``canvas_items`` or "
"``viewport`` stretch mode with the ``integer`` scale mode)."
msgstr ""

msgid ""
"Games should use the **Exclusive Fullscreen** window mode, as opposed to "
"**Fullscreen** which is designed to prevent Windows from automatically "
"treating the window as if it was exclusive fullscreen."
msgstr ""

msgid ""
"**Fullscreen** is meant to be used by GUI applications that want to use per-"
"pixel transparency without a risk of having it disabled by the OS. It "
"achieves this by leaving a 1-pixel line at the bottom of the screen. By "
"contrast, **Exclusive Fullscreen** uses the actual screen size and allows "
"Windows to reduce jitter and input lag for fullscreen games."
msgstr ""

msgid ""
"When using integer scaling, this is particularly important as the 1-pixel "
"height reduction from the **Fullscreen** mode can cause integer scaling to "
"use a smaller scale factor than expected."
msgstr ""

msgid "Common use case scenarios"
msgstr "常見使用場景"

msgid ""
"The following settings are recommended to support multiple resolutions and "
"aspect ratios well."
msgstr "建議使用以下設定以更好地支援多種分辨率和縱橫比。"

msgid "Desktop game"
msgstr "桌面遊戲"

msgid "**Non-pixel art:**"
msgstr "**非像素風：**"

msgid ""
"Set the base window width to ``1920`` and window height to ``1080``. If you "
"have a display smaller than 1920×1080, set **Window Width Override** and "
"**Window Height Override** to lower values to make the window smaller when "
"the project starts."
msgstr ""
"將基礎視窗寬度設定為 ``1920``、視窗高度設定為 ``1080``。如果你的顯示器小於 "
"1920×1080，就將 **Test Width** 和 **Test Height**（測試寬度和測試高度）設定為"
"較小的值，專案啟動時就會將視窗調小。"

msgid ""
"Alternatively, if you're targeting high-end devices primarily, set the base "
"window width to ``3840`` and window height to ``2160``. This allows you to "
"provide higher resolution 2D assets, resulting in crisper visuals at the "
"cost of higher memory usage and file sizes. Note that this will make non-"
"mipmapped textures grainy on low resolution devices, so make sure to follow "
"the instructions described in :ref:"
"`doc_multiple_resolutions_reducing_aliasing_on_downsampling`."
msgstr ""
"或者如果你主要針對的是高端裝置，那麼就把基礎視窗寬度設定為 ``3840``、視窗高度"
"設定為 ``2160`` 。這樣你就可以提供更高解析度的 2D 素材，用更高的記憶體佔用和"
"檔大小換取更清晰的畫面。注意，這樣做會讓未做 mipmap 的紋理在低解析度裝置上具"
"有顆粒感，請參考 :ref:"
"`doc_multiple_resolutions_reducing_aliasing_on_downsampling` 進行操作。"

msgid "Set the stretch mode to ``canvas_items``."
msgstr "將拉伸模式（Stretch Mode）設定為 ``viewport`` （視圖）。"

msgid ""
"Set the stretch aspect to ``expand``. This allows for supporting multiple "
"aspect ratios and makes better use of tall smartphone displays (such as 18:9 "
"or 19:9 aspect ratios)."
msgstr ""
"將拉伸比例（Stretch Aspect）設定為 ``expand`` （擴充）。這樣可以支援多種解析"
"度，並且能夠更好地利用較長的智慧手機螢幕（例如 18:9 和 19:9 的長寬比）。"

msgid ""
"Configure Control nodes' anchors to snap to the correct corners using the "
"**Layout** menu."
msgstr "使用 **佈局** 功能表將 Control 節點的錨點吸附到正確的角落。"

msgid "**Pixel art:**"
msgstr "**PCK 格式:**"

#, fuzzy
msgid ""
"Set the base window size to the viewport size you intend to use. Most pixel "
"art games use viewport sizes between 256×224 and 640×480. 640×360 is a good "
"baseline, as it scales to 1280×720, 1920×1080, 2560×1440, and 3840×2160 "
"without any black bars when using integer scaling. Higher viewport sizes "
"will require using higher resolution artwork, unless you intend to show more "
"of the game world at a given time."
msgstr ""
"將基礎視窗大小設定為你想要使用的視圖尺寸。多數像素風遊戲使用的視圖尺寸在 "
"256×224 和 640×480 之間。視圖尺寸越大，所需素材的解析度也就越高，除非你想要顯"
"示更大的遊戲世界區域。"

msgid "Set the stretch mode to ``viewport``."
msgstr "將拉伸模式（Stretch Mode）設定為 ``viewport`` （視圖）。"

msgid ""
"Set the stretch aspect to ``keep`` to enforce a single aspect ratio (with "
"black bars). As an alternative, you can set the stretch aspect to ``expand`` "
"to support multiple aspect ratios."
msgstr ""
"將拉伸比例（Stretch Aspect）設定為 ``keep`` （保持）可以（通過新增黑條的方"
"式）強制使用固定的長寬比。如果你想支援不同長寬比的話，也可以把拉伸模式設定為 "
"``expand`` （擴充）。"

msgid ""
"If using the ``expand`` stretch aspect, Configure Control nodes' anchors to "
"snap to the correct corners using the **Layout** menu."
msgstr ""
"如果選用 ``expand`` 拉伸比例，使用 **佈局** 功能表將 Control 節點的錨點吸附到"
"正確的角落。"

msgid ""
"Set the stretch scale mode to ``integer``. This prevents uneven pixel "
"scaling from occurring, which makes pixel art not display as intended."
msgstr ""

msgid ""
"The ``viewport`` stretch mode provides low-resolution rendering that is then "
"stretched to the final window size. If you are OK with sprites being able to "
"move or rotate in \"sub-pixel\" positions or wish to have a high resolution "
"3D viewport, you should use the ``canvas_items`` stretch mode instead of the "
"``viewport`` stretch mode."
msgstr ""
"``viewport`` 拉伸模式會先以較低解析度算繪，然後拉伸到最終視窗的大小。如果你能"
"夠接受精靈可以移動或者旋轉到“次像素”位置，或者希望有高解析度的 3D 視圖，可以"
"把 ``viewport`` 拉伸模式換成 ``2d`` 模式。"

msgid "Mobile game in landscape mode"
msgstr "橫屏的手機遊戲"

msgid ""
"Godot is configured to use landscape mode by default. This means you don't "
"need to change the display orientation project setting."
msgstr "Godot 預設使用橫屏模式，所以你無需在專案設定中調整顯示方向。"

msgid "Set the base window width to ``1280`` and window height to ``720``."
msgstr "將基礎視窗寬度設定為 ``1280``，視窗高度設定為 ``720``。"

msgid ""
"Alternatively, if you're targeting high-end devices primarily, set the base "
"window width to ``1920`` and window height to ``1080``. This allows you to "
"provide higher resolution 2D assets, resulting in crisper visuals at the "
"cost of higher memory usage and file sizes. Many devices have even higher "
"resolution displays (1440p), but the difference with 1080p is barely visible "
"given the small size of smartphone displays. Note that this will make non-"
"mipmapped textures grainy on low resolution devices, so make sure to follow "
"the instructions described in :ref:"
"`doc_multiple_resolutions_reducing_aliasing_on_downsampling`."
msgstr ""
"或者如果你主要針對的是高端裝置，那麼就把基礎視窗寬度設定為 ``1920``、視窗高度"
"設定為 ``1080``。這樣你就可以提供更高解析度的 2D 素材，用更高的記憶體佔用和檔"
"大小換取更清晰的畫面。很多裝置擁有更高解析度的顯示幕（1440p），但因為智慧手機"
"的螢幕比較小，所以很難看出和 1080p 的區別。注意，這樣做會讓未做 mipmap 的紋理"
"在低解析度裝置上具有顆粒感，請參考 :ref:"
"`doc_multiple_resolutions_reducing_aliasing_on_downsampling` 進行操作。"

msgid ""
"To better support tablets and foldable phones (which frequently feature "
"displays with aspect ratios close to 4:3), consider using a base resolution "
"that has a 4:3 aspect ratio while following the rest of the instructions "
"here. For instance, you can set the base window width to ``1280`` and the "
"base window height to ``960``."
msgstr ""
"為了更好地支援平板電腦和可折疊手機（其顯示器的寬高比通常接近 4:3），請考慮使"
"用寬高比為 4:3 的基本分辨率，同時遵循此處的其餘說明。例如，您可以將基本視窗寬"
"度設為“1280”，將基本視窗高度設定為“960”。"

msgid "Mobile game in portrait mode"
msgstr "豎屏的手機遊戲"

msgid "Set the base window width to ``720`` and window height to ``1280``."
msgstr "將基礎視窗寬度設定為 ``720``，視窗高度設定為 ``1080``。"

msgid ""
"Alternatively, if you're targeting high-end devices primarily, set the base "
"window width to ``1080`` and window height to ``1920``. This allows you to "
"provide higher resolution 2D assets, resulting in crisper visuals at the "
"cost of higher memory usage and file sizes. Many devices have even higher "
"resolution displays (1440p), but the difference with 1080p is barely visible "
"given the small size of smartphone displays. Note that this will make non-"
"mipmapped textures grainy on low resolution devices, so make sure to follow "
"the instructions described in :ref:"
"`doc_multiple_resolutions_reducing_aliasing_on_downsampling`."
msgstr ""
"或者如果你主要針對的是高端裝置，那麼就把基礎視窗寬度設定為 ``1080``、視窗高度"
"設定為 ``1920``。這樣你就可以提供更高解析度的 2D 素材，用更高的記憶體佔用和檔"
"大小換取更清晰的畫面。很多裝置擁有更高解析度的顯示幕（1440p），但因為智慧手機"
"的螢幕比較小，所以很難看出和 1080p 的區別。注意，這樣做會讓未做 mipmap 的紋理"
"在低解析度裝置上具有顆粒感，請參考 :ref:"
"`doc_multiple_resolutions_reducing_aliasing_on_downsampling` 進行操作。"

msgid "Set **Display > Window > Handheld > Orientation** to ``portrait``."
msgstr ""
"將 **Display > Window > Handheld > Orientation** 設定為 ``portrait`` （豎"
"屏）。"

msgid ""
"To better support tablets and foldable phones (which frequently feature "
"displays with aspect ratios close to 4:3), consider using a base resolution "
"that has a 3:4 aspect ratio while following the rest of the instructions "
"here. For instance, you can set the base window width to ``960`` and the "
"base window height to ``1280``."
msgstr ""
"為了更好地支援平板電腦和可折疊手機（其顯示器的寬高比通常接近 4:3），請考慮使"
"用寬高比為 3:4 的基本分辨率，同時遵循此處的其餘說明。例如，您可以將基本視窗寬"
"度設為“960”，將基本視窗高度設定為“1280”。"

msgid "Non-game application"
msgstr "語言規範"

msgid ""
"Set the base window width and height to the smallest window size that you "
"intend to target. This is not required, but this ensures that you design "
"your UI with small window sizes in mind."
msgstr ""
"將基礎視窗寬高設定為你想要支援的最小視窗尺寸。這不是必須的，但是可以保證你在"
"設計 UI 時考慮較小的視窗尺寸。"

msgid "Keep the stretch mode to its default value, ``disabled``."
msgstr "保持拉伸模式（Stretch Mode）為預設值 ``disabled``（禁用）。"

msgid ""
"Keep the stretch aspect to its default value, ``ignore`` (its value won't be "
"used since the stretch mode is ``disabled``)."
msgstr ""
"保持拉伸比例（Stretch Aspect）為預設值 ``ignore（忽略）`` （因為拉伸模式是 "
"``disabled`` ，所以這裡的值不會被用到）。"

msgid ""
"You can define a minimum window size by setting ``OS.min_window_size`` in a "
"script's ``_ready()`` function. This prevents the user from resizing the "
"application below a certain size, which could break the UI layout."
msgstr ""
"你可以在腳本的 ``_ready()`` 函式中通過設定 ``OS.min_window_size`` 來定義視窗"
"的最小尺寸。這樣可以防止使用者將應用視窗縮得過小，導致 UI 佈局的問題。"

msgid ""
"Godot doesn't support manually overriding the 2D scale factor yet, so it is "
"not possible to have hiDPI support in non-game applications. Due to this, it "
"is recommended to leave **Allow Hidpi** disabled in non-game applications to "
"allow for the OS to use its low-DPI fallback."
msgstr ""
"Godot 尚未支援手動設定 2D 縮放比例，所以無法在非遊戲應用中支援 hiDPI。因此，"
"推薦為非遊戲應用禁用 **Allow Hidpi** 選項，作業系統會退回到低 DPI。"

msgid "hiDPI support"
msgstr "支援平台"

msgid ""
"By default, Godot projects aren't considered DPI-aware by the operating "
"system. This is done to improve performance on low-end systems, since the "
"operating system's DPI fallback scaling will be faster than letting the "
"application scale itself (even when using the ``viewport`` stretch mode)."
msgstr ""
"預設情況下，作業系統會認為 Godot 專案是 DPI 無關的。因為作業系統的 DPI 退回縮"
"放比讓應用程式自己做縮放要快很多（即便用的是 ``viewport`` 拉伸模式），所以這"
"樣做可以提高在低端系統上的性能。"

msgid ""
"However, the OS-provided DPI fallback scaling doesn't play well with "
"fullscreen mode. If you want crisp visuals on hiDPI displays or if project "
"uses fullscreen, it's recommended to enable **Display > Window > Dpi > Allow "
"Hidpi** in the Project Settings."
msgstr ""
"不過作業系統的 DPI 退回縮放功能在全屏模式下並不好用。如果你想在 hiDPI 顯示器"
"下得到清晰的畫面，又或者想要支援全屏，那麼推薦啟用專案設定中的 **Display > "
"Window > Dpi > Allow Hidpi** 。"

msgid ""
"**Allow Hidpi** is only effective on Windows and macOS. It's ignored on all "
"other platforms."
msgstr ""
"**Allow Hidpi（允許 hiDPI）** 僅在 Windows 和 macOS 上有效，其它平臺會忽略這"
"個選項。"

msgid ""
"The Godot editor itself is always marked as DPI-aware. Running the project "
"from the editor will only be DPI-aware if **Allow Hidpi** is enabled in the "
"Project Settings."
msgstr ""
"Godot 編輯器本身是打開了這個選項，與 DPI 相關的。但在編輯器中運作專案時，只有"
"在專案設定裡啟用 **Allow Hidpi** 才會讓專案與 DPI 相關。"

msgid "Reducing aliasing on downsampling"
msgstr "減少縮減取樣的混疊"

msgid ""
"If the game has a very high base resolution (e.g. 3840×2160), aliasing might "
"appear when downsampling to something considerably lower like 1280×720."
msgstr ""
"如果遊戲的基本解析度很高（如 3840×2160），當取樣降到相當低的解析度（如 "
"1280×720）時，可能會出現鋸齒。可以通過在載入時將所有圖像縮小 2 倍來減少鋸齒的"
"出現。這可以通過在載入遊戲資料之前呼叫下面的方法來實作。"

#, fuzzy
msgid ""
"To resolve this, you can :ref:`enable mipmaps "
"<doc_importing_images_mipmaps>` on all your 2D textures. However, enabling "
"mipmaps will increase memory usage which can be an issue on low-end mobile "
"devices."
msgstr ""
"或者, 也可以在所有2D紋理上啟用mipmap. 然而, 啟用mipmap會增加記憶體的使用量, "
"這個在低端移動裝置上可能會出現問題."

msgid "Handling aspect ratios"
msgstr "處理縱橫比"

msgid ""
"Once scaling for different resolutions is accounted for, make sure that your "
"*user interface* also scales for different aspect ratios. This can be done "
"using :ref:`anchors <doc_size_and_anchors>` and/or :ref:`containers "
"<doc_gui_containers>`."
msgstr ""
"一旦考慮到不同解析度的縮放, 請確保你的 *user interface* 也能為不同的長寬比進"
"行縮放. 這可以使用 :ref:`anchors <doc_size_and_anchors>` 和/或 :ref:"
"`containers <doc_gui_containers>` 來完成."

msgid "Field of view scaling"
msgstr "視場角縮放"

msgid ""
"The 3D Camera node's **Keep Aspect** property defaults to the **Keep "
"Height** scaling mode (also called *Hor+*). This is usually the best value "
"for desktop games and mobile games in landscape mode, as widescreen displays "
"will automatically use a wider field of view."
msgstr ""
"3D相機節點的 **Keep Aspect** 屬性預設為 **Keep Height** 縮放模式(也稱為 "
"*Hor+* ). 在橫屏模式下, 這通常是桌面遊戲和手機遊戲的最佳選擇, 因為寬屏顯示器"
"會自動使用更寬的視野."

msgid ""
"However, if your 3D game is intended to be played in portrait mode, it may "
"make more sense to use **Keep Width** instead (also called *Vert-*). This "
"way, smartphones with an aspect ratio taller than 16:9 (e.g. 19:9) will use "
"a *taller* field of view, which is more logical here."
msgstr ""
"然而, 如果您的3D遊戲打算使用縱向模式, 那麼使用 **Keep Width保持寬度** 稱為"
"( *Vert-* )可能會更有意義. 這樣, 寬高比大於16:9(例如19:9)的智慧手機將使用 *更"
"高* 的視野, 這在這裡更符合邏輯."

msgid "Scaling 2D and 3D elements differently using Viewports"
msgstr "使用視圖埠以不同的方式縮放 2D 和 3D 元素"

msgid ""
"Using multiple Viewport nodes, you can have different scales for various "
"elements. For instance, you can use this to render the 3D world at a low "
"resolution while keeping 2D elements at the native resolution. This can "
"improve performance significantly while keeping the HUD and other 2D "
"elements crisp."
msgstr ""
"使用多個視圖視窗節點, 可以對不同的元素使用不同的比例. 例如, 您可以使用此選項"
"以低解析度算繪3D世界, 同時將2D元素保持在原生解析度. 這可以顯著提高性能, 同時"
"保持HUD和其他2D元素的清晰度."

msgid ""
"This is done by using the root Viewport node only for 2D elements, then "
"creating a Viewport node to display the 3D world and displaying it using a "
"SubViewportContainer or TextureRect node. There will effectively be two "
"viewports in the final project. One upside of using TextureRect over "
"SubViewportContainer is that it allows enable linear filtering. This makes "
"scaled 3D viewports look better in many cases."
msgstr ""
"這是通過只對2D元素使用根Viewport節點, 然後建立一個Viewport節點來顯示3D世界並"
"使用ViewportContainer或TextureRect節點來實作的. 最終專案中實際上將有兩個視圖"
"視窗. 與ViewportContainer相比, 使用TextureRect的一個好處是它允許啟用線性篩"
"選. 這使得縮放的3D視圖視窗在許多情況下看起來更好."

msgid ""
"See the `3D viewport scaling demo <https://github.com/godotengine/godot-demo-"
"projects/tree/master/viewport/3d_scaling>`__ for examples."
msgstr ""
"若欲檢視範例專案，請參考作業系統示範專案： https://github.com/godotengine/"
"godot-demo-projects/tree/master/misc/os_test"

msgid "Translation status"
msgstr "翻譯狀態"
