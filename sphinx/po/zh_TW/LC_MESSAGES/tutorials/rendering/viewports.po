# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using Viewports"
msgstr "使用視口"

msgid "Introduction"
msgstr "前言"

#, fuzzy
msgid ""
"Think of a :ref:`Viewport <class_Viewport>` as a screen onto which the game "
"is projected. In order to see the game, we need to have a surface on which "
"to draw it. That surface is the Root Viewport."
msgstr ""
"將 :ref:`Viewports <class_Viewport>` 想成投影遊戲的螢幕. 為了看到遊戲, 我們需"
"要有一個表面來繪製它, 這個表面是作為根節點的 :ref:`Viewport "
"<class_Viewport>`."

#, fuzzy
msgid ""
":ref:`SubViewports <class_SubViewport>` are a kind of Viewport that can be "
"added to the scene so that there are multiple surfaces to draw on. When we "
"are drawing to a SubViewport, we call it a render target. We can access the "
"contents of a render target by accessing its corresponding :ref:`texture "
"<class_Viewport_method_get_texture>`. By using a SubViewport as render "
"target, we can either render multiple scenes simultaneously or we can render "
"to a :ref:`ViewportTexture <class_ViewportTexture>` which is applied to an "
"object in the scene, for example a dynamic skybox."
msgstr ""
":ref:`Viewports <class_Viewport>` 也可以新增到場景中, 以便繪製多個區域. 當我"
"們繪製到一個不是根節點的 :ref:`Viewport <class_Viewport>` 時, 我們將該視口稱"
"為算繪目標. 我們可以通過存取它對應的 :ref:`texture <class_ViewportTexture>` "
"屬性來存取算繪目標的內容. 將任一 :ref:`Viewport <class_Viewport>` 作為算繪目"
"標時, 我們要麼可以同時算繪多個場景, 要麼可以算繪到場景中某個物件的 :ref:"
"`texture <class_ViewportTexture>` 上, 例如算繪到動態天空盒的材質上."

#, fuzzy
msgid ""
":ref:`SubViewports <class_SubViewport>` have a variety of use cases, "
"including:"
msgstr ":ref:`Viewport <class_Viewport>` 有多種使用情況, 包括:"

msgid "Rendering 3D objects within a 2D game"
msgstr "在2D遊戲中算繪3D物體"

msgid "Rendering 2D elements in a 3D game"
msgstr "在3D遊戲中算繪2D元素"

msgid "Rendering dynamic textures"
msgstr "算繪動態紋理"

msgid "Generating procedural textures at runtime"
msgstr "在運作時生成程式式紋理"

msgid "Rendering multiple cameras in the same scene"
msgstr "在同一場景中算繪多個相機"

msgid ""
"What all these use cases have in common is that you are given the ability to "
"draw objects to a texture as if it were another screen and can then choose "
"what to do with the resulting texture."
msgstr ""
"所有這些用例的共同點是, 你被賦予了在紋理上繪製物體的能力, 就好像它是另一個螢"
"幕一樣, 然後可以選擇如何處理產生的紋理."

msgid ""
"Another kind of Viewports in Godot are :ref:`Windows <class_Window>`. They "
"allow their content to be projected onto a window. While the Root Viewport "
"is a Window, they are less flexible. If you want to use the texture of a "
"Viewport, you'll be working with :ref:`SubViewports <class_SubViewport>` "
"most of the time."
msgstr ""

msgid "Input"
msgstr "輸入"

msgid ""
":ref:`Viewports <class_Viewport>` are also responsible for delivering "
"properly adjusted and scaled input events to their children nodes. By "
"default :ref:`SubViewports <class_SubViewport>` don't automatically receive "
"input, unless they receive it from their direct :ref:`SubViewportContainer "
"<class_SubViewportContainer>` parent node. In this case, input can be "
"disabled with the :ref:`Disable Input "
"<class_Viewport_property_gui_disable_input>` property."
msgstr ""
":ref:`Viewport <class_Viewport>` 也負責將正確調整和縮放的輸入事件傳遞給他們所"
"有的子節點. 通常, 輸入是由樹中最近的 :ref:`Viewport <class_Viewport>` 接收"
"的, 但是你可以通過將 'Disable Input' 選為 'on' 來設定 :ref:`Viewport "
"<class_Viewport>` 不接收輸入；這將允許樹中最近的 :ref:`Viewport "
"<class_Viewport>` 捕捉輸入."

#, fuzzy
msgid ""
"For more information on how Godot handles input, please read the :ref:`Input "
"Event Tutorial <doc_inputevent>`."
msgstr ""
"關於 Godot 如何處理輸入的更多資訊，請閱讀:ref:`輸入事件教學 "
"<doc_inputevent>`。"

msgid "Listener"
msgstr "Listener"

#, fuzzy
msgid ""
"Godot supports 3D sound (in both 2D and 3D nodes). More on this can be found "
"in the :ref:`Audio Streams Tutorial <doc_audio_streams>`. For this type of "
"sound to be audible, the :ref:`Viewport <class_Viewport>` needs to be "
"enabled as a listener (for 2D or 3D). If you are using a :ref:`SubViewport "
"<class_SubViewport>` to display your :ref:`World3D <class_World3D>` or :ref:"
"`World2D <class_World2D>`, don't forget to enable this!"
msgstr ""
"Godot 支援 3D 聲音（在 2D 和 3D 節點中都支援）；更多資訊可以在:ref:`音訊流教"
"學 <doc_audio_streams>`中找到。為了使這種型別的聲音能夠被聽到, :ref:"
"`Viewport <class_Viewport>` 需要被啟用為一個監聽器(對於2D或3D). 如果你使用一"
"個自訂的 :ref:`Viewport <class_Viewport>` 來顯示你的 :ref:`World "
"<class_World>`, 別忘了啟用這個功能！"

msgid "Cameras (2D & 3D)"
msgstr "相機（2D 和 3D）"

#, fuzzy
msgid ""
"When using a :ref:`Camera3D <class_Camera3D>` or :ref:`Camera2D "
"<class_Camera2D>`, it will always display on the closest parent :ref:"
"`Viewport <class_Viewport>` (going towards the root). For example, in the "
"following hierarchy:"
msgstr ""
"當使用 :ref:`Camera <class_Camera>` / :ref:`Camera2D <class_Camera2D>` 時, 相"
"機將始終顯示在最近的父節點上 :ref:`Viewport <class_Viewport>` (朝向根節點). "
"例如, 在下面的層次結構中:"

#, fuzzy
msgid ""
"``CameraA`` will display on the Root :ref:`Viewport <class_Viewport>` and it "
"will draw ``MeshA``. ``CameraB`` will be captured by the :ref:`SubViewport "
"<class_SubViewport>` along with ``MeshB``. Even though ``MeshB`` is in the "
"scene hierarchy, it will still not be drawn to the Root Viewport. Similarly, "
"``MeshA`` will not be visible from the SubViewport because SubViewports only "
"capture nodes below them in the hierarchy."
msgstr ""
"CameraA將顯示根節點的 :ref:`Viewport <class_Viewport>` , 它將繪製MeshA. "
"CameraB將被 :ref:`Viewport <class_Viewport>` 節點以及MeshB捕獲. 即使MeshB在場"
"景層次結構中, 它仍然不會被繪製到根節點的 :ref:`Viewport <class_Viewport>` "
"中. 類似地, 在 :ref:`Viewport <class_Viewport>` 節點中不會看到MeshA, 因為 :"
"ref:`Viewport <class_Viewport>` 節點僅捕獲層次結構中它下面的節點."

#, fuzzy
msgid ""
"There can only be one active camera per :ref:`Viewport <class_Viewport>`, so "
"if there is more than one, make sure that the desired one has the :ref:"
"`current <class_Camera3D_property_current>` property set, or make it the "
"current camera by calling:"
msgstr ""
"每個視口 :ref:`Viewport <class_Viewport>` 只能有一個啟動的相機, 因此, 如果有"
"多個相機時, 請確保您需要的那個相機的 \"current\" 屬性被設定上, 或者通過呼叫以"
"下敘述來使其成為目前相機:"

msgid ""
"By default, cameras will render all objects in their world. In 3D, cameras "
"can use their :ref:`cull_mask <class_Camera3D_property_cull_mask>` property "
"combined with the :ref:`VisualInstance3D's <class_VisualInstance3D>` :ref:"
"`layer <class_VisualInstance3D_property_layers>` property to restrict which "
"objects are rendered."
msgstr ""
"預設情況下, 相機將算繪其世界中的所有物件. 在3D中, 相機可以使用他們的 :ref:"
"`cull_mask <class_Camera_property_cull_mask>` 屬性和 :ref:`VisualInstance's "
"<class_VisualInstance>` :ref:`layer <class_VisualInstance_property_layers>` "
"屬性來限制哪些物件被算繪."

msgid "Scale & stretching"
msgstr "縮放和拉伸"

#, fuzzy
msgid ""
":ref:`SubViewports <class_SubViewport>` have a :ref:"
"`size<class_SubViewport_property_size>` property, which represents the size "
"of the SubViewport in pixels. For SubViewports which are children of :ref:"
"`SubViewportContainers <class_SubViewportContainer>`, these values are "
"overridden, but for all others, this sets their resolution."
msgstr ""
":ref:`Viewport <class_Viewport>` 有一個“size”屬性，表示 :ref:`Viewport "
"<class_Viewport>` 的尺寸，單位為像素。對於 :ref:`SubViewportContainer < "
"class_SubViewportContainer >` 的子 :ref:`Viewport <class_Viewport>` 節點而"
"言，這些值會被覆蓋，但其他情況下，這個屬性設定的就是解析度。"

#, fuzzy
msgid ""
"It is also possible to scale the 2D content and make the :ref:`SubViewport "
"<class_SubViewport>` resolution different from the one specified in size, by "
"calling:"
msgstr ""
"也可以通過呼叫 :ref:`Viewport <class_Viewport>` 來縮放2D內容, 並使其解析度與"
"指定的尺寸不同:"

#, fuzzy
msgid ""
"For information on scaling and stretching with the Root Viewport visit the :"
"ref:`Multiple Resolutions Tutorial <doc_multiple_resolutions>`"
msgstr ""
"根節點的 :ref:`Viewport <class_Viewport>` 用到專案設定中的拉伸選項。有關縮放"
"和拉伸的更多資訊，請存取:ref:`多解析度教學 <doc_multiple_resolutions>`"

msgid "Worlds"
msgstr "世界"

msgid ""
"For 3D, a :ref:`Viewport <class_Viewport>` will contain a :ref:`World3D "
"<class_World3D>`. This is basically the universe that links physics and "
"rendering together. Node3D-based nodes will register using the World3D of "
"the closest Viewport. By default, newly created Viewports do not contain a "
"World3D but use the same as their parent Viewport. The Root Viewport always "
"contains a World3D, which is the one objects are rendered to by default."
msgstr ""

msgid ""
"A :ref:`World3D <class_World3D>` can be set in a :ref:`Viewport "
"<class_Viewport>` using the :ref:`World "
"3D<class_Viewport_property_world_3d>` property, that will separate all "
"children nodes of this :ref:`Viewport <class_Viewport>` and will prevent "
"them from interacting with the parent Viewport's World3D. This is especially "
"useful in scenarios where, for example, you might want to show a separate "
"character in 3D imposed over the game (like in StarCraft)."
msgstr ""

#, fuzzy
msgid ""
"As a helper for situations where you want to create :ref:`Viewports "
"<class_Viewport>` that display single objects and don't want to create a :"
"ref:`World3D <class_World3D>`, Viewport has the option to use its :ref:`Own "
"World3D <class_Viewport_property_own_world_3d>`. This is useful when you "
"want to instance 3D characters or objects in :ref:`World2D <class_World2D>`."
msgstr ""
"作為您想要建立的情況的説明 :ref:`Viewports <class_Viewport>` 顯示單個物件而不"
"想建立 :ref:`World <class_World>`, :ref:`Viewport <class_Viewport>` 可以選擇"
"使用自己的 :ref:`World <class_World>`. 當您想要在2D :ref:`World "
"<class_World2D>` 中產生實體3D角色或對象時, 這非常有用."

#, fuzzy
msgid ""
"For 2D, each :ref:`Viewport <class_Viewport>` always contains its own :ref:"
"`World2D <class_World2D>`. This suffices in most cases, but in case sharing "
"them may be desired, it is possible to do so by setting :ref:"
"`world_2d<class_Viewport_property_world_2d>` on the Viewport through code."
msgstr ""
"對於 2D，每個 :ref:`Viewport <class_Viewport>` 總是包含它自己的 :ref:"
"`World2D <class_World2D>`。這在大多數情況下都足夠了，但是如果需要共用，可以手"
"動設定 :ref:`Viewport <class_Viewport>` 的 :ref:`World2D <class_World2D>`。"

msgid ""
"For an example of how this works, see the demo projects `3D in 2D <https://"
"github.com/godotengine/godot-demo-projects/tree/master/viewport/3d_in_2d>`_ "
"and `2D in 3D <https://github.com/godotengine/godot-demo-projects/tree/"
"master/viewport/2d_in_3d>`_ respectively."
msgstr ""
"關於如何工作的例子, 請分別參閱演示專案 `3D in 2D <https://github.com/"
"godotengine/godot-demo-projects/tree/master/viewport/3d_in_2d>`_ 和 `2D in "
"3D <https://github.com/godotengine/godot-demo-projects/tree/master/"
"viewport/2d_in_3d>`_ ."

msgid "Capture"
msgstr "截取"

#, fuzzy
msgid ""
"It is possible to query a capture of the :ref:`Viewport <class_Viewport>` "
"contents. For the Root Viewport, this is effectively a screen capture. This "
"is done with the following code:"
msgstr ""
"可以查詢 :ref:`Viewport <class_Viewport>` 內容的捕獲. 對於根 :ref:`Viewport "
"<class_Viewport>` , 這實際上是一個螢幕截圖. 這可以通過以下程式碼完成:"

msgid ""
"But if you use this in ``_ready()`` or from the first frame of the :ref:"
"`Viewport's <class_Viewport>` initialization, you will get an empty texture "
"because there is nothing to get as texture. You can deal with it using (for "
"example):"
msgstr ""
"但是如果你在 ``_ready()`` 中使用, 或者從 :ref:`Viewport 的 <class_Viewport>` "
"初始化的第一影格開始使用, 你會得到一個空的紋理, 因為沒有什麼可以作為紋理獲"
"得. 你可以用來處理它, 例如:"

msgid "Viewport Container"
msgstr "視口容器"

#, fuzzy
msgid ""
"If the :ref:`SubViewport <class_SubViewport>` is a child of a :ref:"
"`SubViewportContainer <class_SubViewportContainer>`, it will become active "
"and display anything it has inside. The layout looks like this:"
msgstr ""
"如果 :ref:`Viewport <class_Viewport>` 是 :ref:`ViewportContainer "
"<class_viewportcontainer>` 的子節點, 它將變為活動狀態並顯示其內部的任何內容. "
"佈局看起來像這樣:"

#, fuzzy
msgid ""
"The :ref:`SubViewport <class_SubViewport>` will cover the area of its "
"parent :ref:`SubViewportContainer <class_SubViewportContainer>` completely "
"if :ref:`Stretch<class_SubViewportContainer_property_stretch>` is set to "
"``true`` in the SubViewportContainer."
msgstr ""
"如果 :ref:`ViewportContainer <class_viewportcontainer>` 的 :ref:"
"`Stretch<class_viewportcontainer_property_stretch>` 為 ``true``，那麼 :ref:"
"`Viewport <class_Viewport>` 就會完全覆蓋這個父 :ref:`ViewportContainer "
"<class_viewportcontainer>`。注意：該 :ref:`ViewportContainer "
"<class_viewportcontainer>` 的大小不能小於 :ref:`Viewport <class_Viewport>` 的"
"大小。"

msgid ""
"The size of the :ref:`SubViewportContainer <class_SubViewportContainer>` "
"cannot be smaller than the size of the :ref:`SubViewport "
"<class_SubViewport>`."
msgstr ""

msgid "Rendering"
msgstr "算繪"

#, fuzzy
msgid ""
"Due to the fact that the :ref:`Viewport <class_Viewport>` is an entryway "
"into another rendering surface, it exposes a few rendering properties that "
"can be different from the project settings. You can choose to use a "
"different level of :ref:`MSAA <class_Viewport_property_msaa_2d>` for each "
"Viewport. The default behavior is ``Disabled``."
msgstr ""
"由於以下事實 :ref:`Viewport <class_Viewport>` 是進入另一個算繪表面的入口, 它"
"會暴露一些可能與專案設定不同的算繪屬性. 第一個是MSAA, 您可以選擇為每個使用不"
"同級別的MSAA :ref:`Viewport <class_Viewport>`, 預設行為是DISABLED. 您還可以設"
"定 :ref:`Viewport <class_Viewport>` 以使用HDR, 當您想要在紋理中儲存超出0.0 - "
"1.0範圍的值時,HDR非常有用."

#, fuzzy
msgid ""
"If you know that the :ref:`Viewport <class_Viewport>` is only going to be "
"used for 2D, you can :ref:`Disable 3D<class_Viewport_property_disable_3d>`. "
"Godot will then restrict how the Viewport is drawn. Disabling 3D is slightly "
"faster and uses less memory compared to enabled 3D. It's a good idea to "
"disable 3D if your viewport doesn't render anything in 3D."
msgstr ""
"如果你知道 :ref:`Viewport <class_Viewport>` 將被如何使用，可以把它的用法設定"
"為 3D 或 2D。這樣 Godot 就會根據選擇限制 :ref:`Viewport <class_Viewport>` 的"
"繪製方式；預設是 3D。與 3D 使用模式相比，2D使用模式的速度稍快，佔用的記憶體也"
"少。如果視口沒有在 3D 中算繪任何東西，將 :ref:`Viewport <class_Viewport>` 的"
"使用屬性設定為 2D 是一個好主意。"

#, fuzzy
msgid ""
"If you need to render 3D shadows in the viewport, make sure to set the "
"viewport's :ref:"
"`positional_shadow_atlas_size<class_Viewport_property_positional_shadow_atlas_size>` "
"property to a value higher than ``0``. Otherwise, shadows won't be rendered. "
"By default, the equivalent project setting is set to ``4096`` on desktop "
"platforms and ``2048`` on mobile platforms."
msgstr ""
"如果需要在視圖中算繪3D陰影, 請確保將視圖的 *Shadow Atlas Size陰影貼合集大小* "
"屬性設定為大於0的值. 否則, 陰影將不會被算繪. 作為參考, 專案設定預設定義為"
"4096."

#, fuzzy
msgid ""
"Godot also provides a way of customizing how everything is drawn inside :ref:"
"`Viewports <class_Viewport>` using :ref:`Debug "
"Draw<class_Viewport_property_debug_draw>`. Debug Draw allows you to specify "
"a mode which determines how the Viewport will display things drawn inside "
"it. Debug Draw is ``Disabled`` by default. Some other options are "
"``Unshaded``, ``Overdraw``, and ``Wireframe``. For a full list, refer to "
"the :ref:`Viewport Documentation<class_Viewport_property_debug_draw>`."
msgstr ""
"Godot還提供了一種自訂內部繪製方式的方法 :ref:`Viewports <class_Viewport>` 使"
"用\"Debug Draw\". Debug Draw允許您指定以下四個選項之一 :ref:`Viewport "
"<class_Viewport>` 將顯示在其中繪製的內容. 預設情況下禁用Debug Draw."

msgid "**Debug Draw = Disabled** (default): The scene is drawn normally."
msgstr ""

#, fuzzy
msgid ""
"**Debug Draw = Unshaded**: Unshaded draws the scene without using lighting "
"information so all the objects appear flatly colored in their albedo color."
msgstr ""
"其他三個選項是Unhaded,Overdraw和Wireframe. 無陰影在不使用光照資訊的情況下繪製"
"場景, 因此所有物件都顯示為其反射顏色的扁平顏色."

#, fuzzy
msgid ""
"**Debug Draw = Overdraw**: Overdraw draws the meshes semi-transparent with "
"an additive blend so you can see how the meshes overlap."
msgstr "Overdraw 使用加法混合繪製半透明的網格，以便您可以看到網格重疊的方式。"

#, fuzzy
msgid ""
"**Debug Draw = Wireframe**: Wireframe draws the scene using only the edges "
"of triangles in the meshes."
msgstr "最後, 繪製的場景中線框僅使用網格中裡邊緣的三角形."

msgid ""
"Debug Draw modes are currently **not** supported when using the "
"Compatibility rendering method. They will appear as regular draw modes."
msgstr ""

msgid "Render target"
msgstr "算繪目標"

#, fuzzy
msgid ""
"When rendering to a :ref:`SubViewport <class_SubViewport>`, whatever is "
"inside will not be visible in the scene editor. To display the contents, you "
"have to draw the SubViewport's :ref:`ViewportTexture "
"<class_ViewportTexture>` somewhere. This can be requested via code using "
"(for example):"
msgstr ""
"當算繪到一個 :ref:`Viewport <class_Viewport>` 時, 裡面的東西在場景編輯器中是"
"看不到的. 為了顯示內容, 你必須在某個地方繪製 :ref:`Viewport's "
"<class_Viewport>` :ref:`ViewportTexture <class_ViewportTexture>`. 這可以通過"
"程式碼使用, 例如:"

msgid ""
"Or it can be assigned in the editor by selecting \"New ViewportTexture\""
msgstr "或者可以通過選擇\"New ViewportTexture\"在編輯器中指定它"

msgid ""
"and then selecting the :ref:`Viewport <class_Viewport>` you want to use."
msgstr "然後選擇您想要使用的 :ref:`Viewport <class_Viewport>`."

#, fuzzy
msgid ""
"Every frame, the :ref:`Viewport's <class_Viewport>` texture is cleared away "
"with the default clear color (or a transparent color if :ref:`Transparent "
"BG<class_Viewport_property_transparent_bg>` is set to ``true``). This can be "
"changed by setting :ref:`Clear "
"Mode<class_SubViewport_property_render_target_clear_mode>` to ``Never`` or "
"``Next Frame``. As the name implies, Never means the texture will never be "
"cleared, while next frame will clear the texture on the next frame and then "
"set itself to Never."
msgstr ""
"每一影格, :ref:`Viewport <class_Viewport>` 的紋理都會被清除, 並使用預設的透明"
"色(或者如果 :ref:`Transparent Bg<class_Viewport_property_transparent_bg>` 被"
"設定為 ``true`` ). 這可以通過設定 :ref:`Clear "
"Mode<class_Viewport_property_render_target_clear_mode>` 為Never或Next Frame來"
"改變. 顧名思義,Never意味著紋理將永遠不會被清除, 而Next Frame將在下一影格清除"
"紋理, 然後將自己設定為Never."

#, fuzzy
msgid ""
"By default, re-rendering of the :ref:`SubViewport <class_SubViewport>` "
"happens when its :ref:`ViewportTexture <class_ViewportTexture>` has been "
"drawn in a frame. If visible, it will be rendered, otherwise, it will not. "
"This behavior can be changed by setting :ref:`Update "
"Mode<class_SubViewport_property_render_target_update_mode>` to ``Never``, "
"``Once``, ``Always``, or ``When Parent Visible``. Never and Always will "
"never or always re-render respectively. Once will re-render the next frame "
"and change to Never afterwards. This can be used to manually update the "
"Viewport. This flexibility allows users to render an image once and then use "
"the texture without incurring the cost of rendering every frame."
msgstr ""
"預設情況下，:ref:`Viewport <class_Viewport>` 的重新算繪會發生在 :ref:"
"`Viewport <class_Viewport>` 的 :ref:`ViewportTexture "
"<class_ViewportTexture>` 在一影格中被繪製時。可見是會算繪；不可見時則不會。這"
"個行為可以改為手動算繪（單次）或者無論是否可見總是算繪。這種靈活性使使用者可"
"以算繪一次圖像，然後使用紋理，而不需要承擔每一影格算繪的消耗。"

#, fuzzy
msgid ""
"Make sure to check the Viewport demos. They are available in the viewport "
"folder of the demos archive, or at https://github.com/godotengine/godot-demo-"
"projects/tree/master/viewport."
msgstr ""
"一定要查看Viewport演示！ 可以下載演示檔案中的Viewport資料夾, 或https://"
"github.com/godotengine/godot-demo-projects/tree/master/viewport"

msgid "Translation status"
msgstr "翻譯狀態"
