# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Occlusion culling"
msgstr "遮擋剔除"

msgid ""
"In a 3D rendering engine, **occlusion culling** is the process of performing "
"hidden geometry removal."
msgstr "在 3D 算繪引擎中，**遮蔽剔除**是執行隱藏幾何體移除的過程。"

msgid "On this page, you'll learn:"
msgstr "在本指南中，我們將學到："

msgid "What are the advantages and pitfalls of occlusion culling."
msgstr "什麼是遮擋剔除的優點缺點。"

msgid "How to set up occlusion culling in Godot."
msgstr "如何在 Godot 中設定遮擋剔除。"

msgid "Troubleshooting common issues with occlusion culling."
msgstr "**解決 Godot 中控制器的問題**。"

msgid ""
"You can see how occlusion culling works in action using the `Occlusion "
"Culling and Mesh LOD demo project <https://github.com/godotengine/godot-demo-"
"projects/tree/master/3d/occlusion_culling_mesh_lod>`__."
msgstr ""
"除了這份說明文件，你可能也會想看看 `Godot Demo 專案 <https://github.com/"
"godotengine/godot-demo-projects>`_ 。"

msgid "Why use occlusion culling"
msgstr "遮擋模式"

msgid ""
"In this example scene with hundreds of rooms stacked next to each other, a "
"dynamic object (red sphere) is hidden behind the wall in the lit room (on "
"the left of the door):"
msgstr ""
"在這個有數百個房間相鄰堆疊的範例場景中，一個動態物件（紅色球體）隱藏在明亮房"
"間的牆後面（在門的左側）："

msgid "Example scene with an occlusion culling-friendly layout"
msgstr "具有遮擋剔除友好佈局的範例場景"

msgid ""
"With occlusion culling disabled, all the rooms behind the lit room have to "
"be rendered. The dynamic object also has to be rendered:"
msgstr "停用遮擋剔除後，必須算繪照亮房間後方的所有房間。動態物件也必須被算繪："

msgid "Example scene with occlusion culling disabled (wireframe)"
msgstr "停用遮擋剔除的範例場景（線框）"

msgid "Example scene with occlusion culling **disabled** (wireframe)"
msgstr "遮擋剔除**停用**的範例場景（線框）"

msgid ""
"With occlusion culling enabled, only the rooms that are actually visible "
"have to be rendered. The dynamic object is also occluded by the wall, and "
"therefore no longer has to be rendered:"
msgstr ""
"啟用遮擋剔除後，只需算繪實際可見的房間。動態物件也被牆壁遮擋，因此不再需要算"
"繪："

msgid "Example scene with occlusion culling enabled (wireframe)"
msgstr "啟用遮擋剔除的範例場景（線框）"

msgid "Example scene with occlusion culling **enabled** (wireframe)"
msgstr "**啟用**的遮蔽剔除範例場景（線框）"

msgid ""
"Since the engine has less work to do (fewer vertices to render and fewer "
"draw calls), performance will increase as long as there are enough occlusion "
"culling opportunities in the scene. This means occlusion culling is most "
"effective in indoor scenes, preferably with many smaller rooms instead of "
"fewer larger rooms. Combine this with :ref:`doc_mesh_lod` and :ref:"
"`doc_visibility_ranges` to further improve performance gains."
msgstr ""
"由於引擎要做的工作較少（需要算繪的頂點較少，繪製呼叫也較少），因此只要場景中"
"有足夠的遮擋剔除機會，效能就會提高。這意味著遮擋剔除在室內場景中最有效，最好"
"有許多較小的房間，而不是較少的較大房間。將此與 doc_mesh_lod 和 "
"doc_visibility_ranges 結合起來，可以進一步提高效能效益。"

msgid ""
"When using the Clustered Forward rendering backend, the engine already "
"performs a *depth prepass*. This consists in rendering a depth-only version "
"of the scene before rendering the scene's actual materials. This is used to "
"ensure each opaque pixel is only shaded once, reducing the cost of overdraw "
"significantly."
msgstr ""
"當使用叢集前向算繪後端時，引擎已經執行了*深度預通道*。這包括在算繪場景的實際"
"材質之前算繪場景的僅深度版本。這用於確保每個不透明像素僅著色一次，從而顯著降"
"低過度繪製的成本。"

msgid ""
"The greatest performance benefits can be observed when using the Forward "
"Mobile rendering backend, as it does not feature a depth prepass for "
"performance reasons. As a result, occlusion culling will actively decrease "
"shading overdraw with that rendering backend."
msgstr ""
"使用 Forward Mobile 算繪後端時可以觀察到最大的效能優勢，因為出於效能原因，它"
"不具有深度預通道。因此，遮蔽剔除將主動減少算繪後端的著色過度繪製。"

msgid ""
"Nonetheless, even when using a depth prepass, there is still a noticeable "
"benefit to occlusion culling in complex 3D scenes. However, in scenes with "
"few occlusion culling opportunities, occlusion culling may not be worth the "
"added setup and CPU usage."
msgstr ""
"儘管如此，即使使用深度預通道，複雜 3D 場景中的遮蔽剔除仍然具有明顯的優勢。然"
"而，在遮蔽剔除機會很少的場景中，遮蔽剔除可能不值得增加設定和 CPU 使用率。"

msgid "How occlusion culling works in Godot"
msgstr "遮擋模式"

msgid ""
"*\"occluder\" refers to the shape blocking the view, while \"occludee\" "
"refers to the object being hidden.*"
msgstr "*「遮擋物」是指遮擋視線的形狀，而「被遮擋物」是指被隱藏的物體。*"

msgid ""
"In Godot, occlusion culling works by rasterizing the scene's occluder "
"geometry to a low-resolution buffer on the CPU. This is done using the "
"software raytracing library `Embree <https://github.com/embree/embree>`__."
msgstr ""
"在 Godot 中，遮蔽剔除的工作原理是將場景的遮蔽幾何圖形光柵化到 CPU 上的低解析"
"度緩衝區。這是使用軟體光線追蹤庫 `Embree <https://github.com/embree/"
"embree>`__ 完成的。"

msgid ""
"The engine then uses this low-resolution buffer to test occludees' :abbr:"
"`AABB (Axis-Aligned Bounding Box)` against the occluder shapes. The "
"occludee's :abbr:`AABB (Axis-Aligned Bounding Box)` must be *fully occluded* "
"by the occluder shape to be culled."
msgstr ""
"然後，引擎使用此低解析度緩衝區來測試遮擋物的 AABB（軸對齊邊界框）與遮擋物形"
"狀。被遮擋物的 AABB（軸對齊邊界框）必須被要剔除的遮擋物形狀「完全遮擋」。"

msgid ""
"As a result, smaller objects are more likely to be effectively culled than "
"larger objects. Larger occluders (such as walls) also tend to be much more "
"effective than smaller ones (such as decoration props)."
msgstr ""
"因此，較小的物件比較大的物件更有可能被有效剔除。較大的遮蔽物（例如牆壁）也往"
"往比較小的遮擋物（例如裝飾道具）更有效。"

msgid "Setting up occlusion culling"
msgstr "遮擋模式"

msgid ""
"The first step to using occlusion culling is to enable the **Rendering > "
"**Occlusion Culling > Use Occlusion Culling** project setting. (Make sure "
"the **Advanced** toggle is enabled in the Project Settings dialog to be able "
"to see it.)"
msgstr ""
"使用遮蔽剔除的第一步是啟用 **算繪 > **遮蔽剔除 > 使用遮蔽剔除** 專案設定。 "
"（確保在“專案設定”對話框中啟用“**高級**”開關才能看到它。）"

msgid ""
"This project setting applies immediately, so you don't need to restart the "
"editor."
msgstr "專案設定會立即應用，無需重啟編輯器。"

msgid ""
"After enabling the project setting, you still need to create some occluders. "
"For performance reasons, the engine doesn't automatically use all visible "
"geometry as a basis for occlusion culling. Instead, the engine requires a "
"simplified representation of the scene with only static objects to be baked."
msgstr ""
"啟用專案設定後，您仍然需要建立一些遮蔽物。出於性能原因，引擎不會自動使用所有"
"可見幾何體作為遮擋剔除的基礎。相反，引擎需要簡化的場景表示，僅需要烘焙靜態物"
"件。"

msgid "There are two ways to set up occluders in a scene:"
msgstr "有兩種方法可以為伺服器匯出專案："

msgid "Automatically baking occluders (recommended)"
msgstr "自動烘焙遮擋物（建議）"

msgid ""
"Only MeshInstance3D nodes are currently taken into account in the *occluder* "
"baking process. MultiMeshInstance3D, GPUParticles3D, CPUParticles3D and CSG "
"nodes are **not** taken into account when baking occluders. If you wish "
"those to be treated as occluders, you have to manually create occluder "
"shapes that (roughly) match their geometry."
msgstr ""
"目前*遮擋器*烘焙過程中僅考慮 MeshInstance3D 節點。烘焙遮蔽物時，**不**考慮 "
"MultiMeshInstance3D、GPUParticles3D、CPUParticles3D 和 CSG 節點。如果您希望將"
"它們視為遮擋物，則必須手動建立（大致）以配對其幾何形狀的遮擋物形狀。"

msgid ""
"This restriction does not apply to *occludees*. Any node type that inherits "
"from GeometryInstance3D can be occluded."
msgstr ""
"此限制不適用於*被遮蔽者*。任何繼承自 GeometryInstance3D 的節點型別都可以被遮"
"蔽。"

msgid ""
"After enabling the occlusion culling project setting mentioned above, add an "
"OccluderInstance3D node to the scene containing your 3D level."
msgstr ""
"啟用上述遮擋剔除專案設定後，將 OcclusionrInstance3D 節點新增至包含 3D 關卡的"
"場景。"

msgid ""
"Select the OccluderInstance3D node, then click **Bake Occluders** at the top "
"of the 3D editor viewport. After baking, the OccluderInstance3D node will "
"contain an Occluder3D resource that stores a simplified version of your "
"level's geometry. This occluder geometry appears as purple wireframe lines "
"in the 3D view (as long as **View Gizmos** is enabled in the **Perspective** "
"menu). This geometry is then used to provide occlusion culling for both "
"static and dynamic occludees."
msgstr ""
"選擇 OccluderInstance3D 節點，然後點擊 3D 編輯器視窗頂部的 **Bake "
"Occlusionrs**。烘焙後，OccluderInstance3D 節點將包含一個 Occluder3D 資源，用"
"於儲存關卡幾何的簡化版本。此遮擋物幾何體在 3D 視圖中顯示為紫色線框線（只要在 "
"**透視** 選單中啟用 **查看 Gizmos**）。然後使用此幾何體為靜態和動態被遮蔽物提"
"供遮蔽剔除。"

msgid ""
"After baking, you may notice that your dynamic objects (such as the player, "
"enemies, etc…) are included in the baked mesh. To prevent this, set the "
"**Bake > Cull Mask** property on the OccluderInstance3D to exclude certain "
"visual layers from being baked."
msgstr ""
"烘焙後，您可能會注意到動態物件（例如玩家、敵人等）包含在烘焙的網格中。為了防"
"止這種情況發生，請在 OccluderInstance3D 上設定 **Bake > Cull Mask** 屬性，以"
"排除某些視覺層的烘焙。"

msgid ""
"For example, you can disable layer 2 on the cull mask, then configure your "
"dynamic objects' MeshInstance3D nodes to be located on the visual layer 2 "
"(instead of layer 1). To do so, select the MeshInstance3D node in question, "
"then on the **VisualInstance3D > Layers** property, uncheck layer 1 then "
"check layer 2. After configuring both cull mask and layers, bake occluders "
"again by following the above process."
msgstr ""
"例如，您可以停用剔除蒙版上的第 2 層，然後將動態物件的 MeshInstance3D 節點配置"
"為位於視覺層 2（而非第 1 層）上。為此，請選擇相關的MeshInstance3D 節點，然後"
"在**VisualInstance3D > Layers** 屬性上，取消選取圖層1，然後選取圖層2。配置剔"
"除遮罩和圖層後，依照上述流程再次烘焙遮擋物。"

msgid "Manually placing occluders"
msgstr "多預留位置"

msgid ""
"This approach is more suited for specialized use cases, such as creating "
"occlusion for MultiMeshInstance3D setups or CSG nodes (due to the "
"aforementioned limitation)."
msgstr ""
"這種方法更適合專門的用例，例如為 MultiMeshInstance3D 設定或 CSG 節點建立遮蔽"
"（由於上述限制）。"

msgid ""
"After enabling the occlusion culling project setting mentioned above, add an "
"OccluderInstance3D node to the scene containing your 3D level. Select the "
"OccluderInstance3D node, then choose an occluder type to add in the "
"**Occluder** property:"
msgstr ""
"啟用上述遮擋剔除專案設定後，將 OcclusionrInstance3D 節點新增至包含 3D 關卡的"
"場景。選擇 OccluderInstance3D 節點，然後選擇要新增至 **Occlusionr** 屬性中的"
"遮擋器型別："

msgid "QuadOccluder3D (a single plane)"
msgstr "QuadOcclusionr3D（單平面）"

msgid "BoxOccluder3D (a cuboid)"
msgstr "BoxOcclusionr3D（長方體）"

msgid "SphereOccluder3D (a sphere-shaped occluder)"
msgstr "SphereOcclusionr3D（球狀遮擋器）"

msgid "PolygonOccluder3D (a 2D polygon with as many points as you want)"
msgstr "PolygonOccluder3D（具有任意數量點的 2D 多邊形）"

msgid ""
"There is also ArrayOccluder3D, whose points can't be modified in the editor "
"but can be useful for procedural generation from a script."
msgstr ""
"還有 ArrayOccluder3D，其點無法在編輯器中修改，但可用於從腳本進行程式產生。"

msgid "Previewing occlusion culling"
msgstr "遮擋模式"

msgid ""
"You can enable a debug draw mode to preview what the occlusion culling is "
"actually \"seeing\". In the top-left corner of the 3D editor viewport, click "
"the **Perspective** button (or **Orthogonal** depending on your current "
"camera mode), then choose **Display Advanced… > Occlusion Culling Buffer**. "
"This will display the low-resolution buffer that is used by the engine for "
"occlusion culling."
msgstr ""
"您可以啟用除錯繪製模式來預覽遮擋剔除實際「看到」的內容。在3D 編輯器視窗的左上"
"角，按一下**透視** 按鈕（或**正交**，取決於您目前的相機模式），然後選擇**顯示"
"進階... > 遮擋剔除緩衝區**。這將顯示引擎用於遮蔽剔除的低解析度緩衝區。"

msgid ""
"In the same menu, you can also enable **View Information** and **View Frame "
"Time** to view the number of draw calls and rendered primitives (vertices + "
"indices) in the bottom-right corner, along with the number of frames per "
"second rendered in the top-right corner."
msgstr ""
"在同一選單中，您還可以啟用**查看資訊**和**查看影格時間**來查看右下角的繪製呼"
"叫和算繪像素（頂點+索引）的數量，以及右上角算繪的每秒影格數。"

msgid ""
"If you toggle occlusion culling in the project settings while this "
"information is displayed, you can see how much occlusion culling improves "
"performance in your scene. Note that the performance benefit highly depends "
"on the 3D editor camera's view angle, as occlusion culling is only effective "
"if there are occluders in front of the camera."
msgstr ""
"如果在顯示此資訊時在專案設定中切換遮擋剔除，您可以看到遮擋剔除對場景效能的改"
"善程度。請注意，性能優勢在很大程度上取決於 3D 編輯器相機的視角，因為遮擋剔除"
"僅在相機前面存在遮擋物時才有效。"

msgid ""
"To toggle occlusion culling at run-time, set ``use_occlusion_culling`` on "
"the root viewport as follows:"
msgstr ""
"若要在運作時切換遮蔽剔除，請在根視窗上設定“use_occlusion_culling”，如下所示："

msgid ""
"Toggling occlusion culling at run-time is useful to compare performance on a "
"running project."
msgstr "在運作時切換遮擋剔除對於比較正在運作的專案的效能很有用。"

msgid "Performance considerations"
msgstr "效能"

msgid "Design your levels to take advantage of occlusion culling"
msgstr "在建構關卡時考慮遮擋"

msgid ""
"**This is the most important guideline.** A good level design is not just "
"about what the gameplay demands; it should also be built with occlusion in "
"mind."
msgstr ""
"這就是很多專業人士的秘密。好的關卡設計並不只是滿足遊戲性的需求，也應該同時考"
"慮遮擋。"

msgid ""
"For indoor environments, add opaque walls to \"break\" the line of sight at "
"regular intervals and ensure not too much of the scene can be seen at once."
msgstr ""
"對於室內環境，新增不透明的牆壁以定期“打破”視線，並確保一次不會看到太多場景。"

msgid ""
"For large open scenes, use a pyramid-like structure for the terrain's "
"elevation when possible. This provides the greatest culling opportunities "
"compared to any other terrain shape."
msgstr ""
"對於大型開放場景，請盡可能使用類似金字塔的結構來確定地形的標高。與任何其他地"
"形形狀相比，這提供了最大的剔除機會。"

msgid "Avoid moving OccluderInstance3D nodes during gameplay"
msgstr "避免在遊戲過程中移動 OcclusionInstance3D 節點"

msgid ""
"This includes moving the parents of OccluderInstance3D nodes, as this will "
"cause the nodes themselves to move in global space, therefore requiring the :"
"abbr:`BVH (Bounding Volume Hierarchy)` to be rebuilt."
msgstr ""
"這包括移動 OccluderInstance3D 節點的父節點，因為這將導致節點本身在全域空間中"
"移動，因此需要重建 BVH（邊界體積層次結構）。"

msgid ""
"Toggling an OccluderInstance3D's visibility (or one of its parents' "
"visibility) is not as expensive, as the update only needs to happen once "
"(rather than continuously)."
msgstr ""
"切換 OccluderInstance3D 的可見性（或其父級之一的可見性）並不那麼昂貴，因為更"
"新只需要發生一次（而不是連續發生）。"

msgid ""
"For example, if you have a sliding or rotating door, you can make the "
"OccluderInstance3D node not be a child of the door itself (so that the "
"occluder never moves), but you can hide the OccluderInstance3D visibility "
"once the door starts opening. You can then reshow the OccluderInstance3D "
"once the door is fully closed."
msgstr ""
"例如，如果您有一扇滑動門或旋轉門，則可以使 OccluderInstance3D 節點不是門本身"
"的子節點（以便遮擋器永遠不會移動），但您可以在門開始打開後隱藏 "
"OccluderInstance3D 可見性。一旦門完全關閉，您就可以重新顯示 "
"OcclusionrInstance3D。"

msgid ""
"If you absolutely have to move an OccluderInstance3D node during gameplay, "
"use a primitive Occluder3D shape for it instead of a complex baked shape."
msgstr ""
"如果您絕對必須在遊戲過程中移動 OcclusionrInstance3D 節點，請為其使用原始 "
"Occlusionr3D 形狀，而不是複雜的烘焙形狀。"

msgid "Use the simplest possible occluder shapes"
msgstr "使用盡可能簡單的遮擋物形狀"

msgid ""
"If you notice low performance or stuttering in complex 3D scenes, it may "
"mean that the CPU is overloaded as a result of rendering detailed occluders. "
"Select the OccluderInstance3D node, increase the **Bake > Simplification** "
"property then bake occluders again."
msgstr ""
"如果您發現複雜 3D 場景中效能低或卡頓，則可能表示 CPU因算繪詳細遮蔽物而過載。"
"選擇 OccluderInstance3D 節點，增加 **Bake > Simplification** 屬性，然後再次烘"
"焙遮蔽物。"

msgid ""
"Remember to keep the simplification value reasonable. Values that are too "
"high for the level's geometry may cause incorrect occlusion culling to "
"occur, as in :ref:`doc_occlusion_culling_troubleshooting_false_negative`."
msgstr ""
"請記得保持簡化值合理。對於關卡幾何形狀來說太高的值可能會導致發生不正確的遮蔽"
"剔除，如 :ref:`doc_occlusion_culling_troubleshooting_false_negative` 所示。"

msgid ""
"If this still doesn't lead to low enough CPU usage, you can try adjusting "
"the **Rendering > Occlusion Culling > BVH Build Quality** project setting "
"and/or decreasing **Rendering > Occlusion Culling > Occlusion Rays Per "
"Thread**. You'll need to enable the **Advanced** toggle in the Project "
"Settings dialog to see those settings."
msgstr ""
"如果這仍然沒有導致足夠低的 CPU 使用率，您可以嘗試調整 **算繪 > 遮擋剔除 > "
"BVH 建構品質** 專案設定和/或減少 **算繪 > 遮擋剔除 > 每線程遮擋光線**。您需要"
"在「專案設定」對話方塊中啟用「進階」開關才能查看這些設定。"

msgid "Troubleshooting"
msgstr "疑難排解"

msgid "My occludee isn't being culled when it should be"
msgstr "我的被遮蔽者在該被剔除的時候卻沒有被剔除"

msgid "**On the occluder side:**"
msgstr "**在遮擋器一側：**"

msgid ""
"First, double-check that the **Bake > Cull Mask** property in the "
"OccluderInstance3D is set to allow baking the meshes you'd like. The "
"visibility layer of the MeshInstance3D nodes must be present within the cull "
"mask for the mesh to be included in the bake."
msgstr ""
"首先，仔細檢查 OccluderInstance3D 中的 **Bake > Cull Mask** 屬性是否設定為允"
"許烘焙您想要的網格。 MeshInstance3D 節點的可見性層必須存在於剔除遮罩中，網格"
"才能包含在烘焙中。"

msgid ""
"Also note that occluder baking only takes meshes with *opaque* materials "
"into account. Surfaces will *transparent* materials will **not** be included "
"in the bake, even if the texture applied on them is fully opaque."
msgstr ""
"另請注意，遮擋器烘焙僅考慮具有“不透明”材質的網格。表面將*透明*材質將**不**包"
"含在烘焙中，即使應用在其上的紋理是完全不透明的。"

msgid ""
"Lastly, remember that MultiMeshInstance3D, GPUParticles3D, CPUParticles3D "
"and CSG nodes are **not** taken into account when baking occluders. As a "
"workaround, you can add OccluderInstance3D nodes for those manually."
msgstr ""
"最後，請記住，烘焙遮擋物時**不**考慮 MultiMeshInstance3D、GPUParticles3D、"
"CPUParticles3D 和 CSG 節點。作為解決方法，您可以手動為這些節點新增 "
"OccluderInstance3D 節點。"

msgid "**On the occludee side:**"
msgstr "**在被遮蔽方：**"

msgid ""
"Make sure **Extra Cull Margin** is set as low as possible (it should usually "
"be ``0.0``), and that **Ignore Occlusion Culling** is disabled in the "
"object's GeometryInstance3D section."
msgstr ""
"確保**額外剔除餘裕**設定為盡可能低（通常應為``0.0``），並且在物件的 "
"GeometryInstance3D 部分中停用**忽略遮蔽剔除**。"

msgid ""
"Also, check the AABB's size (which is represented by an orange box when "
"selecting the node). This axis-aligned bounding box must be *fully* occluded "
"by the occluder shapes for the occludee to be hidden."
msgstr ""
"另外，檢查 AABB 的大小（選擇節點時以橘色框表示）。此軸對齊的邊界框必須被遮擋"
"物形狀*完全*遮擋，才能隱藏被遮擋物。"

msgid "My occludee is being culled when it shouldn't be"
msgstr "我的被遮蔽者在不該被剔除的情況下被剔除"

msgid ""
"The most likely cause for this is that objects that were included in the "
"occluder bake have been moved after baking occluders. For instance, this can "
"occur when moving your level geometry around or rearranging its layout. To "
"fix this, select the OccluderInstance3D node and bake occluders again."
msgstr ""
"造成這種情況的最可能的原因是，遮擋物烘焙中包含的物件在烘焙遮擋物後已被移動。"
"例如，當行動關卡幾何圖形或重新排列其佈局時，可能會發生這種情況。要解決此問"
"題，請選擇 OccluderInstance3D 節點並再次烘焙遮擋物。"

msgid ""
"This can also happen because dynamic objects were included in the bake, even "
"though they shouldn't be. Use the :ref:`occlusion culling debug draw mode "
"<doc_occlusion_culling_preview>` to look for occluder shapes that shouldn't "
"be present, then :ref:`adjust the bake cull mask accordingly "
"<doc_occlusion_culling_baking>`."
msgstr ""
"這種情況也可能發生，因為動態物件包含在烘焙中，儘管它們不應該包含在內。使用遮"
"蔽剔除除錯繪製模式 <doc_occlusion_culling_preview>` 尋找不應出現的遮蔽形狀，"
"然後相應調整烘焙剔除蒙版 <doc_occlusion_culling_baking>`。"

msgid ""
"The last possible cause for this is overly aggressive mesh simplification "
"during the occluder baking process. Select the OccluderInstance3D node, "
"decrease the **Bake > Simplification** property then bake occluders again."
msgstr ""
"最後一個可能的原因是在遮擋器烘焙過程中過於激進的網格簡化。選擇 "
"OccluderInstance3D 節點，減少 **Bake > Simplification** 屬性，然後再次烘焙遮"
"蔽物。"

msgid ""
"As a last resort, you can enable the **Ignore Occlusion Culling** property "
"on the occludee. This will negate the performance improvements of occlusion "
"culling for that object, but it makes sense to do this for objects that will "
"never be culled (such as a first-person view model)."
msgstr ""
"作為最後的手段，您可以啟用被遮蔽者的 **忽略遮蔽剔除** 屬性。這將抵消該物件的"
"遮蔽剔除的效能改進，但對於永遠不會被剔除的物件（例如第一人稱視圖模型）執行此"
"操作是有意義的。"

msgid "Translation status"
msgstr "翻譯狀態"
