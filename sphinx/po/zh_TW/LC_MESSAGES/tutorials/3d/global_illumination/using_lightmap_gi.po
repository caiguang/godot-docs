# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using Lightmap global illumination"
msgstr "使用光照貼圖全域光照"

msgid ""
"Baked lightmaps are a workflow for adding indirect (or fully baked) lighting "
"to a scene. Unlike the :ref:`VoxelGI <doc_using_voxel_gi>` and :ref:`SDFGI "
"<doc_using_sdfgi>` approaches, baked lightmaps work fine on low-end PCs and "
"mobile devices, as they consume almost no resources at run-time. Also unlike "
"VoxelGI and SDFGI, baked lightmaps can optionally be used to store direct "
"lighting, which provides even further performance gains."
msgstr ""
"烘焙的光照貼圖也是一種為場景新增間接光照（也叫全烘焙光照）的工作流程。與 :"
"ref:`doc_gi_probes` 的方法不同，烘焙光照貼圖在低端PC和移動裝置上運作良好，因"
"為在運作時幾乎不消耗資源。與 GIProbe 的另一個不同點是，烘焙光照貼圖還能夠用來"
"保存直接光照，可以進一步提升性能。"

msgid ""
"Unlike VoxelGI and SDFGI, baked lightmaps are completely static. Once baked, "
"they can't be modified at all. They also don't provide the scene with "
"reflections, so using :ref:`doc_reflection_probes` together with it on "
"interiors (or using a Sky on exteriors) is a requirement to get good quality."
msgstr ""
"烘焙光照貼圖與 GIProbe 不同，是完全靜態的，一旦被烘焙就完全不能被修改。它也不"
"能為場景提供反射，所以如果要達到較好的畫質，在室內場景（或者是使用 Sky 的室外"
"場景）中就需要和 :ref:`doc_reflection_probes` 搭配使用。"

msgid ""
"As they are baked, they have fewer problems than VoxelGI and SDFGI regarding "
"light bleeding, and indirect light will often look better. The downside is "
"that baking lightmaps takes longer compared to baking VoxelGI. While baking "
"VoxelGI can be done in a matter of seconds, baking lightmaps can take "
"several minutes if not more. This can slow down iteration speed "
"significantly, so it is recommended to bake lightmaps only when you actually "
"need to see changes in lighting. Since Godot 4.0, lightmaps are baked on the "
"GPU, making light baking faster if you have a mid-range or high-end "
"dedicated GPU."
msgstr ""
"因為是烘焙出來的，所以在光線滲透方面的問題就比 ``GIProbe`` 少很多，並且間接光"
"照也會看上去更漂亮。烘焙光照貼圖的缺點是烘焙所需的時間比 GIProbe 長很多，"
"GIProbe 幾秒鐘就能搞定的烘焙，換成烘焙光照貼圖就可能至少得花上幾分鐘。這會嚴"
"重拖慢反覆運算速度，所以推薦只在確實有查看光照變化的需求時進行光照貼圖的烘"
"焙。"

msgid ""
"Baking lightmaps will also reserve baked materials' UV2 slot, which means "
"you can no longer use it for other purposes in materials (either in the "
"built-in :ref:`doc_standard_material_3d` or in custom shaders)."
msgstr ""
"烘焙光照貼圖還會佔用被烘焙材質的 UV2 欄位，也就是說你無法再把 UV2 用於該材質"
"的其它用途（無論是內建的 :ref:`doc_spatial_material` 還是自訂著色器）。"

msgid ""
"Despite their lack of flexibility, baked lightmaps typically offer both the "
"best quality *and* performance at the same time in (mostly) static scenes. "
"This makes lightmaps still popular in game development, despite lightmaps "
"being the oldest technique for global illumination in video games."
msgstr ""
"儘管缺乏靈活性，烘焙光照貼圖通常在（大部分）靜態場景中同時提供最佳品質*和*性"
"能。這使得光照貼圖在遊戲開發中仍然很流行，儘管光照貼圖是電玩遊戲中最古老的全"
"域照明技術。"

msgid ""
"Not sure if LightmapGI is suited to your needs? See :ref:"
"`doc_introduction_to_global_illumination_comparison` for a comparison of GI "
"techniques available in Godot 4."
msgstr ""
"不確定 LightmapGI 是否適合您的需求？請參閱 "
"doc_introduction_to_global_Illumination_comparison` 以了解 Godot 4 中可用的 "
"GI 技術的比較。"

msgid "Visual comparison"
msgstr "視覺比較"

msgid "LightmapGI disabled."
msgstr "LightmapGI 已停用。"

msgid "LightmapGI enabled (with indirect light baked only)."
msgstr "LightmapGI 啟用（僅使用間接光烘焙）。"

msgid ""
"LightmapGI enabled (with indirect light baked only). Direct light is still "
"real-time, allowing for subtle changes during gameplay."
msgstr ""
"LightmapGI 啟用（僅使用間接光烘焙）。直射光仍然是即時的，允許在遊戲過程中發生"
"微妙的變化。"

msgid "LightmapGI enabled (with direct and indirect light baked)."
msgstr "LightmapGI 已啟用（直接和間接光照烘焙）。"

msgid ""
"LightmapGI enabled (with direct and indirect light baked). Best performance, "
"but lower quality visuals. Notice the blurrier sun shadow in the top-right "
"corner."
msgstr ""
"LightmapGI 已啟用（直接和間接光照烘焙）。最佳性能，但視覺品質較低。請注意右上"
"角較模糊的太陽陰影。"

msgid ""
"Here are some comparisons of how LightmapGI vs. VoxelGI look. Notice that "
"lightmaps are more accurate, but also suffer from the fact that lighting is "
"on an unwrapped texture, so transitions and resolution may not be that good. "
"VoxelGI looks less accurate (as it's an approximation), but smoother overall."
msgstr ""
"以下是 BakedLightmap 和 GIProbe 的一些顯示效果比較。可以看到光照貼圖更精確，"
"但由於使用的是展開後的紋理，所以過渡以及解析度可能就沒有那麼理想。GIProbe 看"
"上去沒有那麼精確（因為是近似估算），但總體上更平滑。"

msgid ""
"SDFGI is also less accurate compared to LightmapGI. However, SDFGI can "
"support large open worlds without any need for baking."
msgstr ""
"與 LightmapGI 相比，SDFGI 的準確度也較低。然而，SDFGI 可以支援大型開放世界，"
"而不需要任何烘焙。"

msgid "Setting up"
msgstr "設定"

msgid ""
"First of all, before the lightmapper can do anything, the objects to be "
"baked need an UV2 layer and a texture size. An UV2 layer is a set of "
"secondary texture coordinates that ensures any face in the object has its "
"own place in the UV map. Faces must not share pixels in the texture."
msgstr ""
"首先，在光照貼圖器可以執行任何操作之前，要烘焙的物件需要 UV2 圖層和紋理大小。"
"UV2 圖層是一組輔助紋理座標，可確保物件中的任何面在 UV 貼圖中都有自己的位置。"
"面與面之間不得共用紋理中的像素。"

msgid ""
"There are a few ways to ensure your object has a unique UV2 layer and "
"texture size:"
msgstr "這裡有幾種方法可以確保您的物件具有唯一的 UV2 層和紋理大小："

msgid "Unwrap on scene import (recommended)"
msgstr "場景匯入時展開"

msgid ""
"In most scenarios, this is the best approach to use. The only downside is "
"that, on large models, unwrapping can take a while on import. Nonetheless, "
"Godot will cache the UV2 across reimports, so it will only be regenerated "
"when needed."
msgstr ""
"總體來說，這可能是最好的方法。唯一的缺點是，在大型模型上，匯入時展開可能需要"
"一段時間。不過Godot會在重新匯入時快取UV2，所以只會在需要時重新生成。"

msgid ""
"Select the imported scene in the filesystem dock, then go to the **Import** "
"dock. There, the following option can be modified:"
msgstr ""
"在檔案系統面板中選擇被匯入的場景，然後切換到**匯入**面板。這裡可以修改以下選"
"項："

msgid ""
"The **Meshes > Light Baking** option must be set to **Static Lightmaps "
"(VoxelGI/SDFGI/LightmapGI)**:"
msgstr ""
"**網格 > 光照烘焙**選項必須設定為 **靜態光照貼圖 (VoxelGI/SDFGI/"
"LightmapGI)**："

msgid ""
"When unwrapping on import, you can adjust the texture size using the "
"**Meshes > Lightmap Texel Size** option. *Lower* values will result in more "
"detailed lightmaps, possibly resulting in higher visual quality at the cost "
"of longer bake times and larger lightmap file sizes. The default value of "
"``0.2`` is suited for small/medium-sized scenes, but you may want to "
"increase it to ``0.5`` or even more for larger scenes. This is especially "
"the case if you're baking indirect lighting only, as indirect light is low-"
"frequency data (which means it doesn't need high-resolution textures to be "
"accurately represented)."
msgstr ""
"匯入時展開時，您可以使用 **網格 > 光照貼圖紋理大小** 選項調整紋理大小。 *較低"
"的*值將產生更詳細的光照貼圖，可能會導致更高的視覺質量，但代價是更長的烘焙時間"
"和更大的光照貼圖檔案大小。預設值“0.2”適用於小型/中型場景，但您可能需要將其增"
"加到“0.5”，甚至更大的場景。如果您僅烘焙間接光照，則尤其如此，因為間接光是低頻"
"資料（這意味著它不需要準確表示高解析度紋理）。"

msgid ""
"The effect of setting this option is that all meshes within the scene will "
"have their UV2 maps properly generated."
msgstr "設定此選項的效果是場景中的所有網格都將正確生成其UV2貼圖."

msgid ""
"When reusing a mesh within a scene, keep in mind that UVs will be generated "
"for the first instance found. If the mesh is re-used with different scales "
"(and the scales are wildly different, more than half or twice), this will "
"result in inefficient lightmaps. To avoid this, adjust the **Lightmap "
"Scale** property in the GeometryInstance3D section of a MeshInstance3D node. "
"This lets you *increase* the level of lightmap detail for specific "
"MeshInstance3D nodes (but not decrease it)."
msgstr ""
"如果在場景中複用了網格，請注意生成 UV 時只會使用第一個找到的實例。如果複用時"
"使用了不同的縮放比例（並且相差很大，超過了一半或者兩倍），會導致生成低效的光"
"照貼圖。如果你想用光照貼圖，就不要在複用原始網格時使用明顯不同的縮放比例。"

msgid ""
"Also, the ``*.unwrap_cache`` files should *not* be ignored in version "
"control as these files guarantee that UV2 reimports are consistent across "
"platforms and engine versions."
msgstr ""
"另外，請*不要*在版本控制系統中忽略 ``*.unwrap_cache`` 檔，這些檔可以用來保證"
"不同平臺、不同版本的引擎在重新匯入 UV2 時的一致性。"

msgid "Unwrap from within Godot"
msgstr "使用 Godot 進行展開"

msgid ""
"If this Mesh menu operation is used on an imported 3D scene, the generated "
"UV2 will be lost when the scene is reloaded."
msgstr ""
"如果在匯入的 3D 場景上使用此 Mesh 選單操作，則重新載入場景時產生的 UV2 將會遺"
"失。"

msgid ""
"Godot has an option to unwrap meshes and visualize the UV channels. After "
"selecting a MeshInstance3D node, it can be found in the **Mesh** menu at the "
"top of the 3D editor viewport:"
msgstr "Godot可以選擇打開網格並視覺化UV通道. 它可以在Mesh功能表中找到:"

msgid ""
"This will generate a second set of UV2 coordinates which can be used for "
"baking. It will also set the texture size automatically."
msgstr "這將生成第二組UV2座標, 可用於烘焙, 並且還將自動設定紋理大小."

msgid "Unwrap from your 3D modeling software"
msgstr "使用 3D DCC 展開"

msgid ""
"The last option is to do it from your favorite 3D app. This approach is "
"generally **not recommended**, but it's explained so that you know it "
"exists. The main advantage is that, on complex objects that you may want to "
"re-import a lot, the texture generation process can be quite costly within "
"Godot, so having it unwrapped before import can be faster."
msgstr ""
"最後一種方法是在你喜歡的 3D 應用程式中進行操作。通常不推薦這種做法，但為了讓"
"你知道它的存在，這裡還是解釋一下。這種做法的主要優勢在於，針對可能要經常重新"
"匯入的複雜物件，在 Godot 中進行紋理生成的代價可能相當高，所以在匯入前展開可以"
"提高速度。"

msgid "Simply do an unwrap on the second UV2 layer."
msgstr "只需在第二個UV2層上進行展開即可。"

msgid ""
"Then import the 3D scene normally. Remember you will need to set the texture "
"size on the mesh after import."
msgstr "然後正常匯入 3D 場景。記得在匯入後為網格設定紋理大小。"

msgid ""
"If you use external meshes on import, the size will be kept. Be wary that "
"most unwrappers in 3D modeling software are not quality-oriented, as they "
"are meant to work quickly. You will mostly need to use seams or other "
"techniques to create better unwrapping."
msgstr ""
"如果在匯入時使用外部網格, 則將保留大小. 請注意,3D DCC中的大多數解包器都不是面"
"向品質的, 因為它們可以快速工作. 您通常需要使用接縫或其他技術來建立更好的展開."

msgid "Generating UV2 for primitive meshes"
msgstr "將 Sprite 轉換為 2D 網格"

msgid ""
"This option is only available for primitive meshes such as :ref:"
"`class_BoxMesh`, :ref:`class_CylinderMesh`, :ref:`class_PlaneMesh`, etc."
msgstr ""
"此選項僅適用於基本網格體，例如 class_BoxMesh、class_CylinderMesh、"
"class_PlaneMesh 等。"

msgid ""
"Enabling UV2 on primitive meshes allows you to make them receive and "
"contribute to baked lighting. This can be used in certain lighting setups. "
"For instance, you could hide a torus that has an emissive material after "
"baking lightmaps to create an area light that follows the shape of a torus."
msgstr ""
"在原始網格體上啟用 UV2 可以使它們接收並貢獻烘焙光照。這可以用於某些照明設定。"
"例如，您可以在烘焙光貼圖後隱藏具有發光材質的圓環，以建立遵循圓環形狀的區域"
"光。"

msgid ""
"By default, primitive meshes do not have UV2 generated to save resources (as "
"these meshes may be created during gameplay). You can edit a primitive mesh "
"in the inspector and enable **Add UV2** to make the engine procedurally "
"generate UV2 for a primitive mesh. The default **UV2 Padding** value is "
"tuned to avoid most lightmap bleeding, without wasting too much space on the "
"edges. If you notice lightmap bleeding on a specific primitive mesh only, "
"you may have to increase **UV2 Padding**."
msgstr ""
"預設情況下，原始網格體不會產生 UV2 以節省資源（因為這些網格體可能在遊戲過程中"
"建立）。您可以在屬性面板中編輯基本網格並啟用**新增 UV2** 以使引擎按程式為基本"
"網格產生 UV2。預設的 **UV2 填充** 值經過調整以避免大多數光照貼圖滲色，而不會"
"在邊緣上浪費太多空間。如果您發現光照貼圖僅在特定基元網格上滲色，則可能需要增"
"加 **UV2 填充**。"

msgid ""
"**Lightmap Size Hint** represents the size taken by a single mesh on the "
"lightmap texture, which varies depending on the mesh's size properties and "
"the **UV2 Padding** value. **Lightmap Size Hint** should not be manually "
"changed, as any modifications will be lost when the scene is reloaded."
msgstr ""
"**光照貼圖大小提示** 表示光照貼圖紋理上單一網格所佔據的大小，該大小會根據網格"
"的大小屬性和 **UV2 填充** 值而變化。 **光照貼圖大小提示** 不應手動更改，因為"
"重新載入場景時任何修改都會遺失。"

msgid "Checking UV2"
msgstr "檢查 UV2"

msgid ""
"In the **Mesh** menu mentioned before, the UV2 texture coordinates can be "
"visualized. If something is failing, double-check that the meshes have these "
"UV2 coordinates:"
msgstr ""
"在前面提到的網格功能表中, 可以顯示UV2紋理座標. 如果出現問題, 請確保檢查網格是"
"否具有以下UV2座標:"

msgid "Setting up the scene"
msgstr "設定場景"

msgid ""
"Before anything is done, a **LightmapGI** node needs to be added to a scene. "
"This will enable light baking on all nodes (and sub-nodes) in that scene, "
"even on instanced scenes."
msgstr ""
"首先需要在場景中新增一個 **BakedLightmap** 節點。新增後，場景中的所有節點（和"
"子節點）就都可以進行光照烘焙了，甚至產生實體的場景也可以。"

msgid ""
"A sub-scene can be instanced several times, as this is supported by the "
"baker. Each instance will be assigned a lightmap of its own. To avoid issues "
"with inconsistent lightmap texel scaling, make sure to respect the rule "
"about mesh scaling mentioned before."
msgstr ""
"烘焙器支援同一子場景存在多個實例，它們會有各自獨立的光照貼圖（前提是你得遵守"
"之前提過的關於縮放的規則）。"

msgid "Setting up meshes"
msgstr "設定網格"

msgid ""
"For a **MeshInstance3D** node to take part in the baking process, it needs "
"to have its bake mode set to **Static**. Meshes that have their bake mode "
"set to **Disabled** or **Dynamic** will be ignored by the lightmapper."
msgstr ""
"如果需要讓 **MeshInstance** 節點參與烘焙，需要啟用 **Use in Baked Light** 屬"
"性。"

msgid ""
"When auto-generating lightmaps on scene import, this is enabled "
"automatically."
msgstr "在場景匯入時自動生成光照貼圖時, 會自動啟用此功能."

msgid "Setting up lights"
msgstr "設定燈光"

msgid ""
"Lights are baked with indirect light only by default. This means that "
"shadowmapping and lighting are still dynamic and affect moving objects, but "
"light bounces from that light will be baked."
msgstr ""
"預設情況下, 燈光採用間接燈光烘焙. 這意味著陰影貼圖和光照仍然是動態的並影響移"
"動的物體, 但是光線反射的光將被烘焙."

msgid ""
"Lights can be disabled (no bake) or be fully baked (direct and indirect). "
"This can be controlled from the **Bake Mode** menu in lights:"
msgstr ""
"燈可以禁用(不烘焙)或完全烘焙(直接和間接). 這可以通過燈光中的 **烘焙模式** 功"
"能表進行控制:"

msgid "The modes are:"
msgstr "模式有："

msgid "Disabled"
msgstr "已停用的專案"

#, fuzzy
msgid ""
"The light is ignored when baking lightmaps. This is the mode to use for "
"dynamic lighting effects such as explosions and weapon effects."
msgstr "這個模式可以用於動態光照效果，例如爆炸和武器特效。"

msgid ""
"Hiding a light has no effect on the resulting lightmap bake. This means you "
"must use the Disabled bake mode instead of hiding the Light node by "
"disabling its **Visible** property."
msgstr ""

msgid "Dynamic"
msgstr "動態語言："

msgid ""
"This is the default mode, and is a compromise between performance and real-"
"time friendliness. Only indirect lighting will be baked. Direct light and "
"shadows are still real-time, as they would be without LightmapGI."
msgstr ""
"這是預設的模式，是性能與即時友好性的折衷。只會烘焙間接光照。直接燈光和陰影仍"
"舊是即時的，與不使用 BakedLightmap 時一致。"

msgid ""
"This mode allows performing *subtle* changes to a light's color, energy and "
"position while still looking fairly correct. For example, you can use this "
"to create flickering static torches that have their indirect light baked."
msgstr ""
"這個模式可以在保持顯示效果相對正確的同時，允許進行燈光顏色、能量、以及位置的 "
"*微調* 。例如，你可以借此實作靜態火把的閃爍，它的間接光照仍然是烘焙的。"

msgid "Static"
msgstr "靜態語言："

msgid ""
"Both indirect and direct lighting will be baked. Since static surfaces can "
"skip lighting and shadow computations entirely, this mode provides the best "
"performance along with smooth shadows that never fade based on distance. The "
"real-time light will not affect baked surfaces anymore, but it will still "
"affect dynamic objects. When using the **All** bake mode on a light, dynamic "
"objects will not cast real-time shadows onto baked surfaces, so you need to "
"use a different approach such as blob shadows instead. Blob shadows can be "
"implemented with a Decal node."
msgstr ""
"間接和直接光照都會被烘焙。因為靜態表面可以完全跳過光照和陰影的計算，所以這個"
"模式可以提供最佳的性能，並且實作不隨距離衰減的平滑的陰影。即時燈光不會再影響"
"烘焙的表面，但仍然可以影響動態的物件。在光源上使用 **All** （全部）烘焙模式"
"時，動態物件不會在烘焙表面上投射陰影，所以你需要使用別的方法，比如軟陰影。軟"
"陰影既可以通過 Sprite3D + RayCast 實作，也可以通過把朝下的反 SpotLight 的烘焙"
"模式設定成 **禁用** 實作。"

msgid ""
"The light will not be adjustable at all during gameplay. Moving the light or "
"changing its color (or energy) will not have any effect on static surfaces."
msgstr ""
"遊戲過程中無法調整燈光。燈光的移動、變色、能量調整不會對靜態表面產生影響。"

msgid ""
"Since bake modes can be adjusted on a per-light basis, it is possible to "
"create hybrid baked light setups. One popular option is to use a real-time "
"DirectionalLight with its bake mode set to **Dynamic**, and use the "
"**Static** bake mode for OmniLights and SpotLights. This provides good "
"performance while still allowing dynamic objects to cast real-time shadows "
"in outdoor areas."
msgstr ""
"因為烘焙模式可以分光源調整，所以可以設定出混合的烘焙光照。一個比較流行的做法"
"是使用即時 DirectionalLight 並把它的烘焙模式設定成 **Indirect**，然後把 "
"OmniLight 和 SpotLight 的烘焙模式都設定成 **All**。這樣做的性能不錯，同時也允"
"許動態物件在室外投射即時陰影。"

msgid ""
"Fully baked lights can also make use of light nodes' **Size** (omni/spot) or "
"**Angular Distance** (directional) properties. This allows for shadows with "
"realistic penumbra that increases in size as the distance between the caster "
"and the shadow increases. This also has a lower performance cost compared to "
"real-time PCSS shadows, as only dynamic objects have real-time shadows "
"rendered on them."
msgstr ""
"完全烘焙的燈光還可以利用燈光節點的**大小**（全向/聚光）或**角度距離**（方向）"
"屬性。這允許陰影具有真實的半影，隨著施法者和陰影之間距離的增加，半影的尺寸也"
"會增加。與即時 PCSS 陰影相比，這也具有較低的效能成本，因為只有動態物件才會在"
"其上算繪即時陰影。"

msgid "Baking"
msgstr "烘焙"

msgid ""
"To begin the bake process, click the **Bake Lightmaps** button at the top of "
"the 3D editor viewport when selecting the LightmapGI node:"
msgstr ""
"開始烘焙只需在選中 BakedLightmap 節點後點擊上方的 **烘焙光照貼圖** 按鈕："

msgid ""
"This can take from seconds to minutes (or hours) depending on scene size, "
"bake method and quality selected."
msgstr ""
"根據場景大小、所選烘焙方法以及品質的不同，其過程可能花費幾秒鐘到幾分鐘不等"
"（也可能是幾小時）。"

msgid ""
"Baking lightmaps is a process that can require a lot of video memory, "
"especially if the resulting texture is large. Due to internal limitations, "
"the engine may also crash if the generated texture size is too large (even "
"on systems with a lot of video memory)."
msgstr ""
"烘焙光照貼圖是一個可能需要大量視訊記憶體的過程，尤其是當產生的紋理很大時。由"
"於內部限制，如果生成的紋理尺寸太大（即使在具有大量視訊記憶體的系統上），引擎"
"也可能當機。"

msgid ""
"To avoid crashes, make sure the lightmap texel size in the Import dock is "
"set to a high enough value."
msgstr ""
"為了避免當機，請確保匯入停靠列中的光照貼圖紋理像素大小設定為足夠高的值。"

msgid "Tweaks"
msgstr "調整"

msgid ""
"**Quality:** Four bake quality modes are provided: Low, Medium, High, and "
"Ultra. Higher quality takes more time, but result in a better-looking "
"lightmap with less noise. The difference is especially noticeable with "
"emissive materials or areas that get little to no direct lighting. Each bake "
"quality mode can be further adjusted in the Project Settings."
msgstr ""
"**Quality（品質）**：提供了四種烘焙品質：Low（低級）、Medium（中級）、High"
"（高級）、Ultra（超級）。品質越高所需的時間越長，但最終光照貼圖的顯示效果越"
"好、噪點也越少。針對發光材質或者幾乎沒有直接光照的地方，不同品質之間的區別尤"
"為顯著。"

#, fuzzy
msgid ""
"**Bounces:** The number of bounces to use for indirect lighting. The default "
"value (``3``) is a good compromise between bake times and quality. Higher "
"values will make light bounce around more times before it stops, which makes "
"indirect lighting look smoother (but also possibly brighter depending on "
"materials and geometry)."
msgstr ""
"**Bounces（反彈）** ：間接光照的反彈次數。預設值（3）是烘焙時間和品質之間的一"
"個平衡點。取值越高，光線在停止之前反彈的次數越多，間接光照的效果也就越好（同"
"時也越亮）。在做最初的光照反覆運算工作時，建議把反彈次數減小到 1，這樣可以加"
"快烘焙速度。注意降低反彈次數會讓場景變暗。"

msgid ""
"**Bounce Indirect Energy:** The global multiplier to use when baking lights' "
"indirect energy. This multiplies each light's own **Indirect Energy** value. "
"Values different from ``1.0`` are not physically accurate, but can be used "
"for artistic effect."
msgstr ""

msgid ""
"**Directional:** If enabled, stores directional information for lightmaps. "
"This improves normal mapped materials' appearance for baked surfaces, "
"especially with fully baked lights (since they also have direct light "
"baked). The downside is that directional lightmaps are slightly more "
"expensive to render. They also require more time to bake and result in "
"larger file sizes."
msgstr ""
"**定向：** 如果啟用，則儲存光照貼圖的方向資訊。這改善了烘焙表面的法線貼圖材質"
"的外觀，尤其是在完全烘焙的燈光下（因為它們也有直接光線烘焙）。缺點是定向光照"
"貼圖的算繪成本稍高。它們還需要更多的時間來烘烤並導致檔案大小更大。"

msgid ""
"**Interior:** If enabled, environment lighting will not be sourced. Use this "
"for purely indoor scenes to avoid light leaks."
msgstr "**內部：** 若啟用，將不會取得環境照明。將其用於純室內場景以避免漏光。"

msgid ""
"**Use Texture for Bounces:** If enabled, a texture with the lighting "
"information will be generated to speed up the generation of indirect "
"lighting at the cost of some accuracy. The geometry might exhibit extra "
"light leak artifacts when using low resolution lightmaps or UVs that stretch "
"the lightmap significantly across surfaces. Leave this enabled if unsure."
msgstr ""

#, fuzzy
msgid ""
"**Use Denoiser:** If enabled, uses a denoising algorithm to make the "
"lightmap significantly less noisy. This increases bake times and can "
"occasionally introduce artifacts, but the result is often worth it. See :ref:"
"`doc_using_lightmap_gi_denoising` for more information."
msgstr ""
"**Use Color（使用彩色）** ：禁用時，光照貼圖會佔用更少的磁碟空間，但就會無法"
"保存彩色燈光。僅烘焙間接光照時，由於間接燈光通常對比度不高，所以可能幾乎看不"
"出區別。然而使用 **All** 烘焙模式同時烘焙直接和間接光照時，就會導致彩色燈光變"
"成灰度燈光。該選項和 HDR 一起禁用後可以得到相同解析度下最小的光照貼圖。"

msgid ""
"**Denoiser Strength:** The strength of denoising step applied to the "
"generated lightmaps. Higher values are more effective at removing noise, but "
"can reduce shadow detail for static shadows. Only effective if denoising is "
"enabled and the denoising method is :abbr:`JNLM (Non-Local Means with Joint "
"Filtering)` (:abbr:`OIDN (Open Image Denoise)` does not have a denoiser "
"strength setting)."
msgstr ""

msgid ""
"**Bias:** The offset value to use for shadows in 3D units. You generally "
"don't need to change this value, except if you run into issues with light "
"bleeding or dark spots in your lightmap after baking. This setting does not "
"affect real-time shadows casted on baked surfaces (for lights with "
"**Dynamic** bake mode)."
msgstr ""
"**Bias（偏置）** ：陰影的偏移量，使用 3D 單位。除非你遇到了光線滲透問題或者光"
"照貼圖在烘焙後存在暗區，否則通常情況下不需要修改這個值。該選項不會影響投射在"
"烘焙表面上的即時陰影。"

msgid ""
"**Max Texture Size:** The maximum texture size for the generated texture "
"atlas. Higher values will result in fewer slices being generated, but may "
"not work on all hardware as a result of hardware limitations on texture "
"sizes. Leave this at its default value of ``16384`` if unsure."
msgstr ""
"**最大紋理尺寸：** 產生的紋理合集的最大紋理尺寸。較高的值將導致產生的切片較"
"少，但由於硬體對紋理大小的限制，可能無法在所有硬體上工作。如果不確定，請將其"
"保留為預設值“16384”。"

msgid ""
"**Environment > Mode:** Controls how environment lighting is sourced when "
"baking lightmaps. The default value of **Scene** is suited for levels with "
"visible exterior parts. For purely indoor scenes, set this to **Disabled** "
"to avoid light leaks and speed up baking. This can also be set to **Custom "
"Sky** or **Custom Color** to use environment lighting that differs from the "
"actual scene's environment sky."
msgstr ""
"**環境 > 模式：** 控制烘焙光照貼圖時環境光照的來源方式。 **場景** 的預設值適"
"用於具有可見外部元件的關卡。對於純室內場景，將其設定為**停用**以避免漏光並加"
"快烘烤速度。也可以設定為 **自訂天空** 或 **自訂顏色** 以使用與實際場景的環境"
"天空不同的環境照明。"

msgid ""
"**Gen Probes > Subdiv:** See :ref:`doc_using_lightmap_gi_dynamic_objects`."
msgstr ""
"**產生探查 > 細分：** 請參閱 :ref:`doc_using_lightmap_gi_dynamic_objects`。"

msgid "**Data > Light Data:** See :ref:`doc_using_lightmap_gi_data`."
msgstr "**資料 > 光資料：** 請參閱 :ref:`doc_using_lightmap_gi_data`。"

msgid "Balancing bake times with quality"
msgstr "平衡烘焙時間和品質"

msgid ""
"Since high-quality bakes can take very long (up to dozens of minutes for "
"large complex scenes), it is recommended to use lower quality settings at "
"first. Then, once you are confident with your scene's lighting setup, raise "
"the quality settings and perform a \"final\" bake before exporting your "
"project."
msgstr ""
"因為高品質的烘焙可能花費非常長的時間（大型複雜場景可能需要若干小時），推薦首"
"先設定成較低品質，將場景中的燈光佈置成滿意的效果後再改成較高的品質，在匯出專"
"案前進行“終極”烘焙。"

msgid ""
"Reducing the lightmap resolution by increasing **Lightmap Texel Size** on "
"the imported 3D scenes will also speed up baking significantly. However, "
"this will require you to reimport all lightmapped 3D scenes before you can "
"bake lightmaps again."
msgstr ""
"透過增加匯入的 3D 場景上的 **光照貼圖紋理尺寸** 來降低光照貼圖解析度也會顯著"
"加快烘焙速度。但是，這將要求您重新匯入所有光照貼圖 3D 場景，然後才能再次烘焙"
"光照貼圖。"

msgid "Denoising"
msgstr ""

msgid ""
"Since baking lightmaps relies on raytracing, there will always be visible "
"noise in the \"raw\" baked lightmap. Noise is especially visible in areas "
"that are difficult to reach by bounced light, such as indoor areas with "
"small openings where the sunlight can enter. Noise can be reduced by "
"increasing bake quality, but doing so will increase bake times significantly."
msgstr ""

#, fuzzy
msgid "Comparison between denoising disabled and enabled"
msgstr "無抗鋸齒（左）和 TAA（右）之間的比較："

msgid ""
"Comparison between denoising disabled and enabled (with the default JNLM "
"denoiser)."
msgstr ""

msgid ""
"To combat noise without increasing bake times too much, a denoiser can be "
"used. A denoiser is an algorithm that runs on the final baked lightmap, "
"detects patterns of noise and softens them while attempting to best preseve "
"detail. Godot offers two denoising algorithms:"
msgstr ""

msgid "JNLM (Non-Local Means with Joint Filtering)"
msgstr ""

msgid ""
"JNLM is the default denoising method and is included in Godot. It uses a "
"simple but efficient denoising algorithm known as *non-local means*. JNLM "
"runs on the GPU using a compute shader, and is compatible with any GPU that "
"can run Godot 4's Vulkan-based rendering methods. No additional setup is "
"required."
msgstr ""

msgid ""
"JNLM's denoising can be adjusted using the **Denoiser Strength** property "
"that is visible when **Use Denoiser** enabled. Higher values can be more "
"effective at removing noise, at the cost of suppressing shadow detail for "
"static shadows."
msgstr ""

msgid "Comparison between JNLM denoiser strength values"
msgstr ""

msgid ""
"Comparison between JNLM denoiser strength values. Higher values can reduce "
"detail."
msgstr ""

msgid "OIDN (Open Image Denoise)"
msgstr ""

msgid ""
"Unlike JNLM, OIDN uses a machine learning approach to denoising lightmaps. "
"It features a model specifically trained to remove noise from lightmaps "
"while preserving more shadow detail in most scenes compared to JNLM."
msgstr ""

msgid ""
"OIDN can run on the GPU if hardware acceleration is configured. With a "
"modern high-end GPU, this can provide a speedup of over 50× over CPU-based "
"denoising:"
msgstr ""

msgid "On AMD GPUs, HIP must be installed and configured."
msgstr ""

msgid ""
"On NVIDIA GPUs, CUDA must be installed and configured. This may "
"automatically be done by the NVIDIA installer, but on Linux, CUDA libraries "
"may not be installed by default. Double-check that the CUDA packages from "
"your Linux distribution are installed."
msgstr ""

msgid "On Intel GPUs, SYCL must be installed and configured."
msgstr ""

msgid ""
"If hardware acceleration is not available, OIDN will fall back to "
"multithreaded CPU-based denoising. To confirm whether GPU-based denoising is "
"working, use a GPU utilization monitor while baking lightmaps and look at "
"the GPU utilization percentage and VRAM utilization while the denoising step "
"is shown in the Godot editor. The ``nvidia-smi`` command line tool can be "
"useful for this."
msgstr ""

msgid ""
"OIDN is not included with Godot due to its relatively large download size. "
"You can download precompiled OIDN binary packages from its `website <https://"
"www.openimagedenoise.org/downloads.html>`__. Extract the package to a "
"location on your PC, then specify the path to the ``oidnDenoise`` executable "
"in the Editor Settings (**FileSystem > Tools > OIDN > OIDN Denoise Path**). "
"This executable is located within the ``bin`` folder of the binary package "
"you extracted."
msgstr ""

msgid ""
"After specifying the path to the OIDN denoising executable, change the "
"denoising method in the project settings by setting **Rendering > "
"Lightmapping > Denoiser** to **OIDN**. This will affect all lightmap bakes "
"on this project after the setting is changed."
msgstr ""

msgid ""
"The denoising method is configured in the project settings instead of the "
"editor settings. This is done so that different team members working on the "
"same project are assured to be using the same denoising method for "
"consistent results."
msgstr ""

msgid "Comparison between JNLM and OIDN denoisers"
msgstr ""

msgid ""
"Comparison between JNLM and OIDN denoisers. Notice how OIDN better preserves "
"detail and reduces seams across different objects."
msgstr ""

msgid "Dynamic objects"
msgstr "動態物件"

msgid ""
"Unlike VoxelGI and SDFGI, dynamic objects receive indirect lighting "
"differently compared to static objects. This is because lightmapping is only "
"performed on static objects."
msgstr ""
"與 VoxelGI 和 SDFGI 不同，動態物件接收間接光照的方式與靜態物件不同。這是因為"
"光照貼圖僅在靜態物件上執行。"

msgid ""
"To display indirect lighting on dynamic objects, a 3D probe system is used, "
"with light probes being spread throughout the scene. When baking lightmaps, "
"the lightmapper will calculate the amount of *indirect* light received by "
"the probe. Direct light is not stored within light probes, even for lights "
"that have their bake mode set to **Static** (as dynamic objects continue to "
"be lit in real-time)."
msgstr ""
"為了顯示動態物件上的間接照明，使用了 3D 探查系統，其中光探查遍布整個場景。烘"
"焙光照貼圖時，光照貼圖器將計算探頭接收到的*間接*光量。直射光不會儲存在光探查"
"中，即使對於將烘焙模式設定為**靜態**的光源（因為動態物件繼續即時點亮）。"

msgid "There are 2 ways to add light probes to a scene:"
msgstr "有兩種方法可以為伺服器匯出專案："

msgid ""
"**Automatic:** Set **Gen Probes > Subdiv** to a value other than "
"**Disabled**, then bake lightmaps. The default is ``8``, but you can choose "
"a greater value to improve precision at the cost of longer bake times and "
"larger output file size."
msgstr ""
"**自動：** 將 **Gen Probes > Subdiv** 設定為 **Disabled** 以外的值，然後烘焙"
"光照貼圖。預設值為“8”，但您可以選擇更大的值來提高精確度，但代價是烘焙時間更長"
"且輸出檔案大小更大。"

msgid ""
"**Manual:** In addition or as an alternative to generating probes "
"automatically, you can add light probes manually by adding :ref:"
"`class_LightmapProbe` nodes to the scene. This can be used to improve "
"lighting detail in areas frequently travelled by dynamic objects. After "
"placing LightmapProbe nodes in the scene, you must bake lightmaps again for "
"them to be effective."
msgstr ""
"**手動：** 除了自動產生探查之外或作為自動產生探查的替代方案，您可以透過向場景"
"新增:ref:`class_LightmapProbe` 節點來手動新增光照探查。這可用於改善動態物體經"
"常經過的區域的照明細節。在場景中放置 LightmapProbe 節點後，必須再次烘焙光照貼"
"圖才能使其生效。"

msgid ""
"After baking lightmaps, you will notice white spheres in the 3D scene that "
"represent how baked lighting will affect dynamic objects. These spheres do "
"**not** appear in the running project."
msgstr ""
"烘焙光照貼圖後，您會注意到 3D 場景中的白色球體代表烘焙光照將如何影響動態物"
"件。這些球體**不會**出現在正在運作的專案中。"

msgid ""
"If you want to hide these spheres in the editor, toggle **View > Gizmos > "
"LightmapGI** at the top of the 3D editor (a \"closed eye\" icon indicates "
"the gizmo is hidden)."
msgstr ""
"如果要在編輯器中隱藏這些球體，請在 3D 編輯器頂部切換 **View > Gizmos > "
"LightmapGI**（「閉眼」圖示表示 Gizmo 已隱藏）。"

msgid "Lightmap data"
msgstr "光照貼圖資料"

msgid ""
"The **Data > Light Data** property in the LightmapGI node contains the "
"lightmap data after baking. Textures are saved to disk, but this also "
"contains the capture data for dynamic objects, which can be heavy. If you "
"are using a scene in ``.tscn`` format, you should save this resource to an "
"external binary ``.lmbake`` file to avoid bloating the ``.tscn`` scene with "
"binary data encoded in Base64."
msgstr ""
"**Light Data（光照資料）** ：烘焙後包含光照烘焙資料。紋理會被保存到磁片上，但"
"這裡還會包含動態物件的捕獲資料，資料量可能非常大。如果你使用的是 ``.tscn`` 格"
"式的場景，應該將此資源保存成外部的二進位 ``.lmbake`` 檔，否則 ``.tscn`` 場景"
"可能因為使用 Base64 編碼二進位資料而變得巨大。"

msgid ""
"The generated EXR file can be viewed and even edited using an image editor "
"to perform post-processing if needed. However, keep in mind that changes to "
"the EXR file will be lost when baking lightmaps again."
msgstr ""
"如果有後期處理的需要，可以使用圖像編輯器查看並編輯所生成的 EXR 檔。不過請注"
"意，重新烘焙貼圖會覆蓋你對 EXR 檔的修改。"

#, fuzzy
msgid "Reducing LightmapGI artifacts"
msgstr "減少 VoxelGI 漏光和偽影"

msgid ""
"If you notice LightmapGI nodes popping in and out of existence as the camera "
"moves, this is most likely because the engine is rendering too many "
"LightmapGI instances at once. Godot is limited to rendering 8 LightmapGI "
"nodes at once, which means up to 8 instances can be in the camera view "
"before some of them will start flickering."
msgstr ""

msgid "Translation status"
msgstr "翻譯狀態"
