# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Procedural geometry"
msgstr "程式式幾何體"

msgid ""
"There are many ways to procedurally generate geometry in Godot. In this "
"tutorial series, we will explore a few of them. Each technique has its own "
"benefits and drawbacks, so it is best to understand each one and how it can "
"be useful in a given situation."
msgstr ""
"在 Godot 中，有許多方法可以通過程式生成幾何體。在本系列教學中，我們將探討其中"
"的幾種方法。每種技術都有自己的優點和缺點，所以最好瞭解每種技術，以及它在特定"
"情況下如何發揮作用。"

msgid ""
"All the procedural geometry generation methods described here run on the "
"CPU. Godot doesn't support generating geometry on the GPU yet."
msgstr ""
"這裡描述的所有程式幾何生成方法都在 CPU 上運作。 Godot 尚未支援在 GPU 上產生幾"
"何體。"

msgid "What is geometry?"
msgstr "什麼是幾何體？"

msgid ""
"Geometry is a fancy way of saying shape. In computer graphics, geometry is "
"typically represented by an array of positions called \"vertices\". In "
"Godot, geometry is represented by Meshes."
msgstr ""
"幾何體是形狀的一種花式說法。在電腦圖形學中，幾何體通常由稱為“頂點”的位置陣列"
"來表示。在 Godot 中，幾何體用 Mesh（網格）來表示。"

msgid "What is a Mesh?"
msgstr "什麼是網格？"

#, fuzzy
msgid ""
"Many things in Godot have mesh in their name: the :ref:`Mesh <class_Mesh>`, "
"the :ref:`ArrayMesh <class_ArrayMesh>`, the :ref:`ImmediateMesh "
"<class_ImmediateMesh>`, the :ref:`MeshInstance3D <class_MeshInstance3D>`, "
"the :ref:`MultiMesh <class_MultiMesh>`, and the :ref:`MultiMeshInstance3D "
"<class_MultiMeshInstance3D>`. While they are all related, they have slightly "
"different uses."
msgstr ""
"在 Godot 中，很多東西的名字中都帶“Mesh”（網格）：:ref:`Mesh <class_Mesh>`、:"
"ref:`ArrayMesh <class_ArrayMesh>`、:ref:`MeshInstance "
"<class_MeshInstance>`、:ref:`MultiMesh <class_MultiMesh>`、:ref:"
"`MultiMeshInstance <class_MultiMeshInstance>`。雖然它們都是相關的，但用途略有"
"不同。"

msgid ""
"Meshes and ArrayMeshes are resources that are drawn using a MeshInstance3D "
"node. Resources like Meshes and ArrayMeshes cannot be added to the scene "
"directly. A MeshInstance3D represents one instance of a mesh in your scene. "
"You can reuse a single mesh in multiple MeshInstance3Ds to draw it in "
"different parts of your scene with different materials or transformations "
"(scale, rotation, position etc.)."
msgstr ""
"Mesh 和 ArrayMesh 是使用 MeshInstance 節點繪製的資源。像 Mesh 和 ArrayMesh 這"
"樣的資源不能直接新增到場景中。MeshInstance 代表的是某個網格在場景中的實例。您"
"可以在多個 MeshInstance 中重複使用同一個網格，用不同的材質或變換（縮放、旋"
"轉、位置等）在場景的不同部分繪製它。"

msgid ""
"If you are going to draw the same object many times, it can be helpful to "
"use a MultiMesh with a MultiMeshInstance3D. MultiMeshInstance3Ds draw meshes "
"thousands of times very cheaply by taking advantage of hardware instancing. "
"The drawback with using a MultiMeshInstance3D is that each of your mesh's "
"surfaces are limited to one material for all instances. It uses an instance "
"array to store different colors and transformations for each instance, but "
"all the instances of each surface use the same material."
msgstr ""
"如果你要多次繪製同一個物件，那麼使用 MultiMesh 與 MultiMeshInstance 就會很有"
"幫助。MultiMeshInstance 可以非常便宜地繪製數千次網格，利用的是硬體產生實體的"
"優勢。使用 MultiMeshInstance 的缺點是所有實例都只能使用同一種材質。它使用一個"
"實例陣列為每個實例儲存不同的顏色和變換，但所有實例的表面使用的都是相同的材"
"質。"

msgid "What a Mesh is"
msgstr "什麼是網格"

msgid ""
"A Mesh is composed of one or more surfaces. A surface is an array composed "
"of multiple sub-arrays containing vertices, normals, UVs, etc. Normally the "
"process of constructing surfaces and meshes is hidden from the user in the :"
"ref:`RenderingServer <class_RenderingServer>`, but with ArrayMeshes, the "
"user can construct a Mesh manually by passing in an array containing the "
"surface information."
msgstr ""
"網格（Mesh）由一個或多個表面（Surface）組成。表面是由多個子陣列組成的陣列，包"
"含頂點、法線、UV 等。通常情況下，建構表面和網格的過程對使用者來說是隱藏在 :"
"ref:`VisualServer <class_VisualServer>` 中的，但是通過 ArrayMesh，使用者可以"
"通過傳遞一個包含表面資訊的陣列來手動建構網格。"

msgid "Surfaces"
msgstr "表面"

msgid ""
"Each surface has its own material. Alternatively, you can override the "
"material for all surfaces in the Mesh when you use a MeshInstance3D using "
"the :ref:`material_override "
"<class_GeometryInstance3D_property_material_override>` property."
msgstr ""
"每個表面都有自己的材質。使用 MeshInstance 時，你也可以使用 :ref:"
"`material_override <class_GeometryInstance_property_material_override>` 屬性"
"來覆蓋 Mesh 中所有表面的材質。"

msgid "Surface array"
msgstr "表面陣列"

msgid ""
"The surface array is an array of length ``ArrayMesh.ARRAY_MAX``. Each "
"position in the array is filled with a sub-array containing per-vertex "
"information. For example, the array located at ``ArrayMesh.ARRAY_NORMAL`` is "
"a :ref:`PackedVector3Array <class_PackedVector3Array>` of vertex normals. "
"See :ref:`Mesh.ArrayType <enum_Mesh_ArrayType>` for more information."
msgstr ""
"表面陣列是一個長度為 ``ArrayMesh.ARRAY_MAX`` 的陣列。陣列中的每個位置都有一個"
"子陣列，包含每個頂點的資訊。例如，位於 ``ArrayMesh.ARRAY_NORMAL`` 處的陣列是"
"頂點法線的 :ref:`PoolVector3Array <class_PoolVector3Array>`。更多資訊請參閱 :"
"ref:`Mesh.ArrayType <enum_Mesh_ArrayType>`。"

msgid ""
"The surface array can be indexed or non-indexed. Creating a non-indexed "
"array is as easy as not assigning an array at the index ``ArrayMesh."
"ARRAY_INDEX``. A non-indexed array stores unique vertex information for "
"every triangle, meaning that when two triangles share a vertex, the vertex "
"is duplicated in the array. An indexed surface array only stores vertex "
"information for each unique vertex and then also stores an array of indices "
"which maps out how to construct the triangles from the vertex array. In "
"general, using an indexed array is faster, but it means you have to share "
"vertex data between triangles, which is not always desired (e.g. when you "
"want per-face normals)."
msgstr ""
"表面陣列可以是有索引的，也可以是非索引的。建立非索引陣列就像在索引 "
"``ArrayMesh.ARRAY_INDEX`` 處不分配陣列一樣簡單。非索引陣列為每個三角形儲存唯"
"一的頂點資訊，也就是說，當兩個三角形共用一個頂點時，頂點在陣列中是重複的。有"
"索引的曲面陣列只儲存每個唯一頂點的頂點資訊，然後還儲存一個索引陣列，它對應出"
"如何從頂點陣列建構三角形。一般來說，使用索引陣列的速度更快，但這意味著您必須"
"在三角形之間共用頂點資料，這並不總是需要的（例如，當您想要每面法線時）。"

msgid "Tools"
msgstr "工具"

msgid ""
"Godot provides different ways of accessing and working with geometry. More "
"information on each will be provided in the following tutorials."
msgstr ""
"Godot 提供了不同的存取和處理幾何體的方法. 關於每種方法的更多資訊將在下面的教"
"學中提供."

msgid "ArrayMesh"
msgstr "ArrayMesh"

msgid ""
"The ArrayMesh resource extends Mesh to add a few different quality of life "
"functions and, most importantly, the ability to construct a Mesh surface "
"through scripting."
msgstr ""
"ArrayMesh 資源擴充了 Mesh，增加了一些不同的便捷函式，最重要的是，可以通過腳本"
"建構 Mesh 表面。"

msgid ""
"For more information about the ArrayMesh, please see the :ref:`ArrayMesh "
"tutorial <doc_arraymesh>`."
msgstr ""
"有關ArrayMesh的更多資訊, 請參閱 :ref:`ArrayMesh tutorial <doc_arraymesh>`."

msgid "MeshDataTool"
msgstr "MeshDataTool"

msgid ""
"The MeshDataTool is a resource that converts Mesh data into arrays of "
"vertices, faces, and edges that can be modified at runtime."
msgstr ""
"MeshDataTool是一個將Mesh資料轉換為頂點, 面和邊的陣列的資源, 可以在運作時進行"
"修改."

msgid ""
"For more information about the MeshDataTool, please see the :ref:"
"`MeshDataTool tutorial <doc_meshdatatool>`."
msgstr ""
"有關 MeshDataTool 的完整列表, 請參見 :ref:`MeshDataTool tutorial "
"<doc_meshdatatool>`."

msgid "SurfaceTool"
msgstr "SurfaceTool"

msgid ""
"The SurfaceTool allows the creation of Meshes using an OpenGL 1.x immediate "
"mode style interface."
msgstr "SurfaceTool允許使用OpenGL 1.x即時模式風格的介面建立網格."

msgid ""
"For more information about the SurfaceTool, please see the :ref:`SurfaceTool "
"tutorial <doc_surfacetool>`."
msgstr ""
"有關SurfaceTool的更多資訊, 請閱讀 :ref:`SurfaceTool tutorial "
"<doc_surfacetool>`."

msgid "ImmediateMesh"
msgstr "即時幾何體"

#, fuzzy
msgid ""
"ImmediateMesh is a mesh that uses an immediate mode style interface (like "
"SurfaceTool) to draw objects. The difference between ImmediateMesh and the "
"SurfaceTool is that ImmediateMesh is drawn directly with code dynamically, "
"while the SurfaceTool is used to generate a Mesh that you can do whatever "
"you want with."
msgstr ""
"ImmediateGeometry（即時幾何體）是使用立即模式風格的介面繪製物件的節點（像 "
"SurfaceTool 一樣）。ImmediateGeometry 和 SurfaceTool 的區別在於，"
"ImmediateGeometry 本身是一個節點，可以新增到場景樹中，直接從程式碼中繪製。"
"SurfaceTool 則是生成一個 Mesh，需要新增到 MeshInstance 上才能看到。"

#, fuzzy
msgid ""
"ImmediateMesh is useful for prototyping because of its straightforward API, "
"but it is slow because the geometry is rebuilt each time you make a change. "
"It is most useful for adding simple geometry for visual debugging (e.g. by "
"drawing lines to visualize physics raycasts etc.)."
msgstr ""
"ImmediateGeometry 因為其直接的 API 而對原型設計很有用，但它的速度很慢，每一影"
"格都要重建幾何體。它最有用的是快速新增簡單的幾何體來進行視覺化除錯（例如，通"
"過畫線來視覺化物理光線投射等）。"

msgid ""
"For more information about ImmediateMesh, please see the :ref:`ImmediateMesh "
"tutorial <doc_immediatemesh>`."
msgstr ""
"有關 ImmediateGeometry 的更多資訊，請參見 :ref:`ImmediateGeometry 教學 "
"<doc_immediategeometry>`。"

msgid "Which one should I use?"
msgstr "GDScript是什麼？為什麼我要用它？"

msgid ""
"Which approach you use depends on what you are trying to do and what kind of "
"procedure you are comfortable with."
msgstr "用哪種方法取決於你想做什麼，以及你覺得什麼樣的做法用起來更舒服。"

msgid ""
"Both SurfaceTool and ArrayMesh are excellent for generating static geometry "
"(meshes) that don't change over time."
msgstr ""
"SurfaceTool和ArrayMesh都是生成不隨時間變化的靜態幾何體(網格)的絕佳工具."

msgid ""
"Using an ArrayMesh is slightly faster than using a SurfaceTool, but the API "
"is a little more challenging. Additionally, SurfaceTool has a few quality of "
"life methods such as ``generate_normals()`` and ``index()``."
msgstr ""
"使用 ArrayMesh 比使用 SurfaceTool 稍快一些，但 API 的難度更大一些。另外，"
"SurfaceTool 還有一些便捷的方法，比如 ``generate_normals()`` 和 ``index()``。"

#, fuzzy
msgid ""
"ImmediateMesh is more limited than both ArrayMesh and SurfaceTool. However, "
"if you need the geometry to change every frame anyway, it provides a much "
"easier interface that can be slightly faster than generating an ArrayMesh "
"every frame."
msgstr ""
"ImmediateGeometry 每一影格都會重新生成網格，所以它比 ArrayMesh 或 "
"SurfaceTool 慢很多。然而，如果你本來就需要每一影格都改變幾何體，它提供的介面"
"更簡單，甚至可能比每一影格生成一個 ArrayMesh 更快。"

msgid ""
"The MeshDataTool is not fast, but it gives you access to all kinds of "
"properties of the mesh that you don't get with the others (edges, faces, "
"etc.). It is incredibly useful when you need that sort of data to transform "
"the mesh, but it is not a good idea to use it if that extra information is "
"not needed. The MeshDataTool is best used if you are going to be using an "
"algorithm that requires access to the face or edge array."
msgstr ""
"MeshDataTool 的速度並不快，但它可以讓你存取網格的各種屬性，而這些屬性是其他工"
"具無法獲得的（邊、面等）。當你需要根據這類資料來變換網格時，它是非常有用的，"
"但如果不需要這些資訊，就不適合使用。如果您要使用需要存取面陣列或邊陣列的演算"
"法，最好使用 MeshDataTool。"

msgid "Translation status"
msgstr "翻譯狀態"
