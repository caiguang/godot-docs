# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using 3D transforms"
msgstr "使用 3D 變換"

msgid "Introduction"
msgstr "前言"

msgid ""
"If you have never made 3D games before, working with rotations in three "
"dimensions can be confusing at first. Coming from 2D, the natural way of "
"thinking is along the lines of *\"Oh, it's just like rotating in 2D, except "
"now rotations happen in X, Y and Z\"*."
msgstr ""
"如果您以前從未製作過3D遊戲, 那麼一開始在三維環境中進行旋轉可能會讓人感到困"
"惑. 從2D來的人, 自然的思維方式就是類似於 *\"噢, 它就像2D旋轉一樣, 只是現在旋"
"轉發生在X,Y和Z軸上\"* ."

msgid ""
"At first, this seems easy. For simple games, this way of thinking may even "
"be enough. Unfortunately, it's often incorrect."
msgstr ""
"起初這似乎很簡單。對於簡單的遊戲，這種思維方式甚至可能足夠了。不幸的是，這往"
"往是不正確的。"

msgid ""
"Angles in three dimensions are most commonly referred to as \"Euler Angles\"."
msgstr "三維角度通常被稱為“歐拉角”。"

msgid ""
"Euler angles were introduced by mathematician Leonhard Euler in the early "
"1700s."
msgstr "歐拉角是由數學家萊昂哈德•歐拉在 1700 年代初引入的。"

msgid ""
"This way of representing 3D rotations was groundbreaking at the time, but it "
"has several shortcomings when used in game development (which is to be "
"expected from a guy with a funny hat). The idea of this document is to "
"explain why, as well as outlining best practices for dealing with transforms "
"when programming 3D games."
msgstr ""
"這種代表三維旋轉的方式在當時是開創性的, 但在遊戲開發中使用時有一些缺點(這畢竟"
"是一個戴著滑稽帽子的傢伙想出來的). 本文的主旨是解釋其原因, 並概述在編寫3D遊戲"
"時處理變換的最佳做法."

msgid "Problems of Euler angles"
msgstr "歐拉角的問題"

msgid ""
"While it may seem intuitive that each axis has a rotation, the truth is that "
"it's just not practical."
msgstr "雖然看起來很直觀, 每個軸都有一個旋轉, 但事實是它就是不實用."

msgid "Axis order"
msgstr "軸順序"

msgid ""
"The main reason for this is that there isn't a *unique* way to construct an "
"orientation from the angles. There isn't a standard mathematical function "
"that takes all the angles together and produces an actual 3D rotation. The "
"only way an orientation can be produced from angles is to rotate the object "
"angle by angle, in an *arbitrary order*."
msgstr ""
"這樣的主要原因是沒有一種 *單一* 的從角度建構方向的方法. 沒有一個標準的數學函"
"式可以將所有角度放在一起並產生實際的3D旋轉. 從角度產生方向的唯一方法是以 *任"
"意順序* 按角度旋轉物體角度."

msgid ""
"This could be done by first rotating in *X*, then *Y* and then in *Z*. "
"Alternatively, you could first rotate in *Y*, then in *Z* and finally in "
"*X*. Anything works, but depending on the order, the final orientation of "
"the object will *not necessarily be the same*. Indeed, this means that there "
"are several ways to construct an orientation from 3 different angles, "
"depending on *the order of the rotations*."
msgstr ""
"這可以通過先旋轉 *X* , 然後 *Y* , 然後旋轉 *Z* 來完成. 或者, 你可以先以旋轉 "
"*Y* , 然後旋轉 *Z* , 最後旋轉 *X* . 怎樣都行, 但根據順序不同, 物件的最終方向 "
"*不一定是相同的* . 事實上, 這意味著有多種方法可以從3個不同的角度建構方向, 具"
"體取決於 *旋轉的順序* ."

msgid ""
"Following is a visualization of rotation axes (in X, Y, Z order) in a gimbal "
"(from Wikipedia). As you can see, the orientation of each axis depends on "
"the rotation of the previous one:"
msgstr ""
"下圖是一個萬向結(來自維琪百科), 它有視覺化的旋轉軸(以XYZ順序). 如你所見, 每個"
"軸的方向取決於前一個軸的旋轉方向:"

msgid ""
"You may be wondering how this affects you. Let's look at a practical example:"
msgstr "你可能想知道這是如何影響你的. 我們來看一個實際的範例:"

msgid ""
"Imagine you are working on a first-person controller (e.g. an FPS game). "
"Moving the mouse left and right controls your view angle parallel to the "
"ground, while moving it up and down moves the player's view up and down."
msgstr ""
"想像一下, 你正在做一個第一人稱控制器(例如FPS遊戲). 向左和向右移動滑鼠可以控制"
"與地面平行的視角, 同時上下移動可以調整遊戲角色上下的視野."

msgid ""
"In this case to achieve the desired effect, rotation must be applied first "
"in the *Y* axis (\"up\" in this case, since Godot uses a \"Y-Up\" "
"orientation), followed by rotation in the *X* axis."
msgstr ""
"為了實作希望的效果, 必須先在 *Y* 軸上應用旋轉(在這種情況下為 \"up(向上)\", 因"
"為Godot中Y軸指向正上方(\" Y-Up\" 方向)), 然後在 *X* 軸上旋轉."

msgid ""
"If we were to apply rotation in the *X* axis first, and then in *Y*, the "
"effect would be undesired:"
msgstr ""
"如果我們首先在 *X* 軸上應用旋轉, 然後再在 *Y* 軸上應用旋轉, 則效果會不理想:"

msgid ""
"Depending on the type of game or effect desired, the order in which you want "
"axis rotations to be applied may differ. Therefore, applying rotations in X, "
"Y, and Z is not enough: you also need a *rotation order*."
msgstr ""
"根據所需的遊戲型別或效果, 您想要應用軸旋轉的順序可能會有所不同. 因此, 在X,Y和"
"Z中應用旋轉是不夠的: 您還需要 *旋轉順序* ."

msgid "Interpolation"
msgstr "插值"

msgid ""
"Another problem with using Euler angles is interpolation. Imagine you want "
"to transition between two different camera or enemy positions (including "
"rotations). One logical way to approach this is to interpolate the angles "
"from one position to the next. One would expect it to look like this:"
msgstr ""
"使用歐拉角的另一個問題是插值. 設想您想在兩個不同的相機或敵人位置(包括旋轉)之"
"間轉換. 解決這個問題的一個合乎邏輯的方法是從一個位置插值到下一個位置. 人們會"
"期望它看起來像這樣:"

msgid "But this does not always have the expected effect when using angles:"
msgstr "但是, 在使用角度時, 這並不總是有預期的效果:"

msgid "The camera actually rotated the opposite direction!"
msgstr "相機實際上旋轉去了相反的方向！"

msgid "There are a few reasons this may happen:"
msgstr "這可能有幾個原因:"

msgid ""
"Rotations don't map linearly to orientation, so interpolating them does not "
"always result in the shortest path (i.e., to go from ``270`` to ``0`` "
"degrees is not the same as going from ``270`` to ``360``, even though the "
"angles are equivalent)."
msgstr ""
"旋轉不會線性對應到方向, 因此它們插值並不總是會形成最短路徑(即從 ``270`` 到 "
"``0`` 的度數與從 ``270`` 開始到 ``360`` 的度數不同, 即使角度是相同的)."

msgid ""
"Gimbal lock is at play (first and last rotated axis align, so a degree of "
"freedom is lost). See `Wikipedia's page on Gimbal Lock <https://en.wikipedia."
"org/wiki/Gimbal_lock>`_ for a detailed explanation of this problem."
msgstr ""
"萬向節鎖死 正在發揮作用(第一個和最後一個旋轉的軸對齊, 因此失去了一個自由度). "
"請參閱 `維琪百科關於Gimbal Lock 的頁面 <https://en.wikipedia.org/wiki/"
"Gimbal_lock>`_ 以瞭解這個問題的詳細解釋."

msgid "Say no to Euler angles"
msgstr "對歐拉角說不"

msgid ""
"The result of all this is that you should **not use** the ``rotation`` "
"property of :ref:`class_Node3D` nodes in Godot for games. It's there to be "
"used mainly in the editor, for coherence with the 2D engine, and for simple "
"rotations (generally just one axis, or even two in limited cases). As much "
"as you may be tempted, don't use it."
msgstr ""
"所有這些的結論是, 你 **不應該** 在遊戲中使用Godot :ref:`class_Spatial` 節點"
"的 ``rotation`` 屬性. 它主要用在編輯器中, 為了與2D引擎一致, 並且用於簡單的旋"
"轉(通常只有一個軸, 或者, 在有限的情況下, 兩個). 你可能會受到誘惑, 但不要使用"
"它."

msgid "Instead, there is a better way to solve your rotation problems."
msgstr "相反, 有一個更好的方法來解決你的旋轉問題."

msgid "Introducing transforms"
msgstr "變換的介紹"

msgid ""
"Godot uses the :ref:`class_Transform3D` datatype for orientations. Each :ref:"
"`class_Node3D` node contains a ``transform`` property which is relative to "
"the parent's transform, if the parent is a Node3D-derived type."
msgstr ""
"Godot裡的方向使用 :ref:`class_Transform` 資料型別. 每一個 :ref:"
"`class_Spatial` 節點都包含一個 ``transform`` 屬性, 如果該父類是一個空間衍生型"
"別, 則該屬性相對依賴於父類變換."

msgid ""
"It is also possible to access the world coordinate transform via the "
"``global_transform`` property."
msgstr "也可以通過 ``global_transform`` 屬性存取世界座標變換."

msgid ""
"A transform has a :ref:`class_Basis` (transform.basis sub-property), which "
"consists of three :ref:`class_Vector3` vectors. These are accessed via the "
"``transform.basis`` property and can be accessed directly by ``transform."
"basis.x``, ``transform.basis.y``, and ``transform.basis.z``. Each vector "
"points in the direction its axis has been rotated, so they effectively "
"describe the node's total rotation. The scale (as long as it's uniform) can "
"also be inferred from the length of the axes. A *basis* can also be "
"interpreted as a 3x3 matrix and used as ``transform.basis[x][y]``."
msgstr ""
"變換擁有一個基 :ref:`class_Basis`（transform.basis 子屬性），它由三個 :ref:"
"`class_Vector3` 向量組成。這些向量可以通過 ``transform.basis`` 屬性存取，也可"
"以使用 ``transform.basis.x``、``transform.basis.y``、``transform.basis.z`` 直"
"接存取。每個向量指向它的軸被旋轉的方向，因此它們可以有效地描述節點的總旋轉。"
"比例（只要它三個軸長度是一致的）也可以從軸的長度推斷出來。一個*基*也可以被解"
"釋為一個 3x3 矩陣並像 ``transform.basis[x][y]`` 這樣使用。"

msgid "A default basis (unmodified) is akin to:"
msgstr "預設的基（未經修改）類似於："

msgid "This is also an analog of a 3x3 identity matrix."
msgstr "這也類似於一個 3x3 單位矩陣。"

msgid ""
"Following the OpenGL convention, ``X`` is the *Right* axis, ``Y`` is the "
"*Up* axis and ``Z`` is the *Forward* axis."
msgstr "遵循OpenGL慣例, ``X`` 是 *右* 軸, ``Y`` 是 *上* 軸, ``Z`` 是 *前* 軸."

msgid ""
"Together with the *basis*, a transform also has an *origin*. This is a "
"*Vector3* specifying how far away from the actual origin ``(0, 0, 0)`` this "
"transform is. Combining the *basis* with the *origin*, a *transform* "
"efficiently represents a unique translation, rotation, and scale in space."
msgstr ""
"變換除了*基*以外還有一個*原點*。這是一個 *Vector3*，用於指定該變換距離實際原"
"點 ``(0, 0, 0)`` 有多遠。*變換*是*基*與*原點*的組合，可以有效地表示空間中特定"
"的平移、旋轉和縮放。"

msgid ""
"One way to visualize a transform is to look at an object's 3D gizmo while in "
"\"local space\" mode."
msgstr "視覺化變換的一種方法是在“本地空間”模式下查看該物件的 3D 小工具。"

msgid ""
"The gizmo's arrows show the ``X``, ``Y``, and ``Z`` axes (in red, green, and "
"blue respectively) of the basis, while the gizmo's center is at the object's "
"origin."
msgstr ""
"小工具的箭頭顯示的是基的 ``X``、``Y``、``Z`` 軸（分別為紅色、綠色、藍色），小"
"工具的中心位於該物件的原點。"

msgid ""
"For more information on the mathematics of vectors and transforms, please "
"read the :ref:`doc_vector_math` tutorials."
msgstr ""
"有關向量和變換在數學方面的更多資訊, 請閱讀 :ref:`doc_vector_math` 教學."

msgid "Manipulating transforms"
msgstr "操作變換"

msgid ""
"Of course, transforms are not as straightforward to manipulate as angles and "
"have problems of their own."
msgstr "當然, 變換並不像角度那樣容易控制, 並且有它自己的問題."

msgid ""
"It is possible to rotate a transform, either by multiplying its basis by "
"another (this is called accumulation), or by using the rotation methods."
msgstr ""
"可以對變換進行旋轉，方法是將基與另一個基相乘（稱作累加），或者使用其旋轉方"
"法。"

msgid "A method in Node3D simplifies this:"
msgstr "Spatial中的一種方法簡化了這個操作:"

msgid "This rotates the node relative to the parent node."
msgstr "這會相對於父節點來旋轉節點."

msgid ""
"To rotate relative to object space (the node's own transform), use the "
"following:"
msgstr "要相對於物件空間旋轉(節點自己的變換), 請使用下面的方法:"

msgid "Precision errors"
msgstr "精度誤差"

msgid ""
"Doing successive operations on transforms will result in a loss of precision "
"due to floating-point error. This means the scale of each axis may no longer "
"be exactly ``1.0``, and they may not be exactly ``90`` degrees from each "
"other."
msgstr ""
"對變換執行連續的操作將導致由於浮點錯誤導致的精度損失. 這意味著每個軸的比例可"
"能不再精確地為 ``1.0`` , 並且它們可能不完全相互為 ``90`` 度."

msgid ""
"If a transform is rotated every frame, it will eventually start deforming "
"over time. This is unavoidable."
msgstr ""
"如果一個變換每影格旋轉一次, 它最終會隨著時間的推移開始變形. 這是不可避免的."

msgid ""
"There are two different ways to handle this. The first is to "
"*orthonormalize* the transform after some time (maybe once per frame if you "
"modify it every frame):"
msgstr ""
"有兩種不同的方法來處理這個問題. 首先是在一段時間後對變換進行 *正交正規化"
"(orthonormalize)* 處理(如果每影格修改一次, 則可能每影格一次):"

msgid ""
"This will make all axes have ``1.0`` length again and be ``90`` degrees from "
"each other. However, any scale applied to the transform will be lost."
msgstr ""
"這將使所有的軸再次擁有有 ``1.0`` 的長度並且彼此成 ``90`` 度角. 但是, 應用於變"
"換的任何縮放都將丟失."

msgid ""
"It is recommended you not scale nodes that are going to be manipulated; "
"scale their children nodes instead (such as MeshInstance3D). If you "
"absolutely must scale the node, then re-apply it at the end:"
msgstr ""
"建議您不要縮放要操縱的節點, 而是縮放其子節點(如MeshInstance). 如果您必須縮放"
"節點, 則在最後重新應用它:"

msgid "Obtaining information"
msgstr "獲取資訊"

msgid ""
"You might be thinking at this point: **\"Ok, but how do I get angles from a "
"transform?\"**. The answer again is: you don't. You must do your best to "
"stop thinking in angles."
msgstr ""
"現在你可能在想: **\"好吧, 但是我怎麼從變換中獲得角度？\"** . 答案又一次是: 沒"
"有必要. 你必須盡最大努力停止用角度思考."

msgid ""
"Imagine you need to shoot a bullet in the direction your player is facing. "
"Just use the forward axis (commonly ``Z`` or ``-Z``)."
msgstr ""
"想像一下, 你需要朝你的遊戲角色面對的方向射擊子彈. 只需使用向前的軸(通常為 "
"``Z`` 或 ``-Z`` )."

msgid ""
"Is the enemy looking at the player? Use the dot product for this (see the :"
"ref:`doc_vector_math` tutorial for an explanation of the dot product):"
msgstr ""
"敵人在看著遊戲角色嗎？ 為此判斷你可以使用點積（請參閱 :ref:`doc_vector_math` "
"教學以獲取對點積的解釋）："

msgid "Strafe left:"
msgstr "向左平移:"

msgid "Jump:"
msgstr "跳躍:"

msgid "All common behaviors and logic can be done with just vectors."
msgstr "所有常見的行為和邏輯都可以用向量來完成."

msgid "Setting information"
msgstr "設定資訊"

msgid ""
"There are, of course, cases where you want to set information to a "
"transform. Imagine a first person controller or orbiting camera. Those are "
"definitely done using angles, because you *do want* the transforms to happen "
"in a specific order."
msgstr ""
"當然, 有些情況下你想要將一些資訊賦予到變換上. 想像一下第一人稱控制器或環繞旋"
"轉的相機. 那些肯定是用角度來完成的, 因為你 *確實希望* 變換以特定的順序進行."

#, fuzzy
msgid ""
"For such cases, keep the angles and rotations *outside* the transform and "
"set them every frame. Don't try to retrieve and reuse them because the "
"transform is not meant to be used this way."
msgstr ""
"對於這種情況, 請保證角度/旋轉在變換 *外部* , 並每影格設定他們. 不要嘗試獲取並"
"重新使用它們, 因為變換是不該這麼用的."

msgid "Example of looking around, FPS style:"
msgstr "環顧四周,FPS風格的範例:"

msgid ""
"As you can see, in such cases it's even simpler to keep the rotation "
"outside, then use the transform as the *final* orientation."
msgstr ""
"如您所見, 在這種情況下, 保持外部旋轉更為簡單, 然後使用變換作為 *最後的* 方向."

msgid "Interpolating with quaternions"
msgstr "用四元數插值"

msgid ""
"Interpolating between two transforms can efficiently be done with "
"quaternions. More information about how quaternions work can be found in "
"other places around the Internet. For practical use, it's enough to "
"understand that pretty much their main use is doing a closest path "
"interpolation. As in, if you have two rotations, a quaternion will smoothly "
"allow interpolation between them using the closest axis."
msgstr ""
"用四元數能有效率地完成兩個變換之間的插值. 有關四元數如何工作的更多資訊可以在"
"互聯網上的其他地方找到. 在實際應用中, 瞭解它們的主要用途是做最短路插值就足夠"
"了. 同樣, 如果你有兩個旋轉, 四元數將平滑地使用最近的軸在它們之間進行插值."

msgid "Converting a rotation to quaternion is straightforward."
msgstr "將旋轉轉換為四元數很簡單."

msgid ""
"The :ref:`class_Quaternion` type reference has more information on the "
"datatype (it can also do transform accumulation, transform points, etc., "
"though this is used less often). If you interpolate or apply operations to "
"quaternions many times, keep in mind they need to be eventually normalized. "
"Otherwise, they will also suffer from numerical precision errors."
msgstr ""
":ref:`class_Quat` 型別引用有更多關於資料型別的資訊(它還可以做變換累加, 變換點"
"等, 不過這個使用頻率較低). 如果你多次對四元數進行插值或應用操作, 請記住它們最"
"終需要被正規化. 否則, 會帶來數值精度誤差影響."

msgid ""
"Quaternions are useful when doing camera/path/etc. interpolations, as the "
"result will always be correct and smooth."
msgstr ""
"四元數在處理相機/路徑/等東西的移動軌跡時很有用. 插值的結果總會是正確且平滑的."

msgid "Transforms are your friend"
msgstr "變換是你的朋友"

msgid ""
"For most beginners, getting used to working with transforms can take some "
"time. However, once you get used to them, you will appreciate their "
"simplicity and power."
msgstr ""
"對於大多數初學者來說, 習慣於使用變換可能需要一些時間. 但是, 一旦你習慣了它"
"們, 你會欣賞他們的簡單而有力."

msgid ""
"Don't hesitate to ask for help on this topic in any of Godot's `online "
"communities <https://godotengine.org/community>`_ and, once you become "
"confident enough, please help others!"
msgstr ""
"不要猶豫, 在Godot的任何 `線上社區 <https://godotengine.org/community>`_ 網站"
"上尋求幫助, 一旦你變得足夠自信, 請幫助其他人！"

msgid "Translation status"
msgstr "翻譯狀態"
