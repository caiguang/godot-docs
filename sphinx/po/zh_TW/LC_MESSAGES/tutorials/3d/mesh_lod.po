# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Mesh level of detail (LOD)"
msgstr "網格的細節級別（LOD）"

msgid ""
"Level of detail (LOD) is one of the most important ways to optimize "
"rendering performance in a 3D project, along with :ref:"
"`doc_occlusion_culling`."
msgstr ""
"與 :ref:`doc_occlusion_culling` 一樣，細節級別（LOD）是優化 3D 專案算繪性能的"
"最重要方法之一。"

msgid "On this page, you'll learn:"
msgstr "在本指南中，我們將學到："

msgid "How mesh LOD can improve your 3D project's rendering performance."
msgstr "網格 LOD 如何提高 3D 專案的算繪性能。"

msgid "How to set up mesh LOD in Godot."
msgstr "如何在 Godot 中設定網格 LOD。"

msgid ""
"How to measure mesh LOD's effectiveness in your project (and alternatives "
"you can explore if it doesn't meet your expectations)."
msgstr ""
"如何衡量網格 LOD 在專案中的效果（如果達不到預期效果，還可以探索其他方法）。"

msgid ""
"You can see how mesh LOD works in action using the `Occlusion Culling and "
"Mesh LOD demo project <https://github.com/godotengine/godot-demo-projects/"
"tree/master/3d/occlusion_culling_mesh_lod>`__."
msgstr ""
"除了這份說明文件，你可能也會想看看 `Godot Demo 專案 <https://github.com/"
"godotengine/godot-demo-projects>`_ 。"

msgid "Introduction"
msgstr "前言"

msgid ""
"Historically, level of detail in 3D games involved manually authoring meshes "
"with lower geometry density, then configuring the distance thresholds at "
"which these lower-detailed meshes should be drawn. This approach is still "
"used today when increased control is needed."
msgstr ""
"從歷史上看，3D 遊戲中的細節層次包括手動繪製幾何密度較低的網格，然後配置距離閾"
"值，在距離閾值上繪製這些細節較低的網格。如今，當需要加強控制時，這種方法仍在"
"使用。"

msgid ""
"However, in projects that have a large amount of detailed 3D assets, setting "
"up LOD manually can be a very time-consuming process. As a result, automatic "
"mesh decimation and LOD configuration is becoming increasingly popular."
msgstr ""
"然而，在擁有大量詳細 3D 素材的專案中，手動設定 LOD 可能是一個非常耗時的過程。"
"因此，自動網格細分和 LOD 配置越來越受歡迎。"

msgid ""
"Godot provides a way to automatically generate less detailed meshes for LOD "
"usage on import, then use those LOD meshes when needed automatically. This "
"is completely transparent to the user. The `meshoptimizer <https://"
"meshoptimizer.org/>`__ library is used for LOD mesh generation behind the "
"scenes."
msgstr ""
"Godot 提供了一種方法，可以在匯入時自動生成細節較少的網格供 LOD 使用，然後在需"
"要時自動使用這些 LOD 網格。這對使用者完全透明。`meshoptimizer <https://"
"meshoptimizer.org/>`__ 庫用於幕後的 LOD 網格生成。"

msgid ""
"Mesh LOD works with any node that draws 3D meshes. This includes "
"MeshInstance3D, MultiMeshInstance3D, GPUParticles3D and CPUParticles3D."
msgstr ""
"網格 LOD 適用於任何繪製 3D 網格的節點。這包括 MeshInstance3D、"
"MultiMeshInstance3D、GPUParticles3D 和 CPUParticles3D。"

msgid "Visual comparison"
msgstr "視覺比較"

msgid ""
"Here is an example of LOD meshes generated on import. Lower detailed meshes "
"will be used when the camera is far away from the object:"
msgstr ""
"以下是匯入時生成 LOD 網格的範例。當相機遠離物體時，將使用細節較少的網格："

msgid "From most detailed (left) to least detailed (right), shaded view"
msgstr "從最詳細（左）到最不詳細（右），陰影視圖"

msgid ""
"Here's the same image with wireframe rendering to make the decimation easier "
"to see:"
msgstr "這是使用線框算繪的同一張圖像，以使抽取更容易看到："

msgid "From most detailed (left) to least detailed (right), wireframe view"
msgstr "從最詳細（左）到最不詳細（右），線框視圖"

msgid ""
"If you need to manually configure level of detail with artist-created "
"meshes, use :ref:`doc_visibility_ranges` instead of automatic mesh LOD."
msgstr ""
"如果您需要使用藝術家建立的網格手動配置細節級別，請使用 doc_visibility_ranges "
"而不是自動網格 LOD。"

msgid "Generating mesh LOD"
msgstr "建立內容"

msgid ""
"By default, mesh LOD generation happens automatically for imported 3D scenes "
"(glTF, .blend, Collada, FBX). Once LOD meshes are generated, they will "
"automatically be used when rendering the scene. You don't need to configure "
"anything manually."
msgstr ""
"預設情況下，匯入的 3D 場景（glTF、.blend、Collada、FBX）會自動產生網格 LOD。 "
"LOD 網格產生後，算繪場景時將自動使用它們。您無需手動配置任何內容。"

msgid ""
"However, mesh LOD generation does **not** automatically happen for imported "
"3D meshes (OBJ). This is because OBJ files are not imported as full 3D "
"scenes by default, but only as individual mesh resources to load into a "
"MeshInstance3D node (or GPUParticles3D, CPUParticles3D, ...)."
msgstr ""
"但是，對於匯入的 3D 網格 (OBJ)，網格 LOD 產生**不會**自動發生。這是因為預設情"
"況下，OBJ 檔案不會作為完整的 3D 場景匯入，而僅作為單獨的網格資源載入到 "
"MeshInstance3D 節點（或 GPUParticles3D、CPUParticles3D...）中。"

msgid ""
"To make an OBJ file have mesh LOD generated for it, select it in the "
"FileSystem dock, go to the Import dock, change its **Import As** option to "
"**Scene** then click **Reimport**:"
msgstr ""
"若要使OBJ 檔案為其產生網格LOD，請在檔案系統擴充座中選擇它，請前往匯入擴充塢，"
"將其**匯入為** 選項變更為**場景**，然後按一下**重新匯入**："

msgid "Changing the import type on an OBJ file in the Import dock"
msgstr "在匯入塢中變更 OBJ 檔案的匯入型別"

msgid "This will require restarting the editor after clicking **Reimport**."
msgstr "這將需要在單擊“**重新匯入**”後重新啟動編輯器。"

msgid ""
"The mesh LOD generation process is not perfect, and may occasionally "
"introduce rendering issues (especially in skinned meshes). Mesh LOD "
"generation can also take a while on complex meshes."
msgstr ""
"網格 LOD 生成過程並不完美，有時可能會引入算繪問題（尤其是在蒙皮網格中）。在複"
"雜的網格上，網格 LOD 產生也可能需要一段時間。"

msgid ""
"If mesh LOD causes a specific mesh to look broken, you can disable LOD "
"generation for it in the Import dock. This will also speed up resource "
"importing. This can be done globally in the 3D scene's import options, or on "
"a per-mesh basis using the Advanced Import Settings dialog."
msgstr ""
"如果網格 LOD 導致特定網格看起來損壞，您可以在匯入塢中停用它的 LOD 產生。這也"
"將加快資源匯入速度。這可以在 3D 場景的匯入選項中全域完成，也可以使用「進階匯"
"入設定」對話方塊在每個網格上完成。"

msgid ""
"See :ref:`Importing 3D scenes "
"<doc_importing_3d_scenes_using_the_import_dock>` for more information."
msgstr "請參考 :ref:`doc_running_code_in_the_editor` 以瞭解詳情。"

msgid "Comparing mesh LOD visuals and performance"
msgstr "比較網格 LOD 視覺效果和性能"

msgid ""
"To disable mesh LOD in the editor for comparison purposes, use the **Disable "
"Mesh LOD** advanced debug draw mode. This can be done using the menu in the "
"top-left corner of the 3D viewport (labeled **Perspective** or "
"**Orthogonal** depending on camera mode):"
msgstr ""
"若要在編輯器中停用網格 LOD 以進行比較，請使用 **停用網格 LOD** 進階偵錯繪製模"
"式。這可以使用 3D 視窗左上角的選單來完成（標記為 **透視** 或 **正交**，取決於"
"相機模式）："

msgid "Disabling mesh LOD in the 3D viewport's top-left menu"
msgstr "在 3D 視口左上角的選單中禁用網格 LOD"

msgid ""
"Enable **View Frame Time** in the same menu to view FPS in the top-right "
"corner. Also enable **View Information** in the same menu to view the number "
"of primitives (vertices + indices) rendered in the bottom-right corner."
msgstr ""
"在同一選單中啟用**查看影格時間**可在右上角查看 FPS。也可以在同一選單中啟用**"
"查看資訊**，以查看右下角算繪的像素（頂點+索引）的數量。"

msgid ""
"If mesh LOD is working correctly in your scene and your camera is far away "
"enough from the mesh, you should notice the number of drawn primitives "
"decreasing and FPS increasing when mesh LOD is left enabled (unless you are "
"CPU-bottlenecked)."
msgstr ""
"如果網格LOD 在您的場景中正常工作，並且您的相機距離網格足夠遠，您應該會注意"
"到，當網格LOD 保持啟用狀態時，繪製的像素數量會減少，而FPS 會增加（除非您遇到"
"CPU 瓶頸）。"

msgid ""
"To see mesh LOD decimation in action, change the debug draw mode to "
"**Display Wireframe** in the menu specified above, then adjust the "
"**Rendering > Mesh LOD > LOD Change > Threshold Pixels** project setting."
msgstr ""
"若要查看網格LOD 抽取的實際效果，請在上面指定的選單中將偵錯繪製模式變更為**顯"
"示線框**，然後調整**算繪> 網格LOD > LOD 變更> 閾值像素** 專案設定。"

msgid "Configuring mesh LOD performance and quality"
msgstr "配置網格 LOD 性能和質量"

msgid ""
"You can adjust how aggressive mesh LOD transitions should be in the root "
"viewport by changing the **Rendering > Mesh LOD > LOD Change > Threshold "
"Pixels** project setting. To change this value at run-time, set "
"``mesh_lod_threshold`` on the root viewport as follows:"
msgstr ""
"您可以透過變更 **算繪 > 網格 LOD > LOD 變更 > 閾值像素** 專案設定來調整根視窗"
"中網格 LOD 過渡的激程序度。若要在執行時變更此值，請在根視窗上設定"
"``mesh_lod_threshold``，如下所示："

msgid ""
"Each viewport has its own ``mesh_lod_threshold`` property, which can be set "
"independently from other viewports."
msgstr ""
"每個視窗都有自己的「mesh_lod_threshold」屬性，可以獨立於其他視窗進行設定。"

msgid ""
"The default mesh LOD threshold of 1 pixel is tuned to look *perceptually* "
"lossless; it provides a significant performance gain with an unnoticeable "
"loss in quality. Higher values will make LOD transitions happen sooner when "
"the camera moves away, resulting in higher performance but lower quality."
msgstr ""
"預設網格 LOD 閾值 1 像素經過調整，看起來「感知上」無損；它提供了顯著的性能提"
"升，但品質卻有不明顯的損失。當相機移開時，較高的值將使 LOD 過渡更快發生，從而"
"導致更高的性能但品質較低。"

msgid ""
"If you need to perform per-object adjustments to mesh LOD, you can adjust "
"how aggressive LOD transitions should be by adjusting the **LOD Bias** "
"property on any node that inherits from GeometryInstance3D. Values *above* "
"``1.0`` will make LOD transitions happen later than usual (resulting in "
"higher quality but lower performance). Values *below* ``1.0`` will make LOD "
"transitions happen sooner than usual (resulting in lower quality but higher "
"performance)."
msgstr ""
"如果需要對網格 LOD 執行每個物件的調整，則可以透過調整繼承自 "
"GeometryInstance3D 的任何節點上的 **LOD Bias** 屬性來調整 LOD 過渡的激程序"
"度。 *高於*``1.0`` 的值將使 LOD 轉換比平常晚發生（導致品質更高但性能更低）。 "
"*低於*``1.0`` 的值將使 LOD 轉換比平常更快發生（導致品質較低但效能較高）。"

msgid ""
"Additionally, ReflectionProbe nodes have their own **Mesh LOD Threshold** "
"property that can be adjusted to improve rendering performance when the "
"reflection probe updates. This is especially important for ReflectionProbes "
"that use the **Always** update mode."
msgstr ""
"此外，ReflectionProbe 節點具有自己的 **網格 LOD 閾值** 屬性，可在反射探查更新"
"時對其進行調整以提高算繪效能。這對於使用 **Always** 更新模式的 "
"ReflectionProbes 尤其重要。"

msgid ""
"When rendering the scene, mesh LOD selection uses a screen-space metric. "
"This means it automatically takes camera field of view and viewport "
"resolution into account. Higher camera FOV and lower viewport resolutions "
"will make LOD selection more aggressive; the engine will display heavily "
"decimated models earlier when the camera moves away."
msgstr ""
"算繪場景時，網格 LOD 選擇使用螢幕空間度量。這意味著它會自動考慮相機視野和視口"
"解析度。較高的相機 FOV 和較低的視口解析度將使 LOD 選擇更加積極；當相機移開"
"時，引擎將提前顯示嚴重破壞的模型。"

msgid ""
"As a result, unlike :ref:`doc_visibility_ranges`, you don't need to do "
"anything specific in your project to take camera FOV and viewport resolution "
"into account."
msgstr ""
"因此，與 doc_visibility_ranges 不同，您無需在專案中執行任何特定操作即可考慮相"
"機 FOV 和視窗解析度。"

msgid "Using mesh LOD with MultiMesh and particles"
msgstr "將網格 LOD 與 MultiMesh 和粒子結合使用"

msgid ""
"For LOD selection, the point of the node's :abbr:`AABB (Axis-Aligned "
"Bounding Box)` that is the closest to the camera is used as a basis. This "
"applies to any kind of mesh LOD (including for individual MeshInstance3D)s, "
"but this has some implications for nodes that display multiple meshes at "
"once, such as MultiMeshInstance3D, GPUParticles3D and GPUParticles3D. Most "
"importantly, this means that all instances will be drawn with the same LOD "
"level at a given time."
msgstr ""
"對於 LOD 選擇，節點的 AABB（軸對齊邊界框）最接近相機的點用作基礎。這適用於任"
"何型別的網格 LOD（包括單一 MeshInstance3D），但這對於同時顯示多個網格的節點"
"（例如 MultiMeshInstance3D、GPUParticles3D 和 GPUParticles3D）有一些影響。最"
"重要的是，這意味著在給定時間所有實例都將使用相同的 LOD 層級進行繪製。"

msgid ""
"If you are noticing incorrect LOD selection with GPUParticles3D, make sure "
"the node's visibility AABB is configured by selecting the GPUParticles3D "
"node and using **GPUParticles3D > Generate AABB** at the top of the 3D "
"viewport."
msgstr ""
"如果您發現 GPUParticles3D 的 LOD 選擇不正確，請確保透過選擇 GPUParticles3D 節"
"點並使用 3D 視窗頂部的 **GPUParticles3D > 產生 AABB** 來配置節點的可見性 "
"AABB。"

msgid ""
"If you have instances in a MultiMesh that are far away from each other, they "
"should be placed in a separate MultiMeshInstance3D node. Doing so will also "
"improve rendering performance, as frustum and occlusion culling will be able "
"to cull individual nodes (while they can't cull individual instances in a "
"MultiMesh)."
msgstr ""
"如果 MultiMesh 中的執行個體彼此距離較遠，則應將它們放置在單獨的 "
"MultiMeshInstance3D 節點中。這樣做還將提高算繪效能，因為視錐體和遮蔽剔除將能"
"夠剔除單一節點（儘管它們無法剔除 MultiMesh 中的單一實例）。"

msgid "Translation status"
msgstr "翻譯狀態"
