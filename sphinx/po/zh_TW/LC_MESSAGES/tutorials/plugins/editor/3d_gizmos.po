# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "3D gizmo plugins"
msgstr "3D小工具外掛"

msgid "Introduction"
msgstr "前言"

msgid ""
"3D gizmo plugins are used by the editor and custom plugins to define the "
"gizmos attached to any kind of Node3D node."
msgstr ""
"3D 小工具外掛程式是由編輯器和自訂外掛程式來定義附加到任何型別的 Node3D 節點的"
"小工具。"

msgid ""
"This tutorial shows the two main approaches to defining your own custom "
"gizmos. The first option works well for simple gizmos and creates less "
"clutter in your plugin structure, and the second one will let you store some "
"per-gizmo data."
msgstr ""
"本教學將向您展示定義您自己的自訂小工具的兩種主要方法。第一種方法對於簡單的小"
"工具來說效果很好，並且在你的外掛程式結構中較少的混亂，而第二種方法將讓你儲存"
"每個小工具的一些資料。"

msgid ""
"This tutorial assumes you already know how to make generic plugins. If in "
"doubt, refer to the :ref:`doc_making_plugins` page."
msgstr ""
"本教學假設您已經知道如何製作通用外掛程式。如有疑問，請參閱 :ref:"
"`doc_making_plugins` 頁面。"

msgid "The EditorNode3DGizmoPlugin"
msgstr "EditorNode3DGizmoPlugin"

msgid ""
"Regardless of the approach we choose, we will need to create a new :ref:"
"`EditorNode3DGizmoPlugin <class_EditorNode3DGizmoPlugin>`. This will allow "
"us to set a name for the new gizmo type and define other behaviors such as "
"whether the gizmo can be hidden or not."
msgstr ""
"不管我們選擇什麼方式，都需要建立一個新的 :ref:`EditorSpatialGizmoPlugin "
"<class_EditorSpatialGizmoPlugin>`。我們可以為新建的小工具型別設定名稱並定義其"
"他行為，比如是否可以隱藏。"

msgid "This would be a basic setup:"
msgstr "這是一個基本設定:"

msgid ""
"For simple gizmos, inheriting :ref:`EditorNode3DGizmoPlugin "
"<class_EditorNode3DGizmoPlugin>` is enough. If you want to store some per-"
"gizmo data or you are porting a Godot 3.0 gizmo to 3.1+, you should go with "
"the second approach."
msgstr ""
"簡單的小工具只要繼承 :ref:`EditorSpatialGizmoPlugin "
"<class_EditorSpatialGizmoPlugin>` 就足夠了。如果你想儲存每個小工具的一些資"
"料，或者你要把 Godot 3.0 的小工具移植到 3.1+，你應該選擇第二種方法。"

msgid "Simple approach"
msgstr "簡單方法"

#, fuzzy
msgid ""
"The first step is to, in our custom gizmo plugin, override the :ref:"
"`_has_gizmo()<class_EditorNode3DGizmoPlugin_private_method__has_gizmo>` "
"method so that it returns ``true`` when the node parameter is of our target "
"type."
msgstr ""
"第一步，在我們的自訂小工具外掛程式中，重寫 :ref:"
"`has_gizmo()<class_EditorSpatialGizmoPlugin_method_has_gizmo>` 方法，當空間參"
"數為目標型別時，它將返回 ``true``。"

#, fuzzy
msgid ""
"Then we can override methods like :ref:"
"`_redraw()<class_EditorNode3DGizmoPlugin_private_method__redraw>` or all the "
"handle related ones."
msgstr ""
"我們可以重寫譬如 :ref:"
"`redraw()<class_EditorSpatialGizmoPlugin_method_redraw>` 的方法，或所有與控制"
"碼相關的方法。"

msgid ""
"Note that we created a material in the `_init` method, and retrieved it in "
"the `_redraw` method using :ref:"
"`get_material()<class_EditorNode3DGizmoPlugin_method_get_material>`. This "
"method retrieves one of the material's variants depending on the state of "
"the gizmo (selected and/or editable)."
msgstr ""
"請注意，我們在 `_init` 方法中建立了一個材質，並在 `redraw` 方法中使用 :ref:"
"`get_material()<class_EditorSpatialGizmoPlugin_method_get_material>` 取得它。"
"該方法根據小工具的狀態（選擇中和/或可編輯）來獲取材質的變體。"

msgid "So the final plugin would look somewhat like this:"
msgstr "您最後的場景應該是這樣的:"

msgid ""
"Note that we just added some handles in the `_redraw` method, but we still "
"need to implement the rest of handle-related callbacks in :ref:"
"`EditorNode3DGizmoPlugin <class_EditorNode3DGizmoPlugin>` to get properly "
"working handles."
msgstr ""
"注意，我們只是在重繪方法中新增了一些控制碼，但是我們仍然需要在 :ref:"
"`EditorSpatialGizmoPlugin <class_EditorSpatialGizmoPlugin>` 中實作其他與控制"
"碼相關的回呼函式，以獲得正確的工作控制碼。"

msgid "Alternative approach"
msgstr "替代方法"

msgid ""
"In some cases we want to provide our own implementation of :ref:"
"`EditorNode3DGizmo<class_EditorNode3DGizmo>`, maybe because we want to have "
"some state stored in each gizmo or because we are porting an old gizmo "
"plugin and we don't want to go through the rewriting process."
msgstr ""
"在某些情況下，我們希望提供自己的 :ref:"
"`EditorSpatialGizmo<class_EditorSpatialGizmo>` 實作，也許是因為我們想要在每個"
"小工具中儲存一些狀態，或者正在移植一個舊的小工具外掛程式，而不想經歷重寫過"
"程。"

#, fuzzy
msgid ""
"In these cases all we need to do is, in our new gizmo plugin, override :ref:"
"`_create_gizmo()<class_EditorNode3DGizmoPlugin_private_method__create_gizmo>`, "
"so it returns our custom gizmo implementation for the Node3D nodes we want "
"to target."
msgstr ""
"在這些情況下，我們需要做的就是在我們的新小工具外掛程式中覆蓋 :ref:"
"`create_gizmo()<class_EditorSpatialGizmoPlugin_method_create_gizmo>`，讓它返"
"回我們想要實作的目標 Spatial 節點的自訂小工具。"

msgid ""
"This way all the gizmo logic and drawing methods can be implemented in a new "
"class extending :ref:`EditorNode3DGizmo<class_EditorNode3DGizmo>`, like so:"
msgstr ""
"這樣，所有的小工具邏輯和繪圖方法都可以在一個新的類中實作，這個類擴充自 :ref:"
"`EditorSpatialGizmo<class_EditorSpatialGizmo>`，像這樣："

msgid ""
"Note that we just added some handles in the `_redraw` method, but we still "
"need to implement the rest of handle-related callbacks in :ref:"
"`EditorNode3DGizmo<class_EditorNode3DGizmo>` to get properly working handles."
msgstr ""
"請注意，我們剛剛在重繪方法中新增了一些控制碼，但我們仍然需要在 :ref:"
"`EditorSpatialGizmo<class_EditorSpatialGizmo>` 中實作其餘的與控制碼相關的回呼"
"函式，以獲得正確工作的控制碼。"

msgid "Translation status"
msgstr "翻譯狀態"
