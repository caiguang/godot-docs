# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Import plugins"
msgstr "匯入外掛程式"

msgid ""
"This tutorial assumes you already know how to make generic plugins. If in "
"doubt, refer to the :ref:`doc_making_plugins` page. This also assumes you "
"are acquainted with Godot's import system."
msgstr ""
"本教學假設您已經知道如何製作通用外掛程式. 如有疑問, 請參閱 :ref:"
"`doc_making_plugins` 頁面. 這也假設您熟悉Godot的匯入系統."

msgid "Introduction"
msgstr "前言"

msgid ""
"An import plugin is a special type of editor tool that allows custom "
"resources to be imported by Godot and be treated as first-class resources. "
"The editor itself comes bundled with a lot of import plugins to handle the "
"common resources like PNG images, Collada and glTF models, Ogg Vorbis "
"sounds, and many more."
msgstr ""
"匯入外掛程式是一種特殊的編輯器工具, 它允許Godot匯入自訂資源, 並將其作為一級資"
"源對待. 編輯器本身捆綁了很多匯入外掛程式來處理常見的資源, 如PNG圖片, Collada"
"和glTF模型, Ogg Vorbis聲音等等."

msgid ""
"This tutorial shows how to create an import plugin to load a custom text "
"file as a material resource. This text file will contain three numeric "
"values separated by comma, which represents the three channels of a color, "
"and the resulting color will be used as the albedo (main color) of the "
"imported material. In this example it contains the pure blue color (zero "
"red, zero green, and full blue):"
msgstr ""
"本教學將向您展示如何建立一個簡單的匯入外掛程式, 以將自訂文字檔作為材質資源載"
"入. 此文字檔將包含由逗號分隔的三個數值, 它表示顏色的三個通道, 並且生成的顏色"
"將用作匯入材質的反射(主顏色). 在此範例中, 它將包含純藍色(紅色0, 綠色0和滿藍"
"色):"

msgid "Configuration"
msgstr "配置"

msgid ""
"First we need a generic plugin that will handle the initialization and "
"destruction of our import plugin. Let's add the ``plugin.cfg`` file first:"
msgstr ""
"首先, 我們需要一個通用外掛程式來處理匯入外掛程式的初始化和銷毀. 讓我們先新增 "
"``plugin.cfg`` 檔案:"

msgid ""
"Then we need the ``material_import.gd`` file to add and remove the import "
"plugin when needed:"
msgstr ""
"然後我們需要 ``material_import.gd`` 檔來在需要時新增和刪除匯入外掛程式:"

msgid ""
"When this plugin is activated, it will create a new instance of the import "
"plugin (which we'll soon make) and add it to the editor using the :ref:"
"`add_import_plugin() <class_EditorPlugin_method_add_import_plugin>` method. "
"We store a reference to it in a class member ``import_plugin`` so we can "
"refer to it later when removing it. The :ref:`remove_import_plugin() "
"<class_EditorPlugin_method_remove_import_plugin>` method is called when the "
"plugin is deactivated to clean up the memory and let the editor know the "
"import plugin isn't available anymore."
msgstr ""
"當這個外掛程式被啟動時, 它將建立一個新的匯入外掛程式實例(我們很快就會製作), "
"並使用 :ref:`add_import_plugin() "
"<class_EditorPlugin_method_add_import_plugin>` 方法將其加入編輯器. 我們在類成"
"員 ``import_plugin'`` 中儲存它的引用, 這樣我們就可以在以後刪除它時引用它. :"
"ref:`remove_import_plugin() "
"<class_EditorPlugin_method_remove_import_plugin>` 方法在外掛程式停用時被呼"
"叫, 以清理記憶體並讓編輯器知道匯入外掛程式不再可用."

msgid ""
"Note that the import plugin is a reference type, so it doesn't need to be "
"explicitly released from memory with the ``free()`` function. It will be "
"released automatically by the engine when it goes out of scope."
msgstr ""
"注意, 匯入外掛程式是一個參考型別, 所以它不需要明確地用 ``free()`` 函式從記憶"
"體中釋放. 當它超出範圍時, 將被引擎自動釋放."

msgid "The EditorImportPlugin class"
msgstr "EditorImportPlugin 類"

msgid ""
"The main character of the show is the :ref:`EditorImportPlugin class "
"<class_EditorImportPlugin>`. It is responsible for implementing the methods "
"that are called by Godot when it needs to know how to deal with files."
msgstr ""
"這個展示的主角是 :ref:`EditorImportPlugin 類 <class_EditorImportPlugin>`. 它"
"負責實作Godot需要知道如何處理檔時呼叫的方法."

msgid "Let's begin to code our plugin, one method at time:"
msgstr "讓我們開始編寫我們的外掛程式, 一個方法:"

#, fuzzy
msgid ""
"The first method is the :ref:"
"`_get_importer_name()<class_EditorImportPlugin_private_method__get_importer_name>`. "
"This is a unique name for your plugin that is used by Godot to know which "
"import was used in a certain file. When the files needs to be reimported, "
"the editor will know which plugin to call."
msgstr ""
"第一個方法是 :ref:"
"`get_importer_name()<class_EditorImportPlugin_method_get_importer_name>`. 這"
"是你的外掛程式的唯一名稱,Godot用它來知道在某個檔中使用了哪個匯入. 當檔需要重"
"新匯入時, 編輯器會知道該呼叫哪個外掛程式."

#, fuzzy
msgid ""
"The :ref:"
"`_get_visible_name()<class_EditorImportPlugin_private_method__get_visible_name>` "
"method is responsible for returning the name of the type it imports and it "
"will be shown to the user in the Import dock."
msgstr ""
":ref:`get_visible_name()<class_EditorImportPlugin_method_get_visible_name>` "
"方法負責返回它匯入的型別的名稱, 它將在匯入停靠區顯示給使用者."

msgid ""
"You should choose this name as a continuation to \"Import as\", e.g. "
"*\"Import as Silly Material\"*. You can name it whatever you want but we "
"recommend a descriptive name for your plugin."
msgstr ""
"你選擇的名字應該可以接到“匯入為”後面，例如*“匯入為 Silly Material”*。你可以隨"
"心所欲地命名，但我們建議為你的外掛程式起一個描述性的名字。"

#, fuzzy
msgid ""
"Godot's import system detects file types by their extension. In the :ref:"
"`_get_recognized_extensions()<class_EditorImportPlugin_private_method__get_recognized_extensions>` "
"method you return an array of strings to represent each extension that this "
"plugin can understand. If an extension is recognized by more than one "
"plugin, the user can select which one to use when importing the files."
msgstr ""
"Godot的匯入系統通過副檔名偵測檔案型別. 在 :ref:"
"`get_recognized_extensions()<class_EditorImportPlugin_method_get_recognized_extensions>` "
"方法中, 返回一個字串陣列, 代表這個外掛程式能理解的每個副檔名. 如果一個副檔名"
"被一個以上的外掛程式識別, 使用者可以在匯入檔時選擇使用哪一個."

msgid ""
"Common extensions like ``.json`` and ``.txt`` might be used by many plugins. "
"Also, there could be files in the project that are just data for the game "
"and should not be imported. You have to be careful when importing to "
"validate the data. Never expect the file to be well-formed."
msgstr ""
"許多外掛程式可能會使用像 ``.json`` 和 ``.txt`` 這樣的常見擴充. 此外, 專案中可"
"能存在僅作為遊戲資料的檔, 不應匯入. 匯入時必須小心以驗證資料. 永遠不要指望檔"
"案格式正確."

msgid ""
"The imported files are saved in the ``.import`` folder at the project's "
"root. Their extension should match the type of resource you are importing, "
"but since Godot can't tell what you'll use (because there might be multiple "
"valid extensions for the same resource), you need to declare what will be "
"used in the import."
msgstr ""
"匯入的檔被保存在專案根部的 ``.import`` 資料夾中. 它們的副檔名應與你要匯入的資"
"源型別相配對, 但由於Godot不能告訴你將使用什麼(因為同一資源可能有多個有效的副"
"檔名), 你需要宣告將在匯入時使用的內容."

msgid ""
"Since we're importing a Material, we'll use the special extension for such "
"resource types. If you are importing a scene, you can use ``scn``. Generic "
"resources can use the ``res`` extension. However, this is not enforced in "
"any way by the engine."
msgstr ""
"由於我們正在匯入材質, 因此我們將對此類資源型別使用特殊擴充. 如果要匯入場景, "
"可以使用 ``scn`` . 通用資源可以使用 ``res`` 副檔名. 但是, 引擎不會以任何方式"
"強制執行此操作."

msgid ""
"The imported resource has a specific type, so the editor can know which "
"property slot it belongs to. This allows drag and drop from the FileSystem "
"dock to a property in the Inspector."
msgstr ""
"匯入的資源具有特定型別，編輯器可以據此知道它屬於哪個屬性槽。這樣就能夠將其從"
"檔案系統面板拖放到屬性面板的屬性之中。"

msgid ""
"In our case it's a :ref:`class_StandardMaterial3D`, which can be applied to "
"3D objects."
msgstr "在我們的範例中, 它是 :ref:`class_SpatialMaterial`, 可以應用於3D物件."

msgid ""
"If you need to import different types from the same extension, you have to "
"create multiple import plugins. You can abstract the import code on another "
"file to avoid duplication in this regard."
msgstr ""
"如果需要從同一擴充中匯入不同型別, 則必須建立多個匯入外掛程式. 您可以在另一個"
"檔上抽象匯入程式碼, 以避免在這方面出現重複."

msgid "Options and presets"
msgstr "選項和預設"

msgid ""
"Your plugin can provide different options to allow the user to control how "
"the resource will be imported. If a set of selected options is common, you "
"can also create different presets to make it easier for the user. The "
"following image shows how the options will appear in the editor:"
msgstr ""
"您的外掛程式可以提供不同的選項, 以允許使用者控制資源的匯入方式. 如果一組選定"
"的選項很常見, 您還可以建立不同的預設以使使用者更容易. 下圖顯示了選項在編輯器"
"中的顯示方式:"

msgid ""
"Since there might be many presets and they are identified with a number, "
"it's a good practice to use an enum so you can refer to them using names."
msgstr ""
"由於可能有許多預設並且它們用數位識別碼, 因此使用列舉是一個很好的做法, 因此您"
"可以使用名稱來引用它們."

msgid ""
"Now that the enum is defined, let's keep looking at the methods of an import "
"plugin:"
msgstr "既然定義了列舉, 讓我們繼續看一下匯入外掛程式的方法:"

#, fuzzy
msgid ""
"The :ref:`_get_preset_count() "
"<class_EditorImportPlugin_private_method__get_preset_count>` method returns "
"the amount of presets that this plugins defines. We only have one preset "
"now, but we can make this method future-proof by returning the size of our "
"``Presets`` enumeration."
msgstr ""
":ref:`get_preset_count() <class_EditorImportPlugin_method_get_preset_count>` "
"方法返回這個外掛程式定義的預置數量. 我們現在只有一個預設, 但我們可以通過返回"
"我們的 ``Presets`` 列舉的大小來使該方法適應未來的需求."

#, fuzzy
msgid ""
"Here we have the :ref:`_get_preset_name() "
"<class_EditorImportPlugin_private_method__get_preset_name>` method, which "
"gives names to the presets as they will be presented to the user, so be sure "
"to use short and clear names."
msgstr ""
"這裡我們有 :ref:`get_preset_name() "
"<class_EditorImportPlugin_method_get_preset_name>` 方法, 它給出預設的名字, 因"
"為它們將被展示給使用者, 所以一定要使用簡短而清晰的名字."

msgid ""
"We can use the ``match`` statement here to make the code more structured. "
"This way it's easy to add new presets in the future. We use the catch all "
"pattern to return something too. Although Godot won't ask for presets beyond "
"the preset count you defined, it's always better to be on the safe side."
msgstr ""
"我們可以在這裡使用 ``match`` 敘述來使程式碼更加結構化. 這樣, 將來很容易新增新"
"的預設. 我們使用catch all模式來返回一些東西. 雖然Godot不會要求超出您定義的預"
"設計數的預設, 但最好是安全起見."

msgid ""
"If you have only one preset you could simply return its name directly, but "
"if you do this you have to be careful when you add more presets."
msgstr ""
"如果您只有一個預設, 則可以直接返回其名稱, 但如果您這樣做, 則在新增更多預設時"
"必須小心."

#, fuzzy
msgid ""
"This is the method which defines the available options. :ref:"
"`_get_import_options() "
"<class_EditorImportPlugin_private_method__get_import_options>` returns an "
"array of dictionaries, and each dictionary contains a few keys that are "
"checked to customize the option as its shown to the user. The following "
"table shows the possible keys:"
msgstr ""
"這是定義可用選項的方法. :ref:`get_import_options() "
"<class_EditorImportPlugin_method_get_import_options>` 返回一個字典陣列, 每個"
"字典包含一些可被檢查的鍵, 以便在其顯示給使用者時定制選項. 下表顯示了可能的鍵:"

msgid "Key"
msgstr "鍵"

msgid "Type"
msgstr "型別"

msgid "Description"
msgstr "說明"

msgid "``name``"
msgstr "``name``"

msgid "String"
msgstr "字串"

msgid ""
"The name of the option. When showed, underscores become spaces and first "
"letters are capitalized."
msgstr "選項的名稱. 顯示時, 底線變為空格, 首字母大寫."

msgid "``default_value``"
msgstr "``default_value``"

msgid "Any"
msgstr "任何型別"

msgid "The default value of the option for this preset."
msgstr "此預設的選項的預設值."

msgid "``property_hint``"
msgstr "``property_hint``"

msgid "Enum value"
msgstr "列舉值"

msgid ""
"One of the :ref:`PropertyHint <enum_@GlobalScope_PropertyHint>` values to "
"use as hint."
msgstr ""
":ref:`PropertyHint <enum_@GlobalScope_PropertyHint>` 中的一個值, 作為提示使"
"用."

msgid "``hint_string``"
msgstr "``hint_string``"

msgid ""
"The hint text of the property. The same as you'd add in the ``export`` "
"statement in GDScript."
msgstr "屬性的提示文字. 與您在GDScript中的 ``export`` 敘述中新增相同."

msgid "``usage``"
msgstr "``usage``"

msgid ""
"One of the :ref:`PropertyUsageFlags <enum_@GlobalScope_PropertyUsageFlags>` "
"values to define the usage."
msgstr ""
":ref:`PropertyUsageFlags <enum_@GlobalScope_PropertyUsageFlags>` 中的一個值來"
"定義用途."

msgid ""
"The ``name`` and ``default_value`` keys are **mandatory**, the rest are "
"optional."
msgstr "``name`` 和 ``default_value`` 鍵是 **強制** , 其餘是可選的."

msgid ""
"Note that the ``_get_import_options`` method receives the preset number, so "
"you can configure the options for each different preset (especially the "
"default value). In this example we use the ``match`` statement, but if you "
"have lots of options and the presets only change the value you may want to "
"create the array of options first and then change it based on the preset."
msgstr ""
"請注意, ``get_import_options`` 方法接收預設編號, 因此您可以為每個不同的預設"
"(尤其是預設值)配置選項. 在這個範例中, 我們使用 ``match`` 敘述, 但是如果您有很"
"多選項並且預設只改變了您可能想要首先建立選項陣列的值, 然後根據預設更改它."

msgid ""
"The ``_get_import_options`` method is called even if you don't define "
"presets (by making ``_get_preset_count`` return zero). You have to return an "
"array even it's empty, otherwise you can get errors."
msgstr ""
"即使您沒有定義預設(通過使 ``get_preset_count`` 返回零), 也會呼叫 "
"``get_import_options`` 方法. 您必須返回一個陣列, 即使它是空的, 否則您可能會得"
"到錯誤."

#, fuzzy
msgid ""
"For the :ref:`_get_option_visibility() "
"<class_EditorImportPlugin_private_method__get_option_visibility>` method, we "
"simply return ``true`` because all of our options (i.e. the single one we "
"defined) are visible all the time."
msgstr ""
"對於 :ref:`get_option_visibility() "
"<class_EditorImportPlugin_method_get_option_visibility>` 方法, 我們只需返回 "
"``true`` , 因為我們所有的選項(即我們定義的單個選項)始終是可見的."

msgid ""
"If you need to make certain option visible only if another is set with a "
"certain value, you can add the logic in this method."
msgstr ""
"如果只有在使用某個值設定了另一個選項時才需要使某個選項可見, 則可以在此方法中"
"新增邏輯."

msgid "The ``import`` method"
msgstr "``import`` 方法"

#, fuzzy
msgid ""
"The heavy part of the process, responsible for converting the files into "
"resources, is covered by the :ref:`_import() "
"<class_EditorImportPlugin_private_method__import>` method. Our sample code "
"is a bit long, so let's split in a few parts:"
msgstr ""
"負責將檔轉換為資源的重要部分由 :ref:`import() "
"<class_EditorImportPlugin_method_import>` 方法涵蓋. 我們的範例程式碼有點長, "
"所以讓我們分成幾個部分:"

msgid ""
"The first part of our import method opens and reads the source file. We use "
"the :ref:`FileAccess <class_FileAccess>` class to do that, passing the "
"``source_file`` parameter which is provided by the editor."
msgstr ""
"我們匯入方法的第一部分是打開並讀取原始檔案. 使用 :ref:`File <class_File>` 類"
"來做到這一點, 傳遞 ``source_file`` 參數, 該參數由編輯器提供."

msgid ""
"If there's an error when opening the file, we return it to let the editor "
"know that the import wasn't successful."
msgstr "如果打開檔時出錯, 我們將其返回以讓編輯器知道匯入不成功."

msgid ""
"This code takes the line of the file it read before and splits it in pieces "
"that are separated by a comma. If there are more or less than the three "
"values, it considers the file invalid and reports an error."
msgstr ""
"此程式碼獲取之前讀取的檔行, 並將其拆分為以逗號分隔的片段. 如果有多於或少於三"
"個值, 則認為該檔無效並報告錯誤."

msgid ""
"Then it creates a new :ref:`Color <class_Color>` variable and sets its "
"values according to the input file. If the ``use_red_anyway`` option is "
"enabled, then it sets the color as a pure red instead."
msgstr ""
"然後它建立一個新的 :ref:`Color <class_Color>` 變數, 並根據輸入檔設定其值. 如"
"果啟用了 ``use_red_anyway`` 選項, 那麼它將顏色設定為純紅色."

msgid ""
"This part makes a new :ref:`StandardMaterial3D <class_StandardMaterial3D>` "
"that is the imported resource. We create a new instance of it and then set "
"its albedo color as the value we got before."
msgstr ""
"這一部分製作了一個新的 :ref:`SpatialMaterial <class_SpatialMaterial>` , 這是"
"匯入的資源. 我們建立一個新的實例, 然後將其反射顏色設定為我們之前得到的值."

msgid ""
"This is the last part and quite an important one, because here we save the "
"made resource to the disk. The path of the saved file is generated and "
"informed by the editor via the ``save_path`` parameter. Note that this comes "
"**without** the extension, so we add it using :ref:`string formatting "
"<doc_gdscript_printf>`. For this we call the ``_get_save_extension`` method "
"that we defined earlier, so we can be sure that they won't get out of sync."
msgstr ""
"這是最後一個部分, 也是相當重要的部分, 因為在這裡我們把製作好的資源保存到磁片"
"上. 保存檔的路徑由編輯器通過 ``save_path`` 參數生成並告知. 注意, 這個參數 **"
"沒有** 副檔名, 所以我們用 :ref:`string formatting <doc_gdscript_printf>` 新增"
"它. 為此, 我們呼叫前面定義的 ``get_save_extension`` 方法, 這樣我們就可以確保"
"它們不會丟失同步."

msgid ""
"We also return the result from the :ref:`ResourceSaver.save() "
"<class_ResourceSaver_method_save>` method, so if there's an error in this "
"step, the editor will know about it."
msgstr ""
"我們還返回 :ref:`ResourceSaver.save() <class_ResourceSaver_method_save>` 方法"
"的結果, 所以如果這一步有錯誤, 編輯器會知道."

msgid "Platform variants and generated files"
msgstr "平臺變體和生成的檔"

msgid ""
"You may have noticed that our plugin ignored two arguments of the ``import`` "
"method. Those are *return arguments* (hence the ``r`` at the beginning of "
"their name), which means that the editor will read from them after calling "
"your import method. Both of them are arrays that you can fill with "
"information."
msgstr ""
"您可能已經注意到我們的外掛程式忽略了 ``import`` 方法的兩個參數。那些是*返回參"
"數*（因此它們的名稱以 ``r`` 開頭），這意味著編輯器會在呼叫您的 import 方法之"
"後讀取它們。它們都是可以填充資訊的陣列。"

msgid ""
"The ``r_platform_variants`` argument is used if you need to import the "
"resource differently depending on the target platform. While it's called "
"*platform* variants, it is based on the presence of :ref:`feature tags "
"<doc_feature_tags>`, so even the same platform can have multiple variants "
"depending on the setup."
msgstr ""
"``r_platform_variants`` 參數用於需要根據目標平臺匯入不同的資源. 雖然被稱為 *"
"平臺* 變體, 但它是基於 :ref:`feature tags <doc_feature_tags>` 的存在, 所以即"
"使是同一個平臺也可以有多個變體, 這取決於設定."

msgid ""
"To import a platform variant, you need to save it with the feature tag "
"before the extension, and then push the tag to the ``r_platform_variants`` "
"array so the editor can know that you did."
msgstr ""
"要匯入平臺變體, 需要在副檔名之前使用feature標記保存它, 然後將標記推送到 "
"``r_platform_variants`` 陣列, 以便編輯可以知道您做了."

msgid ""
"For example, let's say we save a different material for a mobile platform. "
"We would need to do something like the following:"
msgstr "例如, 假設我們為移動平臺保存一個不同的材質. 我們將需要做如下的事情:"

msgid ""
"The ``r_gen_files`` argument is meant for extra files that are generated "
"during your import process and need to be kept. The editor will look at it "
"to understand the dependencies and make sure the extra file is not "
"inadvertently deleted."
msgstr ""
"``r_gen_files`` 參數用於在匯入過程中生成並需要保留的額外檔. 編輯器將查看它以"
"瞭解依賴關係並確保不會無意中刪除額外檔."

msgid ""
"This is also an array and should be filled with full paths of the files you "
"save. As an example, let's create another material for the next pass and "
"save it in a different file:"
msgstr ""
"這也是一個陣列, 應該填充您保存的檔的完整路徑. 例如, 讓我們為下一個傳遞建立另"
"一個材質並將其保存在不同的檔中:"

msgid "Trying the plugin"
msgstr "試試這個外掛程式"

msgid ""
"This has been theoretical, but now that the import plugin is done, let's "
"test it. Make sure you created the sample file (with the contents described "
"in the introduction section) and save it as ``test.mtxt``. Then activate the "
"plugin in the Project Settings."
msgstr ""
"這是理論上的, 但是現在匯入外掛程式已經完成了, 讓我們來測試一下. 確保您建立了"
"範例檔(包含介紹部分中描述的內容)並將其另存為 ``test.mtxt`` . 然後在 \"專案設"
"定\" 中啟動外掛程式."

msgid ""
"If everything goes well, the import plugin is added to the editor and the "
"file system is scanned, making the custom resource appear on the FileSystem "
"dock. If you select it and focus the Import dock, you can see the only "
"option to select there."
msgstr ""
"如果一切順利, 匯入外掛程式將新增到編輯器中並掃描檔案系統, 使自訂資源顯示在"
"FileSystem基座上. 如果選擇它並聚焦匯入面板, 則可以看到選擇該選項的唯一選項."

msgid ""
"Create a MeshInstance3D node in the scene, and for its Mesh property set up "
"a new SphereMesh. Unfold the Material section in the Inspector and then drag "
"the file from the FileSystem dock to the material property. The object will "
"update in the viewport with the blue color of the imported material."
msgstr ""
"在場景中建立一個 MeshInstance 節點，為其 Mesh 屬性設定一個新的 SphereMesh。"
"在“屬性面板”中展開 Material 部分，然後將檔從“檔案系統”面板拖動到材質屬性。物"
"件將在視口中使用匯入材質的藍色進行更新。"

msgid ""
"Go to Import dock, enable the \"Use Red Anyway\" option, and click on "
"\"Reimport\". This will update the imported material and should "
"automatically update the view showing the red color instead."
msgstr ""
"轉到匯入面板, 啟用 \"強制使用紅色\" 選項, 然後按一下 \"重新匯入\". 這將更新匯"
"入的材質, 並應該自動更新顯示紅色的視圖."

msgid ""
"And that's it! Your first import plugin is done! Now get creative and make "
"plugins for your own beloved formats. This can be quite useful to write your "
"data in a custom format and then use it in Godot as if they were native "
"resources. This shows how the import system is powerful and extendable."
msgstr ""
"就是這樣！ 你的第一個匯入外掛程式已經完成！ 現在就發揮創造力，為自己心愛的格"
"式製作外掛程式吧。這對於以自訂格式編寫資料然後在 Godot 中使用它就像它們是本機"
"資源一樣非常有用。這顯示了匯入系統如何強大和可擴充。"

msgid "Translation status"
msgstr "翻譯狀態"
