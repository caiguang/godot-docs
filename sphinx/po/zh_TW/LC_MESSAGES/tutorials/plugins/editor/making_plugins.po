# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Making plugins"
msgstr "製作外掛程式"

msgid "About plugins"
msgstr "關於外掛程式"

msgid ""
"A plugin is a great way to extend the editor with useful tools. It can be "
"made entirely with GDScript and standard scenes, without even reloading the "
"editor. Unlike modules, you don't need to create C++ code nor recompile the "
"engine. While this makes plugins less powerful, there are still many things "
"you can do with them. Note that a plugin is similar to any scene you can "
"already make, except it is created using a script to add editor "
"functionality."
msgstr ""
"外掛程式是用有用的工具來擴充編輯器的一個好方法. 它可以完全用GDScript和標準場"
"景製作, 甚至不需要重新載入編輯器. 與模組不同, 你不需要建立C++程式碼也不需要重"
"新編譯引擎. 雖然這使得外掛程式的功能不那麼強大, 但你仍然可以用它們做很多事"
"情. 請注意, 一個外掛程式與你已經可以製作的任何場景相似, 只是它是用腳本建立"
"的, 以增加編輯器功能."

msgid ""
"This tutorial will guide you through the creation of two plugins so you can "
"understand how they work and be able to develop your own. The first is a "
"custom node that you can add to any scene in the project, and the other is a "
"custom dock added to the editor."
msgstr ""
"這個教學會教您寫兩個簡單的外掛程式來幫助您理解外掛程式如何運作和如何寫外掛程"
"式. 首先是一個可以往任何場景新增的自訂節點, 其次呢, 是個可以往編輯器裡新增的"
"自訂面板."

msgid "Creating a plugin"
msgstr "建立外掛程式"

msgid ""
"Before starting, create a new empty project wherever you want. This will "
"serve as a base to develop and test the plugins."
msgstr ""
"在開始前, 先找個地方建立個空專案. 這個空專案是製作和測試我們外掛程式的基礎."

msgid ""
"The first thing you need for the editor to identify a new plugin is to "
"create two files: a ``plugin.cfg`` for configuration and a tool script with "
"the functionality. Plugins have a standard path like ``addons/plugin_name`` "
"inside the project folder. Godot provides a dialog for generating those "
"files and placing them where they need to be."
msgstr ""
"編輯器要識別一個新的外掛程式, 首先需要建立兩個檔: 一個是 ``plugin.cfg`` 用於"
"配置和具有此功能的工具腳本. 外掛程式在專案檔案夾裡面有一個標準路徑, 比如 "
"``addons/plugin_name``.Godot提供了一個屬性框, 用於生成這些檔並將它們放在需要"
"的位置."

msgid ""
"In the main toolbar, click the ``Project`` dropdown. Then click ``Project "
"Settings...``. Go to the ``Plugins`` tab and then click on the ``Create New "
"Plugin`` button in the top-right."
msgstr ""
"在主工具列中，點擊 ``專案`` 下拉式功能表，然後點擊 ``專案設定...``。然後轉到 "
"``外掛程式`` 分頁，點擊右上角的 ``建立`` 按鈕。"

msgid "You will see the dialog appear, like so:"
msgstr "你會看到出現了一個對話方塊，類似這樣："

msgid ""
"The placeholder text in each field describes how it affects the plugin's "
"creation of the files and the config file's values."
msgstr "每個欄位中文字屬性都描述了它會影響到哪些設定檔的值."

msgid "To continue with the example, use the following values:"
msgstr "有下列事項需注意："

msgid ""
"Unchecking the ``Activate now?`` option in C# is always required because, "
"like every other C# script, the EditorPlugin script needs to be compiled "
"which requires building the project. After building the project the plugin "
"can be enabled in the ``Plugins`` tab of ``Project Settings``."
msgstr ""
"始終需要在 C# 中去掉對 ``立即啟動？`` 選項的勾選，因為和其他 C# 腳本一樣，"
"EditorPlugin 腳本是需要編譯的，要求建構整個專案。建構專案後，就可以在 ``專案"
"設定`` 的 ``外掛程式`` 分頁中啟用該外掛程式。"

msgid "You should end up with a directory structure like this:"
msgstr "你最終的目錄結構應該是這樣顯示的："

msgid ""
"``plugin.cfg`` is an INI file with metadata about your plugin. The name and "
"description help people understand what it does. Your name helps you get "
"properly credited for your work. The version number helps others know if "
"they have an outdated version; if you are unsure on how to come up with the "
"version number, check out `Semantic Versioning <https://semver.org/>`_. The "
"main script file will instruct Godot what your plugin does in the editor "
"once it is active."
msgstr ""
"``plugin.cfg`` 是一個簡單的INI檔, 包含關於你的外掛程式的中繼資料. 名稱和描述"
"有助於人們瞭解它的作用. 你的名字有助於你的工作得到正確的認可. 版本號可以幫助"
"別人知道他們是否有一個過時的版本；如果你不確定如何得出版本號, 請查看 "
"`Semantic Versioning <https://semver.org/>`_ . 主指令檔將指示Godot, 一旦你的"
"外掛程式被啟動後, 它將在編輯器中做什麼."

msgid "The script file"
msgstr "指令檔"

msgid ""
"Upon creation of the plugin, the dialog will automatically open the "
"EditorPlugin script for you. The script has two requirements that you cannot "
"change: it must be a ``@tool`` script, or else it will not load properly in "
"the editor, and it must inherit from :ref:`class_EditorPlugin`."
msgstr ""
"建立外掛程式後, 對話方塊會自動為你打開EditorPlugin腳本. 該腳本有兩個要求, 你"
"不能改變: 它必須是一個 ``@tool`` 腳本, 否則將無法在編輯器中正常載入；它必須繼"
"承 :ref:`class_EditorPlugin`."

msgid ""
"In addition to the EditorPlugin script, any other GDScript that your plugin "
"uses must *also* be a tool. Any GDScript without ``@tool`` imported into the "
"editor will act like an empty file!"
msgstr ""
"除了 EditorPlugin 腳本之外，外掛程式用到的其他 GDScript *也*必須是工具腳本。*"
"沒有 ``@tool`` 的 GDScript 在匯入編輯器後都會像空檔一樣！*建構專案時不會重新"
"載入沒有 ``[Tool]`` 的 C# 類，你就只能重新啟用外掛程式了！"

#, fuzzy
msgid ""
"It's important to deal with initialization and clean-up of resources. A good "
"practice is to use the virtual function :ref:`_enter_tree() "
"<class_Node_private_method__enter_tree>` to initialize your plugin and :ref:"
"`_exit_tree() <class_Node_private_method__exit_tree>` to clean it up. "
"Thankfully, the dialog generates these callbacks for you. Your script should "
"look something like this:"
msgstr ""
"處理好資源的初始化和清理是很重要的。一個好的做法是使用虛函式 :ref:"
"`_enter_tree() <class_Node_method__enter_tree>` 來初始化你的外掛程式，以及 :"
"ref:`_exit_tree() <class_Node_method__exit_tree>` 來清理它。值得慶倖的是，對"
"話方塊為你生成了這些回呼函式。你的腳本應該看起來像這樣："

msgid "This is a good template to use when creating new plugins."
msgstr "這是建立新外掛程式時使用的好範本."

msgid "A custom node"
msgstr "自訂節點"

msgid ""
"Sometimes you want a certain behavior in many nodes, such as a custom scene "
"or control that can be reused. Instancing is helpful in a lot of cases, but "
"sometimes it can be cumbersome, especially if you're using it in many "
"projects. A good solution to this is to make a plugin that adds a node with "
"a custom behavior."
msgstr ""
"有時您希望在許多節點中存在某種行為, 例如可以重複使用的自訂場景或控制項. 產生"
"實體在很多情況下都很有用, 但有時它會很麻煩, 特別是如果您在許多專案中使用它. "
"一個很好的解決方案是建立一個外掛程式, 新增一個具有自訂行為的節點."

msgid ""
"Nodes added via an EditorPlugin are \"CustomType\" nodes. While they work "
"with any scripting language, they have fewer features than :ref:`the Script "
"Class system <doc_gdscript_basics_class_name>`. If you are writing GDScript "
"or NativeScript, we recommend using Script Classes instead."
msgstr ""
"通過 EditorPlugin 新增的節點是“CustomType”（自訂型別）節點。雖然它們可以用於"
"任何指令碼語言，但功能比 :ref:`Script 類系統 "
"<doc_gdscript_basics_class_name>`少。如果你正在編寫 GDScript 或 "
"NativeScript，建議使用 Script 類代替。"

msgid ""
"To create a new node type, you can use the function :ref:`add_custom_type() "
"<class_EditorPlugin_method_add_custom_type>` from the :ref:"
"`class_EditorPlugin` class. This function can add new types to the editor "
"(nodes or resources). However, before you can create the type, you need a "
"script that will act as the logic for the type. While that script doesn't "
"have to use the ``@tool`` annotation, it can be added so the script runs in "
"the editor."
msgstr ""
"要建立一個新的節點型別, 你可以使用來自 :ref:`class_EditorPlugin` 類的 :ref:"
"`add_custom_type() <class_EditorPlugin_method_add_custom_type>` 這個函式. 這"
"個函式可以向編輯器新增新的型別(節點或資源). 但是, 在你建立型別之前, 需要一個"
"腳本, 作為型別的邏輯. 雖然該腳本不一定要使用 ``@tool`` 關鍵字, 但可以新增它, "
"以便腳本在編輯器中運作."

msgid ""
"For this tutorial, we'll create a button that prints a message when clicked. "
"For that, we'll need a script that extends from :ref:`class_Button`. It "
"could also extend :ref:`class_BaseButton` if you prefer:"
msgstr ""
"在本教學中, 我們將建立一個簡單的按鈕, 在點擊時列印出一條資訊. 對此, 我們需要"
"一個從 :ref:`class_Button` 擴充的簡單腳本. 如果你願意, 它也可以擴充 :ref:"
"`class_BaseButton` :"

msgid ""
"That's it for our basic button. You can save this as ``my_button.gd`` inside "
"the plugin folder. You'll also need a 16×16 icon to show in the scene tree. "
"If you don't have one, you can grab the default one from the engine and save "
"it in your `addons/my_custom_node` folder as `icon.png`, or use the default "
"Godot logo (`preload(\"res://icon.svg\")`)."
msgstr ""
"這就是我們的基本按鈕了. 你可以把它保存為外掛程式資料夾中的 ``my_button."
"gd`` . 你還需要一個16×16的圖示來顯示在場景樹中. 如果你沒有, 可以從引擎中抓取"
"預設的, 並保存在你的 ``addons/my_custom_node`` 資料夾中, 作為 ``icon.png`` , "
"或者使用預設的Godot旗標( `preload(\"res://icon.png\")` ). 如果需要, 你也可以"
"使用SVG圖示."

msgid ""
"SVG images that are used as custom node icons should have the **Editor > "
"Scale With Editor Scale** and **Editor > Convert Icons With Editor Theme** :"
"ref:`import options <doc_importing_images_editor_import_options>` enabled. "
"This allows icons to follow the editor's scale and theming settings if the "
"icons are designed with the same color palette as Godot's own icons."
msgstr ""

msgid ""
"Now, we need to add it as a custom type so it shows on the **Create New "
"Node** dialog. For that, change the ``custom_node.gd`` script to the "
"following:"
msgstr ""
"現在，我們需要把它作為一個自訂型別新增，以便它顯示在**新建 Node** 的對話方塊"
"中。為此，將 ``custom_node.gd`` 腳本改為以下內容："

msgid ""
"With that done, the plugin should already be available in the plugin list in "
"the **Project Settings**, so activate it as explained in `Checking the "
"results`_."
msgstr ""
"完成後, 外掛程式應該已經在 **專案設定** 的外掛程式列表中可用, 因此請按照 "
"`Checking the results`_ 中的說明啟動它."

msgid "Then try it out by adding your new node:"
msgstr "然後通過新增新節點來嘗試:"

msgid ""
"When you add the node, you can see that it already has the script you "
"created attached to it. Set a text to the button, save and run the scene. "
"When you click the button, you can see some text in the console:"
msgstr ""
"當你新增節點時, 你可以看到它已經有你建立的腳本附加在上面. 給這個按鈕設定一個"
"文字, 保存並運作場景. 當你點擊按鈕時, 你可以在控制台中看到一些文字:"

msgid "A custom dock"
msgstr "自訂視窗"

msgid ""
"Sometimes, you need to extend the editor and add tools that are always "
"available. An easy way to do it is to add a new dock with a plugin. Docks "
"are just scenes based on Control, so they are created in a way similar to "
"usual GUI scenes."
msgstr ""
"有時, 您需要擴充編輯器並新增始終可用的工具. 一種簡單的方法是新增一個帶外掛程"
"式的新擴充面板. Docks只是基於Control的場景, 因此它們的建立方式與通常的GUI場景"
"類似."

msgid ""
"Creating a custom dock is done just like a custom node. Create a new "
"``plugin.cfg`` file in the ``addons/my_custom_dock`` folder, then add the "
"following content to it:"
msgstr ""
"建立一個自訂欄好的方法和自訂節點一樣. 在 ``addons/my_custom_dock`` 資料夾中建"
"立一個新的 ``plugin.cfg`` 檔, 然後在其中新增以下內容:"

msgid ""
"Then create the script ``custom_dock.gd`` in the same folder. Fill it with "
"the :ref:`template we've seen before <doc_making_plugins_template_code>` to "
"get a good start."
msgstr ""
"然後在同一資料夾中建立腳本 ``custom_dock.gd``。填寫:ref:`之前見過的範本 "
"<doc_making_plugins_template_code>`以獲得良好的開端。"

msgid ""
"Since we're trying to add a new custom dock, we need to create the contents "
"of the dock. This is nothing more than a standard Godot scene: just create a "
"new scene in the editor then edit it."
msgstr ""
"由於我們正在嘗試新增新的自訂視窗, 因此我們需要建立視窗的內容. 這只不過是一個"
"標準的Godot場景: 只需在編輯器中建立一個新場景然後編輯它."

msgid ""
"For an editor dock, the root node **must** be a :ref:`Control "
"<class_Control>` or one of its child classes. For this tutorial, you can "
"create a single button. The name of the root node will also be the name that "
"appears on the dock tab, so be sure to give it a short and descriptive name. "
"Also, don't forget to add some text to your button."
msgstr ""
"對於編輯器停靠站, 根節點 **必須是** :ref:`Control <class_Control>` 或其子類別"
"之一. 在本教學中, 您可以建立一個按鈕. 根節點的名稱也將是面板對話方塊中顯示的"
"名稱, 因此請務必為其指定一個簡短的描述性名稱. 另外, 不要忘記在按鈕上新增一些"
"文字."

msgid ""
"Save this scene as ``my_dock.tscn``. Now, we need to grab the scene we "
"created then add it as a dock in the editor. For this, you can rely on the "
"function :ref:`add_control_to_dock() "
"<class_EditorPlugin_method_add_control_to_dock>` from the :ref:`EditorPlugin "
"<class_EditorPlugin>` class."
msgstr ""
"把這個場景保存為 ``my_dock.tscn`` . 現在, 我們需要抓取我們建立的場景, 然後在"
"編輯器中把它新增為一個欄目. 為此, 你可以依賴 :ref:`add_control_to_dock() "
"<class_EditorPlugin_method_add_control_to_dock>` 這個函式, 它來自 :ref:"
"`EditorPlugin <class_EditorPlugin>` 類."

msgid ""
"You need to select a dock position and define the control to add (which is "
"the scene you just created). Don't forget to **remove the dock** when the "
"plugin is deactivated. The script could look like this:"
msgstr ""
"你需要選擇一個停靠位置並定義要新增的控制項, 也就是你剛剛建立的場景. 不要忘了"
"在外掛程式停用時 **remove the dock** . 腳本可以是這樣的:"

msgid ""
"Note that, while the dock will initially appear at its specified position, "
"the user can freely change its position and save the resulting layout."
msgstr ""
"請注意, 雖然Dock最初會出現在其指定的位置, 但使用者可以自由改變其位置, 並保存"
"所產生的佈局."

msgid "Checking the results"
msgstr "檢查結果"

msgid ""
"It's now time to check the results of your work. Open the **Project "
"Settings** and click on the **Plugins** tab. Your plugin should be the only "
"one on the list."
msgstr ""
"現在是檢查工作結果的時候了. 打開 **專案設定** , 然後按一下 **外掛程式** 分"
"頁. 您的外掛程式應該是列表中唯一的外掛程式. 如果未顯示, 請按一下右上角的 **更"
"新** 按鈕."

msgid ""
"You can see the plugin is not enabled. Click the **Enable** checkbox to "
"activate the plugin. The dock should become visible before you even close "
"the settings window. You should now have a custom dock:"
msgstr ""
"您可以在 **Status** 列中看到該外掛程式處於非啟動狀態; 點擊狀態選擇 "
"**Active** . 在您關閉設定視窗之前, 該擴充視窗應該可見. 您現在應該看到一個自訂"
"視窗:"

msgid "Going beyond"
msgstr "舉一反三"

msgid ""
"Now that you've learned how to make basic plugins, you can extend the editor "
"in several ways. Lots of functionality can be added to the editor with "
"GDScript; it is a powerful way to create specialized editors without having "
"to delve into C++ modules."
msgstr ""
"現在您已經學會了如何製作基本外掛程式, 您可以通過多種方式擴充編輯器. 可以使用"
"GDScript將許多功能新增到編輯器中; 它是一種建立專業編輯器的強大方法, 無需深入"
"研究C++模組."

msgid ""
"You can make your own plugins to help yourself and share them in the `Asset "
"Library <https://godotengine.org/asset-library/>`_ so that people can "
"benefit from your work."
msgstr ""
"您可以製作自己的外掛程式來幫助自己或在 `素材庫 <https://godotengine.org/"
"asset-library/>`_ 中分享它們，以便人們可以從您的工作中受益。"

msgid "Registering autoloads/singletons in plugins"
msgstr "在外掛程式中註冊自動載入/單例"

msgid ""
"It is possible for editor plugins to automatically register :ref:`autoloads "
"<doc_singletons_autoload>` when the plugin is enabled. This also includes "
"unregistering the autoload when the plugin is disabled."
msgstr ""
"編輯器外掛程式可以在啟用時自動註冊:ref:`自動載入 <doc_singletons_autoload>`。"
"同樣也包含了在外掛程式禁用時反註冊該自動載入。"

msgid ""
"This makes setting up plugins faster for users, as they no longer have to "
"manually add autoloads to their project settings if your editor plugin "
"requires the use of an autoload."
msgstr ""
"這樣使用者就可以更快速地設定外掛程式了，因為你的編輯器外掛程式要求使用自動載"
"入時，他們不必再手動去專案設定裡新增自動載入了。"

msgid "Use the following code to register a singleton from an editor plugin:"
msgstr "可以使用下列指令來移除產生的匯出樣板："

msgid "Translation status"
msgstr "翻譯狀態"
