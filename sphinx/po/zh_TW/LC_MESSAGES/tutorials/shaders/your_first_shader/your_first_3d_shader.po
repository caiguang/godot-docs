# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Your first 3D shader"
msgstr "第一個遊戲"

msgid ""
"You have decided to start writing your own custom Spatial shader. Maybe you "
"saw a cool trick online that was done with shaders, or you have found that "
"the :ref:`StandardMaterial3D <class_StandardMaterial3D>` isn't quite meeting "
"your needs. Either way, you have decided to write your own and now you need "
"to figure out where to start."
msgstr ""
"你已經決定開始編寫一個自訂 Spatial 著色器。或許你在網上看到一個很酷的著色器技"
"巧，或許你發現 :ref:`SpatialMaterial <class_SpatialMaterial>` 並不能完全滿足"
"你的需求。總之，你決定寫一個自己的，你想弄清楚從哪裡開始。"

msgid ""
"This tutorial will explain how to write a Spatial shader and will cover more "
"topics than the :ref:`CanvasItem <doc_your_first_canvasitem_shader>` "
"tutorial."
msgstr ""
"這個教學將說明如何編寫空間著色器, 並將涵蓋比 :ref:`CanvasItem "
"<doc_your_first_canvasitem_shader>` 更多的主題."

msgid ""
"Spatial shaders have more built-in functionality than CanvasItem shaders. "
"The expectation with spatial shaders is that Godot has already provided the "
"functionality for common use cases and all the user needs to do in the "
"shader is set the proper parameters. This is especially true for a PBR "
"(physically based rendering) workflow."
msgstr ""
"空間著色器比CanvasItem著色器有更多的內建功能. 對空間著色器的期望是:Godot為常"
"見的用例提供了功能, 使用者僅需在著色器中設定適當的參數. 這對於PBR(基於物理的"
"算繪)工作流來說尤其如此."

msgid ""
"This is a two-part tutorial. In this first part we will create terrain using "
"vertex displacement from a heightmap in the vertex function. In the :ref:"
"`second part <doc_your_second_spatial_shader>` we will take the concepts "
"from this tutorial and set up custom materials in a fragment shader by "
"writing an ocean water shader."
msgstr ""
"這是一個兩部分的教學. 在第一部分中, 我們將學習如何在頂點函式中使用高度圖的頂"
"點位移來製作一個簡單的地形. 在 :ref:`第二部分 "
"<doc_your_second_spatial_shader>` 中, 我們將採用本教學中的概念, 通過編寫一個"
"海洋水著色器, 講解如何在片段著色器中設定自訂材質."

msgid ""
"This tutorial assumes some basic shader knowledge such as types (``vec2``, "
"``float``, ``sampler2D``), and functions. If you are uncomfortable with "
"these concepts it is best to get a gentle introduction from `The Book of "
"Shaders <https://thebookofshaders.com>`_ before completing this tutorial."
msgstr ""
"這個教學假定你對著色器有一些基本的瞭解, 例如型別( ``vec2`` , ``float`` , "
"``sampler2D`` ), 和函式. 如果你對這些概念摸不著頭腦, 那麼你在完成這個教學之"
"前, 最好先從 `著色器之書 <https://thebookofshaders.com/?lan=ch>` 獲取一些基本"
"知識."

msgid "Where to assign my material"
msgstr "在何處設定材質"

msgid ""
"In 3D, objects are drawn using :ref:`Meshes <class_Mesh>`. Meshes are a "
"resource type that store geometry (the shape of your object) and materials "
"(the color and how the object reacts to light) in units called \"surfaces\". "
"A Mesh can have multiple surfaces, or just one. Typically, you would import "
"a mesh from another program (e.g. Blender). But Godot also has a few :ref:"
"`PrimitiveMeshes <class_primitivemesh>` that allow you to add basic geometry "
"to a scene without importing Meshes."
msgstr ""
"在3D中, 物件是使用 :ref:`Meshes <class_Mesh>` 繪製的.Mesh是一種資源型別, 它"
"以 \"表面(surface)\" 為單位儲存幾何體(物件的形狀)和材質(對象的顏色和對光線的"
"反應). 一個Mesh可以有多個表面, 也可以只有一個. 通常情況下, 你會從另一個程式"
"(如Blender)匯入一個Mesh. 但是Godot也有一些 :ref:`PrimitiveMeshes "
"<class_primitivemesh>` 允許你在不匯入Mesh的情況下為場景新增基本幾何體."

msgid ""
"There are multiple node types that you can use to draw a mesh. The main one "
"is :ref:`MeshInstance3D <class_MeshInstance3D>`, but you can also use :ref:"
"`GPUParticles3D <class_GPUParticles3D>`, :ref:`MultiMeshes "
"<class_MultiMesh>` (with a :ref:`MultiMeshInstance3D "
"<class_MultiMeshInstance3D>`), or others."
msgstr ""
"你可以使用多種節點型別可以用來繪製Mesh. 主要的是 :ref:`MeshInstance "
"<class_meshinstance>`, 但你也可以使用 :ref:`Particles <class_particles>`, :"
"ref:`MultiMeshes <class_MultiMesh>` (與 :ref:`MultiMeshInstance "
"<class_multimeshinstance>` 一起使用), 或其他."

msgid ""
"Typically, a material is associated with a given surface in a mesh, but some "
"nodes, like MeshInstance3D, allow you to override the material for a "
"specific surface, or for all surfaces."
msgstr ""
"通常情況下, 一個材質是與Mesh中的一個給定表面相關聯的, 但有些節點, 如"
"MeshInstance, 允許你覆蓋一個特定的表面或所有表面的材質."

msgid ""
"If you set a material on the surface or mesh itself, then all "
"MeshInstance3Ds that share that mesh will share that material. However, if "
"you want to reuse the same mesh across multiple mesh instances, but have "
"different materials for each instance then you should set the material on "
"the MeshInstance3D."
msgstr ""
"如果你在表面或Mesh本身上設定了材質, 那麼所有共用該Mesh的MeshInstance都共用該"
"材質. 但是, 如果你想在多個Mesh實例中重用同一個Mesh, 但每個實例具有不同的材"
"質, 那麼你應該在Meshinstance上設定材質."

msgid ""
"For this tutorial we will set our material on the mesh itself rather than "
"taking advantage of the MeshInstance3D's ability to override materials."
msgstr ""
"在本教學中, 我們將材質設定在Mesh自身上, 不使用MeshInstance覆蓋材質的功能."

msgid "Setting up"
msgstr "設定"

msgid ""
"Add a new :ref:`MeshInstance3D <class_MeshInstance3D>` node to your scene."
msgstr "向場景新增一個新的 :ref:`MeshInstance <class_meshinstance>` 節點."

msgid ""
"In the inspector tab beside \"Mesh\" click \"[empty]\" and select \"New "
"PlaneMesh\". Then click on the image of a plane that appears."
msgstr ""
"在屬性面板分頁中，點擊“Mesh”旁邊的“[空]”，然後選擇“新建 PlaneMesh”。然後點擊"
"出現的平面的圖像。"

msgid "This adds a :ref:`PlaneMesh <class_planemesh>` to our scene."
msgstr "這會在場景中新增一個 :ref:`PlaneMesh <class_planemesh>` ."

msgid ""
"Then, in the viewport, click in the upper left corner on the button that "
"says \"Perspective\". A menu will appear. In the middle of the menu are "
"options for how to display the scene. Select 'Display Wireframe'."
msgstr ""
"然後，在視圖中，按一下左上角的“透視”按鈕。會出現一個功能表，在功能表中間找到"
"如何顯示場景的選項。選擇“顯示線框”。"

msgid "This will allow you to see the triangles making up the plane."
msgstr "這將允許您查看構成平面的三角形."

msgid ""
"Now set ``Subdivide Width`` and ``Subdivide Depth`` of the :ref:`PlaneMesh "
"<class_planemesh>` to ``32``."
msgstr "現在將 ``Subdivide Width`` 和 ``Subdivide Depth`` 設定為 ``32`` ."

msgid ""
"You can see that there are now many more triangles in the :ref:"
"`MeshInstance3D<class_MeshInstance3D>`. This will give us more vertices to "
"work with and thus allow us to add more detail."
msgstr ""
"可以看到現在 :ref:`Mesh<class_MeshInstance>` 中有了更多的三角形. 這將為我們提"
"供更多頂點, 便於新增更多細節."

msgid ""
":ref:`PrimitiveMeshes <class_primitivemesh>`, like PlaneMesh, only have one "
"surface, so instead of an array of materials there is only one. Click beside "
"\"Material\" where it says \"[empty]\" and select \"New ShaderMaterial\". "
"Then click the sphere that appears."
msgstr ""
"表面，因此也僅有一個材質而非材質陣列。點擊“Material”旁邊的“[空]”，然後選擇“新"
"建 ShaderMaterial”。然後點擊出現的球體。"

msgid ""
"Now click beside \"Shader\" where it says \"[empty]\" and select \"New "
"Shader\"."
msgstr "現在點擊“Shader”旁邊寫著“[空]”的地方，選擇“新建 Shader”。"

msgid ""
"The shader editor should now pop up and you are ready to begin writing your "
"first Spatial shader!"
msgstr "現在將彈出一個著色器編輯器, 你已經準備好編寫你的第一個空間著色器了！"

msgid "Shader magic"
msgstr "著色器魔術"

msgid ""
"The new shader is already generated with a ``shader_type`` variable and the "
"``fragment()`` function. The first thing Godot shaders need is a declaration "
"of what type of shader they are. In this case the ``shader_type`` is set to "
"``spatial`` because this is a spatial shader."
msgstr ""
"注意到已經出現錯誤了嗎？ 這是因為著色器編輯器會自動重新載入著色器. Godot著色"
"器首先需要宣告它們是什麼型別的著色器. 因此, 我們將變數 ``shader_type`` 設定"
"為 ``spatial`` , 因為它是一個空間著色器."

msgid ""
"For now ignore the ``fragment()`` function and define the ``vertex()`` "
"function. The ``vertex()`` function determines where the vertices of your :"
"ref:`MeshInstance3D<class_MeshInstance3D>` appear in the final scene. We "
"will be using it to offset the height of each vertex and make our flat plane "
"appear like a little terrain."
msgstr ""
"接下來我們將定義 ``vertex()`` 函式. ``vertex()`` 函式決定你的 :ref:"
"`Mesh<class_MeshInstance>` 在最終場景中的頂點位置. 我們用它來偏移每個頂點的高"
"度, 使我們的平面看起來像一個小地形."

msgid "We define the vertex shader like so:"
msgstr "我們像這樣定義頂點著色器:"

msgid ""
"With nothing in the ``vertex()`` function, Godot will use its default vertex "
"shader. We can easily start to make changes by adding a single line:"
msgstr ""
"在 ``vertex()`` 函式中沒有任何內容,Godot將使用其預設的頂點著色器. 我們可以簡"
"單地通過新增一行進行更改:"

msgid "Adding this line, you should get an image like the one below."
msgstr "新增此行後, 你應該會得到類似下方的圖像."

msgid ""
"Okay, let's unpack this. The ``y`` value of the ``VERTEX`` is being "
"increased. And we are passing the ``x`` and ``z`` components of the "
"``VERTEX`` as arguments to ``cos`` and ``sin``; that gives us a wave-like "
"appearance across the ``x`` and ``z`` axes."
msgstr ""
"好, 我們來解讀一下. ``VERTEX`` 的 ``y`` 值正在增加. 我們將 ``VERTEX`` 的 "
"``x`` 和 ``z`` 分量作為參數傳遞給 ``cos`` 和 ``sin`` ；這樣就得到了在 ``x`` "
"和 ``z`` 軸上呈現出波浪狀的圖像."

msgid ""
"What we want to achieve is the look of little hills; after all. ``cos`` and "
"``sin`` already look kind of like hills. We do so by scaling the inputs to "
"the ``cos`` and ``sin`` functions."
msgstr ""
"我們想要實作的是小山丘的外觀. 而 ``cos`` 和 ``sin`` 已經有點像山丘了. 我們便"
"可以通過縮放 ``cos`` 和 ``sin`` 函式的輸入來實作."

msgid ""
"This looks better, but it is still too spiky and repetitive, let's make it a "
"little more interesting."
msgstr "看起來效果好了一些, 但它仍然過於尖銳和重複, 讓我們把它變得更有趣一點."

msgid "Noise heightmap"
msgstr "雜訊高度圖"

msgid ""
"Noise is a very popular tool for faking the look of terrain. Think of it as "
"similar to the cosine function where you have repeating hills except, with "
"noise, each hill has a different height."
msgstr ""
"雜訊是一種非常流行的偽造地形的工具. 可以認為它和餘弦函式一樣生成重複的小山, "
"只是在雜訊的影響下每個小山都擁有不同的高度."

msgid ""
"Godot provides the :ref:`NoiseTexture2D <class_noisetexture2D>` resource for "
"generating a noise texture that can be accessed from a shader."
msgstr ""
"Godot提供了 :ref:`雜訊紋理 <class_noisetexture>` 資源, 可以生成從著色器存取的"
"雜訊紋理."

msgid ""
"To access a texture in a shader add the following code near the top of your "
"shader, outside the ``vertex()`` function."
msgstr ""
"要在著色器中存取紋理，請在著色器頂部附近、``vertex()`` 函式外部新增以下程式"
"碼。"

msgid ""
"This will allow you to send a noise texture to the shader. Now look in the "
"inspector under your material. You should see a section called \"Shader "
"Params\". If you open it up, you'll see a section called \"noise\"."
msgstr ""
"你可以用它將雜訊紋理發送給著色器。現在看看屬性面板中的材質。你應該會看到一個"
"名為“Shader Params”（著色器參數）的區域。如果展開該區域，就會看到一個"
"叫“noise”的部分。"

msgid ""
"Click beside it where it says \"[empty]\" and select \"New NoiseTexture2D\". "
"Then in your :ref:`NoiseTexture2D <class_noisetexture2D>` click beside where "
"it says \"Noise\" and select \"New FastNoiseLite\"."
msgstr ""
"點擊旁邊寫著“[空]”的地方，選擇“新建 NoiseTexture”。在你的 NoiseTexture 中，點"
"擊旁邊的“Noise”，然後選擇“新建 OpenSimplexNoise”。"

msgid ""
":ref:`FastNoiseLite <class_fastnoiselite>` is used by the NoiseTexture2D to "
"generate a heightmap."
msgstr ""
"NoiseTexture2D 使用 :ref:`FastNoiseLite <class_fastnoiselite>` 來生成高度圖。"

msgid "Once you set it up and should look like this."
msgstr "設定好後, 看起來應該像這樣."

msgid ""
"Now, access the noise texture using the ``texture()`` function. "
"``texture()`` takes a texture as the first argument and a ``vec2`` for the "
"position on the texture as the second argument. We use the ``x`` and ``z`` "
"channels of ``VERTEX`` to determine where on the texture to look up. Note "
"that the PlaneMesh coordinates are within the [-1,1] range (for a size of "
"2), while the texture coordinates are within [0,1], so to normalize we "
"divide by the size of the PlaneMesh by 2.0 and add 0.5. ``texture()`` "
"returns a ``vec4`` of the ``r, g, b, a`` channels at the position. Since the "
"noise texture is grayscale, all of the values are the same, so we can use "
"any one of the channels as the height. In this case we'll use the ``r``, or "
"``x`` channel."
msgstr ""
"現在, 使用 ``texture()`` 函式獲取雜訊紋理. ``texture()`` 將一個紋理作為第一個"
"參數, 將在紋理上的位置 ``vec2`` 作為第二個參數. 我們用 ``VERTEX`` 的 ``x`` "
"和 ``z`` 通道來確定在紋理上的位置. 請注意 PlaneMesh 座標在 [-1,1] 範圍內 (大"
"小為 2的情況下), 而紋理座標在 [0,1] 範圍內, 所以為了規範化, 我們將PlaneMesh的"
"大小除以2.0並加上 0.5. ``texture()`` 返回一個目前位置 ``r, g, b, a`` 通道的 "
"``vec4`` . 由於雜訊紋理是灰度的, 所有的值都相同, 所以我們可以使用任意一個通道"
"作為高度. 本例中, 我們將使用 ``r`` , 或者說 ``x`` 通道."

msgid ""
"Note: ``xyzw`` is the same as ``rgba`` in GLSL, so instead of ``texture()."
"x`` above, we could use ``texture().r``. See the `OpenGL documentation "
"<https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)#Vectors>`_ for more "
"details."
msgstr ""
"注意: ``xyzw`` 和GLSL中的 ``rgba`` 是相同的, 所以我們可以用 ``texture().x`` "
"代替上面的 ``texture().r`` . 詳情請參見 `OpenGL 文件 <https://www.khronos."
"org/opengl/wiki/Data_Type_(GLSL)#Vectors>`_ ."

msgid "Using this code you can see the texture creates random looking hills."
msgstr "使用此程式碼後, 你可以看到紋理建立了隨機外觀的山峰."

msgid ""
"Right now it is too spiky, we want to soften the hills a bit. To do that, we "
"will use a uniform. You already used a uniform above to pass in the noise "
"texture, now let's learn how they work."
msgstr ""
"目前它還很尖銳, 我們需要稍微柔化一下山峰. 這將用到uniform值. 你在之前已經使用"
"了uniform 值來傳遞雜訊紋理, 現在讓我們來學習一下其中的工作原理."

msgid "Uniforms"
msgstr "Uniform"

msgid ""
"Uniform variables allow you to pass data from the game into the shader. They "
"are very useful for controlling shader effects. Uniforms can be almost any "
"datatype that can be used in the shader. To use a uniform, you declare it in "
"your :ref:`Shader<class_Shader>` using the keyword ``uniform``."
msgstr ""
"uniform值變數允許你把遊戲的變數傳遞到著色器. 它們對於控制著色器效果非常有用. "
"幾乎所有在著色器中使用的資料型別都可以作為uniform值. 要使用uniform值, 請在 :"
"ref:`Shader<class_Shader>` 中使用關鍵字 ``uniform`` 宣告它."

msgid "Let's make a uniform that changes the height of the terrain."
msgstr "讓我們做一個改變地形高度的uniform."

msgid ""
"Godot lets you initialize a uniform with a value; here, ``height_scale`` is "
"set to ``0.5``. You can set uniforms from GDScript by calling the function "
"``set_shader_parameter()`` on the material corresponding to the shader. The "
"value passed from GDScript takes precedence over the value used to "
"initialize it in the shader."
msgstr ""
"Godot讓你用一個值來初始化uniform；這裡, ``height_scale`` 被設定為 ``0.5`` . "
"你可以通過在著色器對應的材質上呼叫函式 ``set_shader_param()`` 來從GDScript設"
"定uniform . 從GDScript傳來的值優先於在著色器中用於初始化的值."

msgid ""
"Changing uniforms in Spatial-based nodes is different from CanvasItem-based "
"nodes. Here, we set the material inside the PlaneMesh resource. In other "
"mesh resources you may need to first access the material by calling "
"``surface_get_material()``. While in the MeshInstance3D you would access the "
"material using ``get_surface_material()`` or ``material_override``."
msgstr ""
"更改uniform值時, 基於空間的節點與基於CanvasItem的節點使用的方法不同. 在這裡, "
"我們在PlaneMesh資源內設定材質. 在其他mesh資源中, 你可能要先呼叫 "
"``surface_get_material()`` 來獲取材質. 而在MeshInstance中, 則是用 "
"``get_surface_material()`` 或 ``material_override`` 獲取材質."

msgid ""
"Remember that the string passed into ``set_shader_parameter()`` must match "
"the name of the uniform variable in the :ref:`Shader<class_Shader>`. You can "
"use the uniform variable anywhere inside your :ref:`Shader<class_Shader>`. "
"Here, we will use it to set the height value instead of arbitrarily "
"multiplying by ``0.5``."
msgstr ""
"請記住, 傳入 ``set_shader_param()`` 的字串必須與 :ref:`Shader<class_Shader>` "
"中的uniform變數名稱相配對. 你可以在 :ref:`Shader<class_Shader>` 中的任何地方"
"使用這個uniform變數. 在這裡, 我們將用它來設定高度值, 而不是任意地乘以 "
"``0.5`` ."

msgid "Now it looks much better."
msgstr "現在它看起來好多了."

msgid ""
"Using uniforms, we can even change the value every frame to animate the "
"height of the terrain. Combined with :ref:`Tweens <class_Tween>`, this can "
"be especially useful for animations."
msgstr ""
"使用 uniform，我們甚至可以在每一影格改變數值，以動畫化地形的高度。結合 :ref:"
"`Tween <class_Tween>`，這對簡單的動畫特別有用。"

msgid "Interacting with light"
msgstr "與光互動"

msgid ""
"First, turn wireframe off. To do so, click in the upper-left of the Viewport "
"again, where it says \"Perspective\", and select \"Display Normal\"."
msgstr "首先關閉線框顯示。再次點擊視口左上角的“透視”字樣，選擇“顯示標準”。"

msgid ""
"Note how the mesh color goes flat. This is because the lighting on it is "
"flat. Let's add a light!"
msgstr ""
"注意網格顏色是如何變得平滑的. 這是因為它的光線是平滑的. 讓我們加一盞燈吧!"

msgid ""
"First, we will add an :ref:`OmniLight3D<class_OmniLight3D>` to the scene."
msgstr "首先, 我們將在場景中新增一個 :ref:`OmniLight<class_OmniLight>` ."

msgid ""
"You can see the light affecting the terrain, but it looks odd. The problem "
"is the light is affecting the terrain as if it were a flat plane. This is "
"because the light shader uses the normals from the :ref:`Mesh <class_mesh>` "
"to calculate light."
msgstr ""
"你會看到光線影響了地形, 但這看起來很奇怪. 問題是光線對地形的影響就像在平面上"
"一樣. 這是因為光著色器使用 :ref:`網格 <class_mesh>` 中的法線來計算光."

msgid ""
"The normals are stored in the Mesh, but we are changing the shape of the "
"Mesh in the shader, so the normals are no longer correct. To fix this, we "
"can recalculate the normals in the shader or use a normal texture that "
"corresponds to our noise. Godot makes both easy for us."
msgstr ""
"法線儲存在網格中, 但是我們在著色器中改變網格的形狀, 所以法線不再正確. 為了解"
"決這個問題, 我們可以在著色器中重新計算法線, 或者使用與我們的雜訊相對應的法線"
"紋理.Godot讓這一切變得很簡單."

msgid ""
"You can calculate the new normal manually in the vertex function and then "
"just set ``NORMAL``. With ``NORMAL`` set, Godot will do all the difficult "
"lighting calculations for us. We will cover this method in the next part of "
"this tutorial, for now we will read normals from a texture."
msgstr ""
"您可以在頂點函式中手動計算新的法線，然後只需設定法線 ``NORMAL``。設定好 "
"``NORMAL`` 後，Godot 將為我們完成所有困難的光照計算。我們將在本教學的下一部分"
"介紹這種方法，現在我們將從紋理中讀取法線。"

msgid ""
"Instead we will rely on the NoiseTexture again to calculate normals for us. "
"We do that by passing in a second noise texture."
msgstr ""
"相反, 我們將再次依靠雜訊來計算法線. 我們通過傳入第二個雜訊紋理來做到這一點."

msgid ""
"Set this second uniform texture to another :ref:`NoiseTexture2D "
"<class_noisetexture2D>` with another :ref:`FastNoiseLite "
"<class_fastnoiselite>`. But this time, check **As Normalmap**."
msgstr ""
"把第二個 uniform 紋理設為另一個帶有單獨 OpenSimplexNoise 的 NoiseTexture。不"
"過這一回，請取消勾選“As Normalmap”。"

msgid ""
"Now, because this is a normalmap and not a per-vertex normal, we are going "
"to assign it in the ``fragment()`` function. The ``fragment()`` function "
"will be explained in more detail in the next part of this tutorial."
msgstr ""
"現在, 因為這是一個法線貼圖, 而不是每個頂點的法線, 我們將在 ``fragment()`` 函"
"式中分配它. ``fragment()`` 函式將在本教學的下一部分中詳細解釋."

msgid ""
"When we have normals that correspond to a specific vertex we set ``NORMAL``, "
"but if you have a normalmap that comes from a texture, set the normal using "
"``NORMAL_MAP``. This way Godot will handle the wrapping of texture around "
"the mesh automatically."
msgstr ""
"當我們有對應某個特定頂點的法線時，就要設定 ``NORMAL``，但如果你有一個來自紋理"
"的法線貼圖，要使用 ``NORMALMAP`` 設定法線。這樣，Godot 將自動處理環繞網格的紋"
"理。"

msgid ""
"Lastly, in order to ensure that we are reading from the same places on the "
"noise texture and the normalmap texture, we are going to pass the ``VERTEX."
"xz`` position from the ``vertex()`` function to the ``fragment()`` function. "
"We do that with varyings."
msgstr ""
"最後, 為了確保我們從雜訊紋理和法線圖紋理的相同位置讀取資料, 我們將把 "
"``vertex()`` 函式中的 ``VERTEX.xz`` 座標傳遞給 ``fragment()`` 函式. 我們用"
"variings來做這個."

msgid ""
"Above the ``vertex()`` define a ``vec2`` called ``tex_position``. And inside "
"the ``vertex()`` function assign ``VERTEX.xz`` to ``tex_position``."
msgstr ""
"在 ``vertex()`` 上面定義一個 ``vec2`` 叫做 ``tex_position`` . 在 "
"``vertex()`` 函式中, 將 ``VERTEX.xz`` 分配給 ``tex_position`` ."

msgid ""
"And now we can access ``tex_position`` from the ``fragment()`` function."
msgstr "現在我們可以從 ``fragment()`` 函式中存取 ``tex_position`` ."

msgid ""
"With the normals in place the light now reacts to the height of the mesh "
"dynamically."
msgstr "法線就位後, 光線就會對網格的高度做出動態反應."

msgid ""
"We can even drag the light around and the lighting will update automatically."
msgstr "我們甚至可以把燈拖來拖去, 燈光會自動更新."

msgid ""
"Here is the full code for this tutorial. You can see it is not very long as "
"Godot handles most of the difficult stuff for you."
msgstr ""
"以下是本教學的完整程式碼. 您可以看到,Godot會為您處理大多數繁瑣的事情, 本教學"
"篇幅不會太長."

msgid ""
"That is everything for this part. Hopefully, you now understand the basics "
"of vertex shaders in Godot. In the next part of this tutorial we will write "
"a fragment function to accompany this vertex function and we will cover a "
"more advanced technique to turn this terrain into an ocean of moving waves."
msgstr ""
"這就是這部分的全部內容. 希望您現在已瞭解Godot中頂點著色器的基本知識. 在本教學"
"的下一部分中, 我們將編寫一個片段函式來配合這個頂點函式, 並且我們將介紹一種更"
"高級的技術來將這個地形轉換成一個移動的波浪海洋."

msgid "Translation status"
msgstr "翻譯狀態"
