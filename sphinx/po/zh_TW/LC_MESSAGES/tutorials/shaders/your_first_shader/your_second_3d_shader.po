# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Your second 3D shader"
msgstr "你的第二個 3D 著色器"

msgid ""
"From a high-level, what Godot does is give the user a bunch of parameters "
"that can be optionally set (``AO``, ``SSS_Strength``, ``RIM``, etc.). These "
"parameters correspond to different complex effects (Ambient Occlusion, "
"SubSurface Scattering, Rim Lighting, etc.). When not written to, the code is "
"thrown out before it is compiled and so the shader does not incur the cost "
"of the extra feature. This makes it easy for users to have complex PBR-"
"correct shading, without writing complex shaders. Of course, Godot also "
"allows you to ignore all these parameters and write a fully customized "
"shader."
msgstr ""
"從高級設定開始,Godot所做的是為使用者提供一組可選設定的參數(\"環境光遮蔽\" , "
"\"次表面散射強度\" , \"邊緣\" 等等)這些參數對應不同的複雜效應(環境遮擋, 次表"
"面散射, 邊緣照明等等)如果沒有寫入, 程式碼在編譯之前被拋出, 因此著色器不會產生"
"額外功能的成本. 這使得使用者很容易擁有複雜的支援PBR著色, 而不需要編寫複雜的著"
"色器. 當然,Godot還允許您忽略所有這些參數, 並編寫一個完全定制的著色器."

msgid ""
"For a full list of these parameters see the :ref:`spatial shader "
"<doc_spatial_shader>` reference doc."
msgstr ""
"有關這些參數的完整列表, 請參見 :ref:`空間著色器 <doc_spatial_shader>` 參考文"
"件."

msgid ""
"A difference between the vertex function and a fragment function is that the "
"vertex function runs per vertex and sets properties such as ``VERTEX`` "
"(position) and ``NORMAL``, while the fragment shader runs per pixel and, "
"most importantly, sets the ``ALBEDO`` color of the :ref:"
"`MeshInstance3D<class_MeshInstance3D>`."
msgstr ""
"頂點函式和片段函式的區別在於, 頂點函式是按頂點運作的, 並設定諸如 ``VERTEX`` "
"(座標)和 ``NORMAL`` 等屬性, 而片段著色器是按像素運作的, 最重要的是設定 :ref:"
"`Mesh<class_MeshInstance>` 的 ``ALBEDO`` 顏色."

msgid "Your first spatial fragment function"
msgstr "第一個空間片段函式"

msgid ""
"As mentioned in the previous part of this tutorial. The standard use of the "
"fragment function in Godot is to set up different material properties and "
"let Godot handle the rest. In order to provide even more flexibility, Godot "
"also provides things called render modes. Render modes are set at the top of "
"the shader, directly below ``shader_type``, and they specify what sort of "
"functionality you want the built-in aspects of the shader to have."
msgstr ""
"如本教學前一部分所述. 在Godot中, 片段函式的標準用法是設定不同的材質屬性, 然後"
"讓Godot處理剩下的部分. 為了提供更大的靈活性,Godot還提供了算繪模式. 算繪模式設"
"定在著色器的頂部, 直接在 \"著色_方式\" 下面, 它們指定了你想要著色器的內建方面"
"具有什麼樣的功能."

msgid ""
"For example, if you do not want to have lights affect an object, set the "
"render mode to ``unshaded``:"
msgstr "例如, 如果你不想讓燈光影響一個物體, 設定算繪模式為 \"無陰影\":"

msgid ""
"You can also stack multiple render modes together. For example, if you want "
"to use toon shading instead of more-realistic PBR shading, set the diffuse "
"mode and specular mode to toon:"
msgstr ""
"您還可以將多個算繪模式堆疊在一起。例如，如果你想使用卡通材質而不是更真實的 "
"PBR 材質，將漫反射模式和鏡面反射模式設定為卡通："

msgid ""
"This model of built-in functionality allows you to write complex custom "
"shaders by changing only a few parameters."
msgstr "這個內建功能模型允許您通過更改幾個參數來編寫複雜的自訂著色器."

msgid ""
"For a full list of render modes see the :ref:`Spatial shader reference "
"<doc_spatial_shader>`."
msgstr ""
"有關算繪模式的完整列表, 請參見空間著色器參考 :ref:`Spatial shader reference "
"<doc_spatial_shader>`."

msgid ""
"In this part of the tutorial, we will walk through how to take the bumpy "
"terrain from the previous part and turn it into an ocean."
msgstr "在本教學的這一部分中, 我們將介紹如何將前一部分的崎嶇地形變成海洋."

msgid ""
"First let's set the color of the water. We do that by setting ``ALBEDO``."
msgstr "首先讓我們設定水的顏色. 我們通過設定 ``ALBEDO`` 來做到這一點."

msgid "``ALBEDO`` is a ``vec3`` that contains the color of the object."
msgstr "``ALBEDO`` 是一個 ``vec3`` , 包含物體的顏色."

msgid "Let's set it to a nice shade of blue."
msgstr "我們把它調成藍色."

msgid ""
"We set it to a very dark shade of blue because most of the blueness of the "
"water will come from reflections from the sky."
msgstr "我們將其設定為深藍色, 因為水的大部分藍色來自天空的反射."

msgid ""
"The PBR model that Godot uses relies on two main parameters: ``METALLIC`` "
"and ``ROUGHNESS``."
msgstr "PBR模型的Godot使用者兩個主要參數:\"金屬度\" 和 \"粗糙度\"."

msgid ""
"``ROUGHNESS`` specifies how smooth/rough the surface of a material is. A low "
"``ROUGHNESS`` will make a material appear like a shiny plastic, while a high "
"roughness makes the material appear more solid in color."
msgstr ""
"粗糙度是指材料表面的光滑程度. 低 \"粗糙度\" 會使材料看起來像閃亮的塑膠, 而高"
"粗糙度使材料在顏色上看起來更堅實."

msgid ""
"``METALLIC`` specifies how much like a metal the object is. It is better set "
"close to ``0`` or ``1``. Think of ``METALLIC`` as changing the balance "
"between the reflection and the ``ALBEDO`` color. A high ``METALLIC`` almost "
"ignores ``ALBEDO`` altogether, and looks like a mirror of the sky. While a "
"low ``METALLIC`` has a more equal representation of sky color and ``ALBEDO`` "
"color."
msgstr ""
"``METALLIC`` 指定該物體有多像金屬, 它最好設定為接近 ``0`` 或 ``1`` . 把 "
"``METALLIC`` 看作是改變反射和 ``ALBEDO`` 顏色之間的平衡. 高的 ``METALLIC`` 幾"
"乎完全忽略了 ``ALBEDO`` , 看起來像天空的鏡子. 而低的 ``METALLIC`` 對天空的顏"
"色和 ``ALBEDO`` 的顏色有一個更平實的表現."

msgid ""
"``ROUGHNESS`` increases from ``0`` to ``1`` from left to right while "
"``METALLIC`` increase from ``0`` to ``1`` from top to bottom."
msgstr "粗糙度 從左到右從0增加到1, 而 \"金屬度\" 從上到下從0增加到1."

msgid ""
"``METALLIC`` should be close to ``0`` or ``1`` for proper PBR shading. Only "
"set it between them for blending between materials."
msgstr ""
"對恰當的PBR陰影,\"金屬度\" 應當接近0或者1. 為了混合不同的材料, 只有將其設定在"
"0和1之間."

msgid ""
"Water is not a metal, so we will set its ``METALLIC`` property to ``0.0``. "
"Water is also highly reflective, so we will set its ``ROUGHNESS`` property "
"to be quite low as well."
msgstr ""
"水不是金屬，所以我們將其 ``METALLIC`` 屬性設定成 ``0.0``。水的反射性也很高，"
"因此我們將其``ROUGHNESS`` 屬性也設定得非常低。"

msgid ""
"Now we have a smooth plastic looking surface. It is time to think about some "
"particular properties of water that we want to emulate. There are two main "
"ones that will take this from a weird plastic surface to nice stylized "
"water. The first is specular reflections. Specular reflections are those "
"bright spots you see from where the sun reflects directly into your eye. The "
"second is fresnel reflectance. Fresnel reflectance is the property of "
"objects to become more reflective at shallow angles. It is the reason why "
"you can see into water below you, but farther away it reflects the sky."
msgstr ""
"現在，我們有了光滑的塑膠外觀表面。現在該考慮要類比的水的某些特定屬性了。這裡"
"有兩種主要的方法可以把詭異的塑膠表面變成好看的水。首先是鏡面反射"
"（Specular）。鏡面反射是那些來自太陽直接反射到你眼裡的明亮斑點。第二個是菲涅"
"耳反射（Fresnel）。菲涅爾反射是物體在小角度下更具反射性的屬性。這就是為什麼你"
"可以看見自己身下的水，卻在更遠處看見天空倒影的原因。"

msgid ""
"In order to increase the specular reflections, we will do two things. First, "
"we will change the render mode for specular to toon because the toon render "
"mode has larger specular highlights."
msgstr ""
"為了增強鏡面反射，我們需要做兩件事。首先，由於卡通算繪模式具有更高的鏡面反射"
"高光，我們將更改鏡面反射為卡通算繪模式。"

msgid ""
"Second we will add rim lighting. Rim lighting increases the effect of light "
"at glancing angles. Usually it is used to emulate the way light passes "
"through fabric on the edges of an object, but we will use it here to help "
"achieve a nice watery effect."
msgstr ""
"其次, 我們將新增邊緣照明. 邊緣照明增加了掠射角度的光線效果. 通常, 它用於類比"
"光線穿過物件邊緣上的織物的路徑, 但是我們將在此處使用它來幫助實作良好的水潤效"
"果."

#, fuzzy
msgid ""
"In order to add fresnel reflectance, we will compute a fresnel term in our "
"fragment shader. Here, we aren't going to use a real fresnel term for "
"performance reasons. Instead, we'll approximate it using the dot product of "
"the ``NORMAL`` and ``VIEW`` vectors. The ``NORMAL`` vector points away from "
"the mesh's surface, while the ``VIEW`` vector is the direction between your "
"eye and that point on the surface. The dot product between them is a handy "
"way to tell when you are looking at the surface head-on or at a glancing "
"angle."
msgstr ""
"為了增加菲涅耳反射率，我們將在片段著色器中計算菲涅耳項。在這裡，出於性能方面"
"的考慮，我們將不使用真正的菲涅耳術語。取而代之的是，我們將使用 ``NORMAL`` 和 "
"``VIEW`` 向量的點積對其進行近似。``NORMAL`` 向量指向遠離網格物體表面的位置，"
"而 ``VIEW`` 向量則是您的眼睛與該表面上的點之間的方向。它們之間的點積是一種可"
"以告訴您何時正視或掠過某個角度的方便方法。"

msgid ""
"And mix it into both ``ROUGHNESS`` and ``ALBEDO``. This is the benefit of "
"ShaderMaterials over StandardMaterial3Ds. With StandardMaterial3D, we could "
"set these properties with a texture, or to a flat number. But with shaders "
"we can set them based on any mathematical function that we can dream up."
msgstr ""
"並將其混合到 ``ROUGHNESS`` 和 ``ALBEDO``。這是 ShaderMaterial 比 "
"SpatialMaterial 的好處。使用 SpatialMaterial，我們可以用紋理來設定這些屬性，"
"或者設定成一個均勻的數字。但是用著色器，我們可以根據我們能想到的任何數學函式"
"來設定它們。"

msgid ""
"And now, with only 5 lines of code, you can have complex looking water. Now "
"that we have lighting, this water is looking too bright. Let's darken it. "
"This is done easily by decreasing the values of the ``vec3`` we pass into "
"``ALBEDO``. Let's set them to ``vec3(0.01, 0.03, 0.05)``."
msgstr ""
"而現在, 只需要5行程式碼, 你就可以擁有看起來很複雜的水. 現在, 我們有了照明, 這"
"個水看起來太亮了. 讓我們把它變暗. 這可以通過減少我們傳入 ``ALBEDO`` 的 "
"``vec3`` 的值來輕鬆實作. 讓我們把它們設定為 ``vec3(0.01, 0.03, 0.05)`` ."

msgid "Animating with ``TIME``"
msgstr "用 ``TIME`` 做動畫"

msgid ""
"Going back to the vertex function, we can animate the waves using the built-"
"in variable ``TIME``."
msgstr "回到頂點功能，我們可以使用內建變數 ``TIME`` 對波浪進行動畫處理。"

msgid ""
"``TIME`` is a built-in variable that is accessible from the vertex and "
"fragment functions."
msgstr "``TIME`` 是一個內建變數，可從頂點和片段函式存取。"

msgid ""
"In the last tutorial we calculated height by reading from a heightmap. For "
"this tutorial, we will do the same. Put the heightmap code in a function "
"called ``height()``."
msgstr ""
"在上一個教學中，我們通過從高度圖讀取來計算高度。對於本教學，我們將做同樣的事"
"情。將高度圖程式碼放在一個名為 ``height()`` 的函式中。"

msgid ""
"In order to use ``TIME`` in the ``height()`` function, we need to pass it in."
msgstr "為了在 ``height()`` 函式中使用 ``TIME``，我們需要將其傳遞進去。"

msgid "And make sure to correctly pass it in inside the vertex function."
msgstr "確保其正確傳遞到頂點函式中."

msgid ""
"Instead of using a normalmap to calculate normals. We are going to compute "
"them manually in the ``vertex()`` function. To do so use the following line "
"of code."
msgstr ""
"而不是使用法線貼圖來計算法線。我們將在 ``vertex()`` 函式中手動計算它們。為"
"此，請使用以下程式碼行。"

msgid ""
"We need to compute ``NORMAL`` manually because in the next section we will "
"be using math to create complex-looking waves."
msgstr ""
"我們需要手動計算 ``NORMAL``，因為在下一節中，我們將使用數學來建立外觀複雜的波"
"形。"

msgid ""
"Now, we are going to make the ``height()`` function a little more "
"complicated by offsetting ``position`` by the cosine of ``TIME``."
msgstr ""
"現在，我們要通過使 ``positon`` 偏移 ``TIME`` 的餘弦來使 ``height()`` 函式更加"
"複雜。"

msgid ""
"This results in waves that move slowly, but not in a very natural way. The "
"next section will dig deeper into using shaders to create more complex "
"effects, in this case realistic waves, by adding a few more mathematical "
"functions."
msgstr ""
"這會實作緩慢移動的波紋效果, 但顯得有點不自然. 下一節將深入探討, 通過加入更多"
"的數學函式, 來用著色器實作更複雜的效果, 比如更加真實的波紋."

msgid "Advanced effects: waves"
msgstr "進階效果：水波"

msgid ""
"What makes shaders so powerful is that you can achieve complex effects by "
"using math. To illustrate this, we are going to take our waves to the next "
"level by modifying the ``height()`` function and by introducing a new "
"function called ``wave()``."
msgstr ""
"利用數學, 著色器可以實作複雜的效果, 這是著色器的強大之處. 為闡述這一點, 我們"
"將修改 ``height()`` 函式和引入新函式 ``wave()`` , 來讓波紋效果更進一層."

msgid ""
"``wave()`` has one parameter, ``position``, which is the same as it is in "
"``height()``."
msgstr "``wave()`` 有一個參數, ``position``, 和在 ``height()`` 中一樣."

msgid ""
"We are going to call ``wave()`` multiple times in ``height()`` in order to "
"fake the way waves look."
msgstr ""
"我們將在 ``height()`` 函式中多次呼叫 ``wave()`` 函式, 來改變波紋的樣子."

msgid "At first this looks complicated. So let's go through it line-by-line."
msgstr "這在一開始會讓人覺得很複雜, 所以我們一行一行地來實作."

msgid ""
"Offset the position by the ``noise`` texture. This will make the waves "
"curve, so they won't be straight lines completely aligned with the grid."
msgstr ""
"通過 ``noise`` 紋理來偏移位置. 這將會使波浪成為曲線, 所以它們將不會是與網格所"
"對齊的直線."

msgid ""
"Define a wave-like function using ``sin()`` and ``position``. Normally "
"``sin()`` waves are very round. We use ``abs()`` to absolute to give them a "
"sharp ridge and constrain them to the 0-1 range. And then we subtract it "
"from ``1.0`` to put the peak on top."
msgstr ""
"用 ``sin()`` 和 ``position`` 定義一個類似波浪的函式. 通常 ``sin()`` 波是很圓"
"的. 我們使用 ``abs()`` 去將其絕對化, 讓它有一個尖銳波峰, 並將其約束於0-1的範"
"圍內. 然後我們再從 ``1.0`` 中減去, 將峰值放在上方."

msgid ""
"Multiply the x-directional wave by the y-directional wave and raise it to a "
"power to sharpen the peaks. Then subtract that from ``1.0`` so that the "
"ridges become peaks and raise that to a power to sharpen the ridges."
msgstr ""
"將x方向的波乘以y方向的波, 並將其提高到使峰值變得尖銳的冪. 然後從 ``1.0`` 中減"
"去它, 使山脊成為山峰, 並提高山脊銳化的能力."

msgid ""
"We can now replace the contents of our ``height()`` function with ``wave()``."
msgstr "現在我們可以用 ``wave()`` 代替 ``height()`` 函式的內容."

msgid "Using this, you get:"
msgstr "使用模組"

msgid ""
"The shape of the sin wave is too obvious. So let's spread the waves out a "
"bit. We do this by scaling ``position``."
msgstr ""
"正弦曲線的形狀太明顯了. 所以讓我們把波型分散一下. 我們通過縮放 ``位置`` 來實"
"作."

msgid "Now it looks much better."
msgstr "現在它看起來好多了."

msgid ""
"We can do even better if we layer multiple waves on top of each other at "
"varying frequencies and amplitudes. What this means is that we are going to "
"scale position for each one to make the waves thinner or wider (frequency). "
"And we are going to multiply the output of the wave to make them shorter or "
"taller (amplitude)."
msgstr ""
"如果我們將多個波以不同的頻率和幅度彼此疊加, 則可以做得更好. 這意味著我們將按"
"比例縮放每個位置, 以使波形更細或更寬(頻率). 我們將乘以波的輸出, 以使它們變低"
"或變高(振幅)."

msgid ""
"Here is an example for how you could layer the four waves to achieve nicer "
"looking waves."
msgstr "下面以四種波形為例, 說明如何將四種波形分層, 以達到更漂亮的波形效果."

msgid ""
"Note that we add time to two and subtract it from the other two. This makes "
"the waves move in different directions creating a complex effect. Also note "
"that the amplitudes (the number the result is multiplied by) all add up to "
"``1.0``. This keeps the wave in the 0-1 range."
msgstr ""
"請注意, 我們把時間加到兩個上, 再從另外兩個上減去. 這使得波在不同的方向上移"
"動, 產生了複雜的效果. 還要注意, 振幅(結果乘以的數位)全部加起來是 ``1.0``. 這"
"使波浪保持在0-1的範圍內."

msgid ""
"With this code you should end up with more complex looking waves and all you "
"had to do was add a bit of math!"
msgstr ""
"有了這段程式碼, 你應該可以得到更複雜的波形, 而你所要做的只是增加一點數學運"
"算！"

msgid ""
"For more information about Spatial shaders read the :ref:`Shading Language "
"<doc_shading_language>` doc and the :ref:`Spatial Shaders "
"<doc_spatial_shader>` doc. Also look at more advanced tutorials in the :ref:"
"`Shading section <toc-learn-features-shading>` and the :ref:`3D <toc-learn-"
"features-3d>` sections."
msgstr ""
"有關空間著色器的更多資訊, 請閱讀 :ref:`Shading Language "
"<doc_shading_language>` 文件和 :ref:`Spatial Shaders <doc_spatial_shader>` 文"
"件. 也可以看看 :ref:`Shading 部分 <toc-learn-features-shading>` 和 :ref:`3D "
"<toc-learn-features-3d>` 部分的高級教學."

msgid "Translation status"
msgstr "翻譯狀態"
