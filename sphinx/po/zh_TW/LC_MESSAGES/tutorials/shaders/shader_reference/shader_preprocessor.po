# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Shader preprocessor"
msgstr "著色器前置處理器"

msgid "Why use a shader preprocessor?"
msgstr "為什麼要使用著色器前置處理器？"

msgid ""
"In programming languages, a *preprocessor* allows changing the code before "
"the compiler reads it. Unlike the compiler, the preprocessor does not care "
"about whether the syntax of the preprocessed code is valid. The preprocessor "
"always performs what the *directives* tell it to do. A directive is a "
"statement starting with a hash symbol (``#``). It is not a *keyword* of the "
"shader language (such as ``if`` or ``for``), but a special kind of token "
"within the language."
msgstr ""
"在程式語言中，“預處理器”允許在編譯器讀取程式碼之前更改程式碼。與編譯器不同，"
"預處理器不關心預處理程式碼的語法是否有效。預處理器總是執行*指令*告訴它要做的"
"事情。指令是以哈希符號 (``#``) 開頭的敘述。它不是著色器語言的“關鍵字”（例"
"如“if”或“for”），而是語言中的一種特殊型別的標記。"

msgid ""
"From Godot 4.0 onwards, you can use a shader preprocessor within text-based "
"shaders. The syntax is similar to what most GLSL shader compilers support "
"(which in turn is similar to the C/C++ preprocessor)."
msgstr ""
"從 Godot 4.0 開始，您可以在基於文字的著色器中使用著色器預處理器。語法類似於大"
"多數 GLSL 著色器編譯器支援的語法（又類似於 C/C++ 預處理器）。"

msgid ""
"The shader preprocessor is not available in :ref:`visual shaders "
"<doc_visual_shaders>`. If you need to introduce preprocessor statements to a "
"visual shader, you can convert it to a text-based shader using the **Convert "
"to Shader** option in the VisualShader inspector resource dropdown. This "
"conversion is a one-way operation; text shaders cannot be converted back to "
"visual shaders."
msgstr ""
"著色器預處理器在視覺著色器 <doc_visual_shaders> 中不可用。如果需要將預處理器"
"敘述引入視覺著色器，可以使用 VisualShader 屬性面板資源下拉列表中的 **轉換為著"
"色器** 選項將其轉換為基於文字的著色器。這種轉換是一種單向操作；文字著色器無法"
"轉換回視覺著色器。"

msgid "Directives"
msgstr "字典"

msgid "General syntax"
msgstr "一般性定義"

msgid ""
"Preprocessor directives do not use brackets (``{}``), but can use "
"parentheses."
msgstr "前置處理器指令不使用大括弧（``{}``），但會用到括弧。"

msgid ""
"Preprocessor directives **never** end with semicolons (with the exception of "
"``#define``, where this is allowed but potentially dangerous)."
msgstr ""
"前置處理器指令**從不**以分號結尾（除非是 ``#define``，允許這麼做，但是可能比"
"較危險）。"

msgid ""
"Preprocessor directives can span several lines by ending each line with a "
"backslash (``\\``). The first line break *not* featuring a backslash will "
"end the preprocessor statement."
msgstr ""
"預處理器指令可以通過以反斜線 （''\\'） 結尾每行來跨越多行。第一個帶有反斜杠的"
"換行符將 *not* 結束預處理器語句。"

msgid "#define"
msgstr "#define"

msgid "**Syntax:** ``#define <identifier> [replacement_code]``."
msgstr "**語法：**``#define <識別字> [替換程式碼]``."

#, fuzzy
msgid ""
"Defines the identifier after that directive as a macro, and replaces all "
"successive occurrences of it with the replacement code given in the shader. "
"Replacement is performed on a \"whole words\" basis, which means no "
"replacement is performed if the string is part of another string (without "
"any spaces or operators separating it)."
msgstr ""
"將該指令後面的標識符定義為宏，並用著色器中給出的替換程式碼替換所有連續出現的"
"標識符。替換是在「整個單字」的基礎上執行的，這意味著如果該字串是另一個字串的"
"一部分（沒有任何空格分隔它），則不會執行替換。"

msgid ""
"Defines with replacements may also have one or more *arguments*, which can "
"then be passed when referencing the define (similar to a function call)."
msgstr ""
"帶有替換的定義也可能有一個或多個*參數*，然後可以在引用定義時傳遞這些參數（類"
"似於函式呼叫）。"

msgid ""
"If the replacement code is not defined, the identifier may only be used with "
"``#ifdef`` or ``#ifndef`` directives."
msgstr ""
"如果未定義替換程式碼，則識別碼只能與「#ifdef」或「#ifndef」指令一起使用。"

msgid ""
"If the *concatenation* symbol (``##``) is present in the replacement code "
"then it will be removed upon macro insertion, together with any space "
"surrounding it, and join the surrounding words and arguments into a new "
"token."
msgstr ""

msgid ""
"Compared to constants (``const CONSTANT = value;``), ``#define`` can be used "
"anywhere within the shader (including in uniform hints). ``#define`` can "
"also be used to insert arbitrary shader code at any location, while "
"constants can't do that."
msgstr ""
"與常數（``const CONSTANT = value;``）相比，``#define`` 可以在著色器中的任何位"
"置使用（包括在均勻提示中）。 ``#define`` 也可以用於在任何位置插入任意著色器程"
"式碼，而常數則不能這樣做。"

msgid ""
"Defining a ``#define`` for an identifier that is already defined results in "
"an error. To prevent this, use ``#undef <identifier>``."
msgstr ""
"為已定義的標識符定義“#define”會導致錯誤。為了防止這種情況，請使用``#undef "
"<identifier>``。"

msgid "#undef"
msgstr "#undef"

msgid "**Syntax:** ``#undef identifier``"
msgstr "**語法：**``#undef 識別字``"

msgid ""
"The ``#undef`` directive may be used to cancel a previously defined "
"``#define`` directive:"
msgstr "“#undef”指令可用來取消先前定義的“#define”指令："

msgid ""
"Without ``#undef`` in the above example, there would be a macro redefinition "
"error."
msgstr "上例中如果沒有“#undef”，就會出現巨集重定義錯誤。"

msgid "#if"
msgstr "if"

msgid "**Syntax:** ``#if <condition>``"
msgstr "**語法：**``#if <條件>``"

msgid ""
"The ``#if`` directive checks whether the ``condition`` passed. If it "
"evaluates to a non-zero value, the code block is included, otherwise it is "
"skipped."
msgstr ""
"``#if`` 指令檢查``condition`` 是否通過。如果其計算結果為非零值，則包含該程式"
"碼區塊，否則將跳過該程式碼區塊。"

msgid ""
"To evaluate correctly, the condition must be an expression giving a simple "
"floating-point, integer or boolean result. There may be multiple condition "
"blocks connected by ``&&`` (AND) or ``||`` (OR) operators. It may be "
"continued by a ``#else`` block, but **must** be ended with the ``#endif`` "
"directive."
msgstr ""
"為了正確計算，條件必須是給出簡單浮點、整數或布林結果的表達式。可能有多個條件"
"區塊透過「&&」（AND）或「||」（OR）運算子連接。它可以由「#else」區塊繼續，但"
"**必須**以「#endif」指令結束。"

msgid ""
"Using the ``defined()`` *preprocessor function*, you can check whether the "
"passed identifier is defined a by ``#define`` placed above that directive. "
"This is useful for creating multiple shader versions in the same file. It "
"may be continued by a ``#else`` block, but must be ended with the ``#endif`` "
"directive."
msgstr ""
"使用“define()”*預處理器函式*，您可以檢查傳遞的識別碼是否由放置在該指令上方"
"的“#define”定義。這對於在同一檔案中建立多個著色器版本非常有用。它可以"
"由“#else”區塊繼續，但必須以“#endif”指令結束。"

msgid ""
"The ``defined()`` function's result can be negated by using the ``!`` "
"(boolean NOT) symbol in front of it. This can be used to check whether a "
"define is *not* set."
msgstr ""
"``define()`` 函式的結果可以透過在其前面使用 ``!`` （布爾 NOT）符號來求反。這"
"可用於檢查定義是否“未”設定。"

msgid ""
"Be careful, as ``defined()`` must only wrap a single identifier within "
"parentheses, never more:"
msgstr "請小心，因為「define()」只能將單一標識符括在括號內，不能再多了："

msgid ""
"In the shader editor, preprocessor branches that evaluate to ``false`` (and "
"are therefore excluded from the final compiled shader) will appear grayed "
"out. This does not apply to run-time ``if`` statements."
msgstr ""
"在著色器編輯器中，評估為「false」的預處理器分支（因此從最終編譯的著色器中排"
"除）將顯示為灰色。這不適用於運作時“if”敘述。"

msgid "**#if preprocessor versus if statement: Performance caveats**"
msgstr "**#if 預處理器與 if 敘述：效能警告**"

msgid ""
"The :ref:`shading language <doc_shading_language>` supports run-time ``if`` "
"statements:"
msgstr ":ref:`著色語言 <doc_shading_language>` 支援執行時期 ``if`` 敘述："

msgid ""
"If the uniform is never changed, this behaves identical to the following "
"usage of the ``#if`` preprocessor statement:"
msgstr "如果制服從未改變，則其行為與「#if」預處理器敘述的以下用法相同："

msgid ""
"However, the ``#if`` variant can be faster in certain scenarios. This is "
"because all run-time branches in a shader are still compiled and variables "
"within those branches may still take up register space, even if they are "
"never run in practice."
msgstr ""
"然而，“#if”變體在某些情況下可能會更快。這是因為著色器中的所有運作時分支仍然被"
"編譯，並且這些分支中的變數可能仍然佔用寄存器空間，即使它們在實踐中從未運作。"

msgid ""
"Modern GPUs are `quite effective <https://medium.com/@jasonbooth_86226/"
"branching-on-a-gpu-18bfc83694f2>`__ at performing \"static\" branching. "
"\"Static\" branching refers to ``if`` statements where *all* pixels/vertices "
"evaluate to the same result in a given shader invocation. However, high "
"amounts of :abbr:`VGPRs (Vector General-Purpose Register)` (which can be "
"caused by having too many branches) can still slow down shader execution "
"significantly."
msgstr ""
"現代 GPU 在執行「靜態」分支方面「非常有效」<https://medium.com/"
"@jasonbooth_86226/branching-on-a-gpu-18bfc83694f2>」。 「靜態」分支是指「if」"
"敘述，其中*所有*像素/頂點在給定著色器呼叫中計算結果相同。然而，大量的 VGPR"
"（向量通用暫存器）（這可能是由於分支過多引起的）仍然會顯著減慢著色器的執行速"
"度。"

msgid "#elif"
msgstr "elif"

msgid ""
"The ``#elif`` directive stands for \"else if\" and checks the condition "
"passed if the above ``#if`` evaluated to ``false``. ``#elif`` can only be "
"used within an ``#if`` block. It is possible to use several ``#elif`` "
"statements after an ``#if`` statement."
msgstr ""
"“#elif” 指令代表“else if”，並檢查如果上述“#if” 計算結果為“false” 則傳遞的條"
"件。 ``#elif`` 只能在``#if`` 區塊中使用。在「#if」敘述之後可以使用多個"
"「#elif」敘述。"

msgid "Like with ``#if``, the ``defined()`` preprocessor function can be used:"
msgstr "與“#if”一樣，可以使用“define()”預處理器函式："

msgid "#ifdef"
msgstr "#ifdef"

msgid "**Syntax:** ``#ifdef <identifier>``"
msgstr "**語法：**``#ifdef <識別字>``"

msgid ""
"This is a shorthand for ``#if defined(...)``. Checks whether the passed "
"identifier is defined by ``#define`` placed above that directive. This is "
"useful for creating multiple shader versions in the same file. It may be "
"continued by a ``#else`` block, but must be ended with the ``#endif`` "
"directive."
msgstr ""
"這是「#if Defined(...)」的簡寫。檢查傳遞的標識符是否由位於該指令上方"
"的“#define”定義。這對於在同一檔案中建立多個著色器版本非常有用。它可以"
"由“#else”區塊繼續，但必須以“#endif”指令結束。"

msgid ""
"The processor does *not* support ``#elifdef`` as a shortcut for ``#elif "
"defined(...)``. Instead, use the following series of ``#ifdef`` and "
"``#else`` when you need more than two branches:"
msgstr ""
"處理器*不*支援「#elifdef」作為「#elif Defined(...)」的捷徑。相反，當您需要兩"
"個以上的分支時，請使用以下系列的“#ifdef”和“#else”："

msgid "#ifndef"
msgstr "#ifndef"

msgid "**Syntax:** ``#ifndef <identifier>``"
msgstr "**語法：**``#ifndef <識別字>``"

msgid ""
"This is a shorthand for ``#if !defined(...)``. Similar to ``#ifdef``, but "
"checks whether the passed identifier is **not** defined by ``#define`` "
"before that directive."
msgstr ""
"這是「#if !define(...)」的簡寫。與“#ifdef”類似，但檢查傳遞的標識符是否不是由"
"該指令之前的“#define”定義的。"

msgid ""
"This is the exact opposite of ``#ifdef``; it will always match in situations "
"where ``#ifdef`` would never match, and vice versa."
msgstr ""
"這與“#ifdef”完全相反；在“#ifdef”永遠不會配對的情況下它總是配對，反之亦然。"

msgid "#else"
msgstr "else"

msgid "**Syntax:** ``#else``"
msgstr "**語法：**``#else``"

msgid ""
"Defines the optional block which is included when the previously defined "
"``#if``, ``#elif``, ``#ifdef`` or ``#ifndef`` directive evaluates to false."
msgstr ""
"定義當先前定義的「#if」、「#elif」、「#ifdef」或「#ifndef」指令計算結果為 "
"false 時所包含的可選區塊。"

msgid "#endif"
msgstr "#endif"

msgid "**Syntax:** ``#endif``"
msgstr "**語法：**``#endif``"

msgid ""
"Used as terminator for the ``#if``, ``#ifdef``, ``#ifndef`` or subsequent "
"``#else`` directives."
msgstr "用作「#if」、「#ifdef」、「#ifndef」或後續「#else」指令的終止符。"

msgid "#include"
msgstr "標頭引用"

msgid "**Syntax:** ``#include \"path\"``"
msgstr "**語法：**``#include \"路徑\"``"

msgid ""
"The ``#include`` directive includes the *entire* content of a shader include "
"file in a shader. ``\"path\"`` can be an absolute ``res://`` path or "
"relative to the current shader file. Relative paths are only allowed in "
"shaders that are saved to ``.gdshader`` or ``.gdshaderinc`` files, while "
"absolute paths can be used in shaders that are built into a scene/resource "
"file."
msgstr ""
"``#include`` 指令將著色器包含檔案的*整個*內容包含在著色器中。 ``\"path\"`` 可"
"以是絕對的``res://`` 路徑或相對於目前著色器檔案的路徑。僅允許在儲存至「."
"gdshader」或「.gdshaderinc」檔案的著色器中使用相對路徑，而絕對路徑可在內建於"
"場景/資源檔案中的著色器中使用。"

msgid ""
"You can create new shader includes by using the **File > Create Shader "
"Include** menu option of the shader editor, or by creating a new :ref:"
"`ShaderInclude<class_ShaderInclude>` resource in the FileSystem dock."
msgstr ""
"您可以使用著色器編輯器的 **檔案 > 建立著色器包含** 選單選項，或透過在檔案系統"
"停靠區中建立新的 ShaderInclude<class_ShaderInclude> 資源來建立新的著色器包"
"含。"

msgid ""
"Shader includes can be included from within any shader, or other shader "
"include, at any point in the file."
msgstr "著色器包含可以包含在檔案中任何點的任何著色器或其他著色器包含中。"

msgid ""
"When including shader includes in the global scope of a shader, it is "
"recommended to do this after the initial ``shader_type`` statement."
msgstr ""
"當著色器包含在著色器的全域範圍中時，建議在初始「shader_type」敘述之後執行此操"
"作。"

msgid ""
"You can also include shader includes from within the body a function. Please "
"note that the shader editor is likely going to report errors for your shader "
"include's code, as it may not be valid outside of the context that it was "
"written for. You can either choose to ignore these errors (the shader will "
"still compile fine), or you can wrap the include in an ``#ifdef`` block that "
"checks for a define from your shader."
msgstr ""
"您也可以將著色器包含在主體內的函式中。請注意，著色器編輯器可能會報告著色器包"
"含程式碼的錯誤，因為它在其編寫的本文之外可能無效。您可以選擇忽略這些錯誤（著"
"色器仍然可以正常編譯），也可以將包含內容包裝在「#ifdef」區塊中，該區塊檢查著"
"色器中的定義。"

msgid ""
"``#include`` is useful for creating libraries of helper functions (or "
"macros) and reducing code duplication. When using ``#include``, be careful "
"about naming collisions, as redefining functions or macros is not allowed."
msgstr ""
"``#include`` 對於建立輔助函式（或巨集）函式庫和減少程式碼重複很有用。使"
"用“#include”時，請注意命名衝突，因為不允許重新定義函式或巨集。"

msgid "``#include`` is subject to several restrictions:"
msgstr "``#include`` 受到幾個限制："

msgid ""
"Only shader include resources (ending with ``.gdshaderinc``) can be "
"included. ``.gdshader`` files cannot be included by another shader, but a ``."
"gdshaderinc`` file can include other ``.gdshaderinc`` files."
msgstr ""
"只能包含著色器包含資源（以``.gdshaderinc``結尾）。 ``.gdshader`` 檔案不能被其"
"他著色器包含，但 ``.gdshaderinc`` 檔案可以包含其他 ``.gdshaderinc`` 檔案。"

msgid "Cyclic dependencies are **not** allowed and will result in an error."
msgstr "**不允許**允許循環依賴，並且會導致錯誤。"

msgid "To avoid infinite recursion, include depth is limited to 25 steps."
msgstr "為了避免無限遞歸，包含深度限制為 25 步。"

msgid "Example shader include file:"
msgstr "這樣的例子包含..."

msgid "Example base shader (using the include file we created above):"
msgstr "範例基礎著色器（使用我們上面建立的包含檔案）："

msgid "#pragma"
msgstr "#pragma"

msgid "**Syntax:** ``#pragma value``"
msgstr "**語法：**``#pragma 值``"

msgid ""
"The ``#pragma`` directive provides additional information to the "
"preprocessor or compiler."
msgstr "``#pragma`` 指令向預處理器或編譯器提供附加資訊。"

msgid ""
"Currently, it may have only one value: ``disable_preprocessor``. If you "
"don't need the preprocessor, use that directive to speed up shader "
"compilation by excluding the preprocessor step."
msgstr ""
"目前，它可能只有一個值：「disable_preprocessor」。如果您不需要預處理器，請使"
"用指令透過排除預處理器步驟來加速著色器編譯。"

msgid "Translation status"
msgstr "翻譯狀態"
