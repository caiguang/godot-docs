# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Screen-reading shaders"
msgstr "螢幕閱讀著色器"

msgid "Introduction"
msgstr "前言"

msgid ""
"It is often desired to make a shader that reads from the same screen to "
"which it's writing. 3D APIs, such as OpenGL or DirectX, make this very "
"difficult because of internal hardware limitations. GPUs are extremely "
"parallel, so reading and writing causes all sorts of cache and coherency "
"problems. As a result, not even the most modern hardware supports this "
"properly."
msgstr ""
"很多人想要讓著色器在寫螢幕的同時讀取該螢幕的資料。因為內部硬體限制，OpenGL "
"和 DirectX 等 3D API 都很難實作這一功能。GPU 是極其並行的，所以同時進行讀寫會"
"導致各種快取和一致性問題。因此，即便是最新的硬體也對此進行無法正確的支援。"

msgid ""
"The workaround is to make a copy of the screen, or a part of the screen, to "
"a back-buffer and then read from it while drawing. Godot provides a few "
"tools that make this process easy."
msgstr ""
"解決辦法是將螢幕或螢幕的一部分複製到一個背景緩衝區，然後在繪圖時從那裡讀取。"
"Godot 提供了一些工具，可以使這一過程變得很容易。"

msgid "Screen texture"
msgstr "匯入紋理"

msgid ""
"Godot :ref:`doc_shading_language` has a special texture to access the "
"already rendered contents of the screen. It is used by specifying a hint "
"when declaring a ``sampler2D`` uniform: ``hint_screen_texture``. A special "
"built-in varying ``SCREEN_UV`` can be used to obtain the UV relative to the "
"screen for the current fragment. As a result, this canvas_item fragment "
"shader results in an invisible object, because it only shows what lies "
"behind:"
msgstr ""
"Godot :ref:`doc_shading_language` 有一個特殊的紋理, ``SCREEN_TEXTURE`` (在3D"
"的情況下, ``DEPTH_TEXTURE`` 代表深度). 它以螢幕的UV作為參數, 並返回一個帶有顏"
"色的RGB vec3. 一個特殊的內建變數.SCREEN_UV可以用來獲取目前片段的UV. 因此, 這"
"是個簡單的canvas_item片段著色器:"

msgid ""
"``textureLod`` is used here as we only want to read from the bottom mipmap. "
"If you want to read from a blurred version of the texture instead, you can "
"increase the third argument to ``textureLod`` and change the hint "
"``filter_nearest`` to ``filter_nearest_mipmap`` (or any other filter with "
"mipmaps enabled). If using a filter with mipmaps, Godot will automatically "
"calculate the blurred texture for you."
msgstr ""
"這裡使用「textureLod」是因為我們只想從底部 mipmap 讀取。如果您想讀取紋理的模"
"糊版本，則可以將第三個參數增加為“textureLod”，並將提示“filter_nearest”更改"
"為“filter_nearest_mipmap”（或啟用 mipmap 的任何其他篩選器） 。如果使用具有 "
"mipmap 的濾鏡，Godot 會自動為您計算模糊紋理。"

msgid ""
"If the filter mode is not changed to a filter mode that contains ``mipmap`` "
"in its name, ``textureLod`` with a LOD parameter greater than ``0.0`` will "
"have the same appearance as with the ``0.0`` LOD parameter."
msgstr ""

msgid "Screen texture example"
msgstr "另一個範例："

msgid ""
"The screen texture can be used for many things. There is a special demo for "
"*Screen Space Shaders*, that you can download to see and learn. One example "
"is a simple shader to adjust brightness, contrast and saturation:"
msgstr ""
"螢幕紋理可以用來做很多事情。有一個針對*螢幕空間著色器*的特殊演示專案，你可以"
"下載後查看學習。其中的一個例子就是用簡單的著色器來調整亮度、對比度以及飽和"
"度："

msgid "Behind the scenes"
msgstr "幕後"

msgid ""
"While this seems magical, it's not. In 2D, when ``hint_screen_texture`` is "
"first found in a node that is about to be drawn, Godot does a full-screen "
"copy to a back-buffer. Subsequent nodes that use it in shaders will not have "
"the screen copied for them, because this ends up being inefficient. In 3D, "
"the screen is copied after the opaque geometry pass, but before the "
"transparent geometry pass, so transparent objects will not be captured in "
"the screen texture."
msgstr ""
"雖然這看起來很神奇，但其實不然。在 2D 中，第一次在即將繪製的節點中發現 "
"``hint_screen_texture`` 時，Godot 就會將整個螢幕拷貝到後臺緩衝之中。後續在著"
"色器中使用它的節點將不會造成螢幕的複製，因為否則的話效率非常低。在 3D 中，進"
"行螢幕拷貝的時機是在不透明幾何體階段之後、透明幾何體階段之前，所以透明的物體"
"不會被捕捉到螢幕紋理之中。"

msgid ""
"As a result, in 2D, if shaders that use ``hint_screen_texture`` overlap, the "
"second one will not use the result of the first one, resulting in unexpected "
"visuals:"
msgstr ""
"因此，在 2D 中，如果使用 ``hint_screen_texture`` 的著色器存在覆蓋，那麼後一個"
"著色器使用的就不是第一個著色器的結果，會導致意外的圖像："

msgid ""
"In the above image, the second sphere (top right) is using the same source "
"for the screen texture as the first one below, so the first one "
"\"disappears\", or is not visible."
msgstr ""
"在上圖中，第二個球體（右上）所使用的螢幕紋理和第一個球體所使用的螢幕紋理的來"
"源是一致的，所以第一個球體會“消失”，或者說不可見。"

msgid ""
"In 2D, this can be corrected via the :ref:`BackBufferCopy "
"<class_BackBufferCopy>` node, which can be instantiated between both "
"spheres. BackBufferCopy can work by either specifying a screen region or the "
"whole screen:"
msgstr ""
"在 2D 中，這個問題可以通過 :ref:`BackBufferCopy <class_BackBufferCopy>` 節點"
"修正，在這兩個球體之間產生實體即可。BackBufferCopy 可以指定螢幕上的某個區域進"
"行複製，也可以複製整個螢幕："

msgid "With correct back-buffer copying, the two spheres blend correctly:"
msgstr "正確複製後臺緩衝之後，這兩個球體就能夠正確混合了："

msgid ""
"In 3D, materials that use ``hint_screen_texture`` are considered transparent "
"themselves and will not appear in the resulting screen texture of other "
"materials. If you plan to instance a scene that uses a material with "
"``hint_screen_texture``, you will need to use a BackBufferCopy node."
msgstr ""

msgid ""
"In 3D, there is less flexibility to solve this particular issue because the "
"screen texture is only captured once. Be careful when using the screen "
"texture in 3D as it won't capture transparent objects and may capture some "
"opaque objects that are in front of the object using the screen texture."
msgstr ""
"在 3D 中，這個問題解決起來就沒有那麼靈活，因為螢幕紋理只會捕捉一次。在 3D 中"
"使用螢幕紋理時請多加小心，因為它並不會捕獲到透明的物件，反而可能捕獲到位於使"
"用螢幕紋理的物件之前的不透明物件。"

msgid ""
"You can reproduce the back-buffer logic in 3D by creating a :ref:`Viewport "
"<class_Viewport>` with a camera in the same position as your object, and "
"then use the :ref:`Viewport's <class_Viewport>` texture instead of the "
"screen texture."
msgstr ""
"要在 3D 中重現後臺緩衝的邏輯，可以建立一個 :ref:`Viewport <class_Viewport>` "
"並在物件的位置建立一個相機，然後就可以使用該 :ref:`Viewport "
"<class_Viewport>` 的紋理來代替螢幕紋理。"

msgid "Back-buffer logic"
msgstr "後臺緩衝邏輯"

msgid ""
"So, to make it clearer, here's how the backbuffer copying logic works in 2D "
"in Godot:"
msgstr ""
"好的，想要對後臺緩衝有更清晰的理解的話，Godot 在 2D 中後臺緩衝複製的原理是這"
"樣的："

msgid ""
"If a node uses ``hint_screen_texture``, the entire screen is copied to the "
"back buffer before drawing that node. This only happens the first time; "
"subsequent nodes do not trigger this."
msgstr ""
"如果某個節點使用了 ``hint_screen_texture``，那麼繪製該節點之前就會將整個螢幕"
"複製到後臺緩衝之中。只有第一次才會這麼做，後續的節點不會觸發。"

msgid ""
"If a BackBufferCopy node was processed before the situation in the point "
"above (even if ``hint_screen_texture`` was not used), the behavior described "
"in the point above does not happen. In other words, automatic copying of the "
"entire screen only happens if ``hint_screen_texture`` is used in a node for "
"the first time and no BackBufferCopy node (not disabled) was found before in "
"tree-order."
msgstr ""
"如果上述情況發生前遇到過 BackBufferCopy 節點（即便尚未使用過 "
"``hint_screen_texture``），那麼也不會執行相關的行為。換句話說，自動複製整個螢"
"幕的條件只有：某個節點中首次使用 ``hint_screen_texture`` 並且按照樹順序不存在"
"更早的（未被禁用的）BackBufferCopy 節點。"

msgid ""
"BackBufferCopy can copy either the entire screen or a region. If set to only "
"a region (not the whole screen) and your shader uses pixels not in the "
"region copied, the result of that read is undefined (most likely garbage "
"from previous frames). In other words, it's possible to use BackBufferCopy "
"to copy back a region of the screen and then read the screen texture from a "
"different region. Avoid this behavior!"
msgstr ""
"BackBufferCopy 可以選擇複製整個螢幕或者只複製某個區域。如果設定為區域（非整個"
"螢幕），但是著色器使用了複製區域之外的像素，那麼讀取到的結果就是未定義的（很"
"可能是上一影格殘留的垃圾資料）。換句話說，你確實能夠使用 BackBufferCopy 複製"
"螢幕上的某個區域，然後讀取螢幕紋理上的其他區域。但請避免這樣的行為！"

msgid "Depth texture"
msgstr "深度紋理"

msgid ""
"For 3D shaders, it's also possible to access the screen depth buffer. For "
"this, the ``hint_depth_texture`` hint is used. This texture is not linear; "
"it must be converted using the inverse projection matrix."
msgstr ""
"3D 著色器也可以存取螢幕深度緩衝，使用 ``hint_depth_texture`` 提示即可。該紋理"
"不是線性的；必須通過逆投影矩陣進行轉換。"

msgid ""
"The following code retrieves the 3D position below the pixel being drawn:"
msgstr "以下程式碼會獲取正在繪製的像素所在的 3D 位置："

msgid "Normal-roughness texture"
msgstr "法線-粗糙度紋理"

#, fuzzy
msgid ""
"Normal-roughness texture is only supported in the Forward+ rendering method, "
"not Mobile or Compatibility."
msgstr "只有“集群 Forward”算繪後端支援體積霧，“Forward 移動”和“相容”不支援。"

msgid ""
"Similarly, the normal-roughness texture can be used to read the normals and "
"roughness of objects rendered in the depth prepass. The normal is stored in "
"the ``.xyz`` channels (mapped to the 0-1 range) while the roughness is "
"stored in the ``.w`` channel."
msgstr ""
"類似的，如果物件在深度預階段中進行了算繪，就可以用法線-粗糙度紋理來讀取該對象"
"的法線和粗糙度。法線儲存在 ``.xyz`` 通道中（對應到了 0-1 範圍內），而粗糙度則"
"儲存在 ``.w`` 通道中。"

msgid "Redefining screen textures"
msgstr "匯入紋理"

msgid ""
"The screen texture hints (``hint_screen_texture``, ``hint_depth_texture``, "
"and ``hint_normal_roughness_texture``) can be used with multiple uniforms. "
"For example, you may want to read from the texture multiple times with a "
"different repeat flag or filter flag."
msgstr ""
"可以對多個 uniform 使用螢幕紋理提示（``hint_screen_texture``、"
"``hint_depth_texture``、``hint_normal_roughness_texture``）。例如，你可能會想"
"要使用不同的重複旗標和篩選旗標多次讀取該紋理。"

msgid ""
"The following example shows a shader that reads the screen space normal with "
"linear filtering, but reads the screen space roughness using nearest "
"neighbor filtering."
msgstr ""
"下面的例子中，著色器在讀取螢幕空間法線時使用的就是線性篩選，而讀取螢幕空間粗"
"糙度時使用的就是最鄰近篩選。"

msgid "Translation status"
msgstr "翻譯狀態"
