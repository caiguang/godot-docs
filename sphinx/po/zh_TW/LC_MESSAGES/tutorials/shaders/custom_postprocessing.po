# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Custom post-processing"
msgstr "自訂後期處理"

msgid "Introduction"
msgstr "前言"

#, fuzzy
msgid ""
"Godot provides many post-processing effects out of the box, including Bloom, "
"DOF, and SSAO, which are described in :ref:"
"`doc_environment_and_post_processing`. However, advanced use cases may "
"require custom effects. This article explains how to write your own custom "
"effects."
msgstr ""
"Godot 提供許多開箱即用的後處理效果，包括泛光、DOF 和 SSAO。有時你想編寫自己的"
"自訂效果。下面介紹如何做到這一點。"

msgid ""
"The easiest way to implement a custom post-processing shader is to use "
"Godot's built-in ability to read from the screen texture. If you're not "
"familiar with this, you should read the :ref:`Screen Reading Shaders "
"Tutorial <doc_screen-reading_shaders>` first."
msgstr ""
"實作自訂後期處理著色器的最簡單方法是使用Godot的內建功能從螢幕紋理中讀取. 如果"
"您不熟悉這個, 您應該先閱讀 :ref:`螢幕閱讀著色器教學 <doc_screen-"
"reading_shaders>` ."

msgid "Single pass post-processing"
msgstr "單通後期處理"

msgid ""
"Post-processing effects are shaders applied to a frame after Godot has "
"rendered it. To apply a shader to a frame, create a :ref:`CanvasLayer "
"<class_CanvasLayer>`, and give it a :ref:`ColorRect <class_ColorRect>`. "
"Assign a new :ref:`ShaderMaterial <class_ShaderMaterial>` to the newly "
"created ``ColorRect``, and set the ``ColorRect``'s layout to \"Full Rect\"."
msgstr ""
"後處理效果是在 Godot 算繪影格後應用於影格的著色器。若要將著色器套用到影格，請"
"建立一個 CanvasLayer <class_CanvasLayer>`，並為其指定一個 ColorRect "
"<class_ColorRect>`。將新的 ShaderMaterial <class_ShaderMaterial> 指派給新建立"
"的“ColorRect”，並將“ColorRect”的佈局設為“完整矩形”。"

msgid "Your scene tree will look something like this:"
msgstr "最後場景應該長這樣。"

msgid ""
"Another more efficient method is to use a :ref:`BackBufferCopy "
"<class_BackBufferCopy>` to copy a region of the screen to a buffer and to "
"access it in a shader script through a ``sampler2D`` using "
"``hint_screen_texture``."
msgstr ""
"另一種更有效的方法是使用 BackBufferCopy <class_BackBufferCopy>` 將螢幕區域複"
"製到緩衝區，並使用「hint_screen_texture」透過「sampler2D」在著色器腳本中存取"
"它。"

#, fuzzy
msgid ""
"As of the time of writing, Godot does not support rendering to multiple "
"buffers at the same time. Your post-processing shader will not have access "
"to other render passes and buffers not exposed by Godot (such as depth or "
"normal/roughness). You only have access to the rendered frame and buffers "
"exposed by Godot as samplers."
msgstr ""
"在撰寫本文時,Godot不支援同時對多個緩衝區進行算繪. 處理之後著色器將無法存取法"
"線或其他算繪通道. 你只能存取已算繪的影格."

msgid ""
"For this demo, we will use this :ref:`Sprite <class_Sprite2D>` of a sheep."
msgstr "這個演示中，我們使用的是這張小羊的:ref:`精靈 <class_Sprite2D>`。"

msgid ""
"Assign a new :ref:`Shader <class_Shader>` to the ``ColorRect``'s "
"``ShaderMaterial``. You can access the frame's texture and UV with a "
"``sampler2D`` using ``hint_screen_texture`` and the built in ``SCREEN_UV`` "
"uniforms."
msgstr ""
"為 ``ColorRect`` 的 ``ShaderMaterial`` 分配一個新的 :ref:`Shader "
"<class_Shader>`。你可以通過使用帶 ``hint_screen_texture`` 的 ``sampler2D`` 以"
"及內建的 uniform ``SCREEN_UV`` 來存取這一影格的紋理和 UV。"

msgid ""
"Copy the following code to your shader. The code below is a hex pixelization "
"shader by `arlez80 <https://bitbucket.org/arlez80/hex-mosaic/src/master/>`_,"
msgstr ""
"將以下程式碼複製到著色器. 上面的程式碼是單通道邊緣偵測濾波器, `Sobel 濾波器 "
"<https://en.wikipedia.org/wiki/Sobel_operator>`_ ，"

msgid "The sheep will look something like this:"
msgstr "最後場景應該長這樣。"

msgid "Multi-pass post-processing"
msgstr "多階段後期處理"

msgid ""
"Some post-processing effects like blurs are resource intensive. You can make "
"them run a lot faster if you break them down in multiple passes. In a "
"multipass material, each pass takes the result from the previous pass as an "
"input and processes it."
msgstr ""
"像模糊這樣的後期處理效果是資源密集型的. 但是如果您在多次通過中將它們分解, 您"
"可以讓它們運作得更快. 在多通道材質中, 每次傳遞都將前一次傳遞的結果作為輸入並"
"對其進行處理."

msgid ""
"To produce a multi-pass post-processing shader, you stack ``CanvasLayer`` "
"and ``ColorRect`` nodes. In the example above, you use a ``CanvasLayer`` "
"object to render a shader using the frame on the layer below. Apart from the "
"node structure, the steps are the same as with the single-pass post-"
"processing shader."
msgstr ""
"若要產生多通道後處理著色器，請堆疊“CanvasLayer”和“ColorRect”節點。在上面的範"
"例中，您使用「CanvasLayer」物件來使用下面圖層上的框架來算繪著色器。除了節點結"
"構之外，步驟與單通道後處理著色器相同。"

msgid ""
"As an example, you could write a full screen Gaussian blur effect by "
"attaching the following pieces of code to each of the ``ColorRect`` nodes. "
"The order in which you apply the shaders depends on the position of the "
"``CanvasLayer`` in the scene tree, higher means sooner. For this blur "
"shader, the order does not matter."
msgstr ""
"例如，可以通過將下面的程式碼片段附加到每個 ``ColorRect`` 上來編寫全屏高斯模糊"
"效果。應用著色器的順序取決於場景樹中 ``CanvasLayer`` 的位置，越往上越早應用。"
"對於這個模糊著色器而言，順序是無所謂的。"

msgid ""
"Using the above code, you should end up with a full screen blur effect like "
"below."
msgstr "使用上面的程式碼, 您應該得到如下所示的全屏模糊效果."

msgid "Translation status"
msgstr "翻譯狀態"
