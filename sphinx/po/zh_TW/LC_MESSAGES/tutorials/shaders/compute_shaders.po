# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using compute shaders"
msgstr "使用計算著色器"

msgid ""
"This tutorial will walk you through the process of creating a minimal "
"compute shader. But first, a bit of background on compute shaders and how "
"they work with Godot."
msgstr ""
"本教學將引導您完成建立最小計算著色器的過程。但首先，我們先了解計算著色器的背"
"景知識以及它們如何與 Godot 搭配使用。"

msgid ""
"This tutorial assumes you are familiar with shaders generally. If you are "
"new to shaders please read :ref:`doc_introduction_to_shaders` and :ref:`your "
"first shader <toc-your-first-shader>` before proceeding with this tutorial."
msgstr ""
"本教學假設您通常熟悉著色器。如果您是著色器新手，請在繼續本教學之前閱讀 :ref:"
"`doc_introduction_to_shaders` 和 :ref:`您的第一個著色器 <toc-your-first-"
"shader>`。"

msgid ""
"A compute shader is a special type of shader program that is orientated "
"towards general purpose programming. In other words, they are more flexible "
"than vertex shaders and fragment shaders as they don't have a fixed purpose "
"(i.e. transforming vertices or writing colors to an image). Unlike fragment "
"shaders and vertex shaders, compute shaders have very little going on behind "
"the scenes. The code you write is what the GPU runs and very little else. "
"This can make them a very useful tool to offload heavy calculations to the "
"GPU."
msgstr ""
"計算著色器是一種特殊型別的著色器程式，面向通用編程。換句話說，它們比頂點著色"
"器和片段著色器更靈活，因為它們沒有固定的用途（即轉換頂點或將顏色寫入圖像）。"
"與片段著色器和頂點著色器不同，計算著色器在幕後幾乎沒有進行任何操作。您編寫的"
"程式碼是 GPU 運作的程式碼，除此之外幾乎沒有其他程式碼。這使得它們成為一個非常"
"有用的工具，可以將繁重的計算解除安裝到 GPU。"

msgid "Now let's get started by creating a short compute shader."
msgstr "現在讓我們開始建立一個簡短的計算著色器。"

msgid ""
"First, in the **external** text editor of your choice, create a new file "
"called ``compute_example.glsl`` in your project folder. When you write "
"compute shaders in Godot, you write them in GLSL directly. The Godot shader "
"language is based on GLSL. If you are familiar with normal shaders in Godot, "
"the syntax below will look somewhat familiar."
msgstr ""
"首先，在您選擇的**外部**文字編輯器中，在專案資料夾中建立一個名為"
"「compute_example.glsl」的新檔案。當您在 Godot 中編寫計算著色器時，您可以直接"
"在 GLSL 中編寫它們。 Godot 著色器語言是基於 GLSL。如果您熟悉 Godot 中的普通著"
"色器，那麼下面的語法看起來有些熟悉。"

msgid ""
"Compute shaders can only be used from RenderingDevice-based renderers (the "
"Forward+ or Mobile renderer). To follow along with this tutorial, ensure "
"that you are using the Forward+ or Mobile renderer. The setting for which is "
"located in the top right-hand corner of the editor."
msgstr ""
"計算著色器只能在基於 RenderingDevice 的算繪器（Forward+ 或 Mobile 算繪器）中"
"使用。若要按照本教學進行操作，請確保您使用的是 Forward+ 或 Mobile 算繪器。其"
"設定位於編輯器的右上角。"

msgid ""
"Note that compute shader support is generally poor on mobile devices (due to "
"driver bugs), even if they are technically supported."
msgstr ""
"請注意，計算著色器在行動裝置上的支援通常很差（由於驅動程式錯誤），即使它們在"
"技術上得到支援。"

msgid "Let's take a look at this compute shader code:"
msgstr "我們把它調成藍色："

msgid ""
"This code takes an array of floats, multiplies each element by 2 and store "
"the results back in the buffer array. Now let's look at it line-by-line."
msgstr ""
"此程式碼採用浮點數陣列，將每個元素乘以 2，並將結果儲存回緩衝區陣列中。現在讓"
"我們逐行看一下。"

msgid "These two lines communicate two things:"
msgstr "這兩行傳達了兩件事："

msgid ""
"The following code is a compute shader. This is a Godot-specific hint that "
"is needed for the editor to properly import the shader file."
msgstr ""
"以下程式碼是計算著色器。這是編輯器正確匯入著色器檔案所需的特定於 Godot 的提"
"示。"

msgid "The code is using GLSL version 450."
msgstr "程式碼使用 GLSL 版本 450。"

msgid ""
"You should never have to change these two lines for your custom compute "
"shaders."
msgstr "您永遠不必為自訂計算著色器更改這兩行。"

msgid ""
"Next, we communicate the number of invocations to be used in each workgroup. "
"Invocations are instances of the shader that are running within the same "
"workgroup. When we launch a compute shader from the CPU, we tell it how many "
"workgroups to run. Workgroups run in parallel to each other. While running "
"one workgroup, you cannot access information in another workgroup. However, "
"invocations in the same workgroup can have some limited access to other "
"invocations."
msgstr ""
"接下來，我們傳達每個工作組中要使用的呼叫次數。呼叫是在同一工作群組中執行的著"
"色器的實例。當我們從 CPU啟動計算著色器時，我們會告訴它要運作多少個工作組。工"
"作小組彼此並行運作。執行一個工作群組時，您無法存取另一工作群組中的資訊。但"
"是，同一工作群組中的呼叫可以對其他呼叫具有一些有限的存取權。"

msgid "Think about workgroups and invocations as a giant nested ``for`` loop."
msgstr "將工作群組和呼叫視為一個巨大的巢狀“for”循環。"

msgid ""
"Workgroups and invocations are an advanced topic. For now, remember that we "
"will be running two invocations per workgroup."
msgstr ""
"工作小組和呼叫是一個高級主題。現在，請記住，我們將為每個工作組執行兩次呼叫。"

msgid ""
"Here we provide information about the memory that the compute shader will "
"have access to. The ``layout`` property allows us to tell the shader where "
"to look for the buffer, we will need to match these ``set`` and ``binding`` "
"positions from the CPU side later."
msgstr ""
"在這裡，我們提供有關計算著色器將存取的記憶體的資訊。 “layout” 屬性允許我們告"
"訴著色器在哪裡尋找緩衝區，稍後我們需要從 CPU 端配對這些“set” 和“binding” 位"
"置。"

msgid ""
"The ``restrict`` keyword tells the shader that this buffer is only going to "
"be accessed from one place in this shader. In other words, we won't bind "
"this buffer in another ``set`` or ``binding`` index. This is important as it "
"allows the shader compiler to optimize the shader code. Always use "
"``restrict`` when you can."
msgstr ""
"“restrict” 關鍵字告訴著色器該緩衝區只能從該著色器中的一個位置存取。換句話說，"
"我們不會將此緩衝區綁定到另一個「set」或「binding」索引中。這很重要，因為它允"
"許著色器編譯器最佳化著色器程式碼。盡可能使用“restrict”。"

msgid ""
"This is an *unsized* buffer, which means it can be any size. So we need to "
"be careful not to read from an index larger than the size of the buffer."
msgstr ""
"這是一個*未確定大小的*緩衝區，這表示它可以是任意大小。所以我們需要小心，不要"
"從大於緩衝區大小的索引中讀取資料。"

msgid ""
"Finally, we write the ``main`` function which is where all the logic "
"happens. We access a position in the storage buffer using the "
"``gl_GlobalInvocationID`` built in variables. ``gl_GlobalInvocationID`` "
"gives you the global unique ID for the current invocation."
msgstr ""
"最後，我們編寫“main”函式，這是所有邏輯發生的地方。我們使用內建變數"
"「gl_GlobalInitationID」來存取儲存緩衝區中的位置。 “gl_GlobalInitationID” 為"
"您提供目前呼叫的全域唯一 ID。"

msgid ""
"To continue, write the code above into your newly created ``compute_example."
"glsl`` file."
msgstr "要繼續，請將上面的程式碼寫入新建立的“compute_example.glsl”檔案中。"

msgid "Create a local RenderingDevice"
msgstr "建立局部 RenderingDevice"

msgid ""
"To interact with and execute a compute shader, we need a script. Create a "
"new script in the language of your choice and attach it to any Node in your "
"scene."
msgstr ""
"為了與計算著色器互動並執行計算著色器，我們需要一個腳本。使用您選擇的語言建立"
"新腳本並將其附加到場景中的任何節點。"

msgid ""
"Now to execute our shader we need a local :ref:`class_RenderingDevice` which "
"can be created using the :ref:`class_RenderingServer`:"
msgstr ""
"現在要執行我們的著色器，我們需要一個本地 class_RenderingDevice ，可以使用 "
"class_RenderingServer 來建立它："

msgid ""
"After that, we can load the newly created shader file ``compute_example."
"glsl`` and create a precompiled version of it using this:"
msgstr ""
"之後，我們可以載入新建立的著色器檔案“compute_example.glsl”並使用以下指令建立"
"它的預編譯版本："

msgid ""
"Local RenderingDevices cannot be debugged using tools such as `RenderDoc "
"<https://renderdoc.org/>`__."
msgstr ""

msgid "Provide input data"
msgstr "提供輸入資料"

msgid ""
"As you might remember, we want to pass an input array to our shader, "
"multiply each element by 2 and get the results."
msgstr ""
"您可能還記得，我們希望將輸入陣列傳遞給著色器，將每個元素乘以 2 並獲得結果。"

msgid ""
"We need to create a buffer to pass values to a compute shader. We are "
"dealing with an array of floats, so we will use a storage buffer for this "
"example. A storage buffer takes an array of bytes and allows the CPU to "
"transfer data to and from the GPU."
msgstr ""
"我們需要建立一個緩衝區來將值傳遞給計算著色器。我們正在處理浮點陣列，因此我們"
"將在本範例中使用儲存緩衝區。儲存緩衝區採用位元組陣列，並允許 CPU 與 GPU 之間"
"傳輸資料。"

msgid "So let's initialize an array of floats and create a storage buffer:"
msgstr "因此，讓我們初始化一個浮點陣列並建立一個儲存緩衝區："

msgid ""
"With the buffer in place we need to tell the rendering device to use this "
"buffer. To do that we will need to create a uniform (like in normal shaders) "
"and assign it to a uniform set which we can pass to our shader later."
msgstr ""
"緩衝區就位後，我們需要告訴算繪裝置使用該緩衝區。為此，我們需要建立一個均勻"
"（就像在普通著色器中一樣）並將其指派給一個均勻集，稍後我們可以將其傳遞給著色"
"器。"

msgid "Defining a compute pipeline"
msgstr "定義計算管線"

msgid ""
"The next step is to create a set of instructions our GPU can execute. We "
"need a pipeline and a compute list for that."
msgstr "下一步是建立 GPU 可以執行的一組指令。我們需要一個管道和一個計算列表。"

msgid "The steps we need to do to compute our result are:"
msgstr "計算結果需要執行的步驟是："

msgid "Create a new pipeline."
msgstr "建立新專案"

msgid "Begin a list of instructions for our GPU to execute."
msgstr "開始我們的 GPU 執行的指令列表。"

msgid "Bind our compute list to our pipeline"
msgstr "將我們的計算列表綁定到我們的管道"

msgid "Bind our buffer uniform to our pipeline"
msgstr "將我們的緩衝區均勻綁定到我們的管道"

msgid "Specify how many workgroups to use"
msgstr "指定要使用的工作群組數量"

msgid "End the list of instructions"
msgstr "編輯器整合"

msgid ""
"Note that we are dispatching the compute shader with 5 work groups in the X "
"axis, and one in the others. Since we have 2 local invocations in the X axis "
"(specified in our shader), 10 compute shader invocations will be launched in "
"total. If you read or write to indices outside of the range of your buffer, "
"you may access memory outside of your shaders control or parts of other "
"variables which may cause issues on some hardware."
msgstr ""
"請注意，我們將計算著色器分派給 X 軸上的 5 個工作組，以及其他一個工作組。由於"
"我們在 X 軸上有 2 個本地呼叫（在著色器中指定），因此總共將啟動 10 個計算著色"
"器呼叫。如果您讀取或寫入緩衝區範圍之外的索引，則可能會存取著色器控制之外的記"
"憶體或其他變數的一部分，這可能會導致某些硬體出現問題。"

msgid "Execute a compute shader"
msgstr "執行計算著色器"

msgid ""
"After all of this we are almost done, but we still need to execute our "
"pipeline. So far we have only recorded what we would like the GPU to do; we "
"have not actually run the shader program."
msgstr ""
"所有這些之後我們就快完成了，但我們仍然需要執行我們的管道。到目前為止，我們只"
"記錄了我們希望 GPU 執行的操作；我們還沒有真正運作著色器程式。"

msgid ""
"To execute our compute shader we need to submit the pipeline to the GPU and "
"wait for the execution to finish:"
msgstr "要執行計算著色器，我們需要將管道提交給 GPU 並等待執行完成："

msgid ""
"Ideally, you would not call ``sync()`` to synchronize the RenderingDevice "
"right away as it will cause the CPU to wait for the GPU to finish working. "
"In our example, we synchronize right away because we want our data available "
"for reading right away. In general, you will want to wait *at least* 2 or 3 "
"frames before synchronizing so that the GPU is able to run in parallel with "
"the CPU."
msgstr ""
"理想情況下，您不會立即呼叫「sync()」來同步 RenderingDevice，因為這會導致 CPU "
"等待 GPU 完成工作。在我們的範例中，我們立即同步，因為我們希望資料可供立即讀"
"取。一般來說，您需要在同步之前等待「至少」2 或 3 影格，以便 GPU 能夠與 CPU 並"
"行運作。"

msgid ""
"Long computations can cause Windows graphics drivers to \"crash\" due to :"
"abbr:`TDR (Timeout Detection and Recovery)` being triggered by Windows. This "
"is a mechanism that reinitializes the graphics driver after a certain amount "
"of time has passed without any activity from the graphics driver (usually 5 "
"to 10 seconds)."
msgstr ""
"由於 Windows 觸發 TDR（逾時偵測和復原），長時間運算可能會導致 Windows 圖形驅"
"動程式「當機」。這是一種在圖形驅動程式沒有任何活動（通常為 5 到 10 秒）一段時"
"間後重新初始化圖形驅動程式的機制。"

msgid ""
"Depending on the duration your compute shader takes to execute, you may need "
"to split it into multiple dispatches to reduce the time each dispatch takes "
"and reduce the chances of triggering a TDR. Given TDR is time-dependent, "
"slower GPUs may be more prone to TDRs when running a given compute shader "
"compared to a faster GPU."
msgstr ""
"根據計算著色器執行所需的持續時間，您可能需要將其拆分為多個調度，以減少每個調"
"度所需的時間並減少觸發 TDR 的機會。鑑於 TDR 與時間相關，與較快的 GPU 相比，在"
"運作給定計算著色器時，較慢的 GPU 可能更容易出現 TDR。"

msgid "Retrieving results"
msgstr "測試結果"

msgid ""
"You may have noticed that, in the example shader, we modified the contents "
"of the storage buffer. In other words, the shader read from our array and "
"stored the data in the same array again so our results are already there. "
"Let's retrieve the data and print the results to our console."
msgstr ""
"您可能已經注意到，在範例著色器中，我們修改了儲存緩衝區的內容。換句話說，著色"
"器從我們的陣列中讀取資料並將資料再次儲存在同一陣列中，因此我們的結果已經存"
"在。讓我們檢索資料並將結果列印到控制台。"

msgid ""
"With that, you have everything you need to get started working with compute "
"shaders."
msgstr "這樣，您就擁有了開始使用計算著色器所需的一切。"

msgid ""
"The demo projects repository contains a `Compute Shader Heightmap demo "
"<https://github.com/godotengine/godot-demo-projects/tree/master/misc/"
"compute_shader_heightmap>`__ This project performs heightmap image "
"generation on the CPU and GPU separately, which lets you compare how a "
"similar algorithm can be implemented in two different ways (with the GPU "
"implementation being faster in most cases)."
msgstr ""
"示範專案儲存庫包含一個「Compute Shader Heightmap demo <https://github.com/"
"godotengine/godot-demo-projects/tree/master/misc/"
"compute_shader_heightmap>`__ 此專案分別在CPU 和GPU 上執行高度圖片圖像生成，它"
"可以讓您比較如何以兩種不同的方式實作類似的演算法（大多數情況下 GPU 實作速度更"
"快）。"

msgid "Translation status"
msgstr "翻譯狀態"
