# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using a Viewport as a texture"
msgstr "使用 Viewport 作為紋理"

msgid "Introduction"
msgstr "前言"

msgid ""
"This tutorial will introduce you to using the :ref:`Viewport "
"<class_Viewport>` as a texture that can be applied to 3D objects. In order "
"to do so, it will walk you through the process of making a procedural planet "
"like the one below:"
msgstr ""
"本教學將向您介紹如何使用 :ref:`Viewport <class_Viewport>` 作為可應用於 3D 對"
"象的紋理。為了做到這一點，它將引導您完成製作程式式星球的過程，如下所示："

msgid ""
"This tutorial does not cover how to code a dynamic atmosphere like the one "
"this planet has."
msgstr "本教學沒有介紹如何編寫像這個星球那樣的動態氛圍."

msgid ""
"This tutorial assumes you are familiar with how to set up a basic scene "
"including: a :ref:`Camera3D <class_Camera3D>`, a :ref:`light source "
"<class_OmniLight3D>`, a :ref:`MeshInstance3D <class_MeshInstance3D>` with a :"
"ref:`Primitive Mesh <class_PrimitiveMesh>`, and applying a :ref:"
"`StandardMaterial3D <class_StandardMaterial3D>` to the mesh. The focus will "
"be on using the :ref:`Viewport <class_Viewport>` to dynamically create "
"textures that can be applied to the mesh."
msgstr ""
"本教學假定你熟悉如何設定基本場景，其中包括：一個 :ref:`相機 <class_Camera>`、"
"一個 :ref:`光源 <class_OmniLight>`、一個 :ref:`像素網格 "
"<class_PrimitiveMesh>`的 :ref:`網格實例 <class_MeshInstance>`，並將一個 :ref:"
"`SpatialMaterial <class_SpatialMaterial>` 應用於網格。我們的重點將會是使用 :"
"ref:`Viewport <class_Viewport>` 來動態地建立可應用於網格的紋理。"

msgid "In this tutorial, we'll cover the following topics:"
msgstr "在本教學中, 我們將介紹以下主題:"

msgid "How to use a :ref:`Viewport <class_Viewport>` as a render texture"
msgstr "如何使用 :ref:`Viewport <class_Viewport>` 作為算繪紋理"

msgid "Mapping a texture to a sphere with equirectangular mapping"
msgstr "使用 equirectangular 對應將紋理對應到球體"

msgid "Fragment shader techniques for procedural planets"
msgstr "程式式行星的片段著色器技術"

msgid ""
"Setting a Roughness map from a :ref:`Viewport Texture "
"<class_ViewportTexture>`"
msgstr "從:ref:`視口紋理 <class_ViewportTexture>`設定粗糙度貼圖"

msgid "Setting up the Viewport"
msgstr "設定視口"

msgid "First, add a :ref:`Viewport <class_Viewport>` to the scene."
msgstr "首先, 在場景中新增 :ref:`Viewport <class_Viewport>` ."

msgid ""
"Next, set the size of the :ref:`Viewport <class_Viewport>` to ``(1024, "
"512)``. The :ref:`Viewport <class_Viewport>` can actually be any size so "
"long as the width is double the height. The width needs to be double the "
"height so that the image will accurately map onto the sphere, as we will be "
"using equirectangular projection, but more on that later."
msgstr ""
"接下來, 將 :ref:`Viewport <class_Viewport>` 的大小設定為 ``(1024, 512)`` . :"
"ref:`Viewport <class_Viewport>` 實際上可以是任何尺寸, 只要其寬度是高度的兩"
"倍. 寬度需要是高度的兩倍, 這樣圖像才能準確地對應到球體上, 因為我們將使用等量"
"矩形投影, 後面會有更多的介紹."

msgid ""
"Next, disable HDR and disable 3D. We don't need HDR because our planet's "
"surface will not be especially bright, so values between ``0`` and ``1`` "
"will be fine. And we will be using a :ref:`ColorRect <class_ColorRect>` to "
"render the surface, so we don't need 3D either."
msgstr ""
"接下來, 禁用HDR和禁用3D. 我們不需要HDR, 因為星球的表面不會特別亮, 所以數值在 "
"``0`` 和 ``1`` 之間就可以了. 將使用一個 :ref:`ColorRect <class_ColorRect>` 來"
"算繪表面, 所以我們也不需要3D."

msgid ""
"Select the Viewport and add a :ref:`ColorRect <class_ColorRect>` as a child."
msgstr "選擇視口並新增 :ref:`ColorRect <class_ColorRect>` 作為子項."

msgid ""
"Set the anchors \"Right\" and \"Bottom\" to ``1``, then make sure all the "
"margins are set to ``0``. This will ensure that the :ref:`ColorRect "
"<class_ColorRect>` takes up the entire :ref:`Viewport <class_Viewport>`."
msgstr ""
"將“Right”和“Bottom”的 Anchor 設定為 ``1``，然後確保所有邊距都設定為 ``0``。這"
"樣就確保 :ref:`ColorRect <class_ColorRect>` 佔據了整個 :ref:`Viewport "
"<class_Viewport>`。"

msgid ""
"Next, we add a :ref:`Shader Material <class_ShaderMaterial>` to the :ref:"
"`ColorRect <class_ColorRect>` (ColorRect > CanvasItem > Material > Material "
"> ``New ShaderMaterial``)."
msgstr ""
"接下來, 我們為 :ref:`Shader Material <class_ShaderMaterial>` 新增一個 :ref:"
"`ColorRect <class_ColorRect>` (ColorRect > CanvasItem > Material > Material "
"> ``New ShaderMaterial``)."

msgid ""
"Basic familiarity with shading is recommended for this tutorial. However, "
"even if you are new to shaders, all the code will be provided, so you should "
"have no problem following along."
msgstr ""
"建議本教學基本瞭解陰影. 但是, 即使您不熟悉著色器, 也將提供所有程式碼, 因此後"
"續操作應該沒有問題."

msgid ""
"ColorRect > CanvasItem > Material > Material > click / Edit > ShaderMaterial "
"> Shader > ``New Shader`` > click / Edit:"
msgstr ""
"ColorRect > CanvasItem > Material > Material > 點擊 / 編輯 > ShaderMaterial "
"> Shader > ``新建 Shader`` > 點擊 / 編輯："

msgid "The above code renders a gradient like the one below."
msgstr "上面的程式碼呈現如下所示的漸變。"

msgid ""
"Now we have the basics of a :ref:`Viewport <class_Viewport>` that we render "
"to and we have a unique image that we can apply to the sphere."
msgstr ""
"現在我們有一個基礎 :ref:`Viewport <class_Viewport>` 我們算繪到的, 我們有一個"
"可以應用於球體的獨特圖像."

msgid "Applying the texture"
msgstr "應用紋理"

msgid ""
"MeshInstance3D > GeometryInstance > Geometry > Material Override > ``New "
"StandardMaterial3D``:"
msgstr ""
"MeshInstance > GeometryInstance > Geometry > Material Override > ``新建 "
"SpatialMaterial``："

msgid ""
"Now we go into the :ref:`MeshInstance3D <class_MeshInstance3D>` and add a :"
"ref:`StandardMaterial3D <class_StandardMaterial3D>` to it. No need for a "
"special :ref:`Shader Material <class_ShaderMaterial>` (although that would "
"be a good idea for more advanced effects, like the atmosphere in the example "
"above)."
msgstr ""
"現在我們進入 :ref:`Mesh Instance <class_MeshInstance>` 並新增一個 :ref:"
"`SpatialMaterial <class_SpatialMaterial>` 給它. 不需要一個特殊的 :ref:"
"`Shader Material <class_ShaderMaterial>` (儘管這對於更高級的效果來說是個好主"
"意, 比如上面例子中的大氣)."

msgid ""
"MeshInstance3D > GeometryInstance > Geometry > Material Override > "
"``click`` / ``Edit``:"
msgstr ""
"MeshInstance > GeometryInstance > Geometry > Material Override > ``點擊`` / "
"``編輯``："

msgid ""
"Open the newly created :ref:`StandardMaterial3D <class_StandardMaterial3D>` "
"and scroll down to the \"Albedo\" section and click beside the \"Texture\" "
"property to add an Albedo Texture. Here we will apply the texture we made. "
"Choose \"New ViewportTexture\""
msgstr ""
"打開新建立的 :ref:`SpatialMaterial <class_SpatialMaterial>` , 向下滾動到 "
"\"Albedo\" 部分, 點擊 \"Texture\" 屬性旁邊, 新增一個Albedo Texture. 這裡我們"
"將應用製作的紋理. 選擇 \"New ViewportTexture\""

msgid ""
"Then, from the menu that pops up, select the Viewport that we rendered to "
"earlier."
msgstr "然後, 從彈出的功能表中, 選擇我們先前算繪的視圖."

msgid ""
"Your sphere should now be colored in with the colors we rendered to the "
"Viewport."
msgstr "現在, 您的球體應使用我們算繪到視口的顏色進行著色."

msgid ""
"Notice the ugly seam that forms where the texture wraps around? This is "
"because we are picking a color based on UV coordinates and UV coordinates do "
"not wrap around the texture. This is a classic problem in 2D map projection. "
"Game developers often have a 2-dimensional map they want to project onto a "
"sphere, but when it wraps around, it has large seams. There is an elegant "
"workaround for this problem that we will illustrate in the next section."
msgstr ""
"注意到在紋理環繞的地方形成的醜陋縫隙嗎？這是因為我們是根據UV座標來選取顏色"
"的, 而UV座標並不會環繞紋理. 這是二維地圖投影中的一個典型問題. 遊戲開發人員通"
"常有一個二維貼圖, 他們想投射到一個球體上, 但是當它環繞時, 將有接縫. 這個問題"
"有一個優雅的解決方法, 我們將在下一節中說明."

msgid "Making the planet texture"
msgstr "製作行星紋理"

msgid ""
"So now, when we render to our :ref:`Viewport <class_Viewport>`, it appears "
"magically on the sphere. But there is an ugly seam created by our texture "
"coordinates. So how do we get a range of coordinates that wrap around the "
"sphere in a nice way? One solution is to use a function that repeats on the "
"domain of our texture. ``sin`` and ``cos`` are two such functions. Let's "
"apply them to the texture and see what happens."
msgstr ""
"所以現在我們算繪到我們的 :ref:`Viewport <class_Viewport>` 它在球體上神奇地出"
"現了. 但是我們的紋理座標會產生一個醜陋的縫隙. 那麼我們如何以一種很好的方式獲"
"得圍繞球體的一系列座標？ 一種解決方案是使用在紋理域上重複的函式. ``sin`` 和 "
"``cos`` 是兩個這樣的函式. 讓我們將它們應用於紋理, 看看會發生什麼."

msgid ""
"Not too bad. If you look around, you can see that the seam has now "
"disappeared, but in its place, we have pinching at the poles. This pinching "
"is due to the way Godot maps textures to spheres in its :ref:"
"`StandardMaterial3D <class_StandardMaterial3D>`. It uses a projection "
"technique called equirectangular projection, which translates a spherical "
"map onto a 2D plane."
msgstr ""
"不算太壞. 如果你環顧四周, 可以看到接縫現在已經消失了, 但在它所處位置, 會有兩"
"極的擠壓. 這種擠壓是由於Godot在其 :ref:`SpatialMaterial "
"<class_SpatialMaterial>` 中把紋理對應到球體的方式造成的. 它使用了一種叫做 "
"\"等角投影\" 的投影技術, 將球面圖形轉化為一個二維平面."

msgid ""
"If you are interested in a little extra information on the technique, we "
"will be converting from spherical coordinates into Cartesian coordinates. "
"Spherical coordinates map the longitude and latitude of the sphere, while "
"Cartesian coordinates are, for all intents and purposes, a vector from the "
"center of the sphere to the point."
msgstr ""
"如果你對技術方面的一些額外資訊感興趣，我們將從球面座標轉換為直角坐標。球面座"
"標對應的是球體的經度和緯度，而直角坐標則是從球體中心到點的一個向量。"

msgid ""
"For each pixel, we will calculate its 3D position on the sphere. From that, "
"we will use 3D noise to determine a color value. By calculating the noise in "
"3D, we solve the problem of the pinching at the poles. To understand why, "
"picture the noise being calculated across the surface of the sphere instead "
"of across the 2D plane. When you calculate across the surface of the sphere, "
"you never hit an edge, and hence you never create a seam or a pinch point on "
"the pole. The following code converts the ``UVs`` into Cartesian coordinates."
msgstr ""
"對於每個像素, 我們將計算它在球體上的三維位置. 由此, 我們將使用3D噪波來確定一"
"個顏色值. 通過計算3D噪波, 我們解決了兩極的擠壓問題. 要理解為什麼, 想像一下在"
"球體表面而不是在二維平面上計算雜訊. 當你跨越球體表面進行計算時, 你永遠不會碰"
"到邊緣, 因此你永遠不會在極點上產生接縫或夾點。下面的程式碼會將“UV”轉換為笛卡"
"爾座標。"

msgid "And if we use ``unit`` as an output ``COLOR`` value, we get:"
msgstr "如果我們使用 ``unit`` 作為輸出 ``COLOR`` 值, 我們可以得到:"

msgid ""
"Now that we can calculate the 3D position of the surface of the sphere, we "
"can use 3D noise to make the planet. We will be using this noise function "
"directly from a `Shadertoy <https://www.shadertoy.com/view/Xsl3Dl>`_:"
msgstr ""
"現在我們可以計算出球體表面的3D位置, 可以使用3D雜訊來製作球體. 直接從 "
"`Shadertoy <https://www.shadertoy.com/view/Xsl3Dl>`_ 中使用這個雜訊函式:"

msgid ""
"All credit goes to the author, Inigo Quilez. It is published under the "
"``MIT`` licence."
msgstr "所有功勞歸作者Inigo Quilez所有. 它是在 ``MIT`` 許可下發行的."

msgid ""
"Now to use ``noise``, add the following to the    ``fragment`` function:"
msgstr "現在使用 ``noised`` , 將以下內容新增到 ``fragment`` 函式中:"

msgid "In order to highlight the texture, we set the material to unshaded."
msgstr "為了突出顯示紋理, 我們將材質設定為無陰影."

msgid ""
"You can see now that the noise indeed wraps seamlessly around the sphere. "
"Although this looks nothing like the planet you were promised. So let's move "
"onto something more colorful."
msgstr ""
"你現在可以看到, 儘管這看起來完全不像所承諾的球體, 但噪音確實無縫地包裹著球"
"體. 對此, 讓我們進入一些更豐富多彩的東西."

msgid "Coloring the planet"
msgstr "著色這個星球"

msgid ""
"Now to make the planet colors. While there are many ways to do this, for "
"now, we will stick with a gradient between water and land."
msgstr ""
"現在來製作行星的顏色. 雖然有很多方法可以做到這一點, 但目前, 我們將使用水和陸"
"地之間的梯度."

msgid ""
"To make a gradient in GLSL, we use the ``mix`` function. ``mix`` takes two "
"values to interpolate between and a third argument to choose how much to "
"interpolate between them; in essence, it *mixes* the two values together. In "
"other APIs, this function is often called ``lerp``. However, ``lerp`` is "
"typically reserved for mixing two floats together; ``mix`` can take any "
"values whether it be floats or vector types."
msgstr ""
"要在 GLSL 中建立漸變, 我們使用 ``mix`` 函式. ``mix`` 需要兩個值來插值和第三個"
"參數來選擇在它們之間插入多少, 實質上它將兩個值 *混合* 在一起. 在其他API中, 此"
"函式通常稱為 ``lerp`` . 雖然 ``lerp`` 通常用於將兩個浮點數混合在一起, 但 "
"``mix`` 可以取任何值, 無論它是浮點數還是向量型別."

msgid ""
"The first color is blue for the ocean. The second color is a kind of reddish "
"color (because all alien planets need red terrain). And finally, they are "
"mixed together by ``n * 0.5 + 0.5``. ``n`` smoothly varies between ``-1`` "
"and ``1``. So we map it into the ``0-1`` range that ``mix`` expects. Now you "
"can see that the colors change between blue and red."
msgstr ""
"第一種顏色是藍色, 代表海洋. 第二種顏色是一種偏紅的顏色, 因為所有外星球都需要"
"紅色的地形. 最後, 它們 ``n * 0.5 + 0.5`` 混合在一起. ``n`` 在 ``-1`` 和 "
"``1`` 之間平滑變化. 所以我們把它對應到 ``mix`` 預期的 ``0-1`` 範圍內. 現在你"
"可以看到, 顏色在藍色和紅色之間變化."

msgid ""
"That is a little more blurry than we want. Planets typically have a "
"relatively clear separation between land and sea. In order to do that, we "
"will change the last term to ``smoothstep(-0.1, 0.0, n)``. And thus the "
"whole line becomes:"
msgstr ""
"這比我們想要的還要模糊一些. 行星通常在陸地和海洋之間有一個相對清晰的分隔. 為"
"了做到這一點, 我們將把最後一項改為 ``smoothstep(-0.1, 0.0, n)`` . 整條線就變"
"成了這樣:"

msgid ""
"What ``smoothstep`` does is return ``0`` if the third argument is below the "
"first and ``1`` if the third argument is larger than the second and smoothly "
"blends between ``0`` and ``1`` if the third number is between the first and "
"the second. So in this line, ``smoothstep`` returns ``0`` whenever ``n`` is "
"less than ``-0.1`` and it returns ``1`` whenever ``n`` is above ``0``."
msgstr ""
"``smoothstep`` 所做的是, 如果第三個參數低於第一個參數, 則返回 ``0`` , 如果第"
"三個參數大於第二個參數, 則返回 ``1`` , 如果第三個數字在第一個和第二個之間, 則"
"在 ``0`` 和 ``1`` 之間平滑地混合. 所以在這一行中, 當 ``n`` 小於 ``-0.1`` 時, "
"``smoothstep`` 返回 ``0`` , 當 ``n`` 高於 ``0`` 時, 它返回 ``1`` ."

msgid ""
"One more thing to make this a little more planet-y. The land shouldn't be so "
"blobby; let's make the edges a little rougher. A trick that is often used in "
"shaders to make rough looking terrain with noise is to layer levels of noise "
"over one another at various frequencies. We use one layer to make the "
"overall blobby structure of the continents. Then another layer breaks up the "
"edges a bit, and then another, and so on. What we will do is calculate ``n`` "
"with four lines of shader code instead of just one. ``n`` becomes:"
msgstr ""
"還有一件事, 使其更像一個行星. 這片土地不應該是圓球狀的；讓我們把邊緣變得更粗"
"糙一些. 在著色器中經常使用的一個技巧是在不同的頻率下將不同層次的雜訊疊加在一"
"起, 使地形看起來粗糙. 我們使用一個層來製作大陸的整體球狀結構. 然後, 另一層將"
"邊緣打碎, 然後是另一層, 以此類推. 我們要做的是用四行著色器程式碼來計算 "
"``n`` , 而不是只有一行. ``n`` 變成了:"

msgid "And now the planet looks like:"
msgstr "現在這個星球看起來像:"

msgid "And with shading turned back on, it looks like:"
msgstr "而在重新打開陰影後, 看起來就像:"

msgid "Making an ocean"
msgstr "製作海洋"

msgid ""
"One final thing to make this look more like a planet. The ocean and the land "
"reflect light differently. So we want the ocean to shine a little more than "
"the land. We can do this by passing a fourth value into the ``alpha`` "
"channel of our output ``COLOR`` and using it as a Roughness map."
msgstr ""
"讓這個看起來更像是一顆行星的最後一件事. 海洋和陸地以不同的方式反射光線. 因"
"此, 我們希望海洋比陸地更加閃耀. 我們可以通過將第四個值傳遞到輸出 ``COLOR`` "
"的 ``alpha`` 通道並將其用作粗糙度圖來實作."

msgid ""
"This line returns ``0.3`` for water and ``1.0`` for land. This means that "
"the land is going to be quite rough, while the water will be quite smooth."
msgstr ""
"該行對於水返回 ``0.3`` , 對於土地返回 ``1.0`` . 這意味著土地將變得很粗糙, 而"
"水將變得非常光滑."

msgid ""
"And then, in the material, under the \"Metallic\" section, make sure "
"``Metallic`` is set to ``0`` and ``Specular`` is set to ``1``. The reason "
"for this is the water reflects light really well, but isn't metallic. These "
"values are not physically accurate, but they are good enough for this demo."
msgstr ""
"然後，在材質中，在“Metallic”（金屬性）部分，請確保 ``Metallic`` 為 ``0``、"
"``Specular`` 為 ``1``。這樣做的原因是水對光線的反射非常好，但它不是金屬的。這"
"些值在物理上並不準確，但對於這個演示來說已經足夠好了。"

msgid ""
"Next, under the \"Roughness\" section, set ``Roughness`` to ``1`` and set "
"the roughness texture to a :ref:`Viewport Texture <class_ViewportTexture>` "
"pointing to our planet texture :ref:`Viewport <class_Viewport>`. Finally, "
"set the ``Texture Channel`` to ``Alpha``. This instructs the renderer to use "
"the ``alpha`` channel of our output ``COLOR`` as the ``Roughness`` value."
msgstr ""
"接下來, 在 \"Roughness\" 部分, 將 ``Roughness`` 設定為 ``1`` , 並將粗糙度紋理"
"設定為 :ref:`Viewport Texture <class_ViewportTexture>` , 指向我們的行星紋理 :"
"ref:`Viewport <class_Viewport>` . 最後, 將 ``Texture Channel`` 設定為 "
"``Alpha`` . 這將指示算繪器使用我們輸出的 ``COLOR`` 的 ``alpha`` 通道作為 "
"``Roughness`` 值."

msgid ""
"You'll notice that very little changes except that the planet is no longer "
"reflecting the sky. This is happening because, by default, when something is "
"rendered with an alpha value, it gets drawn as a transparent object over the "
"background. And since the default background of the :ref:`Viewport "
"<class_Viewport>` is opaque, the ``alpha`` channel of the :ref:`Viewport "
"Texture <class_ViewportTexture>` is ``1``, resulting in the planet texture "
"being drawn with slightly fainter colors and a ``Roughness`` value of ``1`` "
"everywhere. To correct this, we go into the :ref:`Viewport <class_Viewport>` "
"and enable the \"Transparent Bg\" property. Since we are now rendering one "
"transparent object on top of another, we want to enable "
"``blend_premul_alpha``:"
msgstr ""
"你會注意到, 除了行星不再反射天空外, 幾乎沒有什麼變化. 這是因為預設情況下, 當"
"某樣東西以Alpha值算繪時, 它會被繪製為背景上的透明物體. 因為 :ref:`Viewport "
"<class_Viewport>` 的預設背景是不透明的, 所以 :ref:`Viewport Texture "
"<class_ViewportTexture>` 的 ``alpha`` 通道是 ``1`` , 導致行星紋理的顏色略微變"
"淡, 並且到處的 ``Roughness`` 值都是 ``1`` . 為了糾正這個問題, 我們轉到 :ref:"
"`Viewport <class_Viewport>` 並啟用 \"Transparent Bg\" 屬性. 由於現在是在另一"
"個透明物體上算繪, 要啟用 ``blend_premul_alpha`` :"

msgid ""
"This pre-multiplies the colors by the ``alpha`` value and then blends them "
"correctly together. Typically, when blending one transparent color on top of "
"another, even if the background has an ``alpha`` of ``0`` (as it does in "
"this case), you end up with weird color bleed issues. Setting "
"``blend_premul_alpha`` fixes that."
msgstr ""
"這是將顏色預先乘以 ``alpha`` 值, 然後將它們正確地混合在一起. 通常情況下, 當在"
"一個透明的顏色上混合另一個顏色時, 即使背景的 ``alpha`` 為 ``0`` (如本例), 也"
"會出現奇怪的顏色滲漏問題. 設定 ``blend_premul_alpha`` 可以解決這個問題."

msgid ""
"Now the planet should look like it is reflecting light on the ocean but not "
"the land. If you haven't done so already, add an :ref:`OmniLight3D "
"<class_OmniLight3D>` to the scene so you can move it around and see the "
"effect of the reflections on the ocean."
msgstr ""
"現在這個星球看起來海洋上能夠反射光線, 而不是在陸地上. 如果你還沒有這樣做, 在"
"場景中新增一個 :ref:`OmniLight <class_OmniLight>` , 這樣你就可以移動它, 看到"
"海洋上反射的效果."

msgid ""
"And there you have it. A procedural planet generated using a :ref:`Viewport "
"<class_Viewport>`."
msgstr ""
"這就是你的作品。使用 :ref:`Viewport <class_Viewport>` 生成的程式式行星。"

msgid "Translation status"
msgstr "翻譯狀態"
