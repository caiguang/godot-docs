# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Introduction to shaders"
msgstr "匯出簡介"

msgid ""
"This page explains what shaders are and will give you an overview of how "
"they work in Godot. For a detailed reference of the engine's shading "
"language, see :ref:`doc_shading_language`."
msgstr ""
"本頁面會講解什麼是著色器，會為你綜述其在 Godot 中的使用方法。引擎中著色語言的"
"詳細參考見 :ref:`doc_shading_language`。"

msgid ""
"Shaders are a special kind of program that runs on Graphics Processing Units "
"(GPUs). They were initially used to shade 3D scenes but can nowadays do much "
"more. You can use them to control how the engine draws geometry and pixels "
"on the screen, allowing you to achieve all sorts of effects."
msgstr ""
"著色器（Shader）是一種在圖形處理單元（GPU）上運作的特殊程式。他們最初使用來"
"為 3D 場景著色的，不過現在能做的事情就更多了。你可以用它們來控制引擎在螢幕上"
"繪製幾何體以及像素的方式，可以用來實作各種特效。"

msgid ""
"Modern rendering engines like Godot draw everything with shaders: graphics "
"cards can run thousands of instructions in parallel, leading to incredible "
"rendering speed."
msgstr ""
"類似 Godot 的現代算繪引擎都會用著色器來執行所有繪製操作：圖形卡可以並存執行成"
"千上萬條指令，可以達到驚人的算繪速度。"

msgid ""
"Because of their parallel nature, though, shaders don't process information "
"the way a typical program does. Shader code runs on each vertex or pixel in "
"isolation. You cannot store data between frames either. As a result, when "
"working with shaders, you need to code and think differently from other "
"programming languages."
msgstr ""
"因為天生就是並行的，所以著色器處理資訊的方式與普通的程式有所不同。著色器程式"
"碼是單獨針對頂點或像素執行的。你也無法在影格與影格之間儲存資料。因此，使用著"
"色器時，你需要使用與其他程式設計語言不同的編碼和思考方式。"

msgid ""
"Suppose you want to update all the pixels in a texture to a given color. In "
"GDScript, your code would use ``for`` loops::"
msgstr ""
"假設你想要把紋理中的所有像素點都設定成某個給定的顏色。使用 GDScript，你的程式"
"碼會用 ``for`` 迴圈： ::"

msgid ""
"Your code is already part of a loop in a shader, so the corresponding code "
"would look like this."
msgstr ""
"在著色器中，你的程式碼已經是迴圈的一部分了，所以對應的程式碼應該類似這樣。"

msgid ""
"The graphics card calls the ``fragment()`` function once or more for each "
"pixel it has to draw. More on that below."
msgstr ""
"圖形卡會為需要繪製的每一個像素呼叫若干次 ``fragment()`` 函式。後面會詳細說"
"明。"

msgid "Shaders in Godot"
msgstr "設定 Godot"

msgid ""
"Godot provides a shading language based on the popular OpenGL Shading "
"Language (GLSL) but simplified. The engine handles some of the lower-level "
"initialization work for you, making it easier to write complex shaders."
msgstr ""
"Godot 所提供的著色語言是基於流行的 OpenGL 著色語言（GLSL）的簡化。引擎會為你"
"處理一些底層的初始化工作，讓編寫複雜著色器更為簡單。"

msgid ""
"In Godot, shaders are made up of main functions called \"processor "
"functions\". Processor functions are the entry point for your shader into "
"the program. There are seven different processor functions."
msgstr ""
"在 Godot 中，著色器由若干主函式組成，這些函式被稱為“處理器函式”。處理器函式是"
"著色器程式的入口。有七種不同的處理器函式。"

msgid ""
"The ``vertex()`` function runs over all the vertices in the mesh and sets "
"their positions and some other per-vertex variables. Used in :ref:"
"`canvas_item shaders <doc_canvas_item_shader>` and :ref:`spatial shaders "
"<doc_spatial_shader>`."
msgstr ""
"``vertex()`` 函式會為網格中的所有頂點各運作一次，用來設定頂點的位置和其他與頂"
"點相關的變數。在 :ref:`canvas_item 著色器 <doc_canvas_item_shader>`和:ref:`空"
"間著色器 <doc_spatial_shader>`中使用。"

msgid ""
"The ``fragment()`` function runs for every pixel covered by the mesh. It "
"uses values output by the ``vertex()`` function, interpolated between the "
"vertices. Used in :ref:`canvas_item shaders <doc_canvas_item_shader>` and :"
"ref:`spatial shaders <doc_spatial_shader>`."
msgstr ""
"``fragment()`` 函式會為網格所覆蓋的所有像素各運作一次。這個函式會用到 "
"``vertex()`` 函式輸出的值，這些值會在頂點之間進行插值。在 :ref:`canvas_item "
"著色器 <doc_canvas_item_shader>`和:ref:`空間著色器 <doc_spatial_shader>`中使"
"用。"

msgid ""
"The ``light()`` function runs for every pixel and for every light. It takes "
"variables from the ``fragment()`` function and from its previous runs. Used "
"in :ref:`canvas_item shaders <doc_canvas_item_shader>` and :ref:`spatial "
"shaders <doc_spatial_shader>`."
msgstr ""
"``light()`` 函式會為每個像素和每個燈光各運作一次。這個函式會用到 "
"``fragment()`` 函式以及前幾次運作中的變數。在 :ref:`canvas_item 著色器 "
"<doc_canvas_item_shader>`和:ref:`空間著色器 <doc_spatial_shader>`中使用。"

msgid ""
"The ``start()`` function runs for every particle in a particle system once "
"when the particle is first spawned. Used in :ref:`particles shaders "
"<doc_particle_shader>`."
msgstr ""
"``start()`` 函式會在粒子系統中的每個粒子出生時各運作一次。在:ref:`粒子著色器 "
"<doc_particle_shader>`中使用。"

msgid ""
"The ``process()`` function runs for every particle in a particle system for "
"each frame. Used in :ref:`particles shaders <doc_particle_shader>`."
msgstr ""
"``start()`` 函式會為粒子系統中的每個粒子每影格時各運作一次。在:ref:`粒子著色"
"器 <doc_particle_shader>`中使用。"

msgid ""
"The ``sky()`` function runs for every pixel in the radiance cubemap when the "
"radiance cubemap needs to be updated, and for every pixel on the current "
"screen. Used in :ref:`sky shaders <doc_sky_shader>`."
msgstr ""
"``sky()`` 函式會在輻射度立方體貼圖需要更新時為輻射度立方體貼圖中的每個像素各"
"運作一次，也會為目前螢幕上的每個像素運作一次。在:ref:`天空著色器 "
"<doc_sky_shader>`中使用。"

msgid ""
"The ``fog()`` function runs for every froxel in the volumetric fog froxel "
"buffer that intersects with the :ref:`FogVolume <class_FogVolume>`. Used by :"
"ref:`fog shaders <doc_fog_shader>`."
msgstr ""
"``fog()`` 函式會為體積霧片段體素緩衝中與 :ref:`FogVolume <class_FogVolume>` "
"相交的每個片段體素運作一次。在:ref:`霧著色器 <doc_fog_shader>`中使用。"

msgid ""
"The ``light()`` function won't run if the ``vertex_lighting`` render mode is "
"enabled, or if **Rendering > Quality > Shading > Force Vertex Shading** is "
"enabled in the Project Settings. It's enabled by default on mobile platforms."
msgstr ""
"如果啟用了 ``vertex_lighting`` 算繪模式，或者在專案設定中啟用了 **Rendering "
"> Quality > Shading > Force Vertex Shading**（算繪 > 品質 > 著色 > 強制頂點著"
"色），則不會運作 ``light()`` 函式。在移動平臺上預設啟用。"

msgid ""
"Godot also exposes an API for users to write totally custom GLSL shaders. "
"For more information see :ref:`doc_compute_shaders`."
msgstr ""
"Godot 還為使用者編寫完全自訂的 GLSL 著色器暴露了 API。詳見 :ref:"
"`doc_compute_shaders`。"

msgid "Shader types"
msgstr "著色器型別"

msgid ""
"Instead of supplying a general-purpose configuration for all uses (2D, 3D, "
"particles, sky, fog), you must specify the type of shader you're writing. "
"Different types support different render modes, built-in variables, and "
"processing functions."
msgstr ""
"你所編寫的著色器必須指定型別（2D、3D、粒子、天空、霧），不存在所有場景都可以"
"使用的通用配置。不同的型別支援不同的算繪模式、內建變數、處理函式。"

msgid ""
"In Godot, all shaders need to specify their type in the first line, like so:"
msgstr "在 Godot 中，所有的著色器都需要在第一行指定它們的型別，類似這樣："

msgid "Here are the available types:"
msgstr "有六種搜尋模式："

msgid ":ref:`spatial <doc_spatial_shader>` for 3D rendering."
msgstr ":ref:`doc_spatial_shader`"

msgid ":ref:`canvas_item <doc_canvas_item_shader>` for 2D rendering."
msgstr ":ref:`doc_canvas_item_shader`"

msgid ":ref:`particles <doc_particle_shader>` for particle systems."
msgstr ":ref:`doc_particle_shader`"

msgid ":ref:`sky <doc_sky_shader>` to render :ref:`Skies <class_Sky>`."
msgstr "用於算繪 :ref:`Skies <class_Sky>` 的 :ref:`sky <doc_sky_shader>`。"

msgid ""
":ref:`fog <doc_fog_shader>` to render :ref:`FogVolumes <class_FogVolume>`"
msgstr ""
"用於算繪 :ref:`FogVolumes <class_FogVolume>` 的 :ref:`fog <doc_fog_shader>`"

msgid "Render modes"
msgstr "算繪模式"

msgid ""
"Shaders have optional render modes you can specify on the second line, after "
"the shader type, like so:"
msgstr "可以在著色器的第二行，也就是在著色器型別之後，指定算繪模式，類似這樣："

msgid ""
"Render modes alter the way Godot applies the shader. For example, the "
"``unshaded`` mode makes the engine skip the built-in light processor "
"function."
msgstr ""
"算繪模式會修改 Godot 應用著色器的方式。例如，``unshaded`` 模式會讓引擎跳過內"
"建的光線處理器函式。"

msgid ""
"Each shader type has different render modes. See the reference for each "
"shader type for a complete list of render modes."
msgstr ""
"每種著色器型別都有不同的算繪模式。每種著色器型別的完整算繪模式列表請參閱參考"
"手冊。"

msgid "Vertex processor"
msgstr "頂點處理器"

msgid ""
"The ``vertex()`` processing function is called once for every vertex in "
"``spatial`` and ``canvas_item`` shaders. For ``particles`` shaders, it is "
"called once for every particle."
msgstr ""
"在 ``spatial`` 和 ``canvas_item`` 著色器中，會為每一個頂點呼叫 ``vertex()`` "
"處理函式。在 ``particles`` 著色器中則會為每一個粒子呼叫一次。"

msgid ""
"Each vertex in your world's geometry has properties like a position and "
"color. The function modifies those values and passes them to the fragment "
"function. You can also use it to send extra data to the fragment function "
"using varyings."
msgstr ""
"你的世界中的幾何體上，每一個頂點都有位置、顏色等屬性。該函式會修改這些值，並"
"將其傳入片段函式。你也可以借助 varying 向片段著色器傳遞額外的資料。"

msgid ""
"By default, Godot transforms your vertex information for you, which is "
"necessary to project geometry onto the screen. You can use render modes to "
"transform the data yourself; see the :ref:`Spatial shader doc "
"<doc_spatial_shader>` for an example."
msgstr ""
"預設情況下，Godot 會為你對頂點資訊進行變換，這是將幾何體投影到螢幕上所必須"
"的。你可以使用算繪模式來自行變換資料；範例見 :ref:`Spatial 著色器文件 "
"<doc_spatial_shader>`。"

msgid "Fragment processor"
msgstr "片段處理器"

msgid ""
"The ``fragment()`` processing function is used to set up the Godot material "
"parameters per pixel. This code runs on every visible pixel the object or "
"primitive draws. It is only available in ``spatial``, ``canvas_item``, and "
"``sky`` shaders."
msgstr ""
"``fragment()`` 處理函式的作用是設定每一個像素的 Godot 材質參數。這裡的程式碼"
"會在繪製的物件或像素的每一個可見像素上執行。只能在 ``spatial``、"
"``canvas_item``、``sky`` 著色器中使用。"

msgid ""
"The standard use of the fragment function is to set up material properties "
"used to calculate lighting. For example, you would set values for "
"``ROUGHNESS``, ``RIM``, or ``TRANSMISSION``, which would tell the light "
"function how the lights respond to that fragment. This makes it possible to "
"control a complex shading pipeline without the user having to write much "
"code. If you don't need this built-in functionality, you can ignore it and "
"write your own light processing function, and Godot will optimize it away. "
"For example, if you do not write a value to ``RIM``, Godot will not "
"calculate rim lighting. During compilation, Godot checks to see if ``RIM`` "
"is used; if not, it cuts all the corresponding code out. Therefore, you will "
"not waste calculations on the effects that you do not use."
msgstr ""
"片段函式的標準用途是設定用於計算光照的材質屬性。例如，你可以為 "
"``ROUGHNESS``、``RIM``、``TRNASMISSION`` 等設定值，告訴光照函式光照應該如何處"
"理對應的片段。這樣就可以控制複雜的著色管線，而不必讓使用者編寫過多的程式碼。"
"如果你不需要這一內建功能，那麼你可以忽略它，自行編寫光照處理函式，Godot 會將"
"其優化掉。例如，如果你沒有向 ``RIM`` 寫入任何值，那麼 Godot 就不會計算邊緣光"
"照。編譯時，Godot 會檢查是否使用了 ``RIM``；如果沒有，那麼它就會把對應的程式"
"碼刪除。因此，你就不會在沒有使用的效果上浪費算力。"

msgid "Light processor"
msgstr "光照處理器"

msgid ""
"The ``light()`` processor runs per pixel too, and it runs once for every "
"light that affects the object. It does not run if no lights affect the "
"object. It exists as a function called inside the ``fragment()`` processor "
"and typically operates on the material properties setup inside the "
"``fragment()`` function."
msgstr ""
"``light()`` 處理器也會在每一個像素上運作，並且同時還會在每一個影響該物件的燈"
"光上運作。如果沒有燈光影響該物件則不會運作。它會被用於 ``fragment()`` 處理"
"器，一般會在 ``fragment()`` 函式中進行材質屬性設定時執行。"

msgid ""
"The ``light()`` processor works differently in 2D than it does in 3D; for a "
"description of how it works in each, see their documentation, :ref:"
"`CanvasItem shaders <doc_canvas_item_shader>` and :ref:`Spatial shaders "
"<doc_spatial_shader>`, respectively."
msgstr ""
"``light()`` 處理器在 2D 和 3D 中的工作方式不同；每種工作方式的詳細描述請參閱"
"它們對應的文件 :ref:`CanvasItem 著色器 <doc_canvas_item_shader>` and :ref:"
"`Spatial 著色器 <doc_spatial_shader>`。"

msgid "Translation status"
msgstr "翻譯狀態"
