# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Saving games"
msgstr "保存遊戲"

msgid "Introduction"
msgstr "前言"

msgid ""
"Save games can be complicated. For example, it may be desirable to store "
"information from multiple objects across multiple levels. Advanced save game "
"systems should allow for additional information about an arbitrary number of "
"objects. This will allow the save function to scale as the game grows more "
"complex."
msgstr ""
"保存遊戲可能很複雜. 比如, 我們可能會想要儲存跨多個關卡的多個物品的資訊. 更高"
"級的保存遊戲可能需要儲存關於具有任意數量的物件的附加資訊. 當遊戲變得更加複雜"
"時, 這將讓保存函式可以隨著遊戲一同變得更加複雜."

msgid ""
"If you're looking to save user configuration, you can use the :ref:"
"`class_ConfigFile` class for this purpose."
msgstr ""
"如果你想保存玩家的設定，可以用 :ref:`class_ConfigFile` 來實作這個目的。"

msgid ""
"You can see how saving and loading works in action using the `Saving and "
"Loading (Serialization) demo project <https://github.com/godotengine/godot-"
"demo-projects/blob/master/loading/serialization>`__."
msgstr ""
"除了這份說明文件，你可能也會想看看 `Godot Demo 專案 <https://github.com/"
"godotengine/godot-demo-projects>`_ 。"

msgid "Identify persistent objects"
msgstr "識別持久化物件"

msgid ""
"Firstly, we should identify what objects we want to keep between game "
"sessions and what information we want to keep from those objects. For this "
"tutorial, we will use groups to mark and handle objects to be saved, but "
"other methods are certainly possible."
msgstr ""
"首先，我們應該確定在遊戲會話中要保存那些物件，以及我們要保存這些物件中的哪些"
"資訊。本教學中，我們將使用“群組”來標記和處理要保存的物件，但當然也有其他可行"
"的方法。"

msgid ""
"We will start by adding objects we wish to save to the \"Persist\" group. We "
"can do this through either the GUI or script. Let's add the relevant nodes "
"using the GUI:"
msgstr ""
"首先我們將想要保存的物件新增到“Persist”組。我們既可以通過 GUI 也可以通過腳本"
"完成此操作。讓我們使用 GUI 來新增相關節點吧："

msgid ""
"Once this is done, when we need to save the game, we can get all objects to "
"save them and then tell them all to save with this script:"
msgstr ""
"完成這個操作後，我們需要保存遊戲時，就可以獲取所有需要保存的物件，然後通過這"
"個腳本讓這些物件去保存資料："

msgid "Serializing"
msgstr "序列化"

msgid ""
"The next step is to serialize the data. This makes it much easier to read "
"from and store to disk. In this case, we're assuming each member of group "
"Persist is an instanced node and thus has a path. GDScript has helper class :"
"ref:`JSON<class_json>` to convert between dictionary and string, Our node "
"needs to contain a save function that returns this data. The save function "
"will look like this:"
msgstr ""
"下一步是序列化資料。這使得從硬碟讀取資料和儲存資料到硬碟變得更加容易。在這種"
"情況下, 我們假設 Persist 組的每個成員都是一個產生實體的節點，因此它們都有一個"
"路徑。GDScript 有相關的輔助函式，如 :ref:`to_json() "
"<class_@GDScript_method_to_json>` 和 :ref:`parse_json() "
"<class_@GDScript_method_parse_json>`，所以我們使用 Dictionary 來表示資料。我"
"們的節點需要包含一個返回 Dictionary 的保存函式。保存函式看上去大概會像這樣："

msgid ""
"This gives us a dictionary with the style ``{ \"variable_name\":"
"value_of_variable }``, which will be useful when loading."
msgstr ""
"我們得到一個樣式為 ``{ \"variable_name\":that_variables_value }`` 的字典, 它"
"在載入遊戲資料時會被用到."

msgid "Saving and reading data"
msgstr "保存和讀取資料"

msgid ""
"As covered in the :ref:`doc_filesystem` tutorial, we'll need to open a file "
"so we can write to it or read from it. Now that we have a way to call our "
"groups and get their relevant data, let's use the class :ref:"
"`JSON<class_json>` to convert it into an easily stored string and store them "
"in a file. Doing it this way ensures that each line is its own object, so we "
"have an easy way to pull the data out of the file as well."
msgstr ""
"正如在 :ref:`doc_filesystem` 教學中所述, 我們需要打開一個檔來向其中寫入或讀取"
"資料. 既然我們有辦法呼叫我們的組並獲取它們的相關資料, 那麼就讓我們使用 :ref:"
"`to_json() <class_@GDScript_method_to_json>` 將資料轉換成一個容易儲存的字串並"
"將它儲存在檔中吧. 這樣做可以確保每一行都是一個完整的物件的資訊, 這樣的話將資"
"料從檔中提取出來也會更加容易."

msgid ""
"Game saved! Now, to load, we'll read each line. Use the :ref:"
"`parse<class_JSON_method_parse>` method to read the JSON string back to a "
"dictionary, and then iterate over the dict to read our values. But we'll "
"need to first create the object and we can use the filename and parent "
"values to achieve that. Here is our load function:"
msgstr ""
"遊戲保存好了！ 載入也很簡單. 為此, 我們將讀取每一行, 使用parse_json() 將其讀"
"回到一個字典中, 然後走訪字典以讀取保存的值. 首先我們需要建立物件, 這可以通過"
"使用檔案名和父值來實作. 這就是我們的載入函式:"

msgid ""
"Now we can save and load an arbitrary number of objects laid out almost "
"anywhere across the scene tree! Each object can store different data "
"depending on what it needs to save."
msgstr ""
"現在我們可以保存和載入幾乎任何位於場景樹中的任意數量的物件了！ 每個物件可以根"
"據需要保存的內容儲存不同的資料."

msgid "Some notes"
msgstr "一些注釋"

msgid ""
"We have glossed over setting up the game state for loading. It's ultimately "
"up to the project creator where much of this logic goes. This is often "
"complicated and will need to be heavily customized based on the needs of the "
"individual project."
msgstr ""
"我們可能忽略了 \"將遊戲狀態設定到適合以載入資料\" 這一步. 最終, 這一步怎麼做"
"的決定權在專案建立者手裡. 這通常很複雜, 需要根據單個專案的需求對此步驟進行大"
"量定制."

msgid ""
"Additionally, our implementation assumes no Persist objects are children of "
"other Persist objects. Otherwise, invalid paths would be created. To "
"accommodate nested Persist objects, consider saving objects in stages. Load "
"parent objects first so they are available for the :ref:`add_child() "
"<class_node_method_add_child>` call when child objects are loaded. You will "
"also need a way to link children to parents as the :ref:`NodePath "
"<class_nodepath>` will likely be invalid."
msgstr ""
"另外, 此實作假定沒有Persist物件是其他Persist物件的子物件. 否則會產生無效路"
"徑. 如果這是專案的需求之一, 可以考慮分階段保存物件(父物件優先), 以便在載入子"
"物件時可用它們將確保它們可用於 :ref:`add_child() "
"<class_node_method_add_child>` 呼叫. 由於 :ref:`NodePath <class_nodepath>` 可"
"能無效, 因此可能還需要某種方式將子項鍊接到父項."

msgid "JSON vs binary serialization"
msgstr "二進位序列化 API"

msgid ""
"For simple game state, JSON may work and it generates human-readable files "
"that are easy to debug."
msgstr ""
"對於簡單的遊戲狀態，JSON 可能會起作用，並且它會產生易於除錯的人類可讀檔案。"

msgid ""
"But JSON has many limitations. If you need to store more complex game state "
"or a lot of it, :ref:`binary serialization<doc_binary_serialization_api>` "
"may be a better approach."
msgstr ""
"但 JSON 有很多限制。如果您需要儲存更複雜的遊戲狀態或大量遊戲狀態，二進位序列"
"化<doc_binary_serialization_api>`可能是更好的方法。"

msgid "JSON limitations"
msgstr "限制"

msgid "Here are some important gotchas to know about when using JSON."
msgstr "以下是使用 JSON 時需要了解的一些重要問題。"

msgid ""
"**Filesize:** JSON stores data in text format, which is much larger than "
"binary formats."
msgstr "**檔案大小：** JSON 以文字格式儲存資料，比二進位格式大得多。"

msgid ""
"**Data types:** JSON only offers a limited set of data types. If you have "
"data types that JSON doesn't have, you will need to translate your data to "
"and from types that JSON can handle. For example, some important types that "
"JSON can't parse are: ``Vector2``, ``Vector3``, ``Color``, ``Rect2``, and "
"``Quaternion``."
msgstr ""
"**資料型別：** JSON 僅提供一組有限的資料型別。如果您擁有 JSON 沒有的資料型"
"別，則需要在資料與 JSON 可以處理的型別之間進行轉換。例如，JSON 無法解析的一些"
"重要型別是：``Vector2``、``Vector3``、``Color``、``Rect2`` 和``Quaternion``。"

msgid ""
"**Custom logic needed for encoding/decoding:** If you have any custom "
"classes that you want to store with JSON, you will need to write your own "
"logic for encoding and decoding those classes."
msgstr ""
"**編碼/解碼所需的自訂邏輯：** 如果您有任何想要使用 JSON 儲存的自訂類，您將需"
"要編寫自己的邏輯來編碼和解碼這些類別。"

msgid "Binary serialization"
msgstr "在地化"

msgid ""
":ref:`Binary serialization<doc_binary_serialization_api>` is an alternative "
"approach for storing game state, and you can use it with the functions "
"``get_var`` and ``store_var`` of :ref:`class_FileAccess`."
msgstr ""
":ref:`二進位序列化<doc_binary_serialization_api>` 是另一種儲存遊戲狀態的方"
"法，您可以將它與 class_FileAccess` 的函式 ``get_var`` 和 ``store_var`` 一起使"
"用。"

msgid "Binary serialization should produce smaller files than JSON."
msgstr "二進位序列化應該會產生比 JSON 更小的檔案。"

msgid "Binary serialization can handle most common data types."
msgstr "二進位序列化可以處理最常見的資料型別。"

msgid ""
"Binary serialization requires less custom logic for encoding and decoding "
"custom classes."
msgstr "二進制序列化需要較少的自訂邏輯來編碼和解碼自訂類別。"

#, fuzzy
msgid ""
"Note that not all properties are included. Only properties that are "
"configured with the :ref:"
"`PROPERTY_USAGE_STORAGE<class_@GlobalScope_constant_PROPERTY_USAGE_STORAGE>` "
"flag set will be serialized. You can add a new usage flag to a property by "
"overriding the :ref:"
"`_get_property_list<class_Object_private_method__get_property_list>` method "
"in your class. You can also check how property usage is configured by "
"calling ``Object._get_property_list``. See :ref:"
"`PropertyUsageFlags<enum_@GlobalScope_PropertyUsageFlags>` for the possible "
"usage flags."
msgstr ""
"請注意，並非所有屬性都包含在內。只有使用 "
"PROPERTY_USAGE_STORAGE<class_@GlobalScope_constant_PROPERTY_USAGE_STORAGE>` "
"旗標集配置的屬性才會被序列化。您可以透過重寫類別中的 "
"_get_property_list<class_Object_method__get_property_list>` 方法來為屬性新增"
"新的使用旗標。您也可以透過呼叫“Object._get_property_list”來檢查屬性使用的配置"
"方式。請參閱:ref:`PropertyUsageFlags<enum_@GlobalScope_PropertyUsageFlags>` "
"以了解可能的使用旗標。"

msgid "Translation status"
msgstr "翻譯狀態"
