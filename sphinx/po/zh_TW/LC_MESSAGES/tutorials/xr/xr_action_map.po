# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "The XR action map"
msgstr "XR 動作對應"

msgid ""
"Godot has an action map feature as part of the XR system. At this point in "
"time this system is part of the OpenXR module. There are plans to encompass "
"WebXR into this in the near future hence we call it the XR action map system "
"in this document. It implements the built-in action map system of OpenXR "
"mostly exactly as it is offered."
msgstr ""
"Godot 具有動作地圖功能，作為 XR 系統的一部分。此時該系統是 OpenXR 模組的一部"
"分。有計劃在不久的將來將 WebXR 納入其中，因此我們在本文件中將其稱為 XR 動作地"
"圖系統。它實作了 OpenXR 的內建動作地圖系統，基本上與它所提供的一樣。"

msgid ""
"The XR action map system exposes input, positional data and output for XR "
"controllers to your game/application. It does this by exposing named actions "
"that can be tailored to your game/application and binding these to the "
"actual inputs and outputs on your XR devices."
msgstr ""
"XR 動作地圖系統會向您的遊戲/應用程式公開 XR 控制器的輸入、位置資料和輸出。它"
"透過公開可根據您的遊戲/應用程式自訂的命名操作並將這些操作綁定到 XR 裝置上的實"
"際輸入和輸出來實作此目的。"

msgid ""
"As the XR action map is currently part of the OpenXR module, OpenXR needs to "
"be enabled in your project settings to expose it:"
msgstr ""
"由於 XR 動作對應目前是 OpenXR 模組的一部分，因此需要在專案設定中啟用 OpenXR "
"才能顯示它："

msgid ""
"You will then find the XR Action Map interface in the bottom of the screen:"
msgstr "然後，你會在螢幕底部看到 XR 行動地圖介面："

msgid ""
"Godot's built-in input system has many things in common with the XR action "
"map system. In fact our original idea was to add functionality to the "
"existing input system and expose the data to the OpenXR action map system. "
"We may revisit that idea at some point but as it turns out there were just "
"too many problems to overcome. To name a few:"
msgstr ""
"Godot 的內建輸入系統與 XR 動作地圖系統有許多共同點。事實上，我們最初的想法是"
"為現有輸入系統新增功能並將資料公開給 OpenXR 動作地圖系統。我們可能會在某個時"
"候重新審視這個想法，但事實證明有太多的問題需要克服。僅舉幾例："

msgid ""
"Godot's input system mainly centers around button inputs, XR adds triggers, "
"axis, poses and haptics (output) into the mix. This would greatly complicate "
"the input system with features that won't work for normal controllers or "
"contrast with the current approach. It was felt this would lead to confusion "
"for the majority of Godot users."
msgstr ""
"Godot 的輸入系統主要以按鈕輸入為中心，XR 增加了觸發器、軸、姿勢和觸覺（輸"
"出）。這將使輸入系統變得非常複雜，其功能不適用於普通控制器或與目前方法相比。"
"人們認為這會導致大多數 Godot 使用者感到困惑。"

msgid ""
"Godot's input system works with raw input data that is parsed and triggers "
"emitting actions. This input data is made available to the end user. OpenXR "
"completely hides raw data and does all the parsing for us, we only get "
"access to already parsed action data. This inconsistency is likely to lead "
"to bugs when an unsuspecting user tries to use an XR device as a normal "
"input device."
msgstr ""
"Godot 的輸入系統使用經過解析並觸發發出操作的原始輸入資料。此輸入資料可供最終"
"使用者使用。 OpenXR 完全隱藏原始資料並為我們完成所有解析，我們只能存取已經解"
"析的動作資料。當毫無戒心的使用者嘗試將 XR 裝置用作一般輸入裝置時，這種不一致"
"可能會導致錯誤。"

msgid ""
"Godot's input system allows changes to what inputs are bound to actions in "
"runtime, OpenXR does not."
msgstr "Godot 的輸入系統允許在運作時更改輸入與操作的綁定，而 OpenXR 則不允許。"

msgid ""
"Godot's input system is based on device ids which are meaningless in OpenXR."
msgstr "Godot 的輸入系統基於裝置 ID，而這在 OpenXR 中毫無意義。"

msgid ""
"This does mean that a game/application that mixes traditional inputs with XR "
"controllers will have a separation. For most applications either one or the "
"other is used and this is not seen as a problem. In the end, it's a "
"limitation of the system."
msgstr ""
"這確實意味著將傳統輸入與 XR 控制器混合在一起的遊戲/應用程式將會分開。對於大多"
"數應用程式，使用其中之一，這不被視為問題。歸根結底，這是系統的限制。"

msgid "The default action map"
msgstr "光照動畫"

msgid ""
"Godot will automatically create a default action map if no action map file "
"is found."
msgstr "如果找不到操作對應檔，Godot 會自動建立預設操作對應。"

msgid ""
"This default map was designed to help developers port their XR games/"
"applications from Godot 3 to Godot 4. As a result this map essentially binds "
"all known inputs on all controllers supported by default, to actions one on "
"one. This is not a good example of setting up an action map. It does allow a "
"new developer to have a starting point when they want to become familiar "
"with Godot XR. It prevents having to design a proper action map for their "
"game/application first."
msgstr ""
"該預設地圖旨在幫助開發人員將其XR 遊戲/應用程式從Godot 3 移植到Godot 4。因此，"
"該地圖本質上將預設支援的所有控制器上的所有已知輸入綁定到一對一的操作。這不是"
"設定行動圖的好例子。它確實讓新開發者在想要熟悉 Godot XR 時有一個起點。它避免"
"了必須先為他們的遊戲/應用程式設計合適的動作地圖。"

msgid ""
"For this walkthrough we're going to start with a blank action map. You can "
"simply delete the \"Godot action set\" entry at the top by pressing the "
"trash can icon. This will clear out all actions. You might also want to "
"remove the controllers that you do not wish to setup, more on this later."
msgstr ""
"對於本演練，我們將從一張空白的操作地圖開始。您只需按下垃圾桶圖示即可刪除頂部"
"的「Godot 操作集」條目。這將清除所有操作。您可能還想刪除不想設定的控制器，稍"
"後將詳細介紹。"

msgid "Action sets"
msgstr "操作名稱"

msgid ""
"Before we dive in, you will see the term XR runtime used throughout this "
"document. With XR runtime we mean the software that is controlling and "
"interacting with the AR or VR headset. The XR runtime then exposes this to "
"us through an API such as OpenXR. So:"
msgstr ""
"在我們深入討論之前，您將看到本文件中使用的術語「XR 運作時」。對於 XR 運作時，"
"我們指的是控制 AR 或 VR 耳機並與之互動的軟體。然後，XR 運作時透過 OpenXR 等 "
"API 向我們公開這一點。所以："

msgid "for Steam this is SteamVR,"
msgstr "對於 Steam，這是 SteamVR，"

msgid ""
"for Meta on desktop this is the Oculus Client (including when using Quest "
"link),"
msgstr "對於桌面上的 Meta，這是 Oculus 使用者端（包括使用 Quest 連結時），"

msgid "for Meta on Quest this is the Quest's native OpenXR client,"
msgstr "對於 Quest 上的 Meta，這是 Quest 的原生 OpenXR 使用者端，"

msgid "on Linux this could be Monado, etc."
msgstr "在 Linux 上，這可能是 Monado 等。"

msgid ""
"The action map allows us to organize our actions in sets. Each set can be "
"enabled or disabled on its own."
msgstr "行動圖允許我們將行動組織成群組。每組都可以單獨啟用或停用。"

msgid ""
"The concept here is that you could have different sets that provide bindings "
"in different scenarios. You could have:"
msgstr "這裡的概念是，您可以擁有不同的集合來在不同的場景中提供綁定。你可以有："

msgid "a ``Character control`` set for when you're walking around,"
msgstr "當你四處走動時設定“角色控制”，"

msgid "a ``Vehicle control`` set for when you're operating a vehicle,"
msgstr "當您操作車輛時設定的“車輛控制”，"

msgid "a ``Menu`` set for when a menu is open."
msgstr "當選單開啟時設定“Menu”。"

msgid ""
"Only the action set applicable to the current state of your game/application "
"can then be enabled."
msgstr "然後只能啟用適用於遊戲/應用程式目前狀態的操作集。"

msgid ""
"This is especially important if you wish to bind the same input on a "
"controller to a different action. For instance:"
msgstr "如果您希望將控制器上的相同輸入綁定到不同的操作，這一點尤其重要。例如："

msgid "in your ``Character control`` set you may have an action ``Jump``,"
msgstr "在你的“角色控制”集中，你可能有一個動作“跳躍”，"

msgid "in your ``Vehicle control`` set you may have an action ``Accelerate``,"
msgstr "在你的“車輛控制”集中，你可能有一個動作“加速”，"

msgid "in your ``Menu`` set you may have an action ``Select``."
msgstr "在您的“選單”集中，您可能有一個操作“選擇”。"

msgid "All are bound to the trigger on your controller."
msgstr "所有這些都綁定到控制器上的觸發器。"

msgid ""
"OpenXR will only bind an input or output to a single action. If the same "
"input or output is bound to multiple actions the one in the active action "
"set with the highest priority will be the one updated/used. So in our above "
"example it will thus be important that only one action set is active."
msgstr ""
"OpenXR 只會將輸入或輸出綁定到單一操作。如果相同的輸入或輸出綁定到多個操作，則"
"活動操作集中具有最高優先權的操作將會更新/使用。因此，在我們上面的範例中，只有"
"一個操作集處於活動狀態非常重要。"

msgid ""
"For your first XR game/application we highly recommend starting with just a "
"single action set and to not over-engineer things."
msgstr ""
"對於您的第一個 XR 遊戲/應用程式，我們強烈建議您從單一操作集開始，不要過度設"
"計。"

msgid ""
"For our walkthrough in this document we will thus create a single action set "
"called ``my_first_action_set``. We do this by pressing the ``Add action "
"set`` button:"
msgstr ""
"因此，對於本文件中的演練，我們將建立一個名為「my_first_action_set」的操作集。"
"我們透過按下「新增操作集」按鈕來完成此操作："

msgid "The columns in our table are as follows:"
msgstr "常見的使用情景如下："

msgid "Col"
msgstr "顏色"

msgid "Value"
msgstr "值"

msgid "Description"
msgstr "說明"

msgid "1"
msgstr "1"

msgid "my_first_action_set"
msgstr "限制"

msgid ""
"This is the internal name of the action set. OpenXR doesn't specify specific "
"restrictions on this name other then size, however some XR runtimes will not "
"like spaces or special characters."
msgstr ""
"這是操作集的內部名稱。除了大小之外，OpenXR 沒有對此名稱指定特定限制，但是某"
"些 XR 運作時不喜歡空格或特殊字元。"

msgid "2"
msgstr "2"

msgid "My first action set"
msgstr "我的第一個動作組"

msgid ""
"This is a human-readable name for the action set. Some XR runtimes will "
"display this name to the end user, for example in configuration dialogs."
msgstr ""
"這是操作集的人類可讀名稱。某些 XR 運作時會向最終使用者顯示此名稱，例如在設定"
"對話方塊中。"

msgid "3"
msgstr "3"

msgid "0"
msgstr "0"

msgid ""
"This is the priority of the action set. If multiple active action sets have "
"actions bound to the same controllers inputs or outputs, the action set with "
"the highest priority value will determine the action that is updated."
msgstr ""
"這是操作集的優先權。如果多個活動操作集的操作綁定到相同的控制器輸入或輸出，則"
"具有最高優先權值的操作集將決定更新的操作。"

msgid "Actions"
msgstr "動作"

msgid ""
"In the XR action map, actions are the entities that your game/application "
"will interact with. For instance, we can define an action ``Shoot`` and the "
"input bound to that action will trigger the ``button_pressed`` signal on the "
"relevant :ref:`XRController3D <class_xrcontroller3d>` node in your scene "
"with ``Shoot`` as the ``name`` parameter of the signal."
msgstr ""
"在 XR 動作地圖中，動作是您的遊戲/應用程式將與之互動的實體。例如，我們可以定義"
"一個動作“Shoot”，綁定到該動作的輸入將使用“Shoot”觸發場景中相關 "
"XRController3D <class_xrcontroller3d>` 節點上的“button_pressed”訊號` 作為訊號"
"的 ``name`` 參數。"

msgid ""
"You can also poll the current state of an action. :ref:`XRController3D "
"<class_xrcontroller3d>` for instance has an ``is_button_pressed`` method."
msgstr ""
"您也可以輪詢操作的目前狀態。 :ref:`XRController3D <class_xrcontroller3d>` 例"
"如有一個 ``is_button_pressed`` 方法。"

msgid ""
"Actions can be used for both input and output and each action has a type "
"that defines its behavior."
msgstr "操作可用於輸入和輸出，每個操作都有一個定義其行為的型別。"

msgid "The ``Bool`` type is used for discrete input like buttons."
msgstr "“Bool”型別用於離散輸入，例如按鈕。"

msgid "The ``Float`` type is used for analogue input like triggers."
msgstr "“Float”型別用於觸發器等類比輸入。"

msgid ""
"These two are special as they are the only ones that are interchangeable. "
"OpenXR will handle conversions between ``Bool`` and ``Float`` inputs and "
"actions. You can get the value of a ``Float`` type action by calling the "
"method ``get_float`` on your :ref:`XRController3D <class_xrcontroller3d>` "
"node. It emits the ``input_float_changed`` signal when changed."
msgstr ""
"這兩者很特別，因為它們是唯一可以互換的。 OpenXR 將處理「Bool」和「Float」輸入"
"和操作之間的轉換。您可以透過在 XRController3D <class_xrcontroller3d>` 節點上"
"呼叫方法 ``get_float`` 來取得 ``Float`` 型別操作的值。更改時它會發"
"出“input_float_changed”訊號。"

msgid ""
"Where analogue inputs are queried as buttons a threshold is applied. This "
"threshold is currently managed exclusively by the XR runtime. There are "
"plans to extend Godot to provide some level of control over these thresholds "
"in the future."
msgstr ""
"當類比輸入作為按鈕查詢時，會套用閾值。該閾值目前由 XR 運作時專門管理。我們計"
"劃在未來擴充 Godot，以提供對這些閾值的某種程度的控制。"

msgid ""
"The ``Vector2`` type defines the input as an axis input. Touchpads, "
"thumbsticks and similar inputs are exposed as vectors. You can get the value "
"of a ``Vector2`` type action by calling the method ``get_vector2`` on your :"
"ref:`XRController3D <class_xrcontroller3d>` node. It emits the "
"``input_vector2_changed`` signal when changed."
msgstr ""
"“Vector2”型別將輸入定義為軸輸入。觸控板、拇指操縱桿和類似的輸入都以向量形式公"
"開。您可以透過在 XRController3D <class_xrcontroller3d> 節點上呼叫方法"
"「get_vector2」來取得「Vector2」型別操作的值。更改時它會發"
"出“input_vector2_changed”訊號。"

msgid ""
"The ``Pose`` type defines a spatially tracked input. Multiple \"pose\" "
"inputs are available in OpenXR: ``aim``, ``grip`` and ``palm``. Your :ref:"
"`XRController3D <class_xrcontroller3d>` node is automatically positioned "
"based on the pose action assigned to ``pose`` property of this node. More "
"about poses later."
msgstr ""
"“Pose”型別定義了空間追蹤輸入。 OpenXR 中提供多個「姿勢」輸入：「aim」、"
"「grip」 和「palm」。您的 XRController3D <class_xrcontroller3d> 節點會根據指"
"派給該節點的「pose」屬性的姿勢動作自動定位。稍後詳細介紹姿勢。"

msgid ""
"The OpenXR implementation in Godot also exposes a special pose called "
"``Skeleton``. This is part of the hand tracking implementation. This pose is "
"exposed through the ``skeleton`` action that is supported outside of the "
"action map system. It is thus always present if hand tracking is supported. "
"You don't need to bind actions to this pose to use it."
msgstr ""
"Godot 中的 OpenXR 實作也公開了一種名為「Skeleton」的特殊姿勢。這是手部追蹤實"
"施的一部分。這個姿勢是透過動作地圖系統外部支援的「骨架」動作來暴露的。因此，"
"如果支援手部跟踪，它就會始終存在。您不需要將動作綁定到此姿勢即可使用它。"

msgid ""
"Finally, the only output type is ``Haptic`` and it allows us to set the "
"intensity of haptic feedback, such as controller vibration. Controllers can "
"have multiple haptic outputs and support for haptic vests is coming to "
"OpenXR."
msgstr ""
"最後，唯一的輸出型別是“觸覺”，它允許我們設定觸覺回饋的強度，例如控制器振動。"
"控制器可以有多個觸覺輸出，而 OpenXR 即將支援觸覺背心。"

msgid ""
"So lets add an action for our aim pose, we do this by clicking on the ``+`` "
"button for our action set:"
msgstr ""
"因此，讓我們為我們的目標姿勢新增一個動作，我們透過點擊動作集的「+」按鈕來完成"
"此操作："

msgid "aim_pose"
msgstr "aim_pose"

msgid ""
"This is the internal name of the action. OpenXR doesn't specify specific "
"restrictions on this name other then size, however some XR runtimes will not "
"like spaces or special characters."
msgstr ""
"這是操作的內部名稱。除了大小之外，OpenXR 沒有對此名稱指定特定限制，但是某些 "
"XR 運作時不喜歡空格或特殊字元。"

msgid "Aim pose"
msgstr "瞄準姿勢"

msgid ""
"This is a human-readable name for the action. Some XR runtimes will display "
"this name to the end user, for example in configuration dialogs."
msgstr ""
"這是該操作的人類可讀名稱。某些 XR 運作時會向最終使用者顯示此名稱，例如在設定"
"對話方塊中。"

msgid "Pose"
msgstr "姿勢"

msgid "The type of this action."
msgstr "有名稱的型別"

msgid ""
"OpenXR defines a number of bindable input poses that are commonly available "
"for controllers. There are no rules for which poses are supported for "
"different controllers. The poses OpenXR currently defines are:"
msgstr ""
"OpenXR 定義了許多可綁定的輸入姿勢，這些姿勢通常可用於控制器。對於不同控制器支"
"援哪些姿勢沒有規則。 OpenXR 目前定義的姿勢是："

msgid ""
"The aim pose on most controllers is positioned slightly infront of the "
"controller and aims forward. This is a great pose to use for laser pointers "
"or to align the muzzle of a weapon with."
msgstr ""
"大多數控制器上的目標姿勢稍微位於控制器前方並向前瞄準。這是用於雷射筆或對準武"
"器槍口的絕佳姿勢。"

msgid ""
"The grip pose on most controllers is positioned where the grip button is "
"placed on the controller. The orientation of this pose differs between "
"controllers and can differ for the same controller on different XR runtimes."
msgstr ""
"大多數控制器上的握持姿勢位於控制器上握持按鈕所在的位置。此姿勢的方向因控制器"
"而異，並且對於不同 XR 運作時的相同控制器也可能不同。"

msgid ""
"The palm pose on most controllers is positioned in the center of the palm of "
"the hand holding the controller. This is a new pose that is not available on "
"all XR runtimes."
msgstr ""
"大多數控制器上的手掌姿勢位於握住控制器的手掌的中心。這是一個新姿勢，並非在所"
"有 XR 運作時都可用。"

msgid ""
"If hand tracking is used, there are currently big differences in "
"implementations between the different XR runtimes. As a result the action "
"map is currently not suitable for hand tracking. Work is being done on this "
"so stay tuned."
msgstr ""
"如果使用手部追踪，目前不同 XR 運作時之間的實作存在很大差異。因此，動作地圖目"
"前不適合手部追蹤。這方面的工作正在進行中，敬請關注。"

msgid ""
"Let's complete our list of actions for a very simple shooting game/"
"application:"
msgstr "讓我們完成一個非常簡單的射擊遊戲/應用程式的操作列表："

msgid "The actions we have added are:"
msgstr "我們新增的操作是："

msgid ""
"movement, which allows the user to move around outside of normal room scale "
"tracking."
msgstr "移動，允許使用者在正常房間規模追蹤之外移動。"

msgid "grab, which detects that the user wants to hold something."
msgstr "抓取，它偵測到使用者想要握住某物。"

msgid ""
"shoot, which detects that the user wants to fire the weapon they are holding."
msgstr "射擊，它偵測到使用者想要使用他們持有的武器開火。"

msgid "haptic, which allows us to output haptic feedback."
msgstr "觸覺，它允許我們輸出觸覺回饋。"

msgid ""
"Now note that we don't distinguish between the left and right hand. This is "
"something that is determined at the next stage. We've implemented the action "
"system in such a way that you can bind the same action to both hands. The "
"appropriate :ref:`XRController3D <class_xrcontroller3d>` node will emit the "
"signal."
msgstr ""
"現在請注意，我們不區分左手和右手。這是下一階段確定的事。我們以這樣的方式實作"
"了動作系統，您可以將相同的動作綁定到雙手。對應的 XRController3D "
"<class_xrcontroller3d> 節點將發出訊號。"

msgid ""
"For both grab and shoot we've used the ``Bool`` type. As mentioned before, "
"OpenXR does automatic conversions from an analogue controls however not all "
"XR Runtimes currently apply sensible thresholds."
msgstr ""
"對於抓取和射擊，我們都使用了“Bool”型別。如前所述，OpenXR 會從模擬控制進行自動"
"轉換，但目前並非所有 XR 運作時都會套用合理的閾值。"

msgid ""
"We recommend as a workaround to use the ``Float`` type when interacting with "
"triggers and grip buttons and apply your own threshold."
msgstr "手把按鈕互動時使用「Float」型別作為解決方法，並套用您自己的閾值。"

msgid ""
"For buttons like A/B/X/Y and similar where there is no analogue option, the "
"``Bool`` type works fine."
msgstr "對於 A/B/X/Y 等按鈕以及沒有模擬選項的類似按鈕，「Bool」型別效果很好。"

msgid ""
"You can bind the same action to multiple inputs for the same controller on "
"the same profile. In this case the XR runtime will attempt to combine the "
"inputs."
msgstr ""
"您可以將相同的操作綁定到同一設定檔上同一控制器的多個輸入。在這種情況下，XR 運"
"作時將嘗試組合輸入。"

msgid ""
"For ``Bool`` inputs, this will perform an ``OR`` operation between the "
"buttons."
msgstr "對於“Bool”輸入，這將在按鈕之間執行“OR”操作。"

msgid ""
"For ``Float`` inputs, this will take the highest value of the bound inputs."
msgstr "對於“Float”輸入，這將採用綁定輸入的最高值。"

msgid ""
"The behavior for ``Pose`` inputs is undefined, but the first bound input is "
"likely to be used."
msgstr "“Pose” 輸入的行為未定義，但可能會使用第一個綁定輸入。"

msgid ""
"You shouldn't bind multiple actions of the same action set to the same "
"controller input. If you do this, or if actions are bound from multiple "
"action sets but they have overlapping priorities, the behavior is undefined. "
"The XR runtime may simply not accept your action map, or it may take this on "
"a first come first serve basis."
msgstr ""
"您不應將同一操作集的多個操作綁定到同一控制器輸入。如果您這樣做，或者如果操作"
"是從多個操作集綁定的，但它們具有重疊的優先權，則行為是未定義的。 XR 運作時可"
"能根本不接受您的操作圖，或者它可能會按照先到先得的原則接受此操作圖。"

msgid ""
"We are still investigating the restrictions around binding multiple actions "
"to the same output as this scenario makes sense. The OpenXR specification "
"seems to not allow this."
msgstr ""
"我們仍在研究將多個操作綁定到相同輸出的限制，因為這種情況是有意義的。 OpenXR "
"規格似乎不允許這樣做。"

msgid "Now that we have our basic actions defined, it's time to hook them up."
msgstr "現在我們已經定義了基本操作，是時候將它們連接起來了。"

msgid "Profiles"
msgstr "分析工具"

msgid ""
"In OpenXR controller bindings are captured in so-called \"Interaction "
"Profiles\". We've simply shortened it to \"Profiles\" because it takes up "
"less space."
msgstr ""
"在 OpenXR 中，控制器綁定在所謂的「互動配置」中捕獲。我們只是將其縮短為“配置檔"
"案”，因為它佔用的空間更少。"

msgid ""
"This generic name is chosen because controllers don't cover the entire "
"system. Currently there are also profiles for trackers, remotes and tracked "
"pens. There are also provisions for devices such as treadmills, haptic vests "
"and such even though those are not part of the specification yet."
msgstr ""
"選擇此通用名稱是因為控制器不覆蓋整個系統。目前還有追蹤器、遙控器和追蹤筆的設"
"定檔。還有針對跑步機、觸覺背心等裝置的規定，儘管這些裝置尚未包含在規範中。"

msgid ""
"It is important to know that OpenXR has strict checking on supported "
"devices. The core specification identifies a number of controllers and "
"similar devices with their supported inputs and outputs. Every XR runtime "
"must accept these interaction profiles even if they aren't applicable."
msgstr ""
"重要的是要知道 OpenXR 對支援的裝置有嚴格的檢查。核心規範確定了許多控制器和類"
"似裝置及其支援的輸入和輸出。每個 XR 運作時都必須接受這些互動配置檔案，即使它"
"們不適用。"

msgid ""
"New devices are added through extensions and XR runtimes must specify which "
"ones they support. XR runtimes that do not support a device added through "
"extensions will not accept these profiles. XR runtimes that do not support "
"added input or output types will often crash if supplied."
msgstr ""
"新裝置是透過擴充功能新增的，XR 運作時必須指定它們支援哪些裝置。不支援透過擴充"
"功能新增的裝置的 XR 運作時將不接受這些設定檔。如果提供不支援新增的輸入或輸出"
"型別的 XR 運作時通常會當機。"

msgid ""
"As such Godot keeps meta data of all available devices, their inputs and "
"outputs and which extension adds support for them. You can create "
"interaction profiles for all devices you wish to support. Godot will filter "
"out those not supported by the XR runtime the user is using."
msgstr ""
"因此，Godot 保留所有可用裝置的元資料、它們的輸入和輸出以及哪個擴充新增了對它"
"們的支援。您可以為您希望支援的所有裝置建立互動設定檔。 Godot 將篩選掉使用者正"
"在使用的 XR 執行時間不支援的內容。"

msgid ""
"This does mean that in order to support new devices, you might need to "
"update to a more recent version of Godot."
msgstr "這確實意味著為了支援新裝置，您可能需要更新到更新版本的 Godot。"

msgid ""
"It is however also important to note that the action map has been designed "
"with this in mind. When new devices enter the market, or when your users use "
"devices that you do not have access to, the action map system relies on the "
"XR runtime. It is the XR runtime's job to choose the best fitting "
"interaction profile that has been specified and adapt it for the controller "
"the user is using."
msgstr ""
"然而，同樣重要的是要注意，行動地圖的設計就考慮到了這一點。當新裝置進入市場"
"時，或當您的使用者使用您無權存取的裝置時，動作地圖系統將依賴 XR 運作時。 XR "
"運作時的工作是選擇已指定的最合適的互動設定檔並使其適應使用者正在使用的控制"
"器。"

msgid ""
"How the XR runtime does this is left to the implementation of the runtime "
"and there are thus vast differences between the runtimes. Some runtimes "
"might even permit users to edit the bindings themselves."
msgstr ""
"XR 運作時如何做到這一點取決於運作時的實作，因此運作時之間存在巨大差異。某些運"
"作時甚至可能允許使用者自行編輯綁定。"

msgid ""
"A common approach for a runtime is to look for a matching interaction "
"profile first. If this is not found it will check the most common profiles "
"such as that of the \"Touch controller\" and do a conversion. If all else "
"fails, it will check the generic :ref:`\"Simple controller\" "
"<doc_xr_action_map_simple>`."
msgstr ""
"運作時的常見方法是先尋找配對的互動配置檔。如果未找到，它將檢查最常見的配置檔"
"案，例如“觸摸控制器”的配置檔案並進行轉換。如果所有其他方法都失敗，它將檢查通"
"用「簡單控制器」<doc_xr_action_map_simple>`。"

msgid ""
"There is an important conclusion to be made here: When a controller is "
"found, and the action map is applied to it, the XR runtime is not limited to "
"the exact configurations you set up in Godot's action map editor. While the "
"runtime will generally choose a suitable mapping based on one of the "
"bindings you set up in the action map, it can deviate from it."
msgstr ""
"這裡有一個重要的結論：當找到控制器並將動作圖應用於它時，XR 運作時並不限於您"
"在 Godot 的動作圖編輯器中設定的確切配置。雖然運作時通常會根據您在操作對應中設"
"定的綁定之一選擇合適的對應，但它可能會偏離它。"

msgid ""
"For example, when the Touch controller profile is used any of the following "
"scenarios could be true:"
msgstr "例如，使用觸控控制器設定檔時，可能會出現以下任一情況："

msgid "we could be using a Quest 1 controller,"
msgstr "VR控制器的程式碼"

msgid "we could be using a Quest 2 controller,"
msgstr "VR控制器的程式碼"

msgid ""
"we could be using a Quest Pro controller but no Quest Pro profile was given "
"or the XR runtime being used does not support the Quest Pro controller,"
msgstr ""
"我們可以使用 Quest Pro 控制器，但沒有給出 Quest Pro 設定檔案，或者正在使用的 "
"XR 運作時不支援 Quest Pro 控制器，"

msgid ""
"it could be a completely different controller for which no profile was given "
"but the XR runtime is using the touch bindings as a base."
msgstr ""
"它可能是一個完全不同的控制器，沒有給出配置檔案，但 XR 運作時使用觸摸綁定作為"
"基礎。"

msgid ""
"Ergo, there currently is no way to know with certainty, which controller the "
"user is actually using."
msgstr "因此，目前無法確定使用者實際使用哪個控制器。"

msgid ""
"Finally, and this trips up a lot of people, the bindings aren't set in "
"stone. It is fully allowed, and even expected, that an XR runtime allows a "
"user to customise the bindings."
msgstr ""
"最後，這讓很多人感到困惑，綁定並不是一成不變的。 XR 運作時允許使用者自訂綁定"
"是完全允許的，甚至是預期的。"

msgid ""
"At the moment none of the XR runtimes offer this functionality though "
"SteamVR has an existing UI from OpenVRs action map system that is still "
"accessible. This is actively being worked on however."
msgstr ""
"目前，沒有任何 XR 運作時提供此功能，儘管 SteamVR 擁有來自 OpenVR 動作地圖系統"
"的現有 UI，但仍然可以存取。不過，這方面的工作正在積極進行中。"

msgid "Our first controller binding"
msgstr "第一個控制器綁定"

msgid ""
"Let's set up our first controller binding, using the Touch controller as an "
"example."
msgstr "讓我們以觸控控制器為例設定第一個控制器綁定。"

msgid ""
"Press \"Add profile\", find the Touch controller, and add it. If it is not "
"in the list, then it may already have been added."
msgstr ""
"按“新增設定檔”，找到觸控控制器並新增它。如果它不在列表中，則它可能已被新增。"

msgid ""
"Our UI now shows panels for both the left and right controllers. The panels "
"contain all of the possible inputs and outputs for each controller. We can "
"use the ``+`` next to each entry to bind it to an action:"
msgstr ""
"我們的 UI 現在顯示左右控制器的面板。面板包含每個控制器的所有可能的輸入和輸"
"出。我們可以使用每個條目旁邊的“+”將其綁定到一個操作："

msgid "Let's finish our configuration:"
msgstr "程式碼樣式設定"

msgid ""
"Each action is bound the given input or output for both controllers to "
"indicate that we support the action on either controller. The exception is "
"the movement action which is bound only to the right hand controller. It is "
"likely that we would want to use the left hand thumbstick for a different "
"purpose, say a teleport function."
msgstr ""
"每個操作都綁定兩個控制器的給定輸入或輸出，以表示我們支援任一控制器上的操作。"
"例外情況是移動動作僅綁定到右手控制器。我們很可能希望將左手拇指操縱桿用於不同"
"的目的，例如傳送功能。"

msgid ""
"In developing your game/application you have to account for the possibility "
"that the user changes the binding and binds the movement to the left hand "
"thumbstick."
msgstr ""
"在開發遊戲/應用程式時，您必須考慮使用者更改綁定並將運動綁定到左手搖桿的可能"
"性。"

msgid ""
"Also note that our shoot and grab boolean actions are linked to inputs of "
"type ``Float``. As mentioned before OpenXR will do conversions between the "
"two, but do read the warning given on that subject earlier in this document."
msgstr ""
"另請注意，我們的射擊和抓取布林操作與“Float”型別的輸入相關聯。如前所述，"
"OpenXR 將在兩者之間進行轉換，但請閱讀本文件前面關於該主題的警告。"

msgid "Some of the inputs seem to appear in our list multiple times."
msgstr "有些輸入似乎多次出現在我們的列表中。"

msgid ""
"For instance we can find the ``X`` button twice, once as ``X click`` and "
"then as ``X touch``. This is due to the Touch controller having a capacitive "
"sensor."
msgstr ""
"例如，我們可以找到“X”按鈕兩次，一次是“X click”，然後是“X touch”。這是由於觸控"
"控制器具有電容式感測器。"

msgid "``X touch`` will be true if the user is merely touching the X button."
msgstr "如果使用者只是觸摸 X 按鈕，則「X touch」將為 true。"

msgid ""
"``X click`` will be true when the user is actually pressing down on the "
"button."
msgstr "當使用者實際按下按鈕時，「X click」將為 true。"

msgid "Similarly for the thumbstick we have:"
msgstr "同樣，對於拇指操縱桿，我們有："

msgid ""
"``Thumbstick touch`` which will be true if the user is touching the "
"thumbstick."
msgstr "如果使用者觸摸拇指操縱桿，則「拇指操縱桿觸摸」為真。"

msgid ""
"``Thumbstick`` which gives a value for the direction the thumbstick is "
"pushed to."
msgstr "「Thumbstick」 給出了拇指桿被推動的方向的值。"

msgid ""
"``Thumbstick click`` which is true when the user is pressing down on the "
"thumbstick."
msgstr "當使用者按下拇指操縱桿時，會發生「拇指操縱桿點擊」。"

msgid ""
"It is important to note that only a select number of XR controllers support "
"touch sensors or have click features on thumbsticks. Keep that in mind when "
"designing your game/application. Make sure these are used for optional "
"features of your game/application."
msgstr ""
"值得注意的是，只有部分 XR 控制器支援觸控感應器或在搖桿上具有點擊功能。在設計"
"遊戲/應用程式時請記住這一點。確保這些用於您的遊戲/應用程式的可選功能。"

msgid "The simple controller"
msgstr "建立內容"

msgid ""
"The \"Simple controller\" is a generic controller that OpenXR offers as a "
"fallback. We'll apply our mapping:"
msgstr ""
"「簡單控制器」是 OpenXR 作為後備提供的通用控制器。我們將應用我們的對應："

msgid ""
"As becomes painfully clear, the simple controller is often far too simple "
"and falls short for anything but the simplest of VR games/applications."
msgstr ""
"令人痛苦的是，顯而易見的是，簡單的控制器往往過於簡單，除了最簡單的 VR 遊戲/應"
"用程式之外，其他任何東西都達不到要求。"

msgid ""
"This is why many XR runtimes only use it as a last resort and will attempt "
"to use bindings from one of the more popular systems as a fallback first."
msgstr ""
"這就是為什麼許多 XR 運作時僅將其用作最後手段，並首先嘗試使用來自更流行的系統"
"之一的綁定作為後備。"

msgid ""
"Due to the simple controller likely not covering the needs of your game, it "
"is tempting to provide bindings for every controller supported by OpenXR. "
"The default action map seems to suggest this as a valid course of action. As "
"mentioned before, the default action map was designed for ease of migration "
"from Godot 3."
msgstr ""
"由於簡單的控制器可能無法滿足遊戲的需求，因此很容易為 OpenXR 支援的每個控制器"
"提供綁定。預設的行動圖似乎顯示這是一個有效的行動方案。如前所述，預設的動作對"
"應是為了方便從 Godot 3 遷移而設計的。"

msgid ""
"It is the recommendation from the OpenXR Working Group that only bindings "
"for controllers actually tested by the developer are setup. The XR runtimes "
"are designed with this in mind. They can perform a better job of rebinding a "
"provided binding than a developer can make educated guesses. Especially as "
"the developer can't test if this leads to a comfortable experience for the "
"end user."
msgstr ""
"OpenXR 工作小組建議僅設定開發人員實際測試的控制器的綁定。 XR 運作時的設計就考"
"慮到了這一點。他們可以比開發人員做出有根據的猜測更好地重新綁定所提供的綁定。"
"特別是因為開發人員無法測試這是否會為最終使用者帶來舒適的體驗。"

msgid ""
"This is our advice as well: limit your action map to the interaction "
"profiles for devices you have actually tested your game with. The Oculus "
"Touch controller is widely used as a fallback controller by many runtimes. "
"If you are able to test your game using a Meta Rift or Quest and add this "
"profile there is a high probability your game will work with other headsets."
msgstr ""
"這也是我們的建議：將您的動作圖限制為您實際測試遊戲的裝置的互動設定檔。 "
"Oculus Touch 控制器被許多運作時廣泛用作後備控制器。如果您能夠使用 Meta Rift "
"或 Quest 測試您的遊戲並新增此配置檔案，那麼您的遊戲很可能可以與其他耳機配合使"
"用。"

msgid "Translation status"
msgstr "翻譯狀態"
