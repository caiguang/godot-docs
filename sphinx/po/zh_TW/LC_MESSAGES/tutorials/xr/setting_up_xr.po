# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Setting up XR"
msgstr "設定 XR"

msgid "Introduction to the XR system in Godot"
msgstr "建置系統簡介"

msgid ""
"Godot provides a modular XR system that abstracts many of the different XR "
"platform specifics away from the user. At the core sits the :ref:`XRServer "
"<class_xrserver>` which acts as a central interface to the XR system that "
"allows users to discover interfaces and interact with the components of the "
"XR system."
msgstr ""
"Godot 提供了一個模組化 XR 系統，該系統將許多不同的 XR 平台細節從使用者手中抽"
"象化。核心是 XRServer <class_xrserver>`，它充當 XR 系統的中央接口，允許使用者"
"發現接口並與 XR 系統的組件進行互動。"

#, fuzzy
msgid ""
"Each supported XR platform is implemented as an :ref:`XRInterface "
"<class_xrinterface>`. Supported interfaces register themselves with the :ref:"
"`XRServer <class_xrserver>` and can be queried with the ``find_interface`` "
"method on the :ref:`XRServer <class_xrserver>`. When the desired interface "
"is found it can be initialized by calling ``initialize`` on the interface."
msgstr ""
"每個支援的 XR 平台均以 XRInterface <class_xrinterface> 的形式實作。支援的介面"
"將自身註冊到 XRServer <class_xrserver>` 上，並且可以使用 XRServer "
"<class_xrserver>` 上的 ``find_interface`` 方法進行查詢。當找到所需的介面時，"
"可以透過在介面上呼叫“initialize”來初始化它。"

msgid ""
"A registered interface means nothing more than that the interface is "
"available, if the interface is not supported by the host system, "
"initialization may fail and return ``false``. This can have many reasons and "
"sadly the reasons differ from platform to platform. It can be because the "
"user hasn't installed the required software, or that the user simply hasn't "
"plugged in their headset. You as a developer must thus react properly on an "
"interface failing to initialize."
msgstr ""
"已註冊的接口僅表示該接口可用，如果主機系統不支援該接口，則初始化可能會失敗並"
"返回“false”。這可能有許多原因，遺憾的是，不同平台的原因有所不同。這可能是因為"
"使用者尚未安裝所需的軟體，或者使用者根本沒有插入耳機。因此，作為開發人員，您"
"必須對無法初始化的介面做出正確的反應。"

msgid ""
"Due to the special requirements for output in XR, especially for head "
"mounted devices that supply different images to each eye, the :ref:`XRServer "
"<class_xrserver>` in Godot will override various features in the rendering "
"system. For stand-alone devices this means the final output is handled by "
"the :ref:`XRInterface <class_xrinterface>` and Godot's usual output system "
"is disabled. For desktop XR devices that work as a second screen it is "
"possible to dedicate a separate :ref:`Viewport <class_viewport>` to handle "
"the XR output, leaving the main Godot window available for displaying "
"alternative content."
msgstr ""
"由於 XR 中輸出的特殊要求，特別是對於向每隻眼睛提供不同影像的頭戴式裝置，"
"Godot 中的 XRServer <class_xrserver>` 將覆蓋算繪系統中的各種功能。對於獨立裝"
"置，這意味著最終輸出由 XRInterface <class_xrinterface>` 處理，並且 Godot 的常"
"用輸出系統被停用。對於用作第二個螢幕的桌面 XR 裝置，可以專用一個單獨的 "
"Viewport <class_viewport>` 來處理 XR 輸出，從而使主 Godot 視窗可用於顯示替代"
"內容。"

msgid ""
"Note that only one interface can be responsible for handling the output to "
"an XR device, this is known as the primary interface and by default will be "
"the first interface that is initialized. Godot currently thus only supports "
"implementations with a single headset. It is possible, but increasingly "
"uncommon, to have a secondary interface, for example to add tracking to an "
"otherwise 3DOF only device."
msgstr ""
"請注意，只有一個接口可以負責處理 XR 裝置的輸出，這稱為主接口，預設情況下將是"
"第一個初始化的接口。因此，Godot 目前僅支援使用單一耳機的實作。擁有輔助介面是"
"可能的，但越來越不常見，例如向其他僅 3DOF 的裝置新增追蹤。"

msgid ""
"There are three XR specific node types that you will find in nearly all XR "
"applications:"
msgstr "您幾乎可以在所有 XR 應用程式中找到三種 XR 特定節點型別："

msgid ""
":ref:`XROrigin3D <class_xrorigin3d>` represents, for all intents and "
"purposes, the center point of your play space. That is an oversimplified "
"statement but we'll go into more detail later. All objects tracked in "
"physical space by the XR platform are positioned in relation to this point."
msgstr ""
":ref:`XROrigin3D <class_xrorigin3d>` 代表了所有意圖和目的，您的遊戲空間的中心"
"點。這是一個過於簡單的說法，但我們稍後會更詳細地討論。 XR 平台在物理空間中追"
"蹤的所有物件都相對於該點進行定位。"

msgid ""
":ref:`XRCamera3D <class_xrcamera3d>` represents the (stereo) camera that is "
"used when rendering output for the XR device. The positioning of this node "
"is controlled by the XR system and updated automatically using the tracking "
"information provided by the XR platform."
msgstr ""
":ref:`XRCamera3D <class_xrcamera3d>` 表示為 XR 裝置算繪輸出時所使用的（立體）"
"相機。此節點的定位由XR系統控制，並使用XR平台提供的追蹤資訊自動更新。"

msgid ""
":ref:`XRController3D <class_xrcontroller3d>` represents a controller used by "
"the player, commonly there are two, one held in each hand. These nodes give "
"access to various states on these controllers and send out signals when the "
"player presses buttons on them. The positioning of this node is controlled "
"by the XR system and updated automatically using the tracking information "
"provided by the XR platform."
msgstr ""
":ref:`XRController3D <class_xrcontroller3d>` 代表玩家使用的控制器，通常有兩"
"個，每隻手握一個。這些節點可以存取這些控制器上的各種狀態，並在玩家按下它們上"
"的按鈕時發出訊號。此節點的定位由XR系統控制，並使用XR平台提供的追蹤資訊自動更"
"新。"

msgid ""
"There are other XR related nodes and there is much more to say about these "
"three nodes, but we'll get into that later on."
msgstr ""
"還有其他與 XR 相關的節點，關於這三個節點還有很多要說的，但我們稍後會詳細介"
"紹。"

msgid "Prerequisites for XR in Godot 4"
msgstr "Godot 4 中 XR 的先決條件"

msgid ""
"While in Godot 3 most things worked out of the box, Godot 4 needs a little "
"more setup. This is mainly due to the more advanced nature of the Vulkan "
"renderer. There are many rendering features in Vulkan the XR system uses "
"that aren't enabled by default. They are very easy to turn on, simply open "
"up your project settings and tick the XR shaders tickbox in the XR section:"
msgstr ""
"雖然 Godot 3 中的大多數功能都是開箱即用的，但 Godot 4 需要更多設定。這主要是"
"由於 Vulkan 算繪器更加先進。 XR 系統使用的 Vulkan 中有許多算繪功能預設未啟"
"用。它們非常容易打開，只需打開專案設定並勾選 XR 部分中的 XR 著色器複選框即"
"可："

msgid ""
"As Godot 4 is still in development, many post process effects have not yet "
"been updated to support stereoscopic rendering. Using these will have "
"adverse effects."
msgstr ""
"由於Godot 4仍處於開發階段，許多後製效果尚未更新以支援立體算繪。使用這些會產生"
"不良影響。"

msgid ""
"Godot 4 has 3 renderer options, Compatibility, Mobile, and Forward+. In the "
"future XR desktop projects should use Forward+, and projects for stand-alone "
"headsets should use Mobile. However Compatibility is the recommended "
"renderer for now due to it having the best XR performance."
msgstr ""

msgid "OpenXR"
msgstr "OpenXR"

#, fuzzy
msgid ""
"OpenXR is a new industry standard that allows different XR platforms to "
"present themselves through a standardised API to XR applications. This "
"standard is an open standard maintained by the Khronos Group and thus aligns "
"very well with Godot's interests."
msgstr ""
"OpenXR 是一種新的行業標準，允許不同的 XR 平台透過標準化的 API 向 XR 應用程式"
"展示自己。該標準是由 Khronos Group 維護的開放標準，因此非常符合 Godots 的利"
"益。"

msgid ""
"The Vulkan implementation of OpenXR is closely integrated with Vulkan, "
"taking over part of the Vulkan system. This requires tight integration of "
"certain core graphics features in the Vulkan renderer which are needed "
"before the XR system is setup. This was one of the main deciding factors to "
"include OpenXR as a core interface."
msgstr ""
"OpenXR 的 Vulkan 實作與 Vulkan 緊密整合，接管了 Vulkan 系統的一部分。這需要在"
"設定 XR 系統之前將某些核心圖形功能緊密整合到 Vulkan 算繪器中。這是將 OpenXR "
"作為核心介面的主要決定因素之一。"

msgid ""
"This also means OpenXR needs to be enabled when Godot starts in order to set "
"things up correctly. The required setting can be found in your project "
"settings:"
msgstr ""
"這也意味著當 Godot 啟動時需要啟用 OpenXR 才能正確設定。所需的設定可以在您的專"
"案設定中找到："

msgid ""
"As setup is brought forward with OpenXR you can find several other settings "
"related to OpenXR here as well. These can't be changed while your "
"application is running. The default settings will get us started and we will "
"go into detail in another section of the documentation."
msgstr ""
"由於 OpenXR 提供了設定功能，因此您還可以在此處找到與 OpenXR 相關的其他幾個設"
"定。當您的應用程式運作時，這些無法更改。預設設定將幫助我們開始，我們將在檔案"
"的另一部分中詳細介紹。"

msgid "Setting up the XR scene"
msgstr "設定主要場景"

msgid ""
"Every XR application needs at least an :ref:`XROrigin3D <class_xrorigin3d>` "
"and an :ref:`XRCamera3D <class_xrcamera3d>` node. Most will have two :ref:"
"`XRController3D <class_xrcontroller3d>`, one for the left hand and one for "
"the right. Keep in mind that the camera and controller nodes should be "
"children of the origin node. Add these nodes to a new scene and rename the "
"controller nodes to ``LeftHand`` and ``RightHand``, your scene should look "
"something like this:"
msgstr ""
"每個 XR 應用程式至少需要一個 XROrigin3D <class_xrorigin3d>` 和一個 "
"XRCamera3D <class_xrcamera3d>` 節點。大多數都會有兩個 XRController3D "
"<class_xrcontroller3d>`，一個用於左手，一個用於右手。請記住，相機和控制器節點"
"應該是原始節點的子節點。將這些節點新增至新場景並將控制器節點重新命名"
"為“LeftHand”和“RightHand”，您的場景應如下所示："

msgid ""
"Next you need to configure the controllers, select the left hand and set it "
"up as follows:"
msgstr "接下來您需要配置控制器，選擇左手並進行以下設定："

msgid "And the right hand:"
msgstr "將腳本附加到節點。"

#, fuzzy
msgid ""
"Right now all these nodes are on the floor, they will be positioned "
"correctly in runtime. To help during development, it can be helpful to move "
"the camera upwards so its ``y`` is set to ``1.7``, and move the controller "
"nodes to ``-0.5, 1.0, -0.5`` and ``0.5, 1.0, -0.5`` for respectively the "
"left and right hand."
msgstr ""
"現在所有這些節點都在地板上，它們將在運作時正確定位。為了在開發過程中提供幫"
"助，將相機向上移動，將其“y”設定為“1.7”，並將控制器節點移至“-0.5、"
"1.0、-0.5”和“左手和右手分別為0.5、1.0 、-0.5``。"

msgid ""
"Next we need to add a script to our root node. Add the following code into "
"this script:"
msgstr "現在給主節點新增一個腳本, 並新增以下程式碼:"

msgid ""
"This code fragment assumes we are using OpenXR, if you wish to use any of "
"the other interfaces you can change the ``find_interface`` call."
msgstr ""
"此程式碼片段假設我們使用 OpenXR，如果您希望使用任何其他接口，您可以更"
"改“find_interface”呼叫。"

msgid ""
"As you can see in the code snippet above, we turn off v-sync. When using "
"OpenXR you are outputting the rendering results to an HMD that often "
"requires us to run at 90Hz or higher. If your monitor is a 60hz monitor and "
"v-sync is turned on, you will limit the output to 60 frames per second."
msgstr ""
"正如您在上面的程式碼片段中看到的，我們關閉了垂直同步。使用 OpenXR 時，您將算"
"繪結果輸出到 HMD，這通常要求我們以 90Hz 或更高的頻率運作。如果您的顯示器是 "
"60hz 顯示器並且開啟了垂直同步，您會將輸出限制為每秒 60 影格。"

msgid "XR interfaces like OpenXR perform their own sync."
msgstr "OpenXR 等 XR 介面執行自己的同步。"

msgid ""
"Also note that by default the physics engine runs at 60Hz as well and this "
"can result in choppy physics. You should set ``Engine."
"physics_ticks_per_second`` to a higher value."
msgstr ""
"另請注意，預設情況下實體引擎也以 60Hz 運作，這可能會導致物理效果不穩定。您應"
"該將“Engine.physicals_ticks_per_second”設定為更高的值。"

msgid ""
"If you run your project at this point in time, everything will work but you "
"will be in a dark world. So to finish off our starting point add a :ref:"
"`DirectionalLight3D <class_directionallight3d>` and a :ref:`WorldEnvironment "
"<class_worldenvironment>` node to your scene. You may wish to also add a "
"mesh instance as a child to each controller node just to temporarily "
"visualise them. Make sure you configure a sky in your world environment."
msgstr ""
"如果你在這個時間點運作你的專案，一切都會正常，但你將處於一個黑暗的世界。因"
"此，為了完成我們的起點，請在場景中新增一個:ref:`DirectionalLight3D "
"<class_directionlight3d>` 和一個:ref:`WorldEnvironment "
"<class_worldenvironment>` 節點。您可能還想將網格實例作為子級新增到每個控制器"
"節點，只是為了暫時可視化它們。確保您在世界環境中配置了天空。"

msgid ""
"Now run your project, you should be floating somewhere in space and be able "
"to look around."
msgstr "現在運作您的專案，您應該漂浮在太空中的某個位置並且能夠環顧四周。"

msgid ""
"While traditional level switching can definitely be used with XR "
"applications, where this scene setup is repeated in each level, most find it "
"easier to set this up once and loading levels as a subscene. If you do "
"switch scenes and replicate the XR setup in each one, do make sure you do "
"not run ``initialize`` multiple times. The effect can be unpredictable "
"depending on the XR interface used."
msgstr ""
"雖然傳統的關卡切換絕對可以與 XR 應用程式一起使用，其中該場景設定在每個關卡中"
"重複，但大多數人發現更容易設定一次並將關卡載入為子場景。如果您確實切換場景並"
"在每個場景中複製 XR 設定，請確保不要多次執行“初始化”。根據所使用的 XR 接口，"
"效果可能無法預測。"

msgid ""
"For the rest of this basic tutorial series we will create a game that uses a "
"single scene."
msgstr "在本基本教學系列的其餘部分中，我們將建立一個使用單一場景的遊戲。"

msgid "Translation status"
msgstr "翻譯狀態"
