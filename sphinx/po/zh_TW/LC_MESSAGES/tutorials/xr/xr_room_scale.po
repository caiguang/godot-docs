# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Room scale in XR"
msgstr "根縮放"

msgid ""
"One of the staples of XR projects is the ability to walk around freely in a "
"large space. This space is often constrained by the room the player is "
"physically in with tracking sensors placed within this space. With the "
"advent of inside out tracking however ever larger play spaces are possible."
msgstr ""
"XR 專案的主要特點之一是能夠在大空間中自由走動。該空間通常受到玩家所在房間的限"
"制，並且追蹤感測器放置在該空間內。然而，隨著由內向外追蹤的出現，更大的遊戲空"
"間成為可能。"

msgid ""
"As a developer this introduces a number of interesting challenges. In this "
"document we will look at a number of the challenges you may face and outline "
"some solutions. We'll discuss the issues and challenges for seated XR games "
"in another document."
msgstr ""
"作為開發人員，這帶來了許多有趣的挑戰。在本文件中，我們將探討您可能面臨的一些"
"挑戰並概述一些解決方案。我們將在另一份檔案中討論坐式 XR 遊戲的問題和挑戰。"

msgid ""
"Often developers sit behind their desk while building the foundation to "
"their game. In this mode the issues with developing for room scale don't "
"show themselves until it is too late. The advice here is to start testing "
"while standing up and walking around as early as possible. Once you are "
"happy your foundation is solid, you can develop in comfort while remaining "
"seated."
msgstr ""

msgid ""
"In traditional first person games a player is represented by a :ref:"
"`CharacterBody3D <class_characterbody3d>` node. This node is moved by "
"processing traditional controller, mouse or keyboard input. A camera is "
"attached to this node at a location roughly where the player's head will be."
msgstr ""
"在傳統的第一人稱遊戲中，玩家由 CharacterBody3D <class_characterbody3d> 節點表"
"示。此節點透過處理傳統控制器、滑鼠或鍵盤輸入來移動。相機連接到該節點，大致位"
"於玩家頭部所在的位置。"

msgid ""
"Applying this model to the XR setup, we add an :ref:`XROrigin3D "
"<class_xrorigin3d>` node as a child of the character body, and add a :ref:"
"`XRCamera3D <class_xrcamera3d>` as a child of the origin node. At face value "
"this seems to work. However, upon closer examination this model does not "
"take into account that there are two forms of movement in XR. The movement "
"through controller input, and the physical movement of the player in the "
"real world."
msgstr ""
"將此模型應用於 XR 設定，我們新增 XROrigin3D <class_xrorigin3d>` 節點作為角色"
"身體的子節點，並新增 XRCamera3D <class_xrcamera3d>` 作為原始節點的子節點。從"
"表面上看，這似乎有效。然而，經過仔細檢查，該模型並未考慮到 XR 中有兩種運動形"
"式。透過控制器輸入進行的運動，以及玩家在現實世界中的物理運動。"

msgid ""
"As a result, the origin node does not represent the position of the player. "
"It represents the center, or start of, the tracking space in which the "
"player can physically move. As the player moves around their room this "
"movement is represented through the tracking of the players headset. In game "
"this translates to the camera node's position being updated accordingly. For "
"all intents and purposes, we are tracking a disembodied head. Unless body "
"tracking is available, we have no knowledge of the position or orientation "
"of the player's body."
msgstr ""
"因此，原點節點並不代表玩家的位置。它代表玩家可以在其中物理移動的追蹤空間的中"
"心或起點。當玩家在房間內移動時，這種移動是透過玩家耳機的追蹤來表示的。在遊戲"
"中，這會相應地更新相機節點的位置。出於所有意圖和目的，我們正在追蹤一個脫離實"
"體的頭部。除非身體追蹤可用，否則我們不知道玩家身體的位置或方向。"

msgid ""
"The first problem this causes is fairly obvious. When the player moves with "
"controller input, we can use the same approach in normal games and move the "
"player in a forward direction. However the player isn't where we think they "
"are and as we move forward we're checking collisions in the wrong location."
msgstr ""
"這導致的第一個問題是相當明顯的。當玩家透過控制器輸入移動時，我們可以使用與正"
"常遊戲中相同的方法並將玩家向前移動。然而，玩家並不在我們認為的位置，當我們前"
"進時，我們會檢查錯誤位置的碰撞。"

msgid ""
"The second problem really shows itself when the player walks further away "
"from the center of the tracking space and uses controller input to turn. If "
"we rotate our character body, the player will be moved around the room in a "
"circular fashion."
msgstr ""
"當玩家遠離追蹤空間的中心並使用控制器輸入進行轉彎時，第二個問題才真正顯現出"
"來。如果我們旋轉角色身體，玩家將以圓形方式在房間內移動。"

msgid ""
"If we fix the above issues, we will find a third issue. When the path for "
"the player is blocked in the virtual world, the player can still physically "
"move forward."
msgstr ""
"如果我們解決了上述問題，我們就會發現第三個問題。當玩家的路徑在虛擬世界中被阻"
"擋時，玩家仍然可以物理前進。"

msgid ""
"We will look at solving the first two problem with two separate solutions, "
"and then discuss dealing with the third."
msgstr ""
"我們將著眼於用兩個單獨的解決方案來解決前兩個問題，然後討論第三個問題的處理。"

msgid "Origin centric solution"
msgstr "以原點為中心的解決方案"

msgid ""
"Looking at the first approach for solving this we are going to change our "
"structure. This is the approach currently implemented in XR Tools."
msgstr ""
"看看解決這個問題的第一種方法，我們將改變我們的結構。這是 XR Tools 目前實施的"
"方法。"

msgid ""
"In this setup we mark the character body as top level so it does not move "
"with the origin."
msgstr "在此設定中，我們將角色身體標記為頂層，因此它不會隨原點移動。"

msgid ""
"We also have a helper node that tells us where our neck joint is in relation "
"to our camera. We use this to determine where our body center is."
msgstr ""
"我們還有一個輔助節點，它告訴我們頸部關節相對於相機的位置。我們用它來確定我們"
"的身體中心在哪裡。"

msgid "Processing our character movement is now done in three steps."
msgstr "角色移動的處理現在要分三步進行。"

#, fuzzy
msgid ""
"The `Origin centric movement demo <https://github.com/godotengine/godot-demo-"
"projects/tree/master/xr/openxr_origin_centric_movement>`__ contains a more "
"elaborate example of the technique described below."
msgstr ""
"若欲檢視範例專案，請參考作業系統示範專案： https://github.com/godotengine/"
"godot-demo-projects/tree/master/misc/os_test"

msgid "Step 1"
msgstr "逐步執行"

msgid ""
"In the first step we're going to process the physical movement of the "
"player. We determine where the player is right now, and attempt to move our "
"character body there."
msgstr ""
"第一步，我們將處理玩家的身體運動。我們確定玩家現在所在的位置，並嘗試將我們的"
"角色身體移動到那裡。"

msgid ""
"Note that we're returning ``true`` from our "
"``_process_on_physical_movement`` function when we couldn't move our player "
"all the way."
msgstr ""
"請注意，當我們無法完全移動玩家時，我們將從「_process_on_physical_movement」函"
"式傳回「true」。"

msgid "Step 2"
msgstr "逐步執行"

msgid ""
"The second step is to handle rotation of the player as a result of user "
"input."
msgstr "第二步是根據使用者輸入處理玩家的旋轉。"

msgid ""
"As the input used can differ based on your needs we are simply calling the "
"function ``_get_rotational_input``. This function should obtain the "
"necessary input and return the rotational speed in radians per second."
msgstr ""
"由於使用的輸入可能會根據您的需求而有所不同，因此我們只是呼叫函"
"式“_get_rotational_input”。此函式應獲得必要的輸入並傳回以弧度每秒為單位的旋轉"
"速度。"

msgid ""
"For our example we are going to keep this simple and straight forward. We "
"are not going to worry about comfort features such as snap turning and "
"applying a vignette. We highly recommend implementing such comfort features."
msgstr ""

msgid ""
"We've added the call for processing our rotation to our physics process but "
"we are only executing this if we were able to move our player fully. This "
"means that if the player moves somewhere they shouldn't, we don't process "
"further movement."
msgstr ""

msgid "Step 3"
msgstr "逐步執行"

msgid ""
"The third and final step is moving the player forwards, backwards or "
"sideways as a result of user input."
msgstr "第三步也是最後一步是根據使用者輸入向前、向後或側向移動玩家。"

msgid ""
"Just like with the rotation the inputs differ from project to project so we "
"are simply calling the function ``_get_movement_input``. This function "
"should obtain the necessary input and return a directional vector scaled to "
"the required velocity."
msgstr ""
"就像旋轉一樣，專案與專案之間的輸入也不同，因此我們只需呼叫函式"
"「_get_movement_input」。此函式應獲得必要的輸入並傳回縮放至所需速度的方向向"
"量。"

msgid ""
"Just like with rotation we're keeping it simple. Here too it is advisable to "
"look at adding comfort settings."
msgstr ""

msgid "Character body centric solution"
msgstr "角色動畫"

msgid ""
"In this setup we are going to keep our character body as our root node and "
"as such is easier to combine with traditional game mechanics."
msgstr ""
"在此設定中，我們將保留角色身體作為根節點，因此更容易與傳統遊戲機制結合。"

msgid ""
"Here we have a standard character body with collision shape, and our XR "
"origin node and camera as normal children. We also have our neck helper node."
msgstr ""
"這裡我們有一個具有碰撞形狀的標準角色身體，以及我們的 XR 原點節點和相機作為普"
"通子節點。我們還有頸部輔助節點。"

msgid ""
"Processing our character movement is done in the same three steps but "
"implemented slightly differently."
msgstr "處理我們的角色運動是透過相同的三個步驟完成的，但實施方式略有不同。"

#, fuzzy
msgid ""
"The `Character centric movement demo <https://github.com/godotengine/godot-"
"demo-projects/tree/master/xr/openxr_character_centric_movement>`__ contains "
"a more elaborate example of the technique described below."
msgstr ""
"若欲檢視範例專案，請參考作業系統示範專案： https://github.com/godotengine/"
"godot-demo-projects/tree/master/misc/os_test"

msgid ""
"In this approach step 1 is where all the magic happens. Just like with our "
"previous approach we will be applying our physical movement to the character "
"body, but we will counter that movement on the origin node."
msgstr ""
"在這個方法中，第 1 步是所有神奇發生的地方。就像我們之前的方法一樣，我們將把物"
"理運動應用於角色身體，但我們將在原始節點上抵消該運動。"

msgid ""
"This will ensure that the players location stays in sync with the character "
"body's location."
msgstr "這將確保玩家位置與角色身體位置保持同步。"

msgid ""
"In essence the code above will move the character body to where the player "
"is, and then move the origin node back in equal amounts. The result is that "
"the player stays centered above the character body."
msgstr ""
"本質上，上面的程式碼會將角色身體移動到玩家所在的位置，然後將原點節點移回等"
"量。結果是玩家保持在角色身體上方的中心位置。"

msgid ""
"We start with applying the rotation. The character body should be facing "
"where the player was looking the previous frame. We calculate our camera "
"orientation in the space of the character body. We can now calculate the "
"angle by which the player has rotated their head. We rotate our character "
"body by the same amount so our character body faces the same direction as "
"the player. And then we reverse the rotation on the origin node so the "
"camera ends up aligned with the player again."
msgstr ""
"我們從應用旋轉開始。角色身體應該面向玩家在前一影格中註視的位置。我們計算角色"
"身體空間中的相機方向。我們現在可以計算玩家旋轉頭部的角度。我們將角色身體旋轉"
"相同的量，以便我們的角色身體面向與玩家相同的方向。然後我們反轉原點節點上的旋"
"轉，以便相機最終再次與玩家對齊。"

msgid ""
"For the movement we do much the same. The character body should be where the "
"player was standing the previous frame. We calculate by how much the player "
"has moved from this location. Then we attempt to move the character body to "
"this location."
msgstr ""
"對於運動，我們也做同樣的事情。角色身體應該是玩家在前一格站立的位置。我們根據"
"玩家從該位置移動的距離來計算。然後我們嘗試將角色身體移動到這個位置。"

msgid ""
"As the player may hit a collision body and be stopped, we only move the "
"origin point back by the amount we actually moved the character body. The "
"player may thus move away from this location but that will be reflected in "
"the positioning of the player."
msgstr ""
"由於玩家可能會碰到碰撞體並被停止，因此我們只將原點向後移動角色身體實際移動的"
"量。因此，玩家可能會離開該位置，但這將反映在玩家的定位中。"

msgid "As with our previous solution we return true if this is the case."
msgstr "與我們之前的解決方案一樣，如果是這種情況，我們將傳回 true。"

msgid ""
"In this step we again apply the rotation based on controller input. However "
"in this case the code is nearly identical to how one would implement this in "
"a normal first person game."
msgstr ""
"在此步驟中，我們再次根據控制器輸入應用旋轉。然而，在這種情況下，程式碼幾乎與"
"在正常的第一人稱遊戲中實作此程式碼的方式相同。"

msgid ""
"For step three we again apply the movement based on controller input. "
"However just like at step 2, we can now implement this as we would in a "
"normal first person game."
msgstr ""
"對於第三步，我們再次應用基於控制器輸入的運動。然而，就像步驟 2 一樣，我們現在"
"可以像在正常的第一人稱遊戲中一樣實作這一點。"

msgid "When the player walks to somewhere they shouldn't"
msgstr "將玩家移動到樹狀結構中其他地方。"

msgid ""
"Think of a situation where the player is outside a locked room. You don't "
"want the player to go into that room until the door is unlocked. You also "
"don't want the player to see what is in this room."
msgstr ""
"想像一下玩家在上鎖的房間外面的狀況。在門解鎖之前，您不希望玩家進入該房間。您"
"也不希望玩家看到這個房間裡有什麼。"

msgid ""
"The logic for moving the player through controller input nicely prevents "
"this. The player encounters a static body, and the code prevents the player "
"from moving into the room."
msgstr ""
"透過控制器輸入移動玩家的邏輯很好地防止了這種情況。玩家遇到靜態物體，程式碼阻"
"止玩家進入房間。"

msgid ""
"However with XR, nothing is preventing the player from taking a real step "
"forward."
msgstr "然而，有了 XR，沒有什麼可以阻止玩家向前邁出真正的一步。"

msgid ""
"With both the approaches worked out up above we will prevent the character "
"body from moving where the player can't go. As the player has physically "
"moved to this location, the camera will now have moved into the room."
msgstr ""
"透過上面提出的兩種方法，我們將防止角色身體移動到玩家無法到達的地方。當玩家實"
"際移動到該位置時，攝影機現在也已移動到房間中。"

msgid ""
"The logical solution would be to prevent the movement altogether and adjust "
"the placement of the XR origin point so the player stays outside of the room."
msgstr ""
"合乎邏輯的解決方案是完全阻止移動並調整 XR 原點的位置，以便玩家留在房間外面。"

msgid ""
"The problem with this approach is that physical movement is now not "
"replicated in the virtual space. This will cause nausea for the player."
msgstr ""
"這種方法的問題在於，實體運動現在無法在虛擬空間中複製。這會導致玩家感到噁心。"

msgid ""
"What many XR games do instead, is to measure the distance between where the "
"player physically is, and where the players virtual body has been left "
"behind. As this distance increases, usually to a distance of a few "
"centimeters, the screen slowly blacks out."
msgstr ""
"相反，許多 XR 遊戲所做的是測量玩家的實體位置與玩家的虛擬身體被拋在後面的位置"
"之間的距離。隨著這個距離的增加，通常是幾公分的距離，螢幕會慢慢變黑。"

msgid ""
"Our solutions up above would allow us to add this logic into the code at the "
"end of step 1."
msgstr "上面的解決方案允許我們將此邏輯新增到步驟 1 末尾的程式碼中。"

msgid "Further improvements to the code presented could be:"
msgstr "對所提供的程式碼的進一步改進可能是："

msgid "allowing controller input as long as this distance is still small,"
msgstr "只要這個距離仍然很小，就允許控制器輸入，"

msgid ""
"still applying gravity to the player even when controller input is disabled."
msgstr "即使控制器輸入被停用，仍然對玩家施加重力。"

msgid ""
"The movement demos in our demo repository contain an example of blacking out "
"the screen when a user walks into restricted areas."
msgstr ""

msgid "Further suggestions for improvements"
msgstr "進一步的改進建議"

msgid ""
"The above provides two good options as starting points for implementing room "
"scale XR games."
msgstr "以上提供了兩個很好的選擇作為實施房間規模 XR 遊戲的起點。"

msgid ""
"A few more things that are worth pointing out that you will likely want to "
"implement:"
msgstr "您可能想要實施的還有一些值得指出的事情："

msgid ""
"The height of the camera can be used to detect whether the player is "
"standing up, crouching, jumping or lying down. You can adjust the size and "
"orientation of the collision shape accordingly. Extra bonus points for "
"adding multiple collision shapes so the head and body have their own, more "
"accurately sized, shapes."
msgstr ""
"相機的高度可以用來偵測玩家是站立、蹲伏、跳躍還是躺著。您可以相應地調整碰撞形"
"狀的大小和方向。新增多個碰撞形狀的額外獎勵點，使頭部和身體有自己的、尺寸更準"
"確的形狀。"

msgid ""
"When a scene first loads, the player may be far away from the center of the "
"tracking space. This could result in the player spawning into a different "
"room than our origin point. The game will now attempt, and fail, to move the "
"player body from the starting point to where the player is standing. You "
"should implement a reset function that moves the origin point so the player "
"is in the correct starting position."
msgstr ""
"當場景首次加載時，玩家可能遠離追蹤空間的中心。這可能會導致玩家生成到與我們的"
"原點不同的房間。遊戲現在將嘗試將玩家身體從起點移動到玩家站立的位置，但失敗"
"了。您應該實作一個重設函式來移動原點，以便玩家處於正確的起始位置。"

msgid ""
"Both of the above improvements require the player to be ready and standing "
"up straight. There is no guarantee as the player may still be putting their "
"headset on."
msgstr ""
"上述兩項改進都要求玩家做好準備並站直。無法保證，因為玩家可能仍然戴著耳機。"

msgid ""
"Many games, including XR Tools, solve this by introducing an intro screen or "
"loading screen where the player must press a button when they are ready. "
"This starting environment is often a large location where the positioning of "
"the player has little impact on what the player sees. When the player is "
"ready, and presses the button, this is the moment you record the position "
"and height of the camera."
msgstr ""
"許多遊戲（包括 XR Tools）透過引入介紹畫面或載入畫面來解決此問題，玩家必須在準"
"備好時按下按鈕。此起始環境通常是較大的位置，玩家的位置對玩家所看到的內容幾乎"
"沒有影響。當玩家準備好並按下按鈕時，您就記錄了攝影機的位置和高度。"

msgid "Translation status"
msgstr "翻譯狀態"
