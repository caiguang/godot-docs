# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "2D lights and shadows"
msgstr "2D 燈光和陰影"

msgid "Introduction"
msgstr "前言"

msgid ""
"By default, 2D scenes in Godot are unshaded, with no lights and shadows "
"visible. While this is fast to render, unshaded scenes can look bland. Godot "
"provides the ability to use real-time 2D lighting and shadows, which can "
"greatly enhance the sense of depth in your project."
msgstr ""
"預設情況下，Godot 中的 2D 場景採用無光照著色，看不到燈光和陰影。雖然算繪速度"
"很快，但無陰影的場景看起來會很平淡。Godot 提供了可以使用即時 2D 照明和陰影的"
"功能，可以大大增強專案的層次感。"

msgid "No 2D lights or shadows, scene is unshaded"
msgstr "無 2D 燈光或陰影，場景採用無光照著色"

msgid "2D lights enabled (without shadows)"
msgstr ":ref:`doc_2d_lights_and_shadows`"

msgid "2D lights and shadows enabled"
msgstr ":ref:`doc_2d_lights_and_shadows`"

msgid "Nodes"
msgstr "節點"

msgid "There are several nodes involved in a complete 2D lighting setup:"
msgstr "完整的二維照明設定涉及多個節點："

msgid ""
":ref:`CanvasModulate <class_CanvasModulate>` (to darken the rest of the "
"scene)"
msgstr ":ref:`CanvasModulate<class_CanvasModulate>` 用於使場景變暗"

msgid ""
":ref:`PointLight2D <class_PointLight2D>` (for omnidirectional or spot lights)"
msgstr ":ref:`PointLight2D <class_PointLight2D>`（用於全向或點光源）"

msgid ""
":ref:`DirectionalLight2D <class_DirectionalLight2D>` (for sunlight or "
"moonlight)"
msgstr ":ref:`DirectionalLight2D <class_DirectionalLight2D>`（用於日光或月光）"

msgid ""
":ref:`LightOccluder2D <class_LightOccluder2D>` (for light shadow casters)"
msgstr ":ref:`LightOccluder2D <class_LightOccluder2D>`"

msgid "Other 2D nodes that receive lighting, such as Sprite2D or TileMap."
msgstr "其他可接收光照的 2D 節點，如 Sprite2D 或 TileMap。"

msgid ""
":ref:`CanvasModulate <class_CanvasModulate>` is used to darken the scene by "
"specifying a color that will act as the base \"ambient\" color. This is the "
"final lighting color in areas that are *not* reached by any 2D light. "
"Without a CanvasModulate node, the final scene would look too bright as 2D "
"lights would only brighten the existing unshaded appearance (which appears "
"fully lit)."
msgstr ""
":ref:`CanvasModulate<class_CanvasModulate>` 用於指定一種顏色作為“環境”基色，"
"從而使場景變暗。這是任何 2D 燈光都 **無法** 到達區域的最終照明顏色。如果沒有 "
"CanvasModulate 節點，由於 2D 燈光只會照亮現有的無陰影外觀（看起來完全亮了），"
"最終場景看起來會過於明亮。"

msgid ""
":ref:`Sprite2Ds <class_Sprite2D>` are used to display the textures for the "
"light blobs, the background, and for the shadow casters."
msgstr ""
":ref:`Sprites <class_Sprite>` 用於顯示燈泡、背景和產生陰影的物體的紋理。"

msgid ""
":ref:`PointLight2Ds <class_PointLight2D>` are used to light the scene. The "
"way a light typically works is by adding a selected texture over the rest of "
"the scene to simulate lighting."
msgstr ""
":ref:`Light2Ds <class_Light2D>` 用於點亮場景. 光通常的工作方式是在場景的其餘"
"部分新增選定的紋理以模擬光照. 但它可以以其他方式使用, 例如遮罩部分場景."

msgid ""
":ref:`LightOccluder2Ds <class_LightOccluder2D>` are used to tell the shader "
"which parts of the scene cast shadows. These occluders can be placed as "
"independent nodes or can be part of a TileMap node."
msgstr ""
":ref:`LightOccluder2Ds <class_LightOccluder2D>` 用於告訴著色器, 場景的哪些部"
"分投射陰影. 陰影僅出現在 :ref:`Light2D <class_Light2D>` 所覆蓋的區域, 它們的"
"方向基於 :ref:`Light <class_Light2D>` 的中心."

msgid ""
"The shadows appear only on areas covered by the :ref:`PointLight2D "
"<class_PointLight2D>` and their direction is based on the center of the :ref:"
"`Light <class_PointLight2D>`."
msgstr ""
":ref:`LightOccluder2Ds <class_LightOccluder2D>` 用於告訴著色器, 場景的哪些部"
"分投射陰影. 陰影僅出現在 :ref:`Light2D <class_Light2D>` 所覆蓋的區域, 它們的"
"方向基於 :ref:`Light <class_Light2D>` 的中心."

msgid ""
"The background color does **not** receive any lighting. If you want light to "
"be cast on the background, you need to add a visual representation for the "
"background, such as a Sprite2D."
msgstr ""
"背景色 **不會** 接收任何光照。如果要在背景上投射燈光，則需要為背景新增視覺化"
"表示，例如 Sprite2D。"

msgid ""
"The Sprite2D's **Region** properties can be helpful to quickly create a "
"repeating background texture, but remember to also set **Texture > Repeat** "
"to **Enabled** in the Sprite2D's properties."
msgstr ""
"Sprite2D 的 **Region** 屬性有助於快速建立重複的背景紋理，但要記住在 Sprite2D "
"屬性中將 **Texture > Repeat** 設定為 **Enabled** 。"

msgid "Point lights"
msgstr "骨骼權重"

msgid ""
"Point lights (also called positional lights) are the most common element in "
"2D lighting. Point lights can be used to represent light from torches, fire, "
"projectiles, etc."
msgstr ""
"點光源（也稱位置光源）是 2D 照明中最常見的元素。點光源可用於表示火把、火、射"
"彈等發出的光。"

msgid "PointLight2D offers the following properties to tweak in the inspector:"
msgstr "PointLight2D 提供了以下屬性，可在屬性面板中進行調整："

msgid ""
"**Texture:** The texture to use as a light source. The texture's size "
"determines the size of the light. The texture may have an alpha channel, "
"which is useful when using Light2D's **Mix** blend mode, but it is not "
"required if using the **Add** (default) or **Subtract** blend modes."
msgstr ""
"**紋理：** 用作光源的紋理。紋理的大小決定光源的大小。紋理可以有一個 alpha 通"
"道，這在使用 Light2D 的 **Mix** 混合模式時非常有用，但在使用 **Add** （預設）"
"或 **Subtract** 混合模式時則不需要。"

msgid ""
"**Offset:** The offset for the light texture. Unlike when you move the light "
"node, changing the offset does *not* cause shadows to move."
msgstr ""
"**偏移量：** 燈光紋理的偏移量。與移動燈光節點不同，改變偏移量 *不會* 導致陰影"
"移動。"

msgid ""
"**Texture Scale:** The multiplier for the light's size. Higher values will "
"make the light extend out further. Larger lights have a higher performance "
"cost as they affect more pixels on screen, so consider this before "
"increasing a light's size."
msgstr ""
"**紋理縮放：** 燈光大小的乘法器。數值越大，燈光越亮。較大的燈光會影響螢幕上更"
"多的像素，因此在增大燈光尺寸前要考慮到這一點。"

msgid ""
"**Height:** The light's virtual height with regards to normal mapping. By "
"default, the light is very close to surfaces receiving lights. This will "
"make lighting hardly visible if normal mapping is used, so consider "
"increasing this value. Adjusting the light's height only makes a visible "
"difference on surfaces that use normal mapping."
msgstr ""
"**高度：** 燈光在法線貼圖中的虛擬高度。預設情況下，燈光與接收燈光的表面非常接"
"近。如果使用法線貼圖，這將使燈光幾乎不可見，因此可以考慮增加此值。只有在使用"
"法線貼圖的表面上，調整燈光的高度才會產生明顯的不同。"

msgid ""
"If you don't have a pre-made texture to use in a light, you can use this "
"\"neutral\" point light texture (right-click > **Save Image As…**):"
msgstr ""
"如果沒有預製紋理可用於燈光，可以使用這種 “中性 ”點光源紋理（按右鍵 > **圖像另"
"存為...** ）："

msgid "Neutral point light texture"
msgstr "匯入紋理"

msgid ""
"If you need different falloff, you can procedurally create a texture by "
"assigning a **New GradientTexture2D** on the light's **Texture** property. "
"After creating the resource, expand its **Fill** section and set the fill "
"mode to **Radial**. You will then have to adjust the gradient itself to "
"start from opaque white to transparent white, and move its starting location "
"to be in the center."
msgstr ""
"如果您需要不同的漸變，可以通過在燈光的**紋理**屬性上分配 **新建 "
"GradientTexture2D** 來程式化地建立紋理。建立資源後，展開其 **Fill** 部分並將"
"填充模式設定為 **Radial** 。然後，您需要調整漸變本身，使其從不透明的白色開始"
"到透明的白色，並將其起始位置移動到中心。"

msgid "Directional light"
msgstr "平行光"

msgid ""
"New in Godot 4.0 is the ability to have directional lighting in 2D. "
"Directional lighting is used to represent sunlight or moonlight. Light rays "
"are casted parallel to each other, as if the sun or moon was infinitely far "
"away from the surface that is receiving the light."
msgstr ""
"Godot 4.0 的新功能是在 2D 中實作定向照明。定向照明用於表現陽光或月光。光線相"
"互平行投射，就好像太陽或月亮離受光表面無限遠一樣。"

msgid "DirectionalLight2D offers the following properties:"
msgstr "DirectionalLight2D 提供以下的屬性："

msgid ""
"**Height:** The light's virtual height with regards to normal mapping "
"(``0.0`` = parallel to surfaces, ``1.0`` = perpendicular to surfaces). By "
"default, the light is fully parallel with the surfaces receiving lights. "
"This will make lighting hardly visible if normal mapping is used, so "
"consider increasing this value. Adjusting the light's height only makes a "
"visual difference on surfaces that use normal mapping. **Height** does not "
"affect shadows' appearance."
msgstr ""
"**高度：** 燈光在法線貼圖中的虛擬高度（ ``0.0`` = 平行於曲面， ``1.0`` = 垂直"
"於曲面）。預設情況下，燈光與接收燈光的表面完全平行。如果使用法線貼圖，這將使"
"燈光幾乎不可見，因此可以考慮增大此值。調整燈光的高度只會對使用法線貼圖的表面"
"產生視覺差異。 **高度** 不會影響陰影的外觀。"

msgid ""
"**Max Distance:** The maximum distance from the camera center objects can be "
"before their shadows are culled (in pixels). Decreasing this value can "
"prevent objects located outside the camera from casting shadows (while also "
"improving performance). Camera2D zoom is not taken into account by **Max "
"Distance**, which means that at higher zoom values, shadows will appear to "
"fade out sooner when zooming onto a given point."
msgstr ""
"**最大距離：** 物體距離相機中心的最大距離（單位：像素）。減小該值可以防止對位"
"於相機外的物體投射陰影（同時還能提高性能）。 **最大距離** 不考慮 Camera2D 的"
"縮放，這意味著在較高的縮放值下，當縮放至給定點時，陰影會更快消失。"

msgid ""
"Directional shadows will always appear to be infinitely long, regardless of "
"the value of the **Height** property. This is a limitation of the shadow "
"rendering method used for 2D lights in Godot."
msgstr ""
"無論 **Height** 屬性的值是多少，定向陰影看起來總是無限長。這是 Godot 中用於 "
"2D 燈光的陰影算繪方法的限制。"

msgid ""
"To have directional shadows that are not infinitely long, you should disable "
"shadows in the DirectionalLight2D and use a custom shader that reads from "
"the 2D signed distance field instead. This distance field is automatically "
"generated from LightOccluder2D nodes present in the scene."
msgstr ""
"不想獲得無限長的定向陰影，應禁用 DirectionalLight2D 中的陰影，並使用自訂著色"
"器來讀取 2D 帶符號距離場。該距離場從場景中的 LightOccluder2D 節點自動生成。"

msgid "Common light properties"
msgstr "建立屬性群組"

msgid ""
"Both PointLight2D and DirectionalLight2D offer common properties, which are "
"part of the Light2D base class:"
msgstr ""
"PointLight2D 和 DirectionalLight2D 都提供共同的屬性，這些屬性是 Light2D 基底"
"類別的一部分："

msgid ""
"**Enabled:** Allows toggling the light's visibility. Unlike hiding the light "
"node, disabling this property will not hide the light's children."
msgstr ""
"**啟用：** 允許切換燈光的可見性。與隱藏燈光節點不同，禁用此屬性不會隱藏燈光的"
"子節點。"

msgid ""
"**Editor Only:** If enabled, the light is only visible within the editor. It "
"will be automatically disabled in the running project."
msgstr ""
"**僅編輯器：** 如果啟用，燈光僅在編輯器中可見。在運作的專案中將自動禁用。"

msgid "**Color:** The light's color."
msgstr "**顏色：** 燈光的顏色。"

msgid ""
"**Energy:** The light's intensity multiplier. Higher values result in a "
"brighter light."
msgstr "**能量：** 燈光強度乘數。數值越大，光線越亮。"

msgid ""
"**Blend Mode:** The blending formula used for light computations. The "
"default **Add** is suited for most use cases. **Subtract** can be used for "
"negative lights, which are not physically accurate but can be used for "
"special effects. The **Mix** blend mode mixes the value of pixels "
"corresponding to the light's texture with the values of pixels under it by "
"linear interpolation."
msgstr ""
"**混合模式：** 用於光線計算的混合公式。預設的 **新增（Add）** 適合大多數使用"
"情況。 **減（Subtract）** 可用於負光，負光在物理上並不精確，但可用於特殊效"
"果。 **混合（Mix）** 模式通過線性插值將燈光紋理對應的像素值與燈光下方的像素值"
"混合。"

msgid "**Range > Z Min:** The lowest Z index affected by the light."
msgstr "**範圍 > Z 下限：** 受光線影響的最小 Z 值。"

msgid "**Range > Z Max:** The highest Z index affected by the light."
msgstr "**範圍 > Z 上限：** 受光線影響的最大 Z 值。"

msgid "**Range > Layer Min:** The lowest visual layer affected by the light."
msgstr "**範圍 > 層下限：** 受光線影響的最小層數值。"

msgid "**Range > Layer Max:** The highest visual layer affected by the light."
msgstr "**範圍 > 層上限：** 受光線影響的最大層數值。"

msgid ""
"**Range > Item Cull Mask:** Controls which nodes receive light from this "
"node, depending on the other nodes' enabled visual layers **Occluder Light "
"Mask**. This can be used to prevent certain objects from receiving light."
msgstr ""
"**範圍 > 對象遮罩：** 根據其他節點的可視層選項**Occluder Light Mask**（遮擋掩"
"膜），控制那些節點接收到來自這個節點的光線。通過這種方式可以讓某些物體不被光"
"線照射。"

msgid "Setting up shadows"
msgstr "設定 SCons"

msgid ""
"After enabling the **Shadow > Enabled** property on a PointLight2D or "
"DirectionalLight2D node, you will not see any visual difference initially. "
"This is because no nodes in your scene have any *occluders* yet, which are "
"used as a basis for shadow casting."
msgstr ""
"啟用一個 PointLight2D 或者 DirectionalLight2D 節點的 **Shadow > Enabled** 屬"
"性之後，你將看不到任何變化。這是因為在你的場景中還沒有任何節點擁有投射陰影需"
"要使用的 *遮擋器* 。"

msgid ""
"For shadows to appear in the scene, LightOccluder2D nodes must be added to "
"the scene. These nodes must also have occluder polygons that are designed to "
"match the sprite's outline."
msgstr ""
"要在場景中顯示陰影，必須在場景中新增 LightOccluder2D 節點。這些節點還必須具有"
"與精靈輪廓相配對的遮光多邊形。"

msgid ""
"Along with their polygon resource (which must be set to have any visual "
"effect), LightOccluder2D nodes have 2 properties:"
msgstr ""
"除了多邊形資源（必須設定多邊形資源才能產生視覺效果）之外，LightOccluder2D 節"
"點還有兩個屬性："

msgid ""
"**SDF Collision:** If enabled, the occluder will be part of a real-time "
"generated *signed distance field* that can be used in custom shaders. When "
"not using custom shaders that read from this SDF, enabling this makes no "
"visual difference and has no performance cost, so this is enabled by default "
"for convenience."
msgstr ""
"**SDF碰撞：**如果啟用，則遮擋器將成為可在自訂著色器中使用的即時生成的 *簽章距"
"離欄位* （signed distance field）的一部分。當不使用從此 SDF 中讀取的自訂著色"
"器時，啟用這個功能不會帶來視覺上的差異，並且沒有性能成本，因此預設情況下為方"
"便起見它是啟用的。"

msgid ""
"**Occluder Light Mask:** This is used in tandem with PointLight2D and "
"DirectionalLight2D's **Shadow > Item Cull Mask** property to control which "
"objects cast shadows for each light. This can be used to prevent specific "
"objects from casting shadows."
msgstr ""
"**遮擋器光照遮罩：** 這是與 PointLight2D 和 DirectionalLight2D 的 **Shadow > "
"Item Cull Mask** 屬性一起使用的功能，以控制哪些物件為每個光照投射陰影。這可用"
"於防止特定物件投射陰影。"

msgid "There are two ways to create light occluders:"
msgstr "Godot 沒有使用限制"

msgid "Automatically generating a light occluder"
msgstr "自動生成光遮蔽器"

msgid ""
"Occluders can be created automatically from Sprite2D nodes by selecting the "
"node, clicking the **Sprite2D** menu at the top of the 2D editor then "
"choosing **Create LightOccluder2D Sibling**."
msgstr ""
"遮擋器可以自動地 Sprite2D 節點上建立，需要選中節點，按一下2D編輯器頂部的 "
"**Sprite2D**功能表，然後選擇 **建立 LightOccluder2D 兄弟節點**\\\\\\\\從而自"
"動進行。"

msgid ""
"In the dialog that appears, an outline will surround your sprite's edges. If "
"the outline matches the sprite's edges closely, you can click **OK**. If the "
"outline is too far away from the sprite's edges (or is \"eating\" into the "
"sprite's edges), adjust **Grow (pixels)** and **Shrink (pixels)**, then "
"click **Update Preview**. Repeat this operation until you get satisfactory "
"results."
msgstr ""
"在出現的視窗中，一個外框將會包裹在你的精靈的邊緣。如果外框貼合在了你的精靈的"
"邊緣上，你可以點擊**確定**。如果外框離你的精靈邊緣太遠（或者它穿過了你的精靈"
"的邊緣），調整**擴充（像素）**和**收縮（像素）**，然後點擊**更新預覽**。重複"
"這一個操作直到你對結果滿意為止。"

msgid "Manually drawing a light occluder"
msgstr "手動繪製光遮蔽器"

msgid ""
"Create a LightOccluder2D node, then select the node and click the \"+\" "
"button at the top of the 2D editor. When asked to create a polygon resource, "
"answer **Yes**. You can then start drawing an occluder polygon by clicking "
"to create new points. You can remove existing points by right-clicking them, "
"and you can create new points from the existing line by clicking on the line "
"then dragging."
msgstr ""
"建立一個 LightOccluder2D 節點，然後選中節點，點擊 2D 編輯器頂部的 “+” 按鈕。"
"在詢問是否要新增一個多邊形資源的時候選擇**建立**。然後你就可以通過點擊新增頂"
"點的方式繪製遮光多邊形了。你可以通過右鍵已經建立的頂點來刪除它們，並且你可以"
"點擊並拖動一個已經存在的線段上來新增新的頂點。"

msgid ""
"The following properties can be adjusted on 2D lights that have shadows "
"enabled:"
msgstr "啟用陰影的 2D 燈光能夠調整以下屬性："

msgid ""
"**Color:** The color of shaded areas. By default, shaded areas are fully "
"black, but this can be changed for artistic purposes. The color's alpha "
"channel controls how much the shadow is tinted by the specified color."
msgstr ""
"**Color：**陰影區域的顏色。預設情況下，陰影區域是全黑的，但這可以出於藝術目的"
"而改變。顏色的 alpha 通道控制的是陰影被指定顏色著色的程度。"

msgid ""
"**Filter:** The filter mode to use for shadows. The default **None** is the "
"fastest to render, and is well suited for games with a pixel art aesthetic "
"(due to its \"blocky\" visuals). If you want a soft shadow, use **PCF5** "
"instead. **PCF13** is even softer, but is the most demanding to render. "
"PCF13 should only be used for a few lights at once due to its high rendering "
"cost."
msgstr ""
"**Filter：**陰影所使用的篩選模式。預設值為 **None**，算繪速度最快，並且非常適"
"合像素藝術風格的遊戲（因為它具有“方塊”視覺效果）。如果你想要柔和的陰影，請使"
"用 **PCF5**。**PCF13** 則更柔和，但算繪需求更高。由於算繪成本較高，**PCF13** "
"只應用於少量光源同時存在的情況下。"

msgid ""
"**Filter Smooth:** Controls how much softening is applied to shadows when "
"**Filter** is set to **PCF5** or **PCF13**. Higher values result in a softer "
"shadow, but may cause banding artifacts to be visible (especially with PCF5)."
msgstr ""
"**Filter Smooth：**篩選平滑。控制的是當 **Filter** 為 **PCF5** 或* *PCF13** "
"時，應用於陰影的柔化程度。較高的值會導致陰影更加柔和，但可能會出現帶狀偽影"
"（特別是使用 PCF5 時）。"

msgid ""
"**Item Cull Mask:** Controls which LightOccluder2D nodes cast shadows, "
"depending on their respective **Occluder Light Mask** properties."
msgstr ""
"**Item Cull Mask：**專案剔除遮罩。控制的是哪些 LightOccluder2D 節點能夠投射陰"
"影，取決於對應的 **Occluder Light Mask**（遮擋器燈光遮罩）屬性。"

msgid "Hard shadows"
msgstr "硬或軟陰影。"

msgid "Soft shadows (PCF13, Filter Smooth 1.5)"
msgstr "柔和陰影（PCF13，濾鏡平滑度 1.5）"

msgid ""
"Soft shadows with streaking artifacts due to Filter Smooth being too high "
"(PCF5, Filter Smooth 4)"
msgstr "由於濾波平滑度太高（PCF5，濾波平滑度 4），陰影變得柔和，並出現條紋偽影"

msgid "Occluder draw order"
msgstr "遮擋模式"

msgid ""
"**LightOccluder2Ds follows the usual 2D drawing order.** This is important "
"for 2D lighting, as this is how you control whether the occluder should "
"occlude the sprite itself or not."
msgstr ""
"**LightOccluder2D 遵循常規的 2D 繪圖順序。**這對於 2D 燈光而言非常重要，因為"
"可以用來控制遮擋器是否應該遮擋精靈本身。"

msgid ""
"If the LightOccluder2D node is a *sibling* of the sprite, the occluder will "
"occlude the sprite itself if it's placed *below* the sprite in the scene "
"tree."
msgstr ""
"如果 LightOccluder2D 節點是精靈的*兄弟*節點，並且場景樹中的遮擋器被放在精靈的"
"*下方*，會遮擋住精靈本身。"

msgid ""
"If the LightOccluder2D node is a *child* of the sprite, the occluder will "
"occlude the sprite itself if **Show Behind Parent** is disabled on the "
"LightOccluder2D node (which is the default)."
msgstr ""
"如果 LightOccluder2D 節點是一個精靈的子節點，如果在 LightOccluder2D 節點中禁"
"用了 **Show Behind Parent**（顯示在父級之後）這個遮擋器將遮擋住精靈本身（該選"
"項預設禁用）。"

msgid "Normal and specular maps"
msgstr "法線和鏡面貼圖"

msgid ""
"Normal maps and specular maps can greatly enhance the sense of depth of your "
"2D lighting. Similar to how these work in 3D rendering, normal maps can help "
"make lighting look less flat by varying its intensity depending on the "
"direction of the surface receiving light (on a per-pixel basis). Specular "
"maps further help improve visuals by making some of the light reflect back "
"to the viewer."
msgstr ""
"法線貼圖和鏡面貼圖可以大大提升你的2D光照的立體感。與3D算繪類似，法線貼圖可以"
"根據接收光線的表面方向來改變光線的強度，從而使照明效果不再平面化（按像素進行"
"調整）。鏡面貼圖通過讓一部分光線反射回觀察者來進一步改善視覺效果。"

msgid ""
"Both PointLight2D and DirectionalLight2D support normal mapping and specular "
"mapping. Since Godot 4.0, normal and specular maps can be assigned to any 2D "
"element, including nodes that inherit from Node2D or Control."
msgstr ""
"PointLight2D 和 DirectionalLight2D 都支援法線貼圖和鏡面貼圖。自 Godot 4.0 "
"起，法線貼圖和鏡面貼圖可分配給任何 2D 元素，包括繼承自 Node2D 或 Control 的節"
"點。"

msgid ""
"A normal map represents the direction in which each pixel is \"pointing\" "
"towards. This information is then used by the engine to correctly apply "
"lighting to 2D surfaces in a physically plausible way. Normal maps are "
"typically created from hand-painted height maps, but they can also be "
"automatically generated from other textures."
msgstr ""
"法線貼圖表示每個像素 “指向” 的方向。引擎會利用這些資訊，以物理上合理的方式將"
"光照正確應用到 2D 表面。法線貼圖通常由手繪的高度貼圖建立，但也可以由其他紋理"
"自動生成。"

msgid ""
"A specular map defines how much each pixel should reflect light (and in "
"which color, if the specular map contains color). Brighter values will "
"result in a brighter reflection at that given spot on the texture. Specular "
"maps are typically created with manual editing, using the diffuse texture as "
"a base."
msgstr ""
"鏡面貼圖定義了每個像素對光線的反射程度（如果鏡面貼圖包含顏色，則定義反射的顏"
"色）。亮度值越高，紋理上指定位置的反射就越亮。鏡面貼圖通常以漫反射紋理為基"
"礎，通過手動編輯建立。"

msgid ""
"If you don't have normal or specular maps for your sprites, you can generate "
"them using the free and open source `Laigter <https://azagaya.itch.io/"
"laigter>`__ tool."
msgstr ""
"如果在你的精靈中沒有使用法線貼圖或者鏡面貼圖，可以使用免費的開源工具`Laigter "
"<https://azagaya.itch.io/laigter>`來生成。"

msgid ""
"To set up normal maps and/or specular maps on a 2D node, create a new "
"CanvasTexture resource for the property that draws the node's texture. For "
"example, on a Sprite2D:"
msgstr ""
"要在 2D 節點上設定法線貼圖和/或鏡面貼圖，請為繪製節點紋理的屬性建立一個新的 "
"CanvasTexture 資源。例如，在一個 Sprite2D 節點上建立一個新的 CanvasTexture 資"
"源："

msgid "Creating a CanvasTexture resource for a Sprite2D node"
msgstr "為 Sprite2D 節點建立 CanvasTexture 資源"

msgid ""
"Expand the newly created resource. You can find several properties you will "
"need to adjust:"
msgstr "展開新建立的資源。您可以找到需要調整的幾個屬性："

msgid ""
"**Diffuse > Texture:** The base color texture. In this property, load the "
"texture you're using for the sprite itself."
msgstr ""
"**Diffuse > Texture：**（漫反射 > 紋理）基礎的顏色貼圖。在這個屬性中，載入你"
"將使用在精靈本身的紋理。"

msgid ""
"**Normal Map > Texture:** The normal map texture. In this property, load a "
"normal map texture you've generated from a height map (see the tip above)."
msgstr ""
"**Normal Map > Texture：**（法線貼圖 > 紋理）法線貼圖的紋理。在這個屬性中，你"
"可以載入從高度圖生成的法線貼圖紋理（見上面的提示）。"

msgid ""
"**Specular > Texture:** The specular map texture, which controls the "
"specular intensity of each pixel on the diffuse texture. The specular map is "
"usually grayscale, but it can also contain color to multiply the color of "
"reflections accordingly. In this property, load a specular map texture "
"you've created (see the tip above)."
msgstr ""
"**Specular > Texture：**（鏡面反射 > 紋理）鏡面貼圖紋理，可以控制漫反射紋理上"
"每個像素的鏡面反射強度。鏡面貼圖通常使用灰度反射，但是它也可以包含色彩來增強"
"反射的顏色。在這個屬性中，載入一個已建立的鏡面貼圖紋理（見上面的提示）。"

msgid "**Specular > Color:** The color multiplier for specular reflections."
msgstr "**Specular > Color：**（鏡面反射 > 顏色）鏡面反射的顏色乘數。"

msgid ""
"**Specular > Shininess:** The specular exponent to use for reflections. "
"Lower values will increase the brightness of reflections and make them more "
"diffuse, while higher values will make reflections more localized. High "
"values are more suited for wet-looking surfaces."
msgstr ""
"**Specular > Shininess：**（鏡面反射 > 光澤度）用於鏡面反射的高光指數。值越"
"低，反射的明亮度和擴散性會增加，而值越高，反射會更加局部化。較高的值適用於濕"
"潤表面。"

msgid ""
"**Texture > Filter:** Can be set to override the texture filtering mode, "
"regardless of what the node's property is set to (or the **Rendering > "
"Textures > Canvas Textures > Default Texture Filter** project setting)."
msgstr ""
"**Texture > Filter：**（紋理 > 篩檢程式）可以設定為覆蓋紋理篩選模式，無論節點"
"屬性設定如何（或**算繪 > 紋理 > 畫布紋理 > 預設紋理篩選**專案設定）。"

msgid ""
"**Texture > Repeat:** Can be set to override the texture filtering mode, "
"regardless of what the node's property is set to (or the **Rendering > "
"Textures > Canvas Textures > Default Texture Repeat** project setting)."
msgstr ""
"**Texture > Repeat：**（紋理 > 重複）可以設定為覆蓋紋理篩選模式，無論節點的屬"
"性如何設定（或者**算繪 > 紋理 > 畫布紋理 > 預設紋理重複**專案設定）。"

msgid ""
"After enabling normal mapping, you may notice that your lights appear to be "
"weaker. To resolve this, increase the **Height** property on your "
"PointLight2D and DirectionalLight2D nodes. You may also want to increase the "
"lights's **Energy** property slightly to get closer to how your lighting's "
"intensity looked prior to enabling normal mapping."
msgstr ""
"啟用法線貼圖後，你可能會注意到燈光會顯得較弱。為了解決這個問題，可以增加 "
"PointLight2D 和 DirectionalLight2D 節點上的 **Height** 屬性。也可以略微增加燈"
"光的 **Energy** 屬性，以接近啟用法線貼圖之前的照明強度。"

msgid "Using additive sprites as a faster alternative to 2D lights"
msgstr "使用新增式精靈作為 2D 燈光的快速替代品"

msgid ""
"If you run into performance issues when using 2D lights, it may be worth "
"replacing some of them with Sprite2D nodes that use additive blending. This "
"is particularly suited for short-lived dynamic effects, such as bullets or "
"explosions."
msgstr ""
"如果在使用 2D 燈光時遇到性能問題，不妨將其中一些節點替換為使用疊加混合的 "
"Sprite2D 節點。這尤其適用於短暫的動態效果，如子彈或爆炸。"

msgid ""
"Additive sprites are much faster to render, since they don't need to go "
"through a separate rendering pipeline. Additionally, it is possible to use "
"this approach with AnimatedSprite2D (or Sprite2D + AnimationPlayer), which "
"allows for animated 2D \"lights\" to be created."
msgstr ""
"新增式精靈的算繪速度要快得多，因為它們不需要通過單獨的算繪管道。此外，這種方"
"法還可以與 AnimatedSprite2D（或 Sprite2D + AnimationPlayer）一起使用，這樣就"
"可以建立動畫二維 “燈光”。"

msgid "However, additive sprites have a few downsides compared to 2D lights:"
msgstr "不過，與 2D 燈光相比，新增式精靈有一些缺點："

msgid ""
"The blending formula is inaccurate compared to \"actual\" 2D lighting. This "
"is usually not a problem in sufficiently lit areas, but this prevents "
"additive sprites from correctly lighting up areas that are fully dark."
msgstr ""
"與 “實際 ”二維光照相比，混合公式並不準確。這在光線充足的區域通常不是問題，但"
"這會妨礙新增精靈去正確照亮那些完全黑暗的區域。"

msgid "Additive sprites cannot cast shadows, since they are not lights."
msgstr "新增式精靈不能投射陰影，因為它們不是燈光。"

msgid "Additive sprites ignore normal and specular maps used on other sprites."
msgstr "新增式精靈會忽略其他精靈上使用的法線貼圖和鏡面貼圖。"

msgid ""
"To display a sprite with additive blending, create a Sprite2D node and "
"assign a texture to it. In the inspector, scroll down to the **CanvasItem > "
"Material** section, unfold it and click the dropdown next to the "
"**Material** property. Choose **New CanvasItemMaterial**, click the newly "
"created material to edit it, then set **Blend Mode** to **Add**."
msgstr ""
"要顯示一個混合疊加效果的精靈，需要建立一個 Sprite2D 節點並分配一個紋理給它。"
"在檢視視窗中，往下滾動到 **CanvasItem > Material** 部分，展開它並點擊 "
"**Material** 屬性旁邊的下拉式功能表。選擇 **New CanvasItemMaterial**，點擊新"
"建的材質來編輯它，然後將 **Blend Mode** 設定為 **Add**。"

msgid "Translation status"
msgstr "翻譯狀態"
