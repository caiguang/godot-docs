# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Viewport and canvas transforms"
msgstr "Viewport 和畫布變換"

msgid "Introduction"
msgstr "前言"

msgid ""
"This is an overview of the 2D transforms going on for nodes from the moment "
"they draw their content locally to the time they are drawn onto the screen. "
"This overview discusses very low level details of the engine."
msgstr ""
"本頁介紹了節點從其內容在本機被繪製一直到被繪製到畫面上的 2D 變換過程。本概覽"
"也討論了有關引擎非常低階的細節。"

msgid ""
"The goal of this tutorial is to teach a way for feeding input events to the "
"Input with a position in the correct coordinate system."
msgstr ""
"本教學的目標是介紹如何為提供給 Input 的輸入事件在正確的坐標系中確定位置。"

msgid ""
"A more extensive description of all coordinate systems and 2d transforms is "
"available in :ref:`doc_2d_coordinate_systems`."
msgstr ""
"關於所有坐標系以及 2D 變換的詳盡描述見 :ref:`doc_2d_coordinate_systems`。"

msgid "Canvas transform"
msgstr "Canvas 變換"

msgid ""
"As mentioned in the previous tutorial, :ref:`doc_canvas_layers`, every "
"CanvasItem node (remember that Node2D and Control based nodes use CanvasItem "
"as their common root) will reside in a *Canvas Layer*. Every canvas layer "
"has a transform (translation, rotation, scale, etc.) that can be accessed as "
"a :ref:`Transform2D <class_Transform2D>`."
msgstr ""
"與之前的教學，ref:`doc_canvas_layers`，提到的一樣，所有 CanvasItem 節點 (請記"
"得，基於 Node2D 與 Control 的節點都使用 CanvasItem 作為共同的基礎型別) 會被保"
"持放在 **Canvas Layer** 中。所有的 Canvas Layer 都有可作為 :ref:`Transform2D "
"<class_Transform2D>` 存取的變換 (平移、旋轉、縮放…等)。"

msgid ""
"Also covered in the previous tutorial, nodes are drawn by default in Layer "
"0, in the built-in canvas. To put nodes in a different layer, a :ref:"
"`CanvasLayer <class_CanvasLayer>` node can be used."
msgstr ""
"另外，在之前的教學中也有提到，節點預設會在內建 Canvas 的 Layer 0 中繪製。若要"
"將節點放在不同的圖層中，可使用 :ref:`CanvasLayer <class_CanvasLayer>` 節點。"

msgid "Global canvas transform"
msgstr "全域 Canvas 變換"

msgid ""
"Viewports also have a Global Canvas transform (also a :ref:`Transform2D "
"<class_Transform2D>`). This is the master transform and affects all "
"individual *Canvas Layer* transforms. Generally, this is primarily used in "
"Godot's CanvasItem Editor."
msgstr ""
"Viewport 也有一個全域 Canvas 變換 (該變換也是 :ref:`Transform2D "
"<class_Transform2D>`)。全域 Canvas 為主變換，會影響所有單獨的 **Canvas "
"Layer** 變換。一般來說，這種變換並不常用，但在 Godot 編輯器中的 CanvasItem 編"
"輯器中有用到。"

msgid "Stretch transform"
msgstr "拉伸變換"

msgid ""
"Finally, viewports have a *Stretch Transform*, which is used when resizing "
"or stretching the screen. This transform is used internally (as described "
"in :ref:`doc_multiple_resolutions`), but can also be manually set on each "
"viewport."
msgstr ""
"最後，Viewport 還有 **拉伸變換 (Stretch Transform)** ，該變換時用來縮放或拉伸"
"螢幕的。這個變換時在內部使用的 (與 :ref:`doc_multiple_resolutions` 中說明的一"
"樣)，但也可以手動在各個 Viewport 上設定。"

msgid ""
"Input events are multiplied by this transform but lack the ones above. To "
"convert InputEvent coordinates to local CanvasItem coordinates, the :ref:"
"`CanvasItem.make_input_local() <class_CanvasItem_method_make_input_local>` "
"function was added for convenience."
msgstr ""
"有接受 :ref:`MainLoop._input_event() <class_MainLoop_method__input_event>` 回"
"呼的輸入事件也會受到該變換加成，但並不屬於上述變換。若要將 InputEvent 座標轉"
"換為本機 CanvasItem 座標，我們提供了方便的 :ref:`CanvasItem."
"make_input_local() <class_CanvasItem_method_make_input_local>` 函式。"

msgid "Window transform"
msgstr "Canvas 變換"

msgid ""
"The root viewport is a :ref:`Window <class_Window>`. In order to scale and "
"position the *Window's* content as described in :ref:"
"`doc_multiple_resolutions`, each :ref:`Window <class_Window>` contains a "
"*window transform*. It is for example responsible for the black bars at the "
"*Window's* sides so that the *Viewport* is displayed with a fixed aspect "
"ratio."
msgstr ""
"根視口是一個 :ref:`Window <class_Window>`。為了能夠像 :ref:"
"`doc_multiple_resolutions` 中一樣將*視窗*的內容進行縮放和移動，每個 :ref:"
"`Window <class_Window>` 都包含了*視窗變換*。例如在 *Viewport* 使用固定長寬比"
"顯示時，負責*視窗*邊緣的黑框。"

msgid "Transform order"
msgstr "變換順序"

msgid ""
"To convert a CanvasItem local coordinate to an actual screen coordinate, the "
"following chain of transforms must be applied:"
msgstr ""
"要將 CanvasItem 本機屬性內的座標轉換為實際螢幕上的座標，必須要套用下列一系列"
"的變換："

msgid "Transform functions"
msgstr "變換函式"

msgid ""
"The above graphic shows some available transform functions. All transforms "
"are directed from right to left, this means multiplying a transform with a "
"coordinate results in a coordinate system further to the left, multiplying "
"the :ref:`affine inverse <class_Transform2D_method_affine_inverse>` of a "
"transform results in a coordinate system further to the right:"
msgstr ""
"上圖顯示了一些可用的變換函式。所有變換都是從右向左的，這意味著將一個變換與一"
"個座標相乘會得到一個更靠左的坐標系，將一個變換的 :ref:`affine inverse "
"<class_Transform2D_method_affine_inverse>` 相乘會得到一個更靠右的坐標系："

msgid ""
"Finally, then, to convert a CanvasItem local coordinates to screen "
"coordinates, just multiply in the following order:"
msgstr "最後，要將 CanvasItem 本機座標轉換為螢幕座標，只需要以下列順序相乘："

msgid ""
"Keep in mind, however, that it is generally not desired to work with screen "
"coordinates. The recommended approach is to simply work in Canvas "
"coordinates (``CanvasItem.get_global_transform()``), to allow automatic "
"screen resolution resizing to work properly."
msgstr ""
"請記得，我們通常不會使用到螢幕座標。建議的做法是只要處理 Canvas 座標就好了 "
"(``CanvasItem.get_global_transform()``)，使用 Canvas 座標就可以自動處理好不同"
"的螢幕解析度縮放。"

msgid "Feeding custom input events"
msgstr "處理自定輸入事件"

msgid ""
"It is often desired to feed custom input events to the game. With the above "
"knowledge, to correctly do this in the focused window, it must be done the "
"following way:"
msgstr ""
"很多情況下我們會想將自定輸入事件提供給場景樹。有了上述知識，若要正確將自定輸"
"入事件提供給場景樹，則必須要通過下列方法："

msgid "Translation status"
msgstr "翻譯狀態"
