# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Optimizing Navigation Performance"
msgstr "最佳化建置檔案大小"

msgid ""
"Common Navigation related performance problems can be categorized into the "
"following topics:"
msgstr "常見的導覽相關效能問題可分為以下主題："

#, fuzzy
msgid ""
"Performance problems with parsing scene tree nodes for navigation mesh "
"baking."
msgstr "為導覽網格烘焙解析場景樹節點時的性能問題。"

msgid "Performance problems with baking the actual navigation mesh."
msgstr "烘焙實際導覽網格時的性能問題。"

msgid "Performance problems with NavigationAgent path queries."
msgstr "NavigationAgent 路徑查詢的性能問題。"

msgid "Performance problems with the actual path search."
msgstr "實際路徑搜索的性能問題。"

msgid "Performance problems with synchronizing the navigation map."
msgstr "同步導覽地圖的性能問題。"

msgid ""
"In the following sections information can be found on how to identify and "
"fix or at least mitigate their impact on framerates."
msgstr ""
"在以下部分中可以找到有關如何識別和修復或至少減輕其對影格速率的影響的資訊。"

#, fuzzy
msgid "Performance problems with parsing scene tree nodes"
msgstr "解析場景樹節點的性能問題"

msgid ""
"Prefer using simple shapes with as few edges as possible e.g. nothing "
"rounded like a circle, sphere or torus."
msgstr ""
"喜歡使用邊緣盡可能少的簡單形狀，例如，不要像圓形、球體或圓環那樣呈圓形。"

msgid ""
"Prefer using physics collision shapes over complex visual meshes as source "
"geometry as meshes need to be copied from the GPU and are commonly much more "
"detailed than necessary."
msgstr ""
"優先使用物理碰撞形狀而不是複雜的視覺網格作為來源幾何體，因為網格需要從 GPU 複"
"製，並且通常比必要的詳細得多。"

msgid ""
"In general avoid using very complex geometry as source geometry for baking "
"navigation meshes. E.g. never use a very detailed visual mesh, as parsing "
"its shape to data arrays and voxelizing it for the navigation mesh baking "
"will take a long time for no real quality gain on the final navigation mesh. "
"Instead, use a very simplified level of detail version of a shape. Even "
"better, use very primitive shapes like boxes and rectangles that only "
"roughly cover the same geometry but still yield a baked result good enough "
"for pathfinding."
msgstr ""
"一般來說，避免使用非常複雜的幾何體作為烘焙導覽網格的來源幾何體。例如，永遠不"
"要使用非常詳細的視覺網格，因為將其形狀解析為資料陣列並將其體素化以進行導覽網"
"格烘焙將花費很長時間，而不會在最終導覽網格上獲得真正的質量增益。相反，請使用"
"形狀的非常簡化的細節等級版本。更好的是，使用非常原始的形狀，例如盒子和矩形，"
"它們僅大致覆蓋相同的幾何形狀，但仍然會產生足夠好的路徑搜尋烘焙結果。"

msgid ""
"Prefer using simple physics collision shapes over visual meshes, as the "
"source geometry for baking navigation meshes. Physics shapes are by default "
"very limited and optimized shapes that are easy and quick to parse. A visual "
"mesh on the other hand can range from simple to complex. On top, to gain "
"access to visual mesh data the parser needs to request the mesh data arrays "
"from the RenderingServer as visual mesh data is stored directly on the GPU "
"and is not cached on the CPU. This requires locking the RenderingServer "
"thread and can severely impact framerate at runtime while the rendering runs "
"multi-threaded. If the rendering runs single-threaded, the framerate impact "
"might be even worse and the mesh parsing might freeze the entire game for a "
"few seconds on complex meshes."
msgstr ""
"喜歡使用簡單的物理碰撞形狀而不是視覺網格，作為烘焙導覽網格的來源幾何。預設情"
"況下，物理形狀是非常有限且經過最佳化的形狀，可以輕鬆快速地解析。另一方面，視"
"覺網格的範圍可以從簡單到複雜。最重要的是，為了存取視覺網格資料，解析器需要從"
"算繪伺服器請求網格資料陣列，因為視覺網格資料直接儲存在 GPU 上，而不是快取在 "
"CPU 上。這需要鎖定 RenderingServer 線程，並且在算繪以多線程運作時會嚴重影響運"
"作時的影格速率。如果算繪運作單線程，影格率影響可能會更嚴重，並且網格解析可能"
"會在複雜網格上凍結整個遊戲幾秒鐘。"

msgid "Performance problems with navigation mesh baking"
msgstr "烘焙導覽網格的性能問題"

msgid ""
"At runtime, always prefer to use a background thread for baking navigation "
"meshes."
msgstr "在運作時，總是更喜歡使用後台執行緒來烘焙導覽網格。"

msgid ""
"Increase NavigationMesh ``cell_size`` and ``cell_height`` to create less "
"voxels."
msgstr ""
"增加 NavigationMesh ``cell_size`` 和 ``cell_height`` 以建立較少的體素。"

msgid ""
"Change the ``SamplePartitionType`` from watershed to monotone or layers to "
"gain baking performance."
msgstr "將“SamplePartitionType”從分水嶺更改為單調或分層以獲得烘焙性能。"

msgid ""
"NEVER scale source geometry with nodes to avoid precision errors. Most scale "
"applies only visually and shapes that are very large at their base scale "
"require still a lot of extra processing even while downscaled."
msgstr ""
"切勿使用節點縮放源幾何體以避免精度錯誤。大多數比例僅適用於視覺，即使縮小比"
"例，在基本比例下非常大的形狀仍然需要大量額外的處理。"

msgid ""
"Baking navigation meshes at runtime should always be done in a background "
"thread if possible. Even small sized navigation meshes can take far longer "
"to bake than what is possible to squeeze into a single frame, at least if "
"the framerate should stay at a bearable level."
msgstr ""
"如果可能的話，在運作時烘焙導覽網格應該始終在後台執行緒中完成。即使是小尺寸的"
"導覽網格物體的烘焙時間也可能比擠入單個影格所需的時間長得多，至少在影格率保持"
"在可忍受的水平的情況下是如此。"

#, fuzzy
msgid ""
"Complexity of source geometry data parsed from scene tree nodes has big "
"impact on baking performance as everything needs to be mapped to a grid / "
"voxels. For runtime baking performance the NavigationMesh cell size and cell "
"height should be set as high as possible without causing navigation mesh "
"quality problems for a game. If cell size or cell height is set too low the "
"baking is forced to create an excessive amount of voxels to process the "
"source geometry. If the source geometry spans over a very large game world "
"it is even possible that the baking process runs out off memory in the "
"middle and crashes the game. The partition type can also be lowered "
"depending on how complex the games source geometry is to gain some "
"performance. E.g. games with mostly flat surfaces with blocky geometry can "
"get away with the monotone or layers mode that are a lot faster to bake (e."
"g. because they require no distance field pass)."
msgstr ""
"從SceneTree節點解析的源幾何資料的複雜度對烘焙性能有很大的影響，因為所有的資料"
"都需要對應到一個柵格/體素上。為了提高運作時的烘焙性能，NavigationMesh 的 "
"cell size 和 cell height 應該盡可能地設定得高，但不要造成遊戲中導覽網格品質的"
"問題。如果 cell size 或 cell height 設定得太低，烘焙過程就會被迫建立過多的體"
"素來處理源幾何資料。如果源幾何資料覆蓋了一個非常大的遊戲世界，甚至有可能在烘"
"焙過程中記憶體耗盡而導致遊戲當機。partition type 也可以根據遊戲中源幾何資料的"
"複雜度來降低，以提高一些性能。例如，有大量平坦表面和塊狀幾何的遊戲可以使用單"
"調或分層模式來烘焙，這些模式會快很多（例如，因為它們不需要距離場階段）。"

msgid ""
"Never scale source geometry with nodes. Not only can it result in a lot of "
"precision errors with wrongly matched vertices and edges but also some "
"scaling only exists as visuals and not in the actual parsed data. E.g. if a "
"mesh is downscaled visually in the Editor, e.g. the scale set to 0.001 on a "
"MeshInstance, the mesh still requires a gigantic and very complex voxel grid "
"to be processed for the baking."
msgstr ""
"切勿使用節點縮放源幾何。它不僅會導致大量精確度錯誤（頂點和邊配對錯誤），而且"
"某些縮放僅以視覺形式存在，而不存在於實際解析的資料中。例如，如果網格在編輯器"
"中以視覺方式縮小，例如在 MeshInstance 上將比例設為 0.001，則網格仍然需要巨大"
"且非常複雜的體素網格來處理烘焙。"

msgid "Performance problems with NavigationAgent path queries"
msgstr "NavigationAgent 路徑查詢的性能問題"

msgid ""
"Avoid unnecessary path resets and queries every frame in NavigationAgent "
"scripts."
msgstr "避免不必要的路徑重設並查詢 NavigationAgent 腳本中的每一影格。"

msgid "Avoid updating all NavigationAgent paths in the same frame."
msgstr "避免更新同一影格中的所有 NavigationAgent 路徑。"

msgid ""
"Logical errors and wasteful operations in the custom NavigationAgent scripts "
"are very common causes of performance issues, e.g. watch out for resetting "
"the path every single frame. By default NavigationAgents are optimized to "
"only query new paths when the target position changes, the navigation map "
"changes or they are forced too far away from the desired path distance."
msgstr ""
"自訂NavigationAgent 腳本中的邏輯錯誤和浪費性操作是導致效能問題的常見原因，例"
"如，請注意每影格重設路徑。預設情況下，NavigationAgents 經過最佳化，僅在目標位"
"置變更、導覽地圖變更或被迫遠離所需路徑距離時查詢新路徑。"

msgid ""
"E.g. when AI should move to the player, the target position should not be "
"set to the player position every single frame as this queries a new path "
"every frame. Instead, the distance from the current target position to the "
"player position should be compared and only when the player has moved too "
"far away a new target position should be set."
msgstr ""
"例如，當 AI 應移動到玩家時，目標位置不應每影格都設定為玩家位置，因為這會每影"
"格查詢新路徑。相反，應該比較從目前目標位置到玩家位置的距離，並且只有當玩家移"
"動得太遠時才應該設定新的目標位置。"

msgid ""
"Do not check beforehand if a target position is reachable every frame. What "
"looks like an innocent check is the equivalent of an expensive path query "
"behind the scene. If the plan is to request a new path anyway should the "
"position be reachable, a path should be queried directly. By looking at the "
"last position of the returned path and if that position is in a "
"\"reachable\" distance to the checked position it answers the \"is this "
"position reachable?\" question. This avoids doing the equivalent of two full "
"path queries every frame for the same NavigationAgent."
msgstr ""
"不要預先檢查每個畫面是否可以到達目標位置。看似無害的檢查實際上相當於幕後昂貴"
"的路徑查詢。如果計劃無論如何都要請求新路徑（如果位置可達），則應直接查詢路"
"徑。透過查看返迴路徑的最後一個位置，如果該位置距檢查位置處於“可到達”距離，則"
"它會回答“該位置是否可到達？”問題。這避免了對同一個 NavigationAgent 每影格執行"
"兩次完整路徑查詢的等效操作。"

msgid ""
"Divide the total number of NavigationAgents into update groups or use random "
"timers so that they do not all request new paths in the same frame."
msgstr ""
"將導覽代理程式的總數分割為更新組或使用隨機計時器，以便它們不會在同一影格中全"
"部請求新路徑。"

msgid "Performance problems with the actual path search"
msgstr "實際路徑搜索的性能問題"

msgid ""
"Optimize overdetailed navigation meshes by reducing the amount of polygons "
"and edges."
msgstr "透過減少多邊形和邊的數量來優化過於詳細的導覽網格。"

msgid ""
"The cost of the actual path search correlates directly with the amount of "
"navigation mesh polygons and edges and not the real size of a game world. If "
"a giant game world uses very optimized navigation meshes with only few "
"polygons that cover large areas, performance should be acceptable. If the "
"game world is splintered into very small navigation meshes that each have "
"tiny polygons (like for TileMaps) pathfinding performance will be reduced."
msgstr ""
"實際路徑搜尋的成本與導覽網格多邊形和邊緣的數量直接相關，而不是與遊戲世界的實"
"際大小相關。如果一個巨大的遊戲世界使用非常優化的導覽網格，只有少數多邊形覆蓋"
"大面積，那麼效能應該是可以接受的。如果遊戲世界被分割成非常小的導覽網格，每個"
"導覽網格都有微小的多邊形（如 TileMap），則尋路效能將會降低。"

msgid ""
"A common problem is a sudden performance drop when a target position is not "
"reachable in a path query. This performance drop is \"normal\" and the "
"result of a too large, too unoptimized navigation mesh with way to much "
"polygons and edges to search through. In normal path searches where the "
"target position can be reached quickly the pathfinding will do an early exit "
"as soon as the position is reached which can hide this lack of optimization "
"for a while. If the target position can not be reached the pathfinding has "
"to do a far longer search through the available polygons to confirm that the "
"position is absolutely not reachable."
msgstr ""
"一個常見問題是當路徑查詢中無法到達目標位置時效能突然下降。這種性能下降是“正常"
"的”，是導覽網格太大、未優化的結果，需要搜尋大量多邊形和邊緣。在可以快速到達目"
"標位置的正常路徑搜尋中，一旦到達該位置，尋路就會提前退出，這可以暫時隱藏這種"
"優化不足的情況。如果無法到達目標位置，則尋路必須對可用多邊形進行更長的搜索，"
"以確認該位置絕對無法到達。"

msgid "Performance problems with navigation map synchronization"
msgstr "導覽地圖同步的性能問題"

msgid ""
"Merge navigation meshes polygons by vertex instead of by edge connection "
"wherever possible."
msgstr "合併導覽盡可能透過頂點而不是邊連接來網格化多邊形。"

msgid ""
"When changes are made to e.g. navigation meshes or navigation regions, the "
"NavigationServer needs to synchronize the navigation map. Depending on the "
"complexity of navigation meshes, this can take a significant amount of time "
"which may impact the framerate."
msgstr ""
"當對導覽網格或導覽區域進行變更時，導覽伺服器需要同步導覽地圖。根據導覽網格的"
"複雜性，這可能需要大量時間，這可能會影響影格速率。"

msgid ""
"The NavigationServer merges navigation meshes either by vertex or by edge "
"connection. The merge by vertex happens when the two vertex of two different "
"edges land in the same map grid cells. This is a rather quick and low-cost "
"operation. The merge by edge connection happens in a second pass for all "
"still unmerged edges. All the free edges are checked for possible edge "
"connections by both distance and angle which is rather costly."
msgstr ""
"導覽伺服器透過頂點或邊連接合併導覽網格。當兩條不同邊的兩個頂點落在同一地圖網"
"格單元中時，就會發生以頂點合併。這是一個相當快速且低成本的操作。對於所有尚未"
"合併的邊，按邊連接進行合併發生在第二遍。透過距離和角度檢查所有自由邊緣是否有"
"可能的邊緣連接，這是相當昂貴的。"

msgid ""
"So apart from the general rule to have as few polygon edges as possible, as "
"many edges as possible should be merged by vertex upfront so only a few "
"edges are left for the more costly edge connection calculation. The debug "
"Navigation PerformanceMonitor can be used to get statistics on how many "
"polygons and edges are available and how many of them are unmerged or not "
"merged by vertex. If the ratio between vertex merged and edge connections is "
"way off (vertex should be significantly higher) the navigation meshes are "
"properly created or placed very inefficient."
msgstr ""
"因此，除了具有盡可能少的多邊形邊的一般規則之外，還應透過頂點預先合併盡可能多"
"的邊，以便只留下少量邊用於成本更高的邊連接計算。偵錯導覽效能監視器可用於取得"
"有關可用多邊形和邊的數量以及其中有多少未合併或未按頂點合併的統計資料。如果頂"
"點合併和邊連接之間的比率相差很大（頂點應該明顯更高），則導覽網格會正確建立或"
"放置得非常低效。"

msgid "Translation status"
msgstr "翻譯狀態"
