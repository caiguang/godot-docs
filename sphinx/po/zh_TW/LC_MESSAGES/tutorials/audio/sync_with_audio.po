# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Sync the gameplay with audio and music"
msgstr "同步遊戲音訊及音樂"

msgid "Introduction"
msgstr "前言"

msgid ""
"In any application or game, sound and music playback will have a slight "
"delay. For games, this delay is often so small that it is negligible. Sound "
"effects will come out a few milliseconds after any play() function is "
"called. For music this does not matter as in most games it does not interact "
"with the gameplay."
msgstr ""
"在任何應用程式或遊戲中, 聲音和音樂播放都會有輕微的延遲. 對於遊戲, 這種延遲往"
"往小到可以忽略不計. 在呼叫任意play()函式後, 聲音效果將在幾毫秒後出現. 對於音"
"樂來說這並不重要, 因為在大多數遊戲中它不會產生互動."

msgid ""
"Still, for some games (mainly, rhythm games), it may be required to "
"synchronize player actions with something happening in a song (usually in "
"sync with the BPM). For this, having more precise timing information for an "
"exact playback position is useful."
msgstr ""
"不過, 對於一些遊戲(主要是節奏遊戲), 可能會需要讓玩家的操作與歌曲中發生的事情"
"同步(通常與BPM同步). 因此, 得到一個具體播放位置的更精確的定時資訊就很有用了."

msgid ""
"Achieving very low playback timing precision is difficult. This is because "
"many factors are at play during audio playback:"
msgstr ""
"極其精准地定位播放時間是非常困難的. 因為在音訊重播過程中有很多因素在起作用:"

msgid ""
"Audio is mixed in chunks (not continuously), depending on the size of audio "
"buffers used (check latency in project settings)."
msgstr ""
"音訊以塊(不連續)的形式混合在一起, 具體取決於所使用的音訊緩衝區的大小(在專案設"
"定中檢查延遲)."

msgid "Mixed chunks of audio are not played immediately."
msgstr "混合的音訊塊不會立即播放."

msgid "Graphics APIs display two or three frames late."
msgstr "圖形應用程式介面延遲顯示兩到三影格."

msgid "When playing on TVs, some delay may be added due to image processing."
msgstr "當在電視上播放時, 由於影像處理可能會增加一些延遲."

msgid ""
"The most common way to reduce latency is to shrink the audio buffers (again, "
"by editing the latency setting in the project settings). The problem is that "
"when latency is too small, sound mixing will require considerably more CPU. "
"This increases the risk of skipping (a crack in sound because a mix callback "
"was lost)."
msgstr ""
"最常見的減少延遲的方法是縮小音訊緩衝區(同樣是通過編輯專案設定中的延遲設定). "
"問題是, 當延遲很小時, 聲音混合將佔用大量的CPU. 這就增加了跳音的風險(由於混合"
"回呼函式丟失, 導致聲音出現裂縫)."

msgid ""
"This is a common tradeoff, so Godot ships with sensible defaults that should "
"not need to be altered."
msgstr ""
"這是一種常見的折衷方案, 因此Godot附帶了合理的預設值. 一般這些預設值不需要更"
"改."

msgid ""
"The problem, in the end, is not this slight delay but synchronizing graphics "
"and audio for games that require it. Beginning with Godot 3.2, some helpers "
"were added to obtain more precise playback timing."
msgstr ""
"歸根結底, 問題並不在於這一點點的延遲, 而是同步遊戲的畫面和聲音. 從Godot 3.2開"
"始, 加入了一些輔助工具, 幫助獲取更精確的播放時間."

msgid "Using the system clock to sync"
msgstr "使用系統時鐘同步"

msgid ""
"As mentioned before, If you call :ref:`AudioStreamPlayer."
"play()<class_AudioStreamPlayer_method_play>`, sound will not begin "
"immediately, but when the audio thread processes the next chunk."
msgstr ""
"如前所述, 如果你呼叫 :ref:`AudioStreamPlayer."
"play()<class_AudioStreamPlayer_method_play>` , 聲音不會立即開始播放, 而是在音"
"訊執行緒下一個塊時開始."

msgid ""
"This delay can't be avoided but it can be estimated by calling :ref:"
"`AudioServer."
"get_time_to_next_mix()<class_AudioServer_method_get_time_to_next_mix>`."
msgstr ""
"這個延遲是無法避免的, 但是可以通過呼叫 :ref:`AudioServer."
"get_time_to_next_mix()<class_AudioServer_method_get_time_to_next_mix>` 來估"
"算."

msgid ""
"The output latency (what happens after the mix) can also be estimated by "
"calling :ref:`AudioServer."
"get_output_latency()<class_AudioServer_method_get_output_latency>`."
msgstr ""
"輸出延遲(混音後的情況)可以通過呼叫 :ref:`AudioServer."
"get_output_latency()<class_AudioServer_method_get_output_latency>` 來估算."

msgid ""
"Add these two and it's possible to guess almost exactly when sound or music "
"will begin playing in the speakers during *_process()*:"
msgstr ""
"把這兩樣加起來, 就可以幾乎準確地猜到 *_process()* 中的音效或音樂什麼時候開始"
"在揚聲器中播放:"

msgid ""
"In the long run, though, as the sound hardware clock is never exactly in "
"sync with the system clock, the timing information will slowly drift away."
msgstr ""
"然而, 從長遠來看, 由於聲音硬體時鐘從未與系統時鐘完全同步, 計時資訊會逐漸偏移."

msgid ""
"For a rhythm game where a song begins and ends after a few minutes, this "
"approach is fine (and it's the recommended approach). For a game where "
"playback can last a much longer time, the game will eventually go out of "
"sync and a different approach is needed."
msgstr ""
"在節奏遊戲中, 一首歌持續時長僅有幾分鐘, 這種方法就很適合(也是推薦的方法). 而"
"對於一款播放時間更長的遊戲來說, 遊戲最終將失去同步, 因此需要一種不同的方法."

msgid "Using the sound hardware clock to sync"
msgstr "使用聲音硬體時鐘同步"

msgid ""
"Using :ref:`AudioStreamPlayer."
"get_playback_position()<class_AudioStreamPlayer_method_get_playback_position>` "
"to obtain the current position for the song sounds ideal, but it's not that "
"useful as-is. This value will increment in chunks (every time the audio "
"callback mixed a block of sound), so many calls can return the same value. "
"Added to this, the value will be out of sync with the speakers too because "
"of the previously mentioned reasons."
msgstr ""
"雖然可以使用 :ref:`AudioStreamPlayer."
"get_playback_position()<class_AudioStreamPlayer_method_get_playback_position>` "
"來獲取歌曲的目前位置, 但實際並沒有那麼實用. 這個值(每逢音訊回呼函式混合一塊聲"
"音時)將以塊為單位遞增, 導致多次呼叫可能返回相同的值. 除此之外, 由於前面提到的"
"原因, 該值也將與揚聲器失去同步."

msgid ""
"To compensate for the \"chunked\" output, there is a function that can "
"help: :ref:`AudioServer."
"get_time_since_last_mix()<class_AudioServer_method_get_time_since_last_mix>`."
msgstr ""
"為了補償 \"chunked\"(分塊)輸出, 有個函式能有所説明: :ref:`AudioServer."
"get_time_since_last_mix()<class_AudioServer_method_get_time_since_last_mix>`."

msgid ""
"Adding the return value from this function to *get_playback_position()* "
"increases precision:"
msgstr "將這個函式的返回值與 *get_playback_position()* 相加可以提高精度:"

msgid ""
"To increase precision, subtract the latency information (how much it takes "
"for the audio to be heard after it was mixed):"
msgstr "為了提高精度, 減去延遲資訊(音訊從混合後到被聽見花費的時間):"

msgid ""
"The result may be a bit jittery due how multiple threads work. Just check "
"that the value is not less than in the previous frame (discard it if so). "
"This is also a less precise approach than the one before, but it will work "
"for songs of any length, or synchronizing anything (sound effects, as an "
"example) to music."
msgstr ""
"由於多執行緒的工作方式, 結果可能會有點輕微抖動. 只需檢查該值是否小於前一影格"
"中的值(如果小於, 則將其丟棄). 這個方法也不如之前的精確, 但它適用於任何長度的"
"歌曲, 或者將任何東西(例如音效)與音樂同步."

msgid "Here is the same code as before using this approach:"
msgstr "下面是使用這種方法之前相同的程式碼:"

msgid "Translation status"
msgstr "翻譯狀態"
