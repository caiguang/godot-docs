# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "High-level multiplayer"
msgstr "高級多人遊戲"

msgid "High-level vs low-level API"
msgstr "高階 API v.s. 低階 API"

msgid ""
"The following explains the differences of high- and low-level networking in "
"Godot as well as some fundamentals. If you want to jump in head-first and "
"add networking to your first nodes, skip to `Initializing the network`_ "
"below. But make sure to read the rest later on!"
msgstr ""
"以下為 Godot 中高階與低階網路的區別，以及一些基礎說明。若想直接將網路加到第一"
"個節點上，請跳至下方的 `初始化網路`_ 。但請記得等一下再回來讀剩下的部分！"

msgid ""
"Godot always supported standard low-level networking via :abbr:`UDP (User "
"Datagram Protocol)`, :abbr:`TCP (Transmission Control Protocol)` and some "
"higher-level protocols such as :abbr:`HTTP (Hypertext Transfer Protocol)` "
"and :abbr:`SSL (Secure Sockets Layer)`. These protocols are flexible and can "
"be used for almost anything. However, using them to synchronize game state "
"manually can be a large amount of work. Sometimes that work can't be avoided "
"or is worth it, for example when working with a custom server implementation "
"on the backend. But in most cases, it's worthwhile to consider Godot's high-"
"level networking API, which sacrifices some of the fine-grained control of "
"low-level networking for greater ease of use."
msgstr ""
"Godot 使用 UDP、TCP、與其他如 SSL 與 HTTP 等的高級通訊協定來支援標準低階網"
"路。這些通訊協定非常彈性，且幾乎可以用在任何地方。但是，要手動通過這些方法來"
"同步遊戲狀態可能會需要大量的工作。有時候，這種工作是無法避免的，例如要處理後"
"端的自定伺服器實作時。但大多數情況下，都建議考慮一下 Godot 的高階網路 API，使"
"用高階網路 API 只需要犧牲小部分的細節控制，就可以換來更好的易用性。"

msgid "This is due to the inherent limitations of the low-level protocols:"
msgstr "由於繼承了低階通訊協定的一些功能，因此："

msgid ""
"TCP ensures packets will always arrive reliably and in order, but latency is "
"generally higher due to error correction. It's also quite a complex protocol "
"because it understands what a \"connection\" is, and optimizes for goals "
"that often don't suit applications like multiplayer games. Packets are "
"buffered to be sent in larger batches, trading less per-packet overhead for "
"higher latency. This can be useful for things like HTTP, but generally not "
"for games. Some of this can be configured and disabled (e.g. by disabling "
"\"Nagle's algorithm\" for the TCP connection)."
msgstr ""
"TCP確保封包始終可靠且按順序到達，但是由於錯誤校正，延遲通常更高。這也是一個非"
"常複雜的協定，因為它了解什麼是“連接”，並最佳化了通常不適合用於多人遊戲的應用"
"程式。封包被緩衝成更大的批次發送，從而減少了每份封包的開銷，提高了延遲。這對"
"HTTP之類的東西可能很有用，但對遊戲通常不是。其中一些可以配置和禁用（例如禁用"
"TCP連接的Nagle演算法）。"

msgid ""
"UDP is a simpler protocol, which only sends packets (and has no concept of a "
"\"connection\"). No error correction makes it pretty quick (low latency), "
"but packets may be lost along the way or received in the wrong order. Added "
"to that, the MTU (maximum packet size) for UDP is generally low (only a few "
"hundred bytes), so transmitting larger packets means splitting them, "
"reorganizing them and retrying if a part fails."
msgstr ""
"UDP是一種更簡單的協定，它僅發送封包（並且沒有“連接”的概念）。沒有錯誤糾正可以"
"使其快速（低延遲），但是可能會丟失封包或以錯誤的順序接收封包。除此之外，UDP的"
"MTU（最大封包大小）通常很低（只有幾百個位元組），因此傳輸較大的封包意味著得將"
"其拆分、重組並在出現故障時重試。"

msgid ""
"In general, TCP can be thought of as reliable, ordered, and slow; UDP as "
"unreliable, unordered and fast. Because of the large difference in "
"performance, it often makes sense to re-build the parts of TCP wanted for "
"games (optional reliability and packet order), while avoiding the unwanted "
"parts (congestion/traffic control features, Nagle's algorithm, etc). Due to "
"this, most game engines come with such an implementation, and Godot is no "
"exception."
msgstr ""
"普遍來說，TCP可以被認為是可靠，有序且緩慢；UDP不可靠，無序且快速。由於性能上"
"的巨大差異，重新建構遊戲所需的TCP部分（可選的可靠性和封包順序），同時免去不必"
"要的部分（擁塞/流量控制功能，Nagle演算法等）是合理的。因此，大多數遊戲引擎都"
"提供了這樣的實作方式，Godot也不例外。"

msgid ""
"In summary, you can use the low-level networking API for maximum control and "
"implement everything on top of bare network protocols or use the high-level "
"API based on :ref:`SceneTree <class_SceneTree>` that does most of the heavy "
"lifting behind the scenes in a generally optimized way."
msgstr ""
"綜上所述, 您可以使用低級網路API來實作最大限度的控制, 並在完全裸露的網路通訊協"
"定之上實作所有功能, 或者使用基於 :ref:`SceneTree <class_SceneTree>` 的高級"
"API, 後者以通常以一種比較優化的方式在後臺完成大部分繁重的工作."

msgid ""
"Most of Godot's supported platforms offer all or most of the mentioned high- "
"and low-level networking features. As networking is always largely hardware "
"and operating system dependent, however, some features may change or not be "
"available on some target platforms. Most notably, the HTML5 platform "
"currently offers WebSockets and WebRTC support but lacks some of the higher-"
"level features, as well as raw access to low-level protocols like TCP and "
"UDP."
msgstr ""
"Godot 支援的大多數平臺都提供所有或大部分上述的高、低網路功能。但是，由於網路"
"在很大程度上依賴於硬體和作業系統，在某些目標平臺上一些功能可能會改變或者不可"
"用。最值得注意的是 HTML5 平臺目前只提供 WebSocket 和 WebRTC 支援，缺乏一些高"
"級功能，以及對 TCP 和 UDP 等低級協議的原始存取。"

msgid ""
"More about TCP/IP, UDP, and networking: https://gafferongames.com/post/"
"udp_vs_tcp/"
msgstr ""
"更多關於TCP/IP, UDP和網路的資訊: https://gafferongames.com/post/udp_vs_tcp/"

msgid ""
"Gaffer On Games has a lot of useful articles about networking in Games "
"(`here <https://gafferongames.com/categories/game-networking/>`__), "
"including the comprehensive `introduction to networking models in games "
"<https://gafferongames.com/post/"
"what_every_programmer_needs_to_know_about_game_networking/>`__."
msgstr ""
"Gaffer On Games有很多關於遊戲中網路的有用文章( `這裡 <https://gafferongames."
"com/categories/game-networking/>`__ ), 包括全面的 `遊戲中的網路模型介紹 "
"<https://gafferongames.com/post/"
"what_every_programmer_needs_to_know_about_game_networking/>`__ ."

msgid ""
"If you want to use your low-level networking library of choice instead of "
"Godot's built-in networking, see here for an example: https://github.com/"
"PerduGames/gdnet3"
msgstr ""
"如果您想使用您選擇的底層網路庫來代替Godot的內建網路, 請參閱這裡的範例 : "
"https://github.com/PerduGames/gdnet3"

msgid ""
"Adding networking to your game comes with some responsibility. It can make "
"your application vulnerable if done wrong and may lead to cheats or "
"exploits. It may even allow an attacker to compromise the machines your "
"application runs on and use your servers to send spam, attack others or "
"steal your users' data if they play your game."
msgstr ""
"在您的遊戲中加入社交網路需要承擔一定的責任. 如果做錯了, 它會使您的應用程式很"
"容易受到攻擊, 並可能導致欺騙或利用. 它甚至可能允許攻擊者破壞您的應用程式運作"
"在的機器, 並使用您的伺服器發送垃圾郵件, 攻擊其他人或竊取您的使用者資料, 如果"
"他們玩您的遊戲."

msgid ""
"This is always the case when networking is involved and has nothing to do "
"with Godot. You can of course experiment, but when you release a networked "
"application, always take care of any possible security concerns."
msgstr ""
"當涉及到網路而與Godot無關時, 情況總是如此. 當然, 您可以進行試驗, 但是在發行網"
"路應用程式時, 請始終注意任何可能的安全問題."

msgid "Mid-level abstraction"
msgstr "中級抽象"

msgid ""
"Before going into how we would like to synchronize a game across the "
"network, it can be helpful to understand how the base network API for "
"synchronization works."
msgstr ""
"在討論我們希望如何跨網路同步遊戲之前, 瞭解用於同步的基本網路API是如何工作的可"
"能會有所幫助."

msgid ""
"Godot uses a mid-level object :ref:`MultiplayerPeer "
"<class_MultiplayerPeer>`. This object is not meant to be created directly, "
"but is designed so that several C++ implementations can provide it."
msgstr ""
"Godot使用了一個中層物件 :ref:`NetworkedMultiplayerPeer "
"<class_NetworkedMultiplayerPeer>`. 這個物件並不是直接建立的, 但經過設計, 以便"
"多個C++實作可以提供它."

msgid ""
"This object extends from :ref:`PacketPeer <class_PacketPeer>`, so it "
"inherits all the useful methods for serializing, sending and receiving data. "
"On top of that, it adds methods to set a peer, transfer mode, etc. It also "
"includes signals that will let you know when peers connect or disconnect."
msgstr ""
"這個物件擴充自 :ref:`PacketPeer <class_PacketPeer>`, 因此它繼承了所有用於序列"
"化, 發送和接收資料的方法. 除此之外, 它還新增了設定節點, 傳輸模式等的方法. 它"
"同時還包括當節點連接或斷開時將通知您的訊號."

msgid ""
"This class interface can abstract most types of network layers, topologies "
"and libraries. By default, Godot provides an implementation based on ENet (:"
"ref:`ENetMultiplayerPeer <class_ENetMultiplayerPeer>`), one based on WebRTC "
"(:ref:`WebRTCMultiplayerPeer <class_WebRTCMultiplayerPeer>`), and one based "
"on WebSocket (:ref:`WebSocketPeer <class_WebSocketPeer>`), but this could be "
"used to implement mobile APIs (for ad hoc WiFi, Bluetooth) or custom device/"
"console-specific networking APIs."
msgstr ""
"這個類介面可以抽象出大多數型別的網路層, 拓撲結構和庫。預設情況下，Godot提供了"
"一個基於ENet的實作( :ref:`NetworkedMultiplayerEnet "
"<class_NetworkedMultiplayerENet>`), 一個基於WebRTC的實作( :ref:"
"`WebRTCMultiplayer <class_WebRTCMultiplayer>`), 還有一個基於WebSocket的實作"
"( :ref:`WebSocketMultiplayerPeer<class_WebSocketMultiplayerPeer>`)，但這可以"
"用來實作移動API(用於特設的WiFi, 藍牙)或自訂裝置/控制台特定的網路API。"

msgid ""
"For most common cases, using this object directly is discouraged, as Godot "
"provides even higher level networking facilities. This object is still made "
"available in case a game has specific needs for a lower-level API."
msgstr ""
"大多數常見情況下, 不鼓勵直接使用這個物件, 因為Godot提供了更高級別的網路使用. "
"只有當遊戲對較低級別的API有特殊需求的情況下, 才使用它."

msgid "Hosting considerations"
msgstr "其他建議"

msgid ""
"When hosting a server, clients on your :abbr:`LAN (Local Area Network)` can "
"connect using the internal IP address which is usually of the form ``192.168."
"*.*``. This internal IP address is **not** reachable by non-LAN/Internet "
"clients."
msgstr ""
"託管伺服器時，LAN（區域網路）上的使用者端可以使用內部 IP 位址進行連接，該位址"
"通常採用「192.168.*.*」形式。非 LAN/Internet 使用者端**無法**存取此內部 IP 位"
"址。"

msgid ""
"On Windows, you can find your internal IP address by opening a command "
"prompt and entering ``ipconfig``. On macOS, open a Terminal and enter "
"``ifconfig``. On Linux, open a terminal and enter ``ip addr``."
msgstr ""
"在 Windows 上，您可以透過開啟命令提示字元並輸入「ipconfig」來找到您的內部 IP "
"位址。在 macOS 上，開啟終端機並輸入「ifconfig」。在 Linux 上，打開終端機並輸"
"入“ip addr”。"

msgid ""
"If you're hosting a server on your own machine and want non-LAN clients to "
"connect to it, you'll probably have to *forward* the server port on your "
"router. This is required to make your server reachable from the Internet "
"since most residential connections use a `NAT <https://en.wikipedia.org/wiki/"
"Network_address_translation>`__. Godot's high-level multiplayer API only "
"uses UDP, so you must forward the port in UDP, not just TCP."
msgstr ""
"如果您在自己的電腦上託管伺服器並希望非 LAN 使用者端連接到它，您可能必須「轉"
"送」路由器上的伺服器連接埠。這是讓您的伺服器可以透過網路存取所必需的，因為大"
"多數住宅連線都使用「NAT <https://en.wikipedia.org/wiki/"
"Network_address_translation>」__。 Godot 的高級多人 API 僅使用 UDP，因此您必"
"須以 UDP 轉發端口，而不僅僅是 TCP。"

msgid ""
"After forwarding an UDP port and making sure your server uses that port, you "
"can use `this website <https://icanhazip.com/>`__ to find your public IP "
"address. Then give this public IP address to any Internet clients that wish "
"to connect to your server."
msgstr ""
"轉送 UDP 連接埠並確保您的伺服器使用該連接埠後，您可以使用「此網站 <https://"
"icanhazip.com/>」來尋找您的公用 IP 位址。然後將此公用 IP 位址提供給任何希望連"
"接到您的伺服器的 Internet 使用者端。"

msgid ""
"Godot's high-level multiplayer API uses a modified version of ENet which "
"allows for full IPv6 support."
msgstr "Godot 的高級多人 API 使用 ENet 的修改版本，它允許完全支援 IPv6。"

msgid "Initializing the network"
msgstr "初始化網路"

msgid ""
"High level networking in Godot is managed by the :ref:`SceneTree "
"<class_SceneTree>`."
msgstr ""
"在Godot中, 控制聯網的物件與控制所有與樹相關的東西的物件是相同的: :ref:"
"`SceneTree <class_SceneTree>`."

msgid ""
"Each node has a ``multiplayer`` property, which is a reference to the "
"``MultiplayerAPI`` instance configured for it by the scene tree. Initially, "
"every node is configured with the same default ``MultiplayerAPI`` object."
msgstr ""
"每個節點都有一個「multiplayer」屬性，它是對場景樹為其配置的「MultiplayerAPI」"
"實例的參考。最初，每個節點都配置相同的預設「MultiplayerAPI」物件。"

msgid ""
"It is possible to create a new ``MultiplayerAPI`` object and assign it to a "
"``NodePath`` in the the scene tree, which will override ``multiplayer`` for "
"the node at that path and all of its descendants. This allows sibling nodes "
"to be configured with different peers, which makes it possible to run a "
"server and a client simultaneously in one instance of Godot."
msgstr ""
"可以建立一個新的“MultiplayerAPI”物件並將其分配給場景樹中的“NodePath”，這將覆"
"蓋該路徑及其所有後代節點的“multiplayer”。這允許兄弟節點配置不同的對等點，從而"
"可以在一個 Godot 實例中同時執行伺服器和客戶端。"

msgid ""
"To initialize networking, a ``MultiplayerPeer`` object must be created, "
"initialized as a server or client, and passed to the ``MultiplayerAPI``."
msgstr ""
"要初始化網路，必須建立一個「MultiplayerPeer」對象，將其初始化為伺服器或客戶"
"端，然後傳遞給「MultiplayerAPI」。"

msgid "To terminate networking:"
msgstr "停止聯網功能:"

msgid ""
"When exporting to Android, make sure to enable the ``INTERNET`` permission "
"in the Android export preset before exporting the project or using one-click "
"deploy. Otherwise, network communication of any kind will be blocked by "
"Android."
msgstr ""
"當匯出到 Android 時，在匯出專案或使用一鍵部署之前，確保在 Android 匯出預設中"
"啟用 ``INTERNET`` 許可權。否則，任何形式的網路通信都會被 Android 系統阻止。"

msgid "Managing connections"
msgstr "管理連接"

msgid ""
"Every peer is assigned a unique ID. The server's ID is always 1, and clients "
"are assigned a random positive integer."
msgstr ""
"每個對等點都被分配了一個唯一的 ID。伺服器的 ID 始終為 1，並且為客戶端分配一個"
"隨機正整數。"

msgid ""
"Responding to connections or disconnections is possible by connecting to "
"``MultiplayerAPI``'s signals:"
msgstr "透過連接到「MultiplayerAPI」的訊號可以回應連接或斷開連接："

msgid ""
"``peer_connected(id: int)`` This signal is emitted with the newly connected "
"peer's ID on each other peer, and on the new peer multiple times, once with "
"each other peer's ID."
msgstr ""
"``peer_connected(id: int)`` 此訊號在每個其他對等點上與新連接的對等點ID 一起發"
"出，並在新對等點上多次發出，其中一次與每個其他對等點ID 一起發出。"

msgid ""
"``peer_disconnected(id: int)`` This signal is emitted on every remaining "
"peer when one disconnects."
msgstr ""
"``peer_disconnected(id: int)`` 當一個對等點斷開連接時，該訊號會在每個剩餘對等"
"點上發出。"

msgid "The rest are only emitted on clients:"
msgstr "有下列事項需注意："

msgid "``connected_to_server()``"
msgstr "``connected_to_server()``"

msgid "``connection_failed()``"
msgstr "``connection_failed()``"

msgid "``server_disconnected()``"
msgstr "``server_disconnected()``"

msgid "To get the unique ID of the associated peer:"
msgstr "若要取得關聯對等點的唯一 ID："

msgid "To check whether the peer is server or client:"
msgstr "檢查樹是否被初始化為伺服器或使用者端:"

msgid "Remote procedure calls"
msgstr "遠程程式呼叫"

msgid ""
"Remote procedure calls, or RPCs, are functions that can be called on other "
"peers. To create one, use the ``@rpc`` annotation before a function "
"definition. To call an RPC, use ``Callable``'s method ``rpc()`` to call in "
"every peer, or ``rpc_id()`` to call in a specific peer."
msgstr ""
"遠端過程呼叫（RPC）是可以在其他對等點上呼叫的函式。若要建立一個，請在函式定義"
"之前使用“@rpc”註解。若要呼叫 RPC，請使用 Callable 的方法 rpc() 來呼叫每個對等"
"點，或使用 rpc_id() 來呼叫特定對等點。"

msgid "RPCs will not serialize objects or callables."
msgstr "RPC 不會序列化物件或可呼叫物件。"

msgid ""
"For a remote call to be successful, the sending and receiving node need to "
"have the same ``NodePath``, which means they must have the same name. When "
"using ``add_child()`` for nodes which are expected to use RPCs, set the "
"argument ``force_readable_name`` to ``true``."
msgstr ""
"為了使遠端呼叫成功，發送節點和接收節點需要具有相同的“NodePath”，這意味著它們"
"必須具有相同的名稱。當對預期使用 RPC 的節點使用「add_child()」時，請將參數"
"「force_read_name」設為「true」。"

msgid ""
"If a function is annotated with ``@rpc`` on the client script (resp. server "
"script), then this function must also be declared on the server script "
"(resp. client script). Both RPCs must have the same signature which is "
"evaluated with a checksum of **all RPCs**. All RPCs in a script are checked "
"at once, and all RPCs must be declared on both the client scripts and the "
"server scripts, **even functions that are currently not in use**."
msgstr ""

msgid ""
"The signature of the RPC includes the ``@rpc()`` declaration, the function, "
"return type, AND the nodepath. If an RPC resides in a script attached to ``/"
"root/Main/Node1``, then it must reside in precisely the same path and node "
"on both the client script and the server script. Function arguments "
"(example: ``func sendstuff():`` and ``func sendstuff(arg1, arg2):`` **will "
"pass** signature matching)."
msgstr ""

msgid ""
"If these conditions are not met (if all RPCs do not pass signature "
"matching), the script may print an error or cause unwanted behavior. The "
"error message may be unrelated to the RPC function you are currently "
"building and testing."
msgstr ""

msgid ""
"See further explanation and troubleshooting on `this post <https://github."
"com/godotengine/godot/issues/57869#issuecomment-1034215138>`__."
msgstr ""

msgid ""
"The annotation can take a number of arguments, which have default values. "
"``@rpc`` is equivalent to:"
msgstr "註解可以採用多個參數，這些參數具有預設值。 ``@rpc`` 相當於："

msgid "The parameters and their functions are as follows:"
msgstr "常見的使用情景如下："

msgid "``mode``:"
msgstr "``mode``:"

msgid ""
"``\"authority\"``: Only the multiplayer authority (the server) can call "
"remotely."
msgstr "『「authority」『：只有多人權限（伺服器）才能遠端呼叫。"

msgid ""
"``\"any_peer\"``: Clients are allowed to call remotely. Useful for "
"transferring user input."
msgstr "``“any_peer”``：允許客戶端遠端呼叫。對於傳輸使用者輸入很有用。"

msgid "``sync``:"
msgstr "``sync``:"

msgid "``\"call_remote\"``: The function will not be called on the local peer."
msgstr "**注意**：如果引擎當機或無回應，該函式不會被呼叫。"

msgid ""
"``\"call_local\"``: The function can be called on the local peer. Useful "
"when the server is also a player."
msgstr ""
"``“call_local”``：可以在本地對等點上呼叫函式。當伺服器同時也是玩家時很有用。"

msgid "``transfer_mode``:"
msgstr "``transfer_mode``:"

msgid ""
"``\"unreliable\"`` Packets are not acknowledged, can be lost, and can arrive "
"at any order."
msgstr "``「不可靠」`` 封包未被確認，可能會遺失，並且可能以任何順序到達。"

msgid ""
"``\"unreliable_ordered\"`` Packets are received in the order they were sent "
"in. This is achieved by ignoring packets that arrive later if another that "
"was sent after them has already been received. Can cause packet loss if used "
"incorrectly."
msgstr ""
"``「unreliable_ordered」`` 封包按照發送的順序接收。這是透過忽略稍後到達的封包"
"（如果已經收到在它們之後發送的另一個封包）來實作的。如果使用不當可能會導致丟"
"包。"

msgid ""
"``\"reliable\"`` Resend attempts are sent until packets are acknowledged, "
"and their order is preserved. Has a significant performance penalty."
msgstr ""
"``「可靠」`` 發送重新傳送嘗試，直到封包被確認為止，並且它們的順序被保留。具有"
"顯著的性能損失。"

msgid "``transfer_channel`` is the channel index."
msgstr "``transfer_channel`` 是頻道索引。"

msgid ""
"The first 3 can be passed in any order, but ``transfer_channel`` must always "
"be last."
msgstr "前 3 個可以按任何順序傳遞，但「transfer_channel」必須始終是最後一個。"

msgid ""
"The function ``multiplayer.get_remote_sender_id()`` can be used to get the "
"unique id of an rpc sender, when used within the function called by rpc."
msgstr ""
"當在 rpc 呼叫的函式中使用時，函式「multiplayer.get_remote_sender_id()」可用於"
"取得 rpc 發送者的唯一 ID。"

msgid "Channels"
msgstr "改動"

msgid ""
"Modern networking protocols support channels, which are separate connections "
"within the connection. This allows for multiple streams of packets that do "
"not interfere with each other."
msgstr ""
"現代網路協定支援通道，通道是連接內的單獨連接。這允許多個封包流互不干擾。"

msgid ""
"For example, game chat related messages and some of the core gameplay "
"messages should all be sent reliably, but a gameplay message should not wait "
"for a chat message to be acknowledged. This can be achieved by using "
"different channels."
msgstr ""
"例如，遊戲聊天相關訊息和一些核心遊戲訊息都應該可靠地發送，但遊戲訊息不應等待"
"聊天訊息被確認。這可以透過使用不同的管道來實作。"

msgid ""
"Channels are also useful when used with the unreliable ordered transfer "
"mode. Sending packets of variable size with this transfer mode can cause "
"packet loss, since packets which are slower to arrive are ignored. "
"Separating them into multiple streams of homogeneous packets by using "
"channels allows ordered transfer with little packet loss, and without the "
"latency penalty caused by reliable mode."
msgstr ""
"當與不可靠的有序傳輸模式一起使用時，通道也很有用。使用此傳輸模式發送可變大小"
"的封包可能會導致封包遺失，因為到達較慢的封包將被忽略。透過使用通道將它們分成"
"多個同質封包流，可以實作有序傳輸，且封包遺失很少，並且不會因可靠模式而導致延"
"遲損失。"

#, fuzzy
msgid ""
"The default channel with index 0 is actually three different channels - one "
"for each transfer mode."
msgstr "索引為 0 的預設通道實際上是三個不同的通道 - 每個通道對應一種傳輸模式。"

msgid "Example lobby implementation"
msgstr "實作"

msgid ""
"This is an example lobby that can handle peers joining and leaving, notify "
"UI scenes through signals, and start the game after all clients have loaded "
"the game scene."
msgstr ""
"這是一個範例大廳，可以處理同伴的加入和離開，透過訊號通知UI場景，並在所有客戶"
"端載入遊戲場景後啟動遊戲。"

msgid ""
"The game scene's root node should be named Game. In the script attached to "
"it:"
msgstr "遊戲場景的根節點應命名為 Game。在附加的腳本中："

msgid "Exporting for dedicated servers"
msgstr "為專用伺服器匯出"

msgid ""
"Once you've made a multiplayer game, you may want to export it to run it on "
"a dedicated server with no GPU available. See :ref:"
"`doc_exporting_for_dedicated_servers` for more information."
msgstr ""
"一旦你製作了一個多人遊戲, 你可能會想匯出它到一個沒有GPU的專用伺服器上運作. 參"
"見 :ref:`doc_exporting_for_dedicated_servers` 獲取更多資訊."

msgid ""
"The code samples on this page aren't designed to run on a dedicated server. "
"You'll have to modify them so the server isn't considered to be a player. "
"You'll also have to modify the game starting mechanism so that the first "
"player who joins can start the game."
msgstr ""
"這個頁面上的程式碼樣本並不是為了在專用伺服器上運作而設計的. 必須修改它們, 使"
"伺服器不被認為是一個玩家, 還必須修改遊戲啟動機制, 使第一個加入的玩家可以啟動"
"遊戲."

msgid "Translation status"
msgstr "翻譯狀態"
