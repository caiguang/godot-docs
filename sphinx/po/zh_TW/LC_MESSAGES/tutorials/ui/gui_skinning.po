# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Introduction to GUI skinning"
msgstr "序言"

msgid ""
"It is essential for a game to provide clear, informative, and yet visually "
"pleasing user interface to its players. While :ref:`Control <class_Control>` "
"nodes come with a decently functional look out of the box, there is always "
"room for uniqueness and case-specific tuning. For this purpose Godot engine "
"includes a system for GUI skinning (or theming), which allows you to "
"customize the look of every control in your user interface, including your "
"custom controls."
msgstr ""
"遊戲必須為其玩家提供清晰、資訊豐富且視覺上令人愉悅的使用者介面。雖然 :ref:"
"`Control <class_Control>` 節點具有開箱即用的功能外觀，但始終有獨功能和特定於"
"案例的調整空間。為此，Godot 引擎包括一個用於 GUI 換膚（或主題化）的系統，它允"
"許您自訂使用者介面中每個控制項的外觀，包括您的自訂控制項。"

msgid ""
"Here is an example of this system in action — a game with the GUI that is "
"radically different from the default UI theme of the engine:"
msgstr ""
"下面是這個系統的一個例子—— 一個遊戲的 GUI 與引擎的預設 UI 主題完全不同："

msgid "A \"Gear Up!\" screen in Tank Kings, courtesy of Winterpixel Games"
msgstr "《坦克王》中的“裝備起來！”介面，由 Winterpixel Games 提供"

msgid ""
"Beyond achieving a unique look for your game, this system also enables "
"developers to provide customization options to the end users, including "
"accessibility settings. UI themes are applied in a cascading manner (i.e. "
"they propagate from parent controls to their children), which means that "
"font settings or adjustments for colorblind users can be applied in a single "
"place and affect the entire UI tree. Of course this system can also be used "
"for gameplay purposes: your hero-based game can change its style for the "
"selected player character, or you can give different flavors to the sides in "
"your team-based project."
msgstr ""
"除了為您的遊戲實作獨特的外觀外，該系統還使開發人員能夠為最終使用者提供自訂選"
"項，包括互動設定。 UI 主題以級聯方式應用（即從父控制項傳播到其子控制項），這"
"意味著色盲使用者的字形設定或調整，可以在從某處應用並影響整個 UI 樹。當然，這"
"個系統也可以用於遊戲：基於英雄的遊戲可以為選定的玩家角色改變其風格，或者您可"
"以為基於團隊的專案中的雙方賦予不同的風格。"

msgid "Basics of themes"
msgstr "主題基礎知識"

msgid ""
"The skinning system is driven by the :ref:`Theme <class_Theme>` resource. "
"Every Godot project has an inherent default theme that contains the settings "
"used by the built-in control nodes. This is what gives the controls their "
"distinct look out of the box. A theme only describes the configuration, "
"however, and it is still the job of each individual control to use that "
"configuration in the way it requires to display itself. This is important to "
"remember when implementing :ref:`your own custom controls "
"<doc_custom_gui_controls>`."
msgstr ""
"皮膚系統由 :ref:`Theme <class_Theme>` 資源驅動。每個 Godot 專案都有一個固有的"
"預設主題，其中包含內建控制節點使用的設定。這就是使控制項具有開箱即用的獨特外"
"觀的原因。然而，主題僅用於描述配置，並且每個單獨控制項的工作仍然是按照顯示自"
"身所需的方式使用該配置。在實作 :ref:`你自己的自訂控制項 "
"<doc_custom_gui_controls>`時要記住這一點很重要。"

msgid ""
"Even the Godot editor itself relies on the default theme. But it doesn't "
"look the same as a Godot project, because it applies its own heavily "
"customized theme on top of the default one. In principle, this works exactly "
"like it would in your game as explained :ref:`below "
"<doc_gui_theme_in_project>`."
msgstr ""
"甚至 Godot 編輯器本身也依賴於預設主題。但它看起來與 Godot 專案不同，因為它在"
"預設主題之上應用了自己高度定制的主題。原則上，這與在您的遊戲中的工作方式完全"
"相同，:ref:`如下所述 <doc_gui_theme_in_project>`。"

msgid "Theme items"
msgstr "主題"

msgid ""
"The configuration that is stored in a theme consists of theme items. Each "
"item has a unique name and must be one of the following data types:"
msgstr ""
"儲存在一個主題中的配置由主題專案組成。每個專案都有一個唯一的名稱，並且必須是"
"以下資料型別之一："

msgid "**Color**"
msgstr "**編輯器:**"

msgid ""
"A :ref:`color <class_Color>` value, which is often used for fonts and "
"backgrounds. Colors can also be used for modulation of controls and icons."
msgstr ""
":ref:`color <class_Color>` 值，通常用於字形和背景。顏色也可用於控制項和圖示的"
"調變。"

msgid "**Constant**"
msgstr "常數"

msgid ""
"An integer value, which can be used either for numeric properties of "
"controls (such as the item separation in a :ref:`BoxContainer "
"<class_BoxContainer>`), or for boolean flags (such as the drawing of "
"relationship lines in a :ref:`Tree <class_Tree>`)."
msgstr ""
"整型值，可用於控制項的數位型別屬性（例如 :ref:`BoxContainer "
"<class_BoxContainer>` 的間隙設定）或布林值標記（例如 :ref:`Tree "
"<class_Tree>` 中是否繪製關係線條）。"

msgid "**Font**"
msgstr "**霧：**"

msgid ""
"A :ref:`font <class_Font>` resource, which is used by controls that display "
"text. Fonts contain most text rendering settings, except for its size and "
"color. On top of that, alignment and text direction are controlled by "
"individual controls."
msgstr ""
"一個字形資源（:ref:`font <class_Font>`），常常被用於顯示控制項中的文字。字形"
"包含了許多算繪設定，像字形的大小和顏色。之後呢，用另一個單獨的控制項來控制對"
"齊屬性和文字方向。"

msgid "**Font size**"
msgstr "**霧：**"

msgid ""
"An integer value, which is used alongside a font to determine the size at "
"which the text should be displayed."
msgstr "一個整數值，與字形一起使用以確定文字的顯示大小。"

msgid "**Icon**"
msgstr "**版本**"

msgid ""
"A :ref:`texture <class_Texture2D>` resource, which is normally used to "
"display an icon (on a :ref:`Button <class_Button>`, for example)."
msgstr ""
"一個材質資源（:ref:`texture <class_Texture>`），通常用於顯示一個圖示或者圖片"
"（例如在按鈕中 :ref:`Button <class_Button>`）。"

msgid "**StyleBox**"
msgstr "**樣式**"

msgid ""
"A :ref:`StyleBox <class_StyleBox>` resource, a collection of configuration "
"options which define the way a UI panel should be displayed. This is not "
"limited to the :ref:`Panel <class_Panel>` control, as styleboxes are used by "
"many controls for their backgrounds and overlays."
msgstr ""
"一個樣式盒資源（:ref:`StyleBox <class_StyleBox>`），是一個用來定義一個UI面板"
"怎樣展示的配置項集合。不只是用於面板控制項（:ref:`Panel <class_Panel>`），它"
"還常常用於許多控制項的背景設定和遮罩設定。"

msgid "Theme types"
msgstr "有名稱的型別"

msgid ""
"To help with the organization of its items each theme is separated into "
"types, and each item must belong to a single type. In other words, each "
"theme item is defined by its name, its data type and its theme type. This "
"combination must be unique within the theme. For example, there cannot be "
"two color items named ``font_color`` in a type called ``Label``, but there "
"can be another ``font_color`` item in a type ``LineEdit``."
msgstr ""
"用來説明組織分配這些專案中每個主題該屬於哪些型別，並且每個專案只能屬於單個型"
"別。也就是說，用命名來定義每個主題專案，它是資料型別也是它的主題型別。這些組"
"合體中的主題必須是唯一的。例如，``Label`` 型別中不能有 2 個叫做 "
"``font_color`` 的顏色專案，但是在另一個 ``LineEdit`` 中可以出現 "
"``font_color`` 專案。"

msgid ""
"The default Godot theme comes with multiple theme types already defined, one "
"for every built-in control node that uses UI skinning. The example above "
"contains actual theme items present in the default theme. You can refer to "
"the **Theme Properties** section in the class reference for each control to "
"see which items are available to it and its child classes."
msgstr ""
"Godot 的預設主題誕生之初就已經定義了眾多的主題型別，它內建於每個使用了 UI 皮"
"膚的控制項節點中。在預設主題裡上述例子都是目前再用的主題專案。你可以在每個控"
"制項的類參考手冊中查看**主題屬性**區域看看哪些專案是父類和子類別都可用的。"

msgid ""
"Child classes can use theme items defined for their parent class (``Button`` "
"and its derivatives being a good example of that). In fact, every control "
"can use every theme item of any theme type, if it needs to (but for the "
"clarity and predictability we try to avoid that in the engine)."
msgstr ""
"子類別可以使用為其父類定義的主題項， ``Button`` 及其衍生型別就是很好實例。事"
"實上，如果需要的話，每個控制項都可以使用任何主題型別的單個主題項，但為了清晰"
"可控，在引擎中儘量避免這樣做。"

msgid ""
"It is important to remember that for child classes that process is "
"automated. Whenever a built-in control requests a theme item from the theme "
"it can omit the theme type, and its class name will be used instead. On top "
"of that, the class names of its parent classes will also be used in turn. "
"This allows changes to the parent class, such as ``Button``, to affect all "
"derived classes without the need to customize every one of them."
msgstr ""
"牢記子類別中，哪些過程是自動執行的很重要.不論什麼時候內建控制項在主題裡面請求"
"主題專案時，我們可以忽略主題型別僅通過它的類別名稱知悉。之後呢，下次時我們能"
"根據它的父級類別名稱來使用.可以通過改變父級類，例如 ``Button``，來影響所有衍"
"生類，而不是調整每一個類來實作。"

msgid ""
"You can also define your own theme types, and additionally customize both "
"built-in controls and your own controls. Because built-in controls have no "
"knowledge of your custom theme types, you must utilize scripts to access "
"those items. All control nodes have several methods that allow to fetch "
"theme items from the theme that is applied to them. Those methods accept the "
"theme type as one of the arguments."
msgstr ""
"你當然可以定義你自己的主題型別,並且此外你還可以自訂所有內建控制項和自建控制"
"項.因為內建控制項不會有你自訂主題的內容，所以你必須使用腳本把它們加入到這些專"
"案中.所有控制項節點都有一系列的方法可以用來把目前應用主題的主題專案都例遍出"
"來.這些方法通常是把主題型別做為一個可輸入參數."

msgid ""
"To give more customization opportunities types can also be linked together "
"as type variations. This is another use-case for custom theme types. For "
"example, a theme can contain a type ``Header`` which can be marked as a "
"variation of the base ``Label`` type. An individual ``Label`` control can "
"then be set to use the ``Header`` variation for its type, and every time a "
"theme item is requested from a theme this variation will be used before any "
"other type. This allows to store various presets of theme items for the same "
"class of the control node in the single ``Theme`` resource."
msgstr ""
"為了提供更多的自訂可能性，型別還能夠連結在一起成為變種。這是自訂主題型別的另"
"一種使用場景。例如，主題可以包含 ``Header`` 型別，標記為基礎 ``Label`` 型別的"
"變種。那麼各個 ``Label`` 控制項就可以將其型別設為使用 ``Header`` 變種，主題請"
"求主題專案的時候，這個變種都會先於其他型別使用。這樣就可以在同一個 ``Theme`` "
"資源裡為同樣使用某個類的控制項節點保存不同主題專案的預設值。"

msgid ""
"Only variations available from the default theme or defined in the custom "
"project theme are shown in the Inspector dock as options. You can still "
"input manually the name of a variation that is defined outside of those two "
"places, but it is recommended to keep all variations to the project theme."
msgstr ""
"只有預設主題或者自訂專案主題中的變種才會在“屬性面板”中列為可選項。在這兩處之"
"外定義的變種名稱仍然可以手動輸入，但是建議把所有變種都放到專案主題裡面。"

msgid ""
"You can learn more about creating and using theme type variations in a :ref:"
"`dedicated article <doc_gui_theme_type_variations>`."
msgstr ""
"你可以通過:ref:`專門的文章 <doc_gui_theme_type_variations>`瞭解到更多關於主題"
"型別變種的建立和使用的內容。"

msgid "Customizing a control"
msgstr "自訂控制項"

msgid ""
"Each control node can be customized directly without the use of themes. This "
"is called local overrides. Every theme property from the control's class "
"reference can be overridden directly on the control itself, using either the "
"Inspector dock, or scripts. This allows to make granular changes to a "
"particular part of the UI, while not affecting anything else in the project, "
"including this control's children."
msgstr ""
"可以不用主題直接對各個控制項節點進行自訂。這種方式稱為本地重載。控制項的類參"
"考手冊中列出的每個主題屬性，無論是通過屬性面板面板還是腳本，都可以在該控制項"
"上直接重載。這樣就可以針對 UI 中的特定部份進行精細的修改，不影響專案中包括該"
"控制項子類別在內的其他內容。"

msgid ""
"Local overrides are less useful for the visual flair of your user interface, "
"especially if you aim for consistency. However, for layout nodes these are "
"essential. Nodes such as :ref:`BoxContainer <class_BoxContainer>` and :ref:"
"`GridContainer <class_GridContainer>` use theme constants for defining "
"separation between their children, and :ref:`MarginContainer "
"<class_MarginContainer>` stores its customizable margins in its theme items."
msgstr ""
"本地重載對於提升使用者介面的美觀程度意義不大，如果你注重一致性的話就更是如"
"此。然而，本地重載對於佈局節點而言是不可或缺的。:ref:`BoxContainer "
"<class_BoxContainer>` 和 :ref:`GridContainer <class_GridContainer>` 等節點通"
"過主題常數定義其子節點的間隙大小，:ref:`MarginContainer "
"<class_MarginContainer>` 用主題專案來保存自訂邊距。"

msgid ""
"Whenever a control has a local theme item override, this is the value that "
"it uses. Values provided by the theme are ignored."
msgstr ""
"控制項存在本地主題專案重載時，會直接使用這個值，主題中所提供的值會被忽略。"

msgid "Customizing a project"
msgstr "建立專案"

msgid ""
"Out of the box each project adopts the default project theme provided by "
"Godot. The default theme itself is constant and cannot be changed, but its "
"items can be overridden with a custom theme. Custom themes can be applied in "
"two ways: as a project setting, and as a node property throughout the tree "
"of control nodes."
msgstr ""
"所有全新專案使用的都是 Godot 提供的預設專案主題。預設主題本身是常數，無法修"
"改，但可以通過自訂主題進行覆蓋。設定自訂主題有兩種方法：修改專案設定，或者修"
"改場景樹控制項節點的節點屬性。"

msgid ""
"There are two project settings that can be adjusted to affect your entire "
"project: :ref:`gui/theme/custom<class_ProjectSettings_property_gui/theme/"
"custom>` allows you to set a custom project-wide theme, and :ref:`gui/theme/"
"custom_font<class_ProjectSettings_property_gui/theme/custom_font>` does the "
"same to the default fallback font. When a theme item is requested by a "
"control node the custom project theme, if present, is checked first. Only if "
"it doesn't have the item the default theme is checked."
msgstr ""
"目前有2個計畫設定適用於你的整個計畫專案 ::ref:`gui/theme/"
"custom<class_ProjectSettings_property_gui/theme/custom>` 允許你設定一種自訂計"
"畫專案寬屏主題，並且 :ref:`gui/theme/"
"custom_font<class_ProjectSettings_property_gui/theme/custom_font>` 的功能和預"
"設的字形是一樣的。當一個自訂主題的控制項節點使用一個主題專案時，如果專案存在"
"它將被當先選中。只有當它不存在專案時，預設主題將被選中。"

msgid ""
"This allows you to configure the default look of every Godot control with a "
"single theme resource, but you can go more granular than that. Every control "
"node also has a :ref:`theme <class_Control_property_theme>` property, which "
"allows you to set a custom theme for the branch of nodes starting with that "
"control. This means that the control and all of its children, and their "
"children in turn, would first check that custom theme resource before "
"falling back on the project and the default themes."
msgstr ""
"在一個單獨的主題資源中，你可以設定所有 Godot 控制項的預設樣式與外觀,但是你可"
"以做更多的細節調整.每一個控制項節點同樣擁有一個:ref:`主題 "
"<class_Control_property_theme>`屬性，通過這個屬性你可以為一個控制項的所有節點"
"分支設定一個自訂的主題.那意味著那個控制項與其所有的子類別，和子類別的子類別，"
"在回滾目前專案和預設主題之前自訂主題的資源將第一個被檢查。"

msgid ""
"Instead of changing the project setting you can set the custom theme "
"resource to the root-most control node of your entire UI branch to almost "
"the same effect. While in the running project it will behave as expected, "
"individual scenes will still display using the default theme when previewing "
"or running them directly. To fix that you can set the same theme resource to "
"the root control of each individual scene."
msgstr ""
"計畫設定作為一種變化的替代手段，可以讓你通過設定自訂主題資源對幾乎整個UI分支"
"中的根控制項節點做出相同的影響. 然而運作計畫專案時可以充當預期效果展示,當單獨"
"場景直接預覽或者運作時還將使用預設主題展示。為了解決這個問題你可以為每一個單"
"獨場景中的根控制項設定相同的主題資源."

msgid ""
"For example, you can have a certain style for buttons in your project theme, "
"but want a different look for buttons inside of a popup dialog. You can set "
"a custom theme resource to the root control of your popup and define a "
"different style for buttons within that resource. As long as the chain of "
"control nodes between the root of the popup and the buttons is "
"uninterrupted, those buttons will use the styles defined in the theme "
"resource that is closest to them. All other controls will still be styled "
"using the project-wide theme and the default theme styles."
msgstr ""
"例如，你可以在專案主題中為按鈕設定特定的樣式，希望在彈出對話方塊中的按鈕又有"
"不同的外觀。你可以為快顯視窗的根控制項設定自訂主題資源，並在該資源中為按鈕定"
"義不同的樣式。只要快顯視窗的根控制項和按鈕之間的節點鏈不中斷，這些按鈕就會使"
"用最接近它們的主題資源中定義的樣式。所有其他控制項仍將使用整個專案的主題和預"
"設的主題樣式。"

msgid ""
"To sum it up, for an arbitrary control its theme item lookup would look "
"something like this:"
msgstr "寶石計數器看起來應該長這樣"

msgid "Check for local overrides of the same data type and name."
msgstr "檢查相同資料型別和名稱的本地重寫。"

msgid "Using control's type variation, class name and parent class names:"
msgstr "使用控制項的類別名稱和父類別名稱："

msgid ""
"Check every control starting from itself and see if it has a theme property "
"set;"
msgstr "從自身開始檢查每個控制項，看看它是否設定了主題屬性;"

msgid ""
"If it does, check that theme for the matching item of the same name, data "
"and theme type;"
msgstr "如果設定了，就在該主題中搜尋名稱、資料、主題型別都相同的專案;"

msgid ""
"If there is no custom theme or it doesn't have the item, move to the parent "
"control;"
msgstr "如果沒有自訂主題，或者主題中沒有配對的條目，就前往父控制項;"

msgid ""
"Repeat steps a-c. until the root of the tree is reached, or a non-control "
"node is reached."
msgstr "重複步驟 a 至 c，到場景樹的根節點或者非控制項節點為止。"

msgid ""
"Using control's type variation, class name and parent class names check the "
"project-wide theme, if it's present."
msgstr "如果存在專案範圍的主題，就在這個主題中搜尋控制項的類別名稱。"

msgid ""
"Using control's type variation, class name and parent class names check the "
"default theme."
msgstr "在預設主題中搜尋控制項的類別名稱。"

msgid ""
"Even if the item doesn't exist in any theme, a corresponding default value "
"for that data type will be returned."
msgstr "即便所有主題中都不存在對應的專案，也會返回一個針對該資料型別的預設值。"

msgid "Beyond controls"
msgstr "超越控制項"

msgid ""
"Naturally, themes are an ideal type of resource for storing configuration "
"for something visual. While the support for theming is built into control "
"nodes, other nodes can use them as well, just like any other resource."
msgstr ""
"主題是一種用來保存視覺效果配置的理想資源，也非常合理。雖然其他節點並沒有像控"
"制項節點一樣內建針對主題的支援，但還是可以和使用其他資源一樣來使用主題。"

msgid ""
"An example of using themes for something beyond controls can be a modulation "
"of sprites for the same units on different teams in a strategy game. A theme "
"resource can define a collection of colors, and sprites (with a help from "
"scripts) can use those colors to draw the texture. The main benefit being "
"that you could make different themes using the same theme items for red, "
"blue, and green teams, and swap them with a single resource change."
msgstr ""
"舉個非控制項使用主題的例子：在策略遊戲中，相同單位需要根據隊伍的不同而使用不"
"同顏色的精靈。可以在主題資源中定義顏色的合集，精靈（在腳本的幫助下）就可以使"
"用這些顏色來繪製紋理。這樣做的最大好處是可以為紅綠藍隊製作不同的主題但使用相"
"同的主題專案，切換隊伍只需要替換資源就可以了。"

msgid "Translation status"
msgstr "翻譯狀態"
