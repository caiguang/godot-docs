# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using Containers"
msgstr "使用容器"

#, fuzzy
msgid ""
":ref:`Anchors <doc_size_and_anchors>` are an efficient way to handle "
"different aspect ratios for basic multiple resolution handling in GUIs."
msgstr ""
":ref:`錨點 <doc_size_and_anchors>`是處理 GUI 中基本多解析度處理的不同縱橫比的"
"有效方法，"

msgid "For more complex user interfaces, they can become difficult to use."
msgstr "對於更複雜的使用者介面, 它們可能會變得難以使用."

msgid ""
"This is often the case of games, such as RPGs, online chats, tycoons or "
"simulations. Another common case where more advanced layout features may be "
"required is in-game tools (or simply just tools)."
msgstr ""
"這通常是遊戲的情況下, 如角色扮演類, 線上聊天, 大富翁類或模擬類遊戲. 另一個需"
"要更高級佈局功能的常見情況是遊戲內工具(或者僅僅是工具)."

msgid ""
"All these situations require a more capable OS-like user interface, with "
"advanced layout and formatting. For that, :ref:`Containers "
"<class_container>` are more useful."
msgstr ""
"這些情況需要一個更強大的類似作業系統的使用者介面，具有先進的佈局和格式。用 :"
"ref:`Container <class_container>` 會更方便。"

msgid "Container layout"
msgstr "容器佈局"

msgid ""
"Containers provide a huge amount of layout power (as an example, the Godot "
"editor user interface is entirely done using them):"
msgstr ""
"容器提供了巨大的佈局能力(例如,Godot編輯器的使用者介面就是完全使用它們完成的):"

msgid ""
"When a :ref:`Container <class_Container>`-derived node is used, all "
"children :ref:`Control <class_Control>` nodes give up their own positioning "
"ability. This means the *Container* will control their positioning and any "
"attempt to manually alter these nodes will be either ignored or invalidated "
"the next time their parent is resized."
msgstr ""
"當使用 :ref:`Container <class_Container>` 衍生的節點時，所有作為子項的 :ref:"
"`Control <class_Control>` 節點都會放棄自我定位能力。這意味著*容器*將控制它們"
"的位置，任何手動更改這些節點的嘗試，都將在它們的父節點下一次調整大小時被忽略"
"或失效。"

msgid ""
"Likewise, when a *Container* derived node is resized, all its children will "
"be re-positioned according to it, with a behavior based on the type of "
"container used:"
msgstr ""
"同樣，調整 *Container* 衍生節點的大小時，它的所有子節點都將根據它重新定位，其"
"行為基於所用的容器型別："

msgid "Example of *HBoxContainer* resizing children buttons."
msgstr "*HBoxContainer* 調整子按鈕大小的例子。"

msgid ""
"The real strength of containers is that they can be nested (as nodes), "
"allowing the creation of very complex layouts that resize effortlessly."
msgstr ""
"容器的真正優勢在於它們可以巢狀(作為節點), 允許建立非常複雜的佈局, 調整毫不費"
"力."

msgid "Sizing options"
msgstr "大小選項"

msgid ""
"When adding a node to a container, the way the container treats each child "
"depends mainly on their *container sizing options*. These options can be "
"found by inspecting the layout of any *Control* that is a child of a "
"*Container*."
msgstr ""
"當向容器新增節點時, 容器對待每個子元素的方式, 主要取決於它們的 *size flags尺"
"寸標記* . 通過檢查 *容器* 的子控制項, 可以找到這些標記."

msgid ""
"Sizing options are independent for vertical and horizontal sizing and not "
"all containers make use of them (but most do):"
msgstr ""
"尺寸標記獨立於垂直和水平尺寸, 並不是所有容器都使用它們(但大多數容器都使用):"

msgid ""
"**Fill**: Ensures the control *fills* the designated area within the "
"container. No matter if a control *expands* or not (see below), it will only "
"*fill* the designated area when this is toggled on (it is by default)."
msgstr ""
"**Fill填充** : 確保控制項 *fills填充* 容器內指定的區域. 無論控制項是否 "
"*expands擴充* (見下面), 當此選項被選中時(預設情況), 只 *填充* 指定區域."

msgid ""
"**Expand**: Attempts to use as much space as possible in the parent "
"container (in each axis). Controls that don't expand will be pushed away by "
"those that do. Between expanding controls, the amount of space they take "
"from each other is determined by the *Stretch Ratio* (see below). This "
"option is only available when the parent Container is of the right type, for "
"example the *HBoxContainer* has this option for horizontal sizing."
msgstr ""
"**Expand擴充** : 試圖在父容器中盡可能多地使用空間(在每個軸中). 不展開的控制項"
"會被展開的控制項推開. 在擴充的控制項之間, 它們相互佔用的空間大小由 *Ratio* 決"
"定(見下文)."

msgid ""
"**Shrink Begin** When expanding, try to remain at the left or top of the "
"expanded area."
msgstr ""
"**Shrink Center收縮中心** 當擴充時(如果不填充), 儘量保持在擴充區域的中心(預設"
"情況下, 它仍然位於左側或頂部)."

msgid ""
"**Shrink Center** When expanding, try to remain at the center of the "
"expanded area."
msgstr ""
"**Shrink Center收縮中心** 當擴充時(如果不填充), 儘量保持在擴充區域的中心(預設"
"情況下, 它仍然位於左側或頂部)."

msgid ""
"**Shrink End** When expanding, try to remain at the right or bottom of the "
"expanded area."
msgstr ""
"**Shrink Center收縮中心** 當擴充時(如果不填充), 儘量保持在擴充區域的中心(預設"
"情況下, 它仍然位於左側或頂部)."

msgid ""
"**Stretch Ratio**: The ratio of how much expanded controls take up the "
"available space in relation to each other. A control with \"2\", will take "
"up twice as much available space as one with \"1\"."
msgstr ""
"**Ratio比例** 擴充控制項之間, 相互佔用可用空間的簡單比例. 一個比例為 \"2\" 的"
"控制項, 將佔用比例為 \"1\" 控制項的兩倍可用空間."

msgid ""
"Experimenting with these flags and different containers is recommended to "
"get a better grasp on how they work."
msgstr "建議使用這些標記和不同的容器進行試驗, 以便更好地瞭解它們是如何工作的."

msgid "Container types"
msgstr "容器型別"

msgid ""
"Godot provides several container types out of the box as they serve "
"different purposes:"
msgstr "Godot提供了幾種開箱即用的容器型別, 因為它們有不同的用途:"

msgid "Box Containers"
msgstr "盒式容器"

msgid ""
"Arranges child controls vertically or horizontally (via :ref:`HBoxContainer "
"<class_HBoxContainer>` and :ref:`VBoxContainer <class_VBoxContainer>`). In "
"the opposite of the designated direction (as in, vertical for an horizontal "
"container), it just expands the children."
msgstr ""
"將子控制項垂直或者水平排列（使用 :ref:`HBoxContainer <class_HBoxContainer>` "
"和 :ref:`VBoxContainer <class_VBoxContainer>` ）。而在相對方向上（比如水平容"
"器的垂直方向），子節點會被擴充。"

msgid ""
"These containers make use of the *Ratio* property for children with the "
"*Expand* flag set."
msgstr ""
"這些容器會用到設定了 *Expand（擴充）* 選項的子節點的 *Ratio（比例）* 屬性。"

msgid "Grid Container"
msgstr "網格容器"

msgid ""
"Arranges child controls in a grid layout (via :ref:`GridContainer "
"<class_GridContainer>`, amount of columns must be specified). Uses both the "
"vertical and horizontal expand flags."
msgstr ""
"將子控制項按照網格排列（使用 :ref:`GridContainer <class_GridContainer>` ，必"
"須指定列數），會同時用到垂直和水平擴充選項。"

msgid "Margin Container"
msgstr "邊距容器"

msgid ""
"Child controls are expanded towards the bounds of this control (via :ref:"
"`MarginContainer <class_MarginContainer>`). Padding will be added on the "
"margins depending on the theme configuration."
msgstr ""
"將子節點擴充到該控制項的邊界（使用 :ref:`MarginContainer "
"<class_MarginContainer>` ），會根據主題的設定來新增不同大小的邊距。"

msgid ""
"Again, keep in mind that the margins are a *Theme* value, so they need to be "
"edited from the constants overrides section of each control:"
msgstr ""
"同樣, 請記住, 邊距是一個 *Theme* 值, 所以它們需要從每個控制項的常數重寫部分進"
"行編輯:"

msgid "Tab Container"
msgstr "分頁容器"

msgid ""
"Allows you to place several child controls stacked on top of each other "
"(via :ref:`TabContainer <class_TabContainer>`), with only the *current* one "
"visible."
msgstr ""
"允許你將多個子控制項堆疊在一起（使用 :ref:`TabContainer "
"<class_TabContainer>` ），只會顯示 *目前* 控制項。"

msgid ""
"Changing the *current* one is done via tabs located at the top of the "
"container, via clicking:"
msgstr "點擊容器頂部的分頁可以更改 *目前* 控制項："

msgid ""
"The titles are generated from the node names by default (although they can "
"be overridden via *TabContainer* API)."
msgstr ""
"標題預設是根據節點名稱生成的（儘管可以通過 *TabContainer* 的 API 重寫）。"

msgid ""
"Settings such as tab placement and *StyleBox* can be modified in the "
"*TabContainer* theme overrides."
msgstr ""
"可以在 *TabContainer* 的主題覆蓋項中修改類似分頁位置和 *StyleBox* 等設定。"

msgid "Split Container"
msgstr "拆分容器"

msgid ""
"Accepts only one or two children controls, then places them side to side "
"with a divisor (via :ref:`HSplitContainer <class_HSplitContainer>` and :ref:"
"`VSplitContainer <class_VSplitContainer>`). Respects both horizontal and "
"vertical flags, as well as *Ratio*."
msgstr ""
"只接受單個或者兩個子控制項，會將它們相鄰放置，中間是分隔線（使用 :ref:"
"`HSplitContainer <class_HSplitContainer>` 和 :ref:`VSplitContainer "
"<class_VSplitContainer>` ），會使用到水平和垂直選項以及 *Ratio* 屬性。"

msgid ""
"The divisor can be dragged around to change the size relation between both "
"children:"
msgstr "可以通過拖動分隔線來調整兩個子節點所占區域的大小："

msgid "PanelContainer"
msgstr "PanelContainer"

msgid ""
"A container that draws a *StyleBox*, then expands children to cover its "
"whole area (via :ref:`PanelContainer <class_PanelContainer>`, respecting the "
"*StyleBox* margins). It respects both the horizontal and vertical sizing "
"options."
msgstr ""
"繪製 *StyleBox* 的簡單容器，會將子節點擴大到整個區域（使用 :ref:"
"`PanelContainer <class_PanelContainer>`，會考慮 *StyleBox* 的邊距）。它同時考"
"慮水平和垂直尺寸旗標。"

msgid ""
"This container is useful as top-level, or just to add custom backgrounds to "
"sections of a layout."
msgstr "這個容器作為頂層非常有用, 或者只是為佈局各個部分新增自訂背景."

msgid "ScrollContainer"
msgstr "ScrollContainer"

msgid ""
"Accepts a single child node. If this node is bigger than the container, "
"scrollbars will be added to allow panning the node around (via :ref:"
"`ScrollContainer <class_ScrollContainer>`). Both vertical and horizontal "
"size options are respected, and the behavior can be turned on or off per "
"axis in the properties."
msgstr ""
"接受一個單獨的子節點. 如果這個節點比容器大, 將新增捲軸以允許移動節點（通過 :"
"ref:`ScrollContainer <class_ScrollContainer>`）。垂直和水平尺寸旗標都會被遵"
"守，該行為可以在屬性中的每個軸上打開或關閉."

msgid ""
"Mouse wheel and touch drag (when touch is available) are also valid ways to "
"pan the child control around."
msgstr "滑鼠滾輪和觸摸拖動(當觸摸可用時)也是平移子控制項的有效方法."

msgid ""
"As in the example above, one of the most common ways to use this container "
"is together with a *VBoxContainer* as child."
msgstr ""
"正如上面的例子中所展示的，使用此容器最常見的方法之一，是將 *VBoxContainer* 作"
"為子容器一起使用。"

#, fuzzy
msgid "AspectRatioContainer"
msgstr "建立內容"

msgid ""
"A container type that arranges its child controls in a way that preserves "
"their proportions automatically when the container is resized. (via :ref:"
"`AspectRatioContainer <class_AspectRatioContainer>`). It has multiple "
"stretch modes, providing options for adjusting the child controls' sizes "
"concerning the container: \"fill,\" \"width control height,\" \"height "
"control width,\" and \"cover.\""
msgstr ""

msgid ""
"useful when you have a container that needs to be dynamic and responsive to "
"different screen sizes, and you want the child elements to scale "
"proportionally without losing their intended shapes."
msgstr ""

#, fuzzy
msgid "FlowContainer"
msgstr "容器"

#, fuzzy
msgid ""
"FlowContainer is a container that arranges its child controls either "
"horizontally or vertically, (via :ref:`HFlowContainer "
"<class_HFlowContainer>` and via :ref:`VFlowContainer "
"<class_VFlowContainer>`). and when the available space runs out, it wraps "
"the children to the next line or column, similar to how text wraps in a book."
msgstr ""
"將子控制項垂直或者水平排列（使用 :ref:`HBoxContainer <class_HBoxContainer>` "
"和 :ref:`VBoxContainer <class_VBoxContainer>` ）。而在相對方向上（比如水平容"
"器的垂直方向），子節點會被擴充。"

msgid ""
"useful for creating flexible layouts where the child controls adjust "
"automatically to the available space without overlapping."
msgstr ""

#, fuzzy
msgid "CenterContainer"
msgstr "PanelContainer"

msgid ""
"CenterContainer is a container that automatically keeps all of its child "
"controls centered within it at their minimum size. It ensures that the child "
"controls are always aligned to the center, making it easier to create "
"centered layouts without manual positioning. (via :ref:`CenterContainer "
"<class_CenterContainer>`)."
msgstr ""

msgid "SubViewportContainer"
msgstr "建立內容"

msgid ""
"This is a special control that will only accept a single *Viewport* node as "
"child, and it will display it as if it was an image (via :ref:"
"`SubViewportContainer <class_SubViewportContainer>`)."
msgstr ""
"這是一個特殊的控制項，只接受單個 *Viewport* 節點作為子節點，並且會把它作為圖"
"片顯示（使用 :ref:`ViewportContainer <class_ViewportContainer>`）。"

msgid "Creating custom Containers"
msgstr "建立內容"

msgid ""
"It is possible to create a custom container using a script. Here is an "
"example of a container that fits children to its rect size:"
msgstr ""
"可以使用腳本輕鬆地建立自訂容器。下面是一個簡單容器的例子，它會根據自身的矩形"
"尺寸調整子節點："

msgid "Translation status"
msgstr "翻譯狀態"
