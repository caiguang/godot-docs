# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Kinematic character (2D)"
msgstr "運動學角色（2D）"

msgid "Introduction"
msgstr "前言"

msgid ""
"Yes, the name sounds strange. \"Kinematic Character\". What is that? The "
"reason for the name is that, when physics engines came out, they were called "
"\"Dynamics\" engines (because they dealt mainly with collision responses). "
"Many attempts were made to create a character controller using the dynamics "
"engines, but it wasn't as easy as it seemed. Godot has one of the best "
"implementations of dynamic character controller you can find (as it can be "
"seen in the 2d/platformer demo), but using it requires a considerable level "
"of skill and understanding of physics engines (or a lot of patience with "
"trial and error)."
msgstr ""
"是的，名字聽起來很奇怪。“運動學角色”是什麼東西？使用這個名稱的原因是物理引擎"
"問世之處，它們被稱為“動力學（Dynamics）”引擎（因為它們主要處理碰撞回應）。人"
"們做了許多嘗試，想使用動力學引擎建立角色控制器，但它並不像看起來那麼容易。"
"Godot 擁有您能找到的最好的動力學角色控制器（可以在 2d/platformer 演示中查"
"看），但使用它需要相當高水平的技能和對物理引擎的理解（或者對試驗和試錯有足夠"
"的耐心）。"

msgid ""
"Some physics engines, such as Havok seem to swear by dynamic character "
"controllers as the best option, while others (PhysX) would rather promote "
"the kinematic one."
msgstr ""
"像 Havok 這樣的物理引擎似乎認為力學角色控制器是最好的選擇，而其他物理引擎"
"（PhysX）則更願意推廣運動學（Kinematic）的角色控制器。"

msgid "So, what is the difference?:"
msgstr "那麼區別是什麼呢？："

msgid ""
"A **dynamic character controller** uses a rigid body with an infinite "
"inertia tensor. It's a rigid body that can't rotate. Physics engines always "
"let objects move and collide, then solve their collisions all together. This "
"makes dynamic character controllers able to interact with other physics "
"objects seamlessly, as seen in the platformer demo. However, these "
"interactions are not always predictable. Collisions can take more than one "
"frame to be solved, so a few collisions may seem to displace a tiny bit. "
"Those problems can be fixed, but require a certain amount of skill."
msgstr ""
"**動力學角色控制器**使用的是一個具有無限慣性張量的剛體。這是一個不能旋轉的剛"
"體. 物理引擎總是讓物體移動和碰撞, 然後一併解決它們的碰撞. 這使得動態角色控制"
"器能夠與其他物理物件無縫互動, 就像在平臺遊戲演示中看到的那樣. 然而, 這些互動"
"並不總是可預測的. 碰撞可能需要多於一影格的時間來解決, 所以幾個碰撞可能看起來"
"會有很小的位移. 這些問題是可以解決的, 但需要一定的技巧."

msgid ""
"A **kinematic character controller** is assumed to always begin in a non-"
"colliding state, and will always move to a non-colliding state. If it starts "
"in a colliding state, it will try to free itself like rigid bodies do, but "
"this is the exception, not the rule. This makes their control and motion a "
"lot more predictable and easier to program. However, as a downside, they "
"can't directly interact with other physics objects, unless done by hand in "
"code."
msgstr ""
"**運動學角色控制器**總是假設以非碰撞狀態開始，並將總是移動到非碰撞狀態。如果"
"它開始時處於碰撞狀態, 將像剛體一樣嘗試釋放自己, 但這是特例, 而不是規則. 這使"
"得它們的控制和運動更可預測, 更容易程式設計. 然而, 有一個缺點, 它們不能直接與"
"其他物理物件互動, 除非在程式碼中手動完成."

msgid ""
"This short tutorial focuses on the kinematic character controller. It uses "
"the old-school way of handling collisions, which is not necessarily simpler "
"under the hood, but well hidden and presented as an API."
msgstr ""
"這個簡短的教學將重點介紹運動學角色控制器。基本上，傳統處理衝突的方法（它並不"
"一定在底層更簡單，但隱蔽性很好，並且呈現為一個簡潔漂亮的 API）。"

msgid "Physics process"
msgstr "物理過程處理"

msgid ""
"To manage the logic of a kinematic body or character, it is always advised "
"to use physics process, because it's called before physics step and its "
"execution is in sync with physics server, also it is called the same amount "
"of times per second, always. This makes physics and motion calculation work "
"in a more predictable way than using regular process, which might have "
"spikes or lose precision if the frame rate is too high or too low."
msgstr ""
"為了管理運動物體或角色的邏輯, 總是建議使用物理過程處理, 因為它在物理步驟之前"
"被呼叫並且它的執行與物理伺服器同步, 它也被以被每秒相同的次數呼叫. 這使得物理"
"和運動計算以比使用常規過程處理更可預測的方式工作, 如果畫面播放速率太高或太"
"低, 則可能具有尖峰或丟失精度."

msgid "Scene setup"
msgstr "場景設定"

msgid ""
"To have something to test, here's the scene (from the tilemap tutorial): "
"`kinematic_character_2d_starter.zip <https://github.com/godotengine/godot-"
"docs-project-starters/releases/download/latest-4.x/"
"kinematic_character_2d_starter.zip>`_. We'll be creating a new scene for the "
"character. Use the robot sprite and create a scene like this:"
msgstr ""
"要進行測試, 這裡有場景(來自tilemap教學): :download:`kbscene.zip <files/"
"kbscene.zip>`. 我們將為角色創造一個新場景. 使用機器人精靈並建立一個這樣的場"
"景:"

msgid ""
"You'll notice that there's a warning icon next to our CollisionShape2D node; "
"that's because we haven't defined a shape for it. Create a new CircleShape2D "
"in the shape property of CollisionShape2D. Click on <CircleShape2D> to go to "
"the options for it, and set the radius to 30:"
msgstr ""
"您會注意到, 在 \"二維碰撞形狀 \"(CollisionShape2D)節點旁邊有一個警告圖示；那"
"是因為我們還沒有定義它的形狀. 在\" 二維碰撞形狀\"(CollisionShape2D)的形狀屬性"
"中建立一個新的二維圓形形狀(CircleShape2D). 點擊 <二維圓形形狀>(CircleShape2D)"
"進入選項, 將半徑設定為30:"

msgid ""
"**Note: As mentioned before in the physics tutorial, the physics engine "
"can't handle scale on most types of shapes (only collision polygons, planes "
"and segments work), so always change the parameters (such as radius) of the "
"shape instead of scaling it. The same is also true for the kinematic/rigid/"
"static bodies themselves, as their scale affects the shape scale.**"
msgstr ""
"**注意: 正如之前在物理教學中提到的, 物理引擎無法處理大多數型別形狀的縮放, 只"
"有碰撞多邊形, 平面和段才有效, 所以, 總是改變形狀的半徑等參數, 而不是縮放它. "
"對於運動體或剛性體或靜態體本身也是如此, 因為它們的比例會影響形狀的比例.**"

msgid ""
"Now, create a script for the character, the one used as an example above "
"should work as a base."
msgstr "現在, 為這個角色建立一個腳本, 上面作為例子的那個腳本可以作為基礎."

msgid ""
"Finally, instance that character scene in the tilemap, and make the map "
"scene the main one, so it runs when pressing play."
msgstr ""
"最後, 產生實體tilemap中的角色場景, 並使地圖場景成為主場景, 因此在按下播放時運"
"作."

msgid "Moving the kinematic character"
msgstr "移動動態角色"

msgid ""
"Go back to the character scene, and open the script, the magic begins now! "
"Kinematic body will do nothing by default, but it has a useful function "
"called ``CharacterBody2D.move_and_collide()``. This function takes a :ref:"
"`Vector2 <class_Vector2>` as an argument, and tries to apply that motion to "
"the kinematic body. If a collision happens, it stops right at the moment of "
"the collision."
msgstr ""
"回到角色場景, 打開腳本, 魔法開始了!動態物體預設不會做任何事情, 但它有一個有用"
"的函式, 叫做 :ref:`KinematicBody2D.move_and_collide() "
"<class_KinematicBody2D_method_move_and_collide>` . 該函式以一個 :ref:"
"`Vector2 <class_Vector2>` 作為參數, 並嘗試將該運動應用到動態物體. 如果發生了"
"碰撞, 它就在碰撞的瞬間停止."

msgid "So, let's move our sprite downwards until it hits the floor:"
msgstr "所以, 讓我們向下移動我們的精靈, 直到它撞上地板:"

msgid ""
"The result is that the character will move, but stop right when hitting the "
"floor. Pretty cool, huh?"
msgstr "結果是角色會移動, 但在擊中地板時會停止. 很酷, 對吧？"

msgid ""
"The next step will be adding gravity to the mix, this way it behaves a "
"little more like a regular game character:"
msgstr "下一步將加入重力, 這樣一來, 它的行為就更像一個常規的遊戲角色:"

msgid ""
"Now the character falls smoothly. Let's make it walk to the sides, left and "
"right when touching the directional keys. Remember that the values being "
"used (for speed at least) are pixels/second."
msgstr ""
"現在人物平滑下落. 我們讓它向兩邊行走, 在按下方向鍵時向左或向右. 記住, 正在使"
"用的值(至少對於速度)單位是像素/秒."

msgid "This adds basic support for walking when pressing left and right:"
msgstr "通過向左和向右按下可以增加簡單的步行支援:"

msgid "And give it a try."
msgstr "試一試."

msgid ""
"This is a good starting point for a platformer. A more complete demo can be "
"found in the demo zip distributed with the engine, or in the https://github."
"com/godotengine/godot-demo-projects/tree/master/2d/kinematic_character."
msgstr ""
"這是平臺遊戲的良好起點. 可以在隨引擎分發的演示zip中找到更完整的演示, 或者在"
"https://github.com/godotengine/godot-demo-projects/tree/master/2d/"
"kinematic_character中找到."

msgid "Translation status"
msgstr "翻譯狀態"
