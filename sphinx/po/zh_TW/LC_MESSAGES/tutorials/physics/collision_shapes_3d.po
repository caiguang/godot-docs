# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Collision shapes (3D)"
msgstr "碰撞形體"

msgid "This guide explains:"
msgstr "本指南解釋："

msgid "The types of collision shapes available in 3D in Godot."
msgstr "Godot 3D 中可用的碰撞形狀型別。"

msgid "Using a convex or a concave mesh as a collision shape."
msgstr "使用凸形或凹形網格作為碰撞形狀."

msgid "Performance considerations regarding 3D collisions."
msgstr "執行效能偵測"

msgid ""
"Godot provides many kinds of collision shapes, with different performance "
"and accuracy tradeoffs."
msgstr "Godot提供多種碰撞形狀, 具有不同的性能和精度權衡."

msgid ""
"You can define the shape of a :ref:`class_PhysicsBody3D` by adding one or "
"more :ref:`CollisionShape3Ds <class_CollisionShape3D>` as child nodes. Note "
"that you must add a :ref:`class_Shape3D` *resource* to collision shape nodes "
"in the Inspector dock."
msgstr ""
"您可以通過新增一個或多個 :ref:`class_PhysicsBody` 作為子節點來定義 :ref:"
"`CollisionShapes <class_CollisionShape>` 的形狀。請注意，你必須在屬性面板面板"
"中為碰撞形狀節點新增一個 :ref:`class_Shape` *資源*。"

msgid ""
"When you add multiple collision shapes to a single PhysicsBody, you don't "
"have to worry about them overlapping. They won't \"collide\" with each other."
msgstr ""
"當你將多個碰撞形狀新增到一個PhysicsBody中時, 你不必擔心它們會重疊, 它們不會相"
"互 \"碰撞\"."

msgid "Primitive collision shapes"
msgstr "顯示碰撞區域"

msgid "Godot provides the following primitive collision shape types:"
msgstr "Godot 可匯入下列圖片格式："

msgid ":ref:`class_BoxShape3D`"
msgstr ":ref:`Basis <class_Basis>`"

msgid ":ref:`class_SphereShape3D`"
msgstr ":ref:`Plane <class_Plane>`"

msgid ":ref:`class_CapsuleShape3D`"
msgstr ":ref:`Plane <class_Plane>`"

msgid ":ref:`class_CylinderShape3D`"
msgstr ":ref:`Plane <class_Plane>`"

msgid ""
"You can represent the collision of most smaller objects using one or more "
"primitive shapes. However, for more complex objects, such as a large ship or "
"a whole level, you may need convex or concave shapes instead. More on that "
"below."
msgstr ""
"您可以使用一個或多個原始形狀來表示大多數較小物體的碰撞. 然而, 對於更複雜的物"
"體, 如大型船舶或整個水平面, 你可能需要凸形或凹形來代替. 下面會有更多的介紹."

#, fuzzy
msgid ""
"We recommend favoring primitive shapes for dynamic objects such as "
"RigidBodies and CharacterBodies as their behavior is the most reliable. They "
"often provide better performance as well."
msgstr ""
"建議動態物件使用原始形狀, 如 RigidBodies 和 KinematicBodies, 因為它們的行為是"
"可靠的, 通常也能提供更好的性能."

msgid "Convex collision shapes"
msgstr "碰撞形體"

msgid ""
":ref:`Convex collision shapes <class_ConvexPolygonShape3D>` are a compromise "
"between primitive collision shapes and concave collision shapes. They can "
"represent shapes of any complexity, but with an important caveat. As their "
"name implies, an individual shape can only represent a *convex* shape. For "
"instance, a pyramid is *convex*, but a hollow box is *concave*. To define a "
"concave object with a single collision shape, you need to use a concave "
"collision shape."
msgstr ""
":ref:`凸形碰撞形狀 <class_ConvexPolygonShape>` 是基礎碰撞形狀和凹形碰撞形狀之"
"間的折衷, 可以表示任何複雜的形狀, 但要警告的是, 正如名稱所示, 一個單獨的形狀"
"只能表示一個 *凸* 的形狀. 要用單個碰撞形狀定義一個凹形物件, 需要使用一個凹形"
"碰撞形狀. 例如, 一個金字塔是 *凸* 的, 但一個空心盒子是 *凹* 的."

msgid ""
"Depending on the object's complexity, you may get better performance by "
"using multiple convex shapes instead of a concave collision shape. Godot "
"lets you use *convex decomposition* to generate convex shapes that roughly "
"match a hollow object. Note this performance advantage no longer applies "
"after a certain amount of convex shapes. For large and complex objects such "
"as a whole level, we recommend using concave shapes instead."
msgstr ""
"根據物件的複雜程度, 可能要通過使用多個凸形而不是一個凹形碰撞形狀來獲得更好的"
"性能.Godot可以使用 *凸分解* 來生成與空心物體大致配對的凸形. 請注意, 在一定數"
"量的凸形之後, 就沒有了這種性能優勢, 對於大而複雜的物件, 如整個關卡, 建議使用"
"凹形代替."

msgid ""
"You can generate one or several convex collision shapes from the editor by "
"selecting a MeshInstance3D and using the **Mesh** menu at the top of the 3D "
"viewport. The editor exposes two generation modes:"
msgstr ""
"您可以通過選擇一個網格實例, 並使用3D視圖頂部的 **網格** 功能表從編輯器中生成"
"一個或多個凸形碰撞形狀. 編輯器有兩種生成模式:"

msgid ""
"**Create Single Convex Collision Sibling** uses the Quickhull algorithm. It "
"creates one CollisionShape node with an automatically generated convex "
"collision shape. Since it only generates a single shape, it provides good "
"performance and is ideal for small objects."
msgstr ""
"**建立單凸碰撞同級** 使用Quickhull演算法, 建立一個CollisionShape碰撞形狀節"
"點, 並自動生成一個凸碰撞形狀, 由於只生成單個形狀, 因此提供了良好的性能, 非常"
"適合小物件."

msgid ""
"**Create Multiple Convex Collision Siblings** uses the V-HACD algorithm. It "
"creates several CollisionShape nodes, each with a convex shape. Since it "
"generates multiple shapes, it is more accurate for concave objects at the "
"cost of performance. For objects with medium complexity, it will likely be "
"faster than using a single concave collision shape."
msgstr ""
"**建立多個凸形碰撞同級** 使用V-HACD演算法. 建立多個CollisionShape碰撞形狀節"
"點, 每個節點都有一個凸形, 由於它能生成多個形狀, 所以對於凹形物體來說, 精度更"
"高, 但性能不佳. 對於中等複雜度的物件, 可能會比使用單個凹形碰撞形狀更快."

msgid "Concave or trimesh collision shapes"
msgstr "碰撞形體"

#, fuzzy
msgid ""
":ref:`Concave collision shapes <class_ConcavePolygonShape3D>`, also called "
"trimesh collision shapes, can take any form, from a few triangles to "
"thousands of triangles. Concave shapes are the slowest option but are also "
"the most accurate in Godot. **You can only use concave shapes within "
"StaticBodies.** They will not work with CharacterBodies or RigidBodies "
"unless the RigidBody's mode is Static."
msgstr ""
":ref:`凹形碰撞形狀 <class_ConcavePolygonShape>`, 也稱為三角碰撞形狀, 可以採取"
"任何形式, 從幾個到數千個三角形, 凹形是最慢的選擇, 但也是Godot中最精確的.**除"
"非剛體的模式是靜態的, 否則它不能用於KinematicBodies動態體或RigidBodies剛體."

msgid ""
"Even though concave shapes offer the most accurate *collision*, contact "
"reporting can be less precise than primitive shapes."
msgstr "即使凹形提供了最準確的 *碰撞*, 但觸碰資訊的精度可能不如基礎形狀."

msgid ""
"When not using GridMaps for level design, concave shapes are the best "
"approach for a level's collision. That said, if your level has small "
"details, you may want to exclude those from collision for performance and "
"game feel. To do so, you can build a simplified collision mesh in a 3D "
"modeler and have Godot generate a collision shape for it automatically. More "
"on that below"
msgstr ""
"當不使用網路地圖進行關卡設計時, 凹形是關卡碰撞的最佳方法, 也就是說, 如果關卡"
"有一些小細節, 可能希望將這些細節排除碰撞之外, 以保證性能和遊戲體驗, 要做到這"
"一點, 可以在3D建模中建立一個簡化的碰撞網格, 並讓Godot為其自動生成一個碰撞形"
"狀. 下面會有更多的介紹"

msgid ""
"Note that unlike primitive and convex shapes, a concave collision shape "
"doesn't have an actual \"volume\". You can place objects both *outside* of "
"the shape as well as *inside*."
msgstr ""
"請注意, 與基礎形狀和凸形狀不同, 凹形碰撞形狀沒有實際的 \"體積\", 既可以將物件"
"放置在形狀的 *外側*, 也可以放置在 *內側*."

msgid ""
"You can generate a concave collision shape from the editor by selecting a "
"MeshInstance3D and using the **Mesh** menu at the top of the 3D viewport. "
"The editor exposes two options:"
msgstr ""
"選中一個網格實例，然後使用 3D 視口頂部的**網格**功能表就可以在編輯器中生成一"
"個凹形碰撞形狀。編輯器提供了兩個選項："

msgid ""
"**Create Trimesh Static Body** is a convenient option. It creates a "
"StaticBody containing a concave shape matching the mesh's geometry."
msgstr ""
"建立三網格靜態體是個方便的選擇. 它建立一個包含與網格幾何學配對的凹形的靜態體."

msgid ""
"**Create Trimesh Collision Sibling** creates a CollisionShape node with a "
"concave shape matching the mesh's geometry."
msgstr ""
"**建立Trimesh(三角面)碰撞同級** 建立具有與網格幾何體配對的凹面形狀的"
"CollisionShape(碰撞形狀)節點."

msgid ""
"See :ref:`doc_importing_3d_scenes` for information on how to export models "
"for Godot and automatically generate collision shapes on import."
msgstr ""
"有關如何匯出 Godot 模型並在匯入時自動產生碰撞形狀的信息，請參閱 "
"doc_importing_3d_scenes`。"

msgid "Performance caveats"
msgstr "效能"

#, fuzzy
msgid ""
"You aren't limited to a single collision shape per PhysicsBody. Still, we "
"recommend keeping the number of shapes as low as possible to improve "
"performance, especially for dynamic objects like RigidBodies and "
"CharacterBodies. On top of that, avoid translating, rotating, or scaling "
"CollisionShapes to benefit from the physics engine's internal optimizations."
msgstr ""
"每個PhysicsBody(物理體)不限於一個碰撞形狀. 儘管如此, 我們還是建議儘量減少碰撞"
"形狀的數量以提高性能, 特別是對於像RigidBodies (剛體)和KinematicBodies(運動體)"
"這樣的動態物件. 除此之外, 避免translating(平移), rotating(旋轉)或scaling(縮"
"放)碰撞形狀, 可以提高物理引擎運作效率."

msgid ""
"When using a single non-transformed collision shape in a StaticBody, the "
"engine's *broad phase* algorithm can discard inactive PhysicsBodies. The "
"*narrow phase* will then only have to take into account the active bodies' "
"shapes. If a StaticBody has many collision shapes, the broad phase will "
"fail. The narrow phase, which is slower, must then perform a collision check "
"against each shape."
msgstr ""
"在靜態體中使用單個非轉換碰撞形狀時, 引擎的寬相位演算法可以丟棄不活躍的物理"
"體. 這個窄相只需考慮到活躍物體的形狀. 如果一個StaticBody有許多碰撞形狀, 那麼"
"寬相位就會失敗. 較慢的窄相位必須對每個形狀執行碰撞檢查."

msgid ""
"If you run into performance issues, you may have to make tradeoffs in terms "
"of accuracy. Most games out there don't have a 100% accurate collision. They "
"find creative ways to hide it or otherwise make it unnoticeable during "
"normal gameplay."
msgstr ""
"如果遇到性能問題, 您可能需要在準確性方面進行權衡. 大多數遊戲都沒有100%的精確"
"碰撞. 他們找到了一些創造性的方法來隱藏它, 或者在正常的遊戲中讓它變得不讓人注"
"意."

msgid "Translation status"
msgstr "翻譯狀態"
