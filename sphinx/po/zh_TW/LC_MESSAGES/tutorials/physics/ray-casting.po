# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Ray-casting"
msgstr "發射射線"

msgid "Introduction"
msgstr "前言"

msgid ""
"One of the most common tasks in game development is casting a ray (or custom "
"shaped object) and checking what it hits. This enables complex behaviors, "
"AI, etc. to take place. This tutorial will explain how to do this in 2D and "
"3D."
msgstr ""
"遊戲開發中最常見的工作之一是發射射線(或自訂形狀的物件)並檢查其擊中的內容. 這"
"可以產生複雜的行為, 如AI等. 本教學將介紹如何在2D和3D中執行此操作."

msgid ""
"Godot stores all the low level game information in servers, while the scene "
"is only a frontend. As such, ray casting is generally a lower-level task. "
"For simple raycasts, nodes like :ref:`RayCast3D <class_RayCast3D>` and :ref:"
"`RayCast2D <class_RayCast2D>` will work, as they return every frame what the "
"result of a raycast is."
msgstr ""
"Godot 將所有底層遊戲資訊儲存在伺服器中，場景只是一個前端。因此，光線投射通常"
"是較底層的工作。對於簡單的光線投射，使用 :ref:`RayCast <class_RayCast>` 和 :"
"ref:`RayCast2D <class_RayCast2D>` 節點就可以了，因為它們將每一影格都返回光線"
"投射的結果。"

msgid ""
"Many times, though, ray-casting needs to be a more interactive process so a "
"way to do this by code must exist."
msgstr ""
"但是, 很多時候, 射線投射應該是一個更具互動性的過程, 因此必須存在通過程式碼執"
"行此操作的方法."

msgid "Space"
msgstr "空格"

msgid ""
"In the physics world, Godot stores all the low level collision and physics "
"information in a *space*. The current 2d space (for 2D Physics) can be "
"obtained by accessing :ref:`CanvasItem.get_world_2d().space "
"<class_CanvasItem_method_get_world_2d>`. For 3D, it's :ref:`Node3D."
"get_world_3d().space <class_Node3D_method_get_world_3d>`."
msgstr ""
"在物理世界中,Godot將所有低級的碰撞和物理資訊儲存在一個 *空間* 中. 目前的2D空"
"間, 對於2D物理, 可以通過存取 :ref:`CanvasItem.get_world_2d().space "
"<class_CanvasItem_method_get_world_2d>` 獲得. 對於3D, 則為 :ref:`Spatial."
"get_world().space <class_Spatial_method_get_world>` ."

msgid ""
"The resulting space :ref:`RID <class_RID>` can be used in :ref:"
"`PhysicsServer3D <class_PhysicsServer3D>` and :ref:`PhysicsServer2D "
"<class_PhysicsServer2D>` respectively for 3D and 2D."
msgstr ""
"結果空間 :ref:`RID <class_RID>` 可在3D的 :ref:`PhysicsServer "
"<class_PhysicsServer>` 和2D的 :ref:`Physics2DServer <class_Physics2DServer>` "
"中."

msgid "Accessing space"
msgstr "獲取空間"

#, fuzzy
msgid ""
"Godot physics runs by default in the same thread as game logic, but may be "
"set to run on a separate thread to work more efficiently. Due to this, the "
"only time accessing space is safe is during the :ref:`Node."
"_physics_process() <class_Node_private_method__physics_process>` callback. "
"Accessing it from outside this function may result in an error due to space "
"being *locked*."
msgstr ""
"Godot物理預設與遊戲邏輯運作在同一個執行緒中, 但可以設定為在一個單獨的執行緒上"
"運作, 以便更高效地工作. 由於這一點, 只有在 :ref:`Node._physics_process() "
"<class_Node_method__physics_process>` 回呼函式期間存取空間才是安全的. 從這個"
"函式之外存取它可能會因為空間被 *鎖定* 而導致錯誤."

msgid ""
"To perform queries into physics space, the :ref:`PhysicsDirectSpaceState2D "
"<class_PhysicsDirectSpaceState2D>` and :ref:`PhysicsDirectSpaceState3D "
"<class_PhysicsDirectSpaceState3D>` must be used."
msgstr ""
"要對物理空間執行查詢, 必須使用 :ref:`Physics2DDirectSpaceState "
"<class_Physics2DDirectSpaceState>` 和 :ref:`PhysicsDirectSpaceState "
"<class_PhysicsDirectSpaceState>` ."

msgid "Use the following code in 2D:"
msgstr "在 2D 中使用以下程式碼："

msgid "Or more directly:"
msgstr "或者更直接："

msgid "And in 3D:"
msgstr "在 3D 中："

msgid "Raycast query"
msgstr "Raycast 查詢"

msgid ""
"For performing a 2D raycast query, the method :ref:"
"`PhysicsDirectSpaceState2D.intersect_ray() "
"<class_PhysicsDirectSpaceState2D_method_intersect_ray>` may be used. For "
"example:"
msgstr ""
"為了執行二維 raycast射線查詢, 可以使用方法 :ref:`Physics2DDirectSpaceState."
"intersect_ray() <class_Physics2DDirectSpaceState_method_intersect_ray>` . 例"
"如:"

msgid ""
"The result is a dictionary. If the ray didn't hit anything, the dictionary "
"will be empty. If it did hit something, it will contain collision "
"information:"
msgstr ""
"結果是一個字典. 如果射線沒有擊中任何東西, 字典將是空的. 如果它確實碰撞到了物"
"體, 將包含碰撞資訊碰撞:"

msgid ""
"The ``result`` dictionary when a collision occurs contains the following "
"data:"
msgstr "發生碰撞時，``result`` 字典包含以下資料："

msgid ""
"The data is similar in 3D space, using Vector3 coordinates. Note that to "
"enable collisions with Area3D, the boolean parameter ``collide_with_areas`` "
"must be set to ``true``."
msgstr ""
"3D 空間中的資料類似，使用 Vector3 座標。請注意，要啟用與 Area3D 的碰撞，布林"
"參數「collide_with_areas」必須設為「true」。"

msgid "Collision exceptions"
msgstr "碰撞例外"

msgid ""
"A common use case for ray casting is to enable a character to gather data "
"about the world around it. One problem with this is that the same character "
"has a collider, so the ray will only detect its parent's collider, as shown "
"in the following image:"
msgstr ""
"光線投射的常見用例是使角色能夠收集有關其周圍世界的資料。這種情況的一個問題是"
"該角色上有碰撞體，因此光線只會偵測到其父節點上的碰撞體，如下圖所示："

msgid ""
"To avoid self-intersection, the ``intersect_ray()`` parameters object can "
"take an array of exceptions via its ``exclude`` property. This is an example "
"of how to use it from a CharacterBody2D or any other collision object node:"
msgstr ""
"為了避免自相交, ``intersect_ray()`` 函式可以採用可選的第三個參數, 這是一個排"
"除陣列. 這是如何從KinematicBody2D或任何其他碰撞物件節點使用它的範例:"

msgid "The exceptions array can contain objects or RIDs."
msgstr "例外陣列可以包含物件或 RID。"

msgid "Collision Mask"
msgstr "碰撞遮罩"

msgid ""
"While the exceptions method works fine for excluding the parent body, it "
"becomes very inconvenient if you need a large and/or dynamic list of "
"exceptions. In this case, it is much more efficient to use the collision "
"layer/mask system."
msgstr ""
"雖然例外方法適用於排除父體, 但如果需要大型和/或動態的例外列表, 則會變得非常不"
"方便. 在這種情況下, 使用碰撞層/遮罩系統要高效得多."

msgid ""
"The ``intersect_ray()`` parameters object can also be supplied a collision "
"mask. For example, to use the same mask as the parent body, use the "
"``collision_mask`` member variable. The array of exceptions can be supplied "
"as the last argument as well:"
msgstr ""
"``intersect_ray()`` 的第四個可選參數是一個碰撞遮罩. 例如, 要使用與父級相同的"
"遮罩, 請使用 ``collision_mask`` 成員變數:"

msgid ""
"See :ref:`doc_physics_introduction_collision_layer_code_example` for details "
"on how to set the collision mask."
msgstr ""
"關於如何設定碰撞遮罩, 請參閱 :ref:"
"`doc_physics_introduction_collision_layer_code_example` ."

msgid "3D ray casting from screen"
msgstr "來自螢幕的 3D 光線投射"

msgid ""
"Casting a ray from screen to 3D physics space is useful for object picking. "
"There is not much need to do this because :ref:`CollisionObject3D "
"<class_CollisionObject3D>` has an \"input_event\" signal that will let you "
"know when it was clicked, but in case there is any desire to do it manually, "
"here's how."
msgstr ""
"將一條射線從螢幕上投射到3D物理空間, 對於物件的選取是很有用, 但沒有太多必要這"
"樣做, 因為 :ref:`CollisionObject <class_CollisionObject>` 有一個 "
"\"input_event\" 訊號, 會讓你知道它是什麼時候被點擊的, 但是如果有想要手動操作"
"需要, 可這樣."

msgid ""
"To cast a ray from the screen, you need a :ref:`Camera3D <class_Camera3D>` "
"node. A ``Camera3D`` can be in two projection modes: perspective and "
"orthogonal. Because of this, both the ray origin and direction must be "
"obtained. This is because ``origin`` changes in orthogonal mode, while "
"``normal`` changes in perspective mode:"
msgstr ""
"要從螢幕投射光線, 您需要 :ref:`Camera <class_Camera>` 節點. ``相機`` 可以是兩"
"種投影模式: 透視和正交. 因此, 必須獲得射線原點和方向. 這是因為 ``origin`` 在"
"正交模式下改變, 而 ``normal`` 在透視模式下改變:"

msgid "To obtain it using a camera, the following code can be used:"
msgstr "要使用相機獲取它, 可以使用以下程式碼:"

msgid ""
"Remember that during ``_input()``, the space may be locked, so in practice "
"this query should be run in ``_physics_process()``."
msgstr ""
"請記住，在 ``_input()`` 期間空間可能被鎖定，所以實踐中應該在 "
"``_physics_process()`` 中運作這個查詢。"

msgid "Translation status"
msgstr "翻譯狀態"
