# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using CharacterBody2D/3D"
msgstr "使用 CharacterBody2D/3D"

msgid "Introduction"
msgstr "前言"

msgid ""
"Godot offers several collision objects to provide both collision detection "
"and response. Trying to decide which one to use for your project can be "
"confusing. You can avoid problems and simplify development if you understand "
"how each of them works and what their pros and cons are. In this tutorial, "
"we'll look at the :ref:`CharacterBody2D <class_CharacterBody2D>` node and "
"show some examples of how to use it."
msgstr ""
"Godot 提供了多種碰撞物件來提供碰撞偵測和回應。試圖決定在你的專案中使用哪一個"
"可能會讓你感到困惑。如果你瞭解它們中的每一個是如何工作的，以及它們的優點和缺"
"點是什麼，你就可以避免問題並簡化開發。在本教學中，我們將查看 :ref:"
"`CharacterBody2D <class_CharacterBody2D>` 節點，並展示一些如何使用它的例子."

msgid ""
"While this document uses ``CharacterBody2D`` in its examples, the same "
"concepts apply in 3D as well."
msgstr ""
"雖然本文件在其範例中使用 ``CharacterBody2D`` ，但相同的概念也適用於 3D。"

msgid "What is a character body?"
msgstr "什麼是角色體？"

msgid ""
"``CharacterBody2D`` is for implementing bodies that are controlled via code. "
"Character bodies detect collisions with other bodies when moving, but are "
"not affected by engine physics properties, like gravity or friction. While "
"this means that you have to write some code to create their behavior, it "
"also means you have more precise control over how they move and react."
msgstr ""
"``CharacterBody2D`` 用於實作通過程式碼控制的物體。Character bodies 在移動時可"
"以偵測到與其他物體的碰撞，但不受引擎物理屬性（如重力、摩擦力等）的影響。雖然"
"這意味著你必須編寫一些程式碼來建立它們的行為，但這也意味著你可以更精確地控制"
"它們如何移動和反應。"

msgid ""
"This document assumes you're familiar with Godot's various physics bodies. "
"Please read :ref:`doc_physics_introduction` first, for an overview of the "
"physics options."
msgstr ""
"本文假設你熟悉 Godot 中的各種物理體。否則請先閱讀 :ref:"
"`doc_physics_introduction` 。"

msgid ""
"A `CharacterBody2D` can be affected by gravity and other forces, but you "
"must calculate the movement in code. The physics engine will not move a "
"`CharacterBody2D`."
msgstr ""
"`CharacterBody2D` 可以受到重力和其他力的影響，但您必須在程式碼中計算它的運"
"動。物理引擎不會移動 `CharacterBody2D`。"

msgid "Movement and collision"
msgstr "運動與碰撞"

msgid ""
"When moving a ``CharacterBody2D``, you should not set its ``position`` "
"property directly. Instead, you use the ``move_and_collide()`` or "
"``move_and_slide()`` methods. These methods move the body along a given "
"vector and detect collisions."
msgstr ""
"當移動一個 ``CharacterBody2D`` 時，你不應該直接設定它的 ``position`` 屬性，而"
"應該使用 ``move_and_collide()`` 或 ``move_and_slide()`` 方法。這些方法沿著給"
"定的向量移動物體，並且偵測碰撞。"

msgid ""
"You should handle physics body movement in the ``_physics_process()`` "
"callback."
msgstr "你應該在 ``_physics_process()`` 回呼函式中處理物理體的運動。"

msgid ""
"The two movement methods serve different purposes, and later in this "
"tutorial, you'll see examples of how they work."
msgstr ""
"這兩種運動方法有不同的作用, 在後面的教學中, 你會看到它們如何工作的例子."

msgid "move_and_collide"
msgstr "move_and_collide"

msgid ""
"This method takes one required parameter: a :ref:`Vector2 <class_Vector2>` "
"indicating the body's relative movement. Typically, this is your velocity "
"vector multiplied by the frame timestep (``delta``). If the engine detects a "
"collision anywhere along this vector, the body will immediately stop moving. "
"If this happens, the method will return a :ref:`KinematicCollision2D "
"<class_KinematicCollision2D>` object."
msgstr ""
"這個方法需要一個 :ref:`Vector2 <class_Vector2>` 參數以表示物體的相對運動。通"
"常，這是速度向量乘以影格時間步長( ``delta`` )。如果引擎在沿著此向量方向的任何"
"位置偵測到碰撞，則物體將立即停止移動。如果發生這種情況，該方法將返回一個 :"
"ref:`KinematicCollision2D <class_KinematicCollision2D>` 對象。"

msgid ""
"``KinematicCollision2D`` is an object containing data about the collision "
"and the colliding object. Using this data, you can calculate your collision "
"response."
msgstr ""
"``KinematicCollision2D`` 是一個包含碰撞和碰撞物件資料的物件. 使用這些資料, 你"
"可以計算出你的碰撞回應."

msgid ""
"``move_and_collide`` is most useful when you just want to move the body and "
"detect collision, but don't need any automatic collision response. For "
"example, if you need a bullet that ricochets off a wall, you can directly "
"change the angle of the velocity when you detect a collision. See below for "
"an example."
msgstr ""
"當你只想移動物體並偵測碰撞，並且不需要任何自動碰撞回應時， "
"``move_and_collide`` 最有用。例如，如果你需要一顆從牆上彈開的子彈，你可以在偵"
"測到碰撞時直接更改速度角度。請參閱下面的範例。"

msgid "move_and_slide"
msgstr "move_and_slide"

msgid ""
"The ``move_and_slide()`` method is intended to simplify the collision "
"response in the common case where you want one body to slide along the "
"other. It is especially useful in platformers or top-down games, for example."
msgstr ""
"``move_and_slide()`` 方法旨在簡化常見情況下的碰撞回應, 即你希望一個物體沿著另"
"一個物體滑動. 例如, 在平臺遊戲或自上而下的遊戲中, 它特別有用."

msgid ""
"When calling ``move_and_slide()``, the function uses a number of node "
"properties to calculate its slide behavior. These properties can be found in "
"the Inspector, or set in code."
msgstr ""
"當呼叫 ``move_and_slide()`` 時，該函式使用許多節點屬性來計算其滑動行為。這些"
"屬性可以在屬性面板中找到，或在程式碼中設定。"

msgid "``velocity`` - *default value:* ``Vector2( 0, 0 )``"
msgstr "``up_direction`` - *預設值:* ``Vector2( 0, 0 )``"

msgid ""
"This property represents the body's velocity vector in pixels per second. "
"``move_and_slide()`` will modify this value automatically when colliding."
msgstr ""
"此屬性表示身體的速度向量（以每秒像素為單位）。 ``move_and_slide()`` 會在碰撞"
"時自動修改此值。"

msgid "``motion_mode`` - *default value:* ``MOTION_MODE_GROUNDED``"
msgstr "``max_slides`` - *預設值:* ``4``"

msgid ""
"This property is typically used to distinguish between side-scrolling and "
"top-down movement. When using the default value, you can use the "
"``is_on_floor()``, ``is_on_wall()``, and ``is_on_ceiling()`` methods to "
"detect what type of surface the body is in contact with, and the body will "
"interact with slopes. When using ``MOTION_MODE_FLOATING``, all collisions "
"will be considered \"walls\"."
msgstr ""
"這個參數允許你定義哪些表面應該被引擎視為地板. 設定這個參數可以讓你使用 "
"``is_on_floor()`` , ``is_on_wall()`` 和 ``is_on_ceiling()`` 方法來偵測物體接"
"觸的表面型別. 預設值意味著所有的表面都被認為是牆壁."

msgid "``up_direction`` - *default value:* ``Vector2( 0, -1 )``"
msgstr "``up_direction`` - *預設值:* ``Vector2( 0, 0 )``"

msgid ""
"This property allows you to define what surfaces the engine should consider "
"being the floor. Its value lets you use the ``is_on_floor()``, "
"``is_on_wall()``, and ``is_on_ceiling()`` methods to detect what type of "
"surface the body is in contact with. The default value means that the top "
"side of horizontal surfaces will be considered \"ground\"."
msgstr ""
"這個參數允許你定義哪些表面應該被引擎視為地板. 設定這個參數可以讓你使用 "
"``is_on_floor()`` , ``is_on_wall()`` 和 ``is_on_ceiling()`` 方法來偵測物體接"
"觸的表面型別. 預設值意味著所有的表面都被認為是牆壁."

msgid "``floor_stop_on_slope`` - *default value:* ``true``"
msgstr "``stop_on_slope`` - *預設值:* ``false``"

msgid ""
"This parameter prevents a body from sliding down slopes when standing still."
msgstr "該參數可以防止物體站立不動時從斜坡上滑落."

msgid ""
"``wall_min_slide_angle`` - *default value:* ``0.261799`` (in radians, "
"equivalent to ``15`` degrees)"
msgstr ""
"``floor_max_angle`` - *預設值:* ``0.785398`` (以弧度表示, 相當於 ``45`` 度)"

msgid ""
"This is the minimum angle where the body is allowed to slide when it hits a "
"slope."
msgstr "這是當身體碰到斜坡時允許滑動的最小角度。"

msgid ""
"``floor_max_angle`` - *default value:* ``0.785398`` (in radians, equivalent "
"to ``45`` degrees)"
msgstr ""
"``floor_max_angle`` - *預設值:* ``0.785398`` (以弧度表示, 相當於 ``45`` 度)"

msgid ""
"This parameter is the maximum angle before a surface is no longer considered "
"a \"floor.\""
msgstr "這是表面不再被視為 \"地板\" 之前的最大角度"

msgid ""
"There are many other properties that can be used to modify the body's "
"behavior under specific circumstances. See the :ref:`CharacterBody2D "
"<class_CharacterBody2D>` docs for full details."
msgstr ""
"還有許多其他屬性可用於在特定情況下改變身體的行為。有關完整詳細信息，請參閱:"
"ref:`CharacterBody2D <class_CharacterBody2D>` 檔案。"

msgid "Detecting collisions"
msgstr "偵測碰撞"

msgid ""
"When using ``move_and_collide()`` the function returns a "
"``KinematicCollision2D`` directly, and you can use this in your code."
msgstr ""
"當使用 ``move_and_collide()`` 時, 函式直接返回一個 "
"``KinematicCollision2D`` , 你可以在程式碼中使用這個."

msgid ""
"When using ``move_and_slide()`` it's possible to have multiple collisions "
"occur, as the slide response is calculated. To process these collisions, use "
"``get_slide_collision_count()`` and ``get_slide_collision()``:"
msgstr ""
"當使用 ``move_and_slide()`` 時, 有可能發生多次碰撞, 因為滑動回應是計算出來"
"的. 要處理這些碰撞, 使用 ``get_slide_count()`` 和 ``get_slide_collision()``:"

msgid ""
"`get_slide_collision_count()` only counts times the body has collided and "
"changed direction."
msgstr "`get_slide_count()` 只計算物體碰撞和改變方向的次數."

msgid ""
"See :ref:`KinematicCollision2D <class_KinematicCollision2D>` for details on "
"what collision data is returned."
msgstr ""
"關於返回哪些碰撞資料, 請參見 :ref:`KinematicCollision2D "
"<class_KinematicCollision2D>` ."

msgid "Which movement method to use?"
msgstr "使用哪種運動方式？"

msgid ""
"A common question from new Godot users is: \"How do you decide which "
"movement function to use?\" Often, the response is to use "
"``move_and_slide()`` because it seems simpler, but this is not necessarily "
"the case. One way to think of it is that ``move_and_slide()`` is a special "
"case, and ``move_and_collide()`` is more general. For example, the following "
"two code snippets result in the same collision response:"
msgstr ""
"Godot新使用者的一個常見問題是:\"你如何決定使用哪個移動函式？\" 通常, 回答是使"
"用 ``move_and_slide()`` , 因為它 \"更簡單\" , 但情況不一定如此. 有一種思路"
"是, ``move_and_slide()`` 是一種特殊情況, 而 ``move_and_collide()`` 更通用. 例"
"如, 下面兩個程式碼片段的結果是相同的碰撞回應:"

msgid ""
"Anything you do with ``move_and_slide()`` can also be done with "
"``move_and_collide()``, but it might take a little more code. However, as "
"we'll see in the examples below, there are cases where ``move_and_slide()`` "
"doesn't provide the response you want."
msgstr ""
"您用 ``move_and_slide()`` 做的任何事情都可以用 ``move_and_collide()`` 來完"
"成, 但它可能需要更多的程式碼. 但是, 正如我們在下面的範例中將看到的, 有些情況"
"下 ``move_and_slide()`` 不能提供您想要的回應."

msgid ""
"In the example above, ``move_and_slide()`` automatically alters the "
"``velocity`` variable. This is because when the character collides with the "
"environment, the function recalculates the speed internally to reflect the "
"slowdown."
msgstr ""
"在上面的例子中, 我們將 ``move_and_slide()`` 返回的速度賦值給 ``velocity`` 變"
"數. 這是因為當角色與環境發生碰撞時, 函式會在內部重新計算速度, 以反映減速的情"
"況."

msgid ""
"For example, if your character fell on the floor, you don't want it to "
"accumulate vertical speed due to the effect of gravity. Instead, you want "
"its vertical speed to reset to zero."
msgstr ""
"例如, 如果角色倒在地上, 不希望它因為重力的影響而積累垂直速度, 而希望它的垂直"
"速度重設為零."

msgid ""
"``move_and_slide()`` may also recalculate the kinematic body's velocity "
"several times in a loop as, to produce a smooth motion, it moves the "
"character and collides up to five times by default. At the end of the "
"process, the character's new velocity is available for use on the next frame."
msgstr ""
"``move_and_slide()`` 還可以在迴圈中多次重新計算運動體的速度, 為了產生一個平滑"
"的運動, 它預設會移動角色, 並碰撞5次, 在這個過程結束時, 函式返回角色的新速度, "
"可以將其儲存在 ``velocity`` 變數中, 並在下一影格中使用."

msgid "Examples"
msgstr "範例"

msgid ""
"To see these examples in action, download the sample project: "
"`character_body_2d_starter.zip <https://github.com/godotengine/godot-docs-"
"project-starters/releases/download/latest-4.x/character_body_2d_starter."
"zip>`_"
msgstr ""
"若要查看這些範例的實際效果，請下載範例專案：`character_body_2d_starter.zip "
"<https://github.com/godotengine/godot-docs-project-starters/releases/"
"download/latest-4.x/character_body_2d_starter.zip> ` _"

msgid "Movement and walls"
msgstr "移動和牆壁"

msgid ""
"If you've downloaded the sample project, this example is in \"basic_movement."
"tscn\"."
msgstr "如果你已經下載了範例專案, 這個例子在 \"BasicMovement.tscn\" 中."

msgid ""
"For this example, add a ``CharacterBody2D`` with two children: a "
"``Sprite2D`` and a ``CollisionShape2D``. Use the Godot \"icon.svg\" as the "
"Sprite2D's texture (drag it from the Filesystem dock to the *Texture* "
"property of the ``Sprite2D``). In the ``CollisionShape2D``'s *Shape* "
"property, select \"New RectangleShape2D\" and size the rectangle to fit over "
"the sprite image."
msgstr ""
"在這個例子中, 新增一個 ``KinematicBody2D`` , 有兩個子級: ``Sprite`` 和 "
"``CollisionShape2D`` . 使用Godot \"icon.png\" 作為Sprite的紋理, 將其從檔案系"
"統欄拖到 ``Sprite`` 的 *Texture* 屬性. 在 ``CollisionShape2D`` 的 *Shape* 屬"
"性中, 選擇 \"New RectangleShape2D\" , 並將矩形的大小調整到適合sprite圖像的大"
"小."

msgid ""
"See :ref:`doc_2d_movement` for examples of implementing 2D movement schemes."
msgstr "有關實作2D移動方案的範例, 請參閱 :ref:`doc_2d_movement` ."

msgid "Attach a script to the CharacterBody2D and add the following code:"
msgstr "點擊 [場景] -> [新增場景]，然後新增下列節點："

msgid ""
"Run this scene and you'll see that ``move_and_collide()`` works as expected, "
"moving the body along the velocity vector. Now let's see what happens when "
"you add some obstacles. Add a :ref:`StaticBody2D <class_StaticBody2D>` with "
"a rectangular collision shape. For visibility, you can use a Sprite2D, a "
"Polygon2D, or turn on \"Visible Collision Shapes\" from the \"Debug\" menu."
msgstr ""
"運作這個場景, 您會看到 ``move_and_collide()`` 按預期工作, 沿著速度向量方向移"
"動物體. 現在讓我們看看當您新增一些障礙時會發生什麼. 新增一個具有矩形碰撞形狀"
"的 :ref:`StaticBody2D <class_StaticBody2D>` . 為了可見性, 您可以使用精靈,"
"Polygon2D, 或從 \"除錯\" 選單中打開 \"可見碰撞形狀\"."

msgid ""
"Run the scene again and try moving into the obstacle. You'll see that the "
"``CharacterBody2D`` can't penetrate the obstacle. However, try moving into "
"the obstacle at an angle and you'll find that the obstacle acts like glue - "
"it feels like the body gets stuck."
msgstr ""
"再次運作場景並嘗試移動到障礙物中. 您會看到 ``KinematicBody2D`` 無法穿透障礙"
"物. 但是, 嘗試以某個角度進入障礙物, 您會發現障礙物就像膠水一樣 - 感覺物體被卡"
"住了."

msgid ""
"This happens because there is no *collision response*. "
"``move_and_collide()`` stops the body's movement when a collision occurs. We "
"need to code whatever response we want from the collision."
msgstr ""
"發生這種情況是因為沒有 *碰撞回應* . ``move_and_collide()`` 在碰撞發生時停止物"
"體的運動. 我們需要編寫我們想要的碰撞響應."

msgid "Try changing the function to ``move_and_slide()`` and running again."
msgstr ""
"嘗試將函式更改為 ``move_and_slide(velocity)`` 並再次運作. 請注意, 我們從速度"
"計算中刪除了 \"delta\"."

msgid ""
"``move_and_slide()`` provides a default collision response of sliding the "
"body along the collision object. This is useful for a great many game types, "
"and may be all you need to get the behavior you want."
msgstr ""
"``move_and_slide()`` 提供了一個沿碰撞物件滑動物體的預設碰撞響應. 這對於許多遊"
"戲型別都很有用, 並且可能是獲得所需行為所需的全部內容."

msgid "Bouncing/reflecting"
msgstr "彈跳/反射"

msgid ""
"What if you don't want a sliding collision response? For this example "
"(\"bounce_and_collide.tscn\" in the sample project), we have a character "
"shooting bullets and we want the bullets to bounce off the walls."
msgstr ""
"如果您不想要滑動碰撞回應怎麼辦？ 對於這個範例(範例專案中的 "
"\"BounceandCollide.tscn\"), 我們有一個角色射擊子彈, 我們希望子彈從牆上反彈."

msgid ""
"This example uses three scenes. The main scene contains the Player and "
"Walls. The Bullet and Wall are separate scenes so that they can be instanced."
msgstr ""
"此範例使用三個場景. 主場景包含遊戲角色和牆壁. 子彈和牆是單獨的場景, 以便它們"
"可以產生實體."

msgid ""
"The Player is controlled by the ``w`` and ``s`` keys for forward and back. "
"Aiming uses the mouse pointer. Here is the code for the Player, using "
"``move_and_slide()``:"
msgstr ""
"遊戲角色由 `w` 和 `s` 鍵控制前進和後退. 瞄準使用滑鼠指標. 這是遊戲角色的程式"
"碼, 使用 ``move_and_slide()`` :"

msgid "And the code for the Bullet:"
msgstr "子彈的程式碼:"

msgid ""
"The action happens in ``_physics_process()``. After using "
"``move_and_collide()``, if a collision occurs, a ``KinematicCollision2D`` "
"object is returned (otherwise, the return is ``null``)."
msgstr ""
"動作發生在 ``_physics_process()`` 中. 在使用 ``move_and_collide()`` 後, 如果"
"發生碰撞, 將返回一個 ``KinematicCollision2D`` 物件, 否則, 返回 ``Nil`` ."

msgid ""
"If there is a returned collision, we use the ``normal`` of the collision to "
"reflect the bullet's ``velocity`` with the ``Vector2.bounce()`` method."
msgstr ""
"如果有一個返回的碰撞, 我們使用碰撞的 ``normal`` 來反映子彈的 ``velocity`` 和 "
"``Vector2.bounce()`` 方法."

msgid ""
"If the colliding object (``collider``) has a ``hit`` method, we also call "
"it. In the example project, we've added a flashing color effect to the Wall "
"to demonstrate this."
msgstr ""
"如果碰撞物件( ``collider`` )有一個 ``hit`` 方法, 我們也呼叫它. 在範例專案中, "
"我們為牆壁新增了一個顏色閃爍效果來演示這一點."

msgid "Platformer movement"
msgstr "平臺運動"

msgid ""
"Let's try one more popular example: the 2D platformer. ``move_and_slide()`` "
"is ideal for quickly getting a functional character controller up and "
"running. If you've downloaded the sample project, you can find this in "
"\"platformer.tscn\"."
msgstr ""
"讓我們嘗試一個更流行的範例:2D平臺遊戲. ``move_and_slide()`` 非常適合快速啟動"
"和運作功能字元控制器. 如果您已下載範例專案, 可以在 \"Platformer.tscn\" 中找到"
"它."

msgid ""
"For this example, we'll assume you have a level made of one or more "
"``StaticBody2D`` objects. They can be any shape and size. In the sample "
"project, we're using :ref:`Polygon2D <class_Polygon2D>` to create the "
"platform shapes."
msgstr ""
"對於這個範例, 我們假設您有一個由 ``StaticBody2D`` 物件構成的級別. 它們可以是"
"任何形狀和大小. 在範例專案中, 我們使用 :ref:`Polygon2D <class_Polygon2D>` 來"
"建立平臺形狀."

msgid "Here's the code for the player body:"
msgstr "這是遊戲角色物體的程式碼:"

msgid ""
"In this code we're using ``move_and_slide()`` as described above - to move "
"the body along its velocity vector, sliding along any collision surfaces "
"such as the ground or a platform. We're also using ``is_on_floor()`` to "
"check if a jump should be allowed. Without this, you'd be able to \"jump\" "
"in midair; great if you're making Flappy Bird, but not for a platformer game."
msgstr ""
"在這段程式碼中，我們使用如上所述的“move_and_slide()” - 沿著其速度向量移動物"
"體，沿著任何碰撞表面（例如地面或平台）滑動。我們也使用「is_on_floor()」來檢查"
"是否允許跳躍。沒有這個，你就可以在半空中「跳躍」；如果您正在製作《Flappy "
"Bird》，那麼這很好，但不適用於平台遊戲。"

msgid ""
"There is a lot more that goes into a complete platformer character: "
"acceleration, double-jumps, coyote-time, and many more. The code above is "
"just a starting point. You can use it as a base to expand into whatever "
"movement behavior you need for your own projects."
msgstr ""
"完整的平台遊戲角色還有很多東西：加速、二段跳、郊狼時間等等。上面的程式碼只是"
"一個起點。您可以使用它作為基礎來擴充您自己的專案所需的任何運動行為。"

msgid "Translation status"
msgstr "翻譯狀態"
