# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Physics introduction"
msgstr "物理介紹"

msgid ""
"In game development, you often need to know when two objects in the game "
"intersect or come into contact. This is known as **collision detection**. "
"When a collision is detected, you typically want something to happen. This "
"is known as **collision response**."
msgstr ""
"在遊戲開發領域，你常常會需要在遊戲中兩個物體相交或是接觸時得到提醒。這被稱為 "
"**碰撞偵測(collision detection)**。當偵測到碰撞，你通常會想要讓某些事情發生。"
"這被稱作**碰撞反應(collision response)**。"

msgid ""
"Godot offers a number of collision objects in 2D and 3D to provide both "
"collision detection and response. Trying to decide which one to use for your "
"project can be confusing. You can avoid problems and simplify development if "
"you understand how each works and what their pros and cons are."
msgstr ""
"Godot在2D和3D中提供了許多碰撞物件, 以提供碰撞偵測和回應. 你可能很難決定哪個適"
"合你的專案. 一旦瞭解了每種方法的工作原理以及它們的優缺點, 你就可以避免出現問"
"題並簡化開發過程."

msgid "In this guide, you will learn:"
msgstr "在本指南中，我們將學到："

msgid "Godot's four collision object types"
msgstr "Godot的四種碰撞對象型別"

msgid "How each collision object works"
msgstr "每個碰撞物件的工作原理"

msgid "When and why to choose one type over another"
msgstr "何時以及為何選擇這種型別而不是另一種型別"

msgid ""
"This document's examples will use 2D objects. Every 2D physics object and "
"collision shape has a direct equivalent in 3D and in most cases they work in "
"much the same way."
msgstr ""
"本文件的範例將使用2D物件. 每個2D物理物件和碰撞形狀在3D中具有直接等價物, 並且"
"在大多數情況下它們以相同的方式工作."

msgid "Collision objects"
msgstr "碰撞物體"

msgid ""
"Godot offers four kinds of collision objects which all extend :ref:"
"`CollisionObject2D <class_CollisionObject2D>`. The last three listed below "
"are physics bodies and additionally extend :ref:`PhysicsBody2D "
"<class_PhysicsBody2D>`."
msgstr ""
"Godot 提供了四個碰撞對象，它們都擴充了:ref:`CollisionObject2D "
"<class_CollisionObject2D>`。以下列出的最後三個是物理體，也擴充了 :ref:"
"`PhysicsBody2D <class_PhysicsBody2D>`。"

msgid ":ref:`Area2D <class_Area2D>`"
msgstr ":ref:`Area2D <class_Area2D>`"

msgid ""
"``Area2D`` nodes provide **detection** and **influence**. They can detect "
"when objects overlap and can emit signals when bodies enter or exit. An "
"``Area2D`` can also be used to override physics properties, such as gravity "
"or damping, in a defined area."
msgstr ""
"``Area2D`` 節點提供 **偵測** 和 **影響** . 它們可以偵測物體何時重疊, 並在物體"
"進入或離開時發出訊號. ``Area2D`` 也可用於覆蓋物理屬性, 例如一定區域內的重力或"
"阻尼."

msgid ":ref:`StaticBody2D <class_StaticBody2D>`"
msgstr ":ref:`StaticBody2D <class_StaticBody2D>`"

msgid ""
"A static body is one that is not moved by the physics engine. It "
"participates in collision detection, but does not move in response to the "
"collision. They are most often used for objects that are part of the "
"environment or that do not need to have any dynamic behavior."
msgstr ""
"靜態主體是物理引擎不移動的主體. 它參與碰撞偵測, 但不會回應碰撞而移動. 它們通"
"常用於屬於環境的物件或不需要任何動態行為的物件."

msgid ":ref:`RigidBody2D <class_RigidBody2D>`"
msgstr ":ref:`RigidBody2D <class_RigidBody2D>`"

msgid ""
"This is the node that implements simulated 2D physics. You do not control a "
"``RigidBody2D`` directly, but instead you apply forces to it (gravity, "
"impulses, etc.) and the physics engine calculates the resulting movement. :"
"ref:`Read more about using rigid bodies. <doc_rigid_body>`"
msgstr ""
"這是實作類比2D物理的節點. 您不直接控制 ``RigidBody2D`` , 而是您對它施加力(重"
"力, 衝動等), 物理引擎計算得到的運動. :ref:`閱讀更多關於使用剛體的資訊. "
"<doc_rigid_body>`"

msgid ":ref:`CharacterBody2D <class_CharacterBody2D>`"
msgstr ":ref:`Vector2 <class_Vector2>`"

msgid ""
"A body that provides collision detection, but no physics. All movement and "
"collision response must be implemented in code."
msgstr ""
"提供碰撞偵測的物體, 但沒有物理功能. 所有移動和碰撞回應必須在程式碼中實作."

msgid "Physics material"
msgstr "物理屬性"

msgid ""
"Static bodies and rigid bodies can be configured to use a :ref:"
"`PhysicsMaterial <class_PhysicsMaterial>`. This allows adjusting the "
"friction and bounce of an object, and set if it's absorbent and/or rough."
msgstr ""
"靜態體和剛性體可以被配置為使用:ref:`物理材質 <class_PhysicsMaterial>`。這允許"
"調整一個物體的摩擦力和反彈力，並設定它是否具有吸收性、粗糙性。"

msgid "Collision shapes"
msgstr "碰撞形體"

msgid ""
"A physics body can hold any number of :ref:`Shape2D <class_Shape2D>` objects "
"as children. These shapes are used to define the object's collision bounds "
"and to detect contact with other objects."
msgstr ""
"物理體可以包含任意數量的 :ref:`Shape2D <class_Shape2D>` 對象作為子物件. 這些"
"形狀用於定義物件的碰撞邊界並偵測與其他物件的接觸."

msgid ""
"In order to detect collisions, at least one ``Shape2D`` must be assigned to "
"the object."
msgstr "為了偵測碰撞, 必須至少為物件分配一個 ``Shape2D`` ."

msgid ""
"The most common way to assign a shape is by adding a :ref:`CollisionShape2D "
"<class_CollisionShape2D>` or :ref:`CollisionPolygon2D "
"<class_CollisionPolygon2D>` as a child of the object. These nodes allow you "
"to draw the shape directly in the editor workspace."
msgstr ""
"分配形狀的最常用方法是新增 :ref:`CollisionShape2D <class_CollisionShape2D>` "
"或 :ref:`CollisionPolygon2D <class_CollisionPolygon2D>` 作為對象的子項. 這些"
"節點允許您直接在編輯器工作區中繪製形狀."

msgid ""
"Be careful to never scale your collision shapes in the editor. The \"Scale\" "
"property in the Inspector should remain ``(1, 1)``. When changing the size "
"of the collision shape, you should always use the size handles, **not** the "
"``Node2D`` scale handles. Scaling a shape can result in unexpected collision "
"behavior."
msgstr ""
"注意，不要在編輯器中縮放碰撞形狀。“屬性面板”中的“Scale”屬性應保持為 ``(1, "
"1)``。改變碰撞形狀的大小時，你應該使用尺寸控制柄，而**不是** ``Node2D`` 縮放"
"控制柄。縮放形狀可能會導致意外的碰撞行為。"

msgid "Physics process callback"
msgstr "物理過程回呼函式"

msgid ""
"The physics engine runs at a fixed rate (a default of 60 iterations per "
"second). This rate is typically different from the frame rate which "
"fluctuates based on what is rendered and available resources."
msgstr ""
"物理引擎以固定速率運作（預設為每秒 60 次迭代）。此速率通常不同於影格速率，影"
"格速率根據算繪內容和可用資源而波動。"

msgid ""
"It is important that all physics related code runs at this fixed rate. "
"Therefore Godot differentiates :ref:`between physics and idle processing "
"<doc_idle_and_physics_processing>`. Code that runs each frame is called idle "
"processing and code that runs on each physics tick is called physics "
"processing. Godot provides two different callbacks, one for each of those "
"processing rates."
msgstr ""
"重要的是所有與物理相關的程式碼都以這個固定速率運作。因此，Godot 區分了物理處"
"理和空閒處理 <doc_idle_and_physical_processing>`。運作每一影格的程式碼稱為空"
"閒處理，在每個物理滴答上運作的程式碼稱為物理處理。 Godot 提供了兩種不同的回"
"調，每種回調對應一種處理速率。"

#, fuzzy
msgid ""
"The physics callback, :ref:`Node._physics_process() "
"<class_Node_private_method__physics_process>`, is called before each physics "
"step. Any code that needs to access a body's properties should be run in "
"here. This method will be passed a ``delta`` parameter, which is a floating-"
"point number equal to the time passed in *seconds* since the last step. When "
"using the default 60 Hz physics update rate, it will typically be equal to "
"``0.01666...`` (but not always, see below)."
msgstr ""
"為了避免這種不準確性, 任何需要存取物體屬性的程式碼都應該在 :ref:`Node."
"_physics_process() <class_Node_method__physics_process>` 回呼函式中運作, 它在"
"每個物理步驟之前以恒定的畫面播放速率(預設為每秒60次)被呼叫. 一個 ``delta`` 參"
"數會傳遞給這個方法, 這個參數是一個浮點數, 等於自上一步以來經過的時間( *秒"
"* ). 當使用預設的60Hz物理更新率時, 它通常等於 ``0.01666...`` (但並非總是如"
"此, 見下文)."

msgid ""
"It's recommended to always use the ``delta`` parameter when relevant in your "
"physics calculations, so that the game behaves correctly if you change the "
"physics update rate or if the player's device can't keep up."
msgstr ""
"建議在物理計算中使用 ``delta`` 參數, 以便當您更改物理更新速率或玩家裝置跟不上"
"時, 遊戲能夠正確運作."

msgid "Collision layers and masks"
msgstr "碰撞層與遮罩"

msgid ""
"One of the most powerful, but frequently misunderstood, collision features "
"is the collision layer system. This system allows you to build up complex "
"interactions between a variety of objects. The key concepts are **layers** "
"and **masks**. Each ``CollisionObject2D`` has 32 different physics layers it "
"can interact with."
msgstr ""
"碰撞層系統是最強大但經常被誤解的碰撞功能之一。該系統允許您在各種物件之間建立"
"複雜的互動。關鍵概念是**層**（Layer）和**遮罩**（Mask）。每個 "
"``CollisionObject2D`` 都有 20 個不同的實體層可以相互作用。"

msgid "Let's look at each of the properties in turn:"
msgstr "讓我們依次看看每個屬性："

msgid "collision_layer"
msgstr "collision_layer"

msgid ""
"This describes the layers that the object appears **in**. By default, all "
"bodies are on layer ``1``."
msgstr "表示該物件**位於**哪些層。預設情況下，所有實體都在圖層 ``1`` 上。"

msgid "collision_mask"
msgstr "collision_mask"

msgid ""
"This describes what layers the body will **scan** for collisions. If an "
"object isn't in one of the mask layers, the body will ignore it. By default, "
"all bodies scan layer ``1``."
msgstr ""
"表示該物件會對哪些層上的實體進行**掃描**。如果物件不在任何遮罩層中，則該實體"
"將其忽略。預設情況下，所有實體都會掃描圖層 ``1``。"

msgid ""
"These properties can be configured via code, or by editing them in the "
"Inspector."
msgstr "可以通過程式碼配置這些屬性，也可以在“屬性面板”中對其進行編輯。"

msgid ""
"Keeping track of what you're using each layer for can be difficult, so you "
"may find it useful to assign names to the layers you're using. Names can be "
"assigned in Project Settings -> Layer Names."
msgstr ""
"追蹤您正在使用每個圖層的內容可能很困難，因此您可能會發現為您正在使用的圖層指"
"定名稱很有用。可以在“專案設定 -> Layer Names”中指定名稱。"

msgid "GUI example"
msgstr "計時器範例"

msgid ""
"You have four node types in your game: Walls, Player, Enemy, and Coin. Both "
"Player and Enemy should collide with Walls. The Player node should detect "
"collisions with both Enemy and Coin, but Enemy and Coin should ignore each "
"other."
msgstr ""
"遊戲中有四種節點型別：牆（Wall）、玩家（Player）、敵人（Enemy）、金幣"
"（Coin）。玩家和敵人都應該與牆碰撞。玩家節點應該偵測與敵人和硬幣的碰撞，但敵"
"人和硬幣應該互相忽略。"

msgid ""
"Start by naming layers 1-4 \"walls\", \"player\", \"enemies\", and \"coins\" "
"and place each node type in its respective layer using the \"Layer\" "
"property. Then set each node's \"Mask\" property by selecting the layers it "
"should interact with. For example, the Player's settings would look like "
"this:"
msgstr ""
"首先將 1 至 4 層分別命名為“walls”（牆）“player”（玩家）“enemies”（敵"
"人）“coins”（金幣）並使用“Layer”屬性將每個節點型別放在其各自的層中。然後通過"
"選擇它應該與之互動的層來設定每個節點的“Mash”屬性。例如，玩家的設定將看起來像"
"這樣："

msgid "Code example"
msgstr "計時器範例"

msgid ""
"In function calls, layers are specified as a bitmask. Where a function "
"enables all layers by default, the layer mask will be given as "
"``0xffffffff``. Your code can use binary, hexadecimal, or decimal notation "
"for layer masks, depending on your preference."
msgstr ""
"在函式呼叫中, 為層指定位元遮罩. 當一個函式預設啟用所有圖層時, 圖層遮罩將被指"
"定為 ``0x7fffffff``. 根據你的喜好, 你的程式碼可以使用二進位, 十六進位或十進位"
"來展示層遮罩."

msgid ""
"The code equivalent of the above example where layers 1, 3 and 4 were "
"enabled would be as follows::"
msgstr "如果要用程式碼來啟用第 1、3、4 層： ::"

msgid "Area2D"
msgstr "Area2D"

msgid ""
"Area nodes provide **detection** and **influence**. They can detect when "
"objects overlap and emit signals when bodies enter or exit. Areas can also "
"be used to override physics properties, such as gravity or damping, in a "
"defined area."
msgstr ""
"Area 節點的作用是**偵測**和**影響**。它們可以偵測物體何時重疊，並在物體進入或"
"離開時發出訊號。Area 也可用於覆蓋物理屬性，例如一定區域內的重力或阻尼。"

msgid "There are three main uses for :ref:`Area2D <class_Area2D>`:"
msgstr ":ref:`Area2D <class_Area2D>` 的主要用途有三種："

msgid "Overriding physics parameters (such as gravity) in a given region."
msgstr "覆蓋給定區域中的物理參數（例如重力）。"

msgid ""
"Detecting when other bodies enter or exit a region or what bodies are "
"currently in a region."
msgstr "偵測其他實體何時進入或退出某個區域或目前哪個實體位於某個區域。"

msgid "Checking other areas for overlap."
msgstr "檢查是否與其他區域重疊。"

msgid "By default, areas also receive mouse and touchscreen input."
msgstr "預設情況下,area還會接收滑鼠和觸控式螢幕輸入."

msgid "StaticBody2D"
msgstr "StaticBody2D"

msgid ""
"A static body is one that is not moved by the physics engine. It "
"participates in collision detection, but does not move in response to the "
"collision. However, it can impart motion or rotation to a colliding body "
"**as if** it were moving, using its ``constant_linear_velocity`` and "
"``constant_angular_velocity`` properties."
msgstr ""
"靜態主體是物理引擎不移動的主體. 它參與碰撞偵測, 但不會回應碰撞而移動. 然而, "
"它可以使用它的 ``constant_linear_velocity`` 和 ``constant_angular_velocity`` "
"屬性將運動或旋轉傳遞給碰撞體, **好像** 它正在移動一樣."

msgid ""
"``StaticBody2D`` nodes are most often used for objects that are part of the "
"environment or that do not need to have any dynamic behavior."
msgstr "``StaticBody2D`` 節點最常用於屬於環境的物件或不需要任何動態行為的物件."

msgid "Example uses for ``StaticBody2D``:"
msgstr "``StaticBody2D`` 的範例用法："

msgid "Platforms (including moving platforms)"
msgstr "平臺（包括可移動的平臺）"

msgid "Conveyor belts"
msgstr "輸送帶"

msgid "Walls and other obstacles"
msgstr "牆壁和其他障礙"

msgid "RigidBody2D"
msgstr "RigidBody2D"

msgid ""
"This is the node that implements simulated 2D physics. You do not control a :"
"ref:`RigidBody2D <class_RigidBody2D>` directly. Instead, you apply forces to "
"it and the physics engine calculates the resulting movement, including "
"collisions with other bodies, and collision responses, such as bouncing, "
"rotating, etc."
msgstr ""
"這是實作類比2D物理的節點. 你不能直接控制一個 :ref:`RigidBody2D "
"<class_RigidBody2D>`. 取而代之的是, 對它施加力, 物理引擎會計算由此產生的運"
"動, 包括與其他物體的碰撞, 以及碰撞回應, 如彈跳, 旋轉等."

msgid ""
"You can modify a rigid body's behavior via properties such as \"Mass\", "
"\"Friction\", or \"Bounce\", which can be set in the Inspector."
msgstr ""
"你可以通過“Mass”（品質）“Friction”（摩擦）“Bounce”（反彈）等屬性修改剛體的行"
"為，這些都可以在屬性面板中設定。"

msgid ""
"The body's behavior is also affected by the world's properties, as set in "
"`Project Settings -> Physics`, or by entering an :ref:`Area2D "
"<class_Area2D>` that is overriding the global physics properties."
msgstr ""
"物體的行為也受到“專案設定 -> Physics”中設定的世界屬性的影響，或者通過輸入覆蓋"
"全域物理屬性的 :ref:`Area2D <class_Area2D>`。"

msgid ""
"When a rigid body is at rest and hasn't moved for a while, it goes to sleep. "
"A sleeping body acts like a static body, and its forces are not calculated "
"by the physics engine. The body will wake up when forces are applied, either "
"by a collision or via code."
msgstr ""
"當一個剛體處於靜止狀態, 有一段時間沒有移動, 它就會進入睡眠狀態. 睡眠的物體就"
"像一個靜態的物體, 它的力不會被物理引擎計算. 當力被施加時, 無論是通過碰撞還是"
"通過程式碼, 該物體都會被喚醒."

msgid "Using RigidBody2D"
msgstr "使用 RigidBody2D"

msgid ""
"One of the benefits of using a rigid body is that a lot of behavior can be "
"had \"for free\" without writing any code. For example, if you were making "
"an \"Angry Birds\"-style game with falling blocks, you would only need to "
"create RigidBody2Ds and adjust their properties. Stacking, falling, and "
"bouncing would automatically be calculated by the physics engine."
msgstr ""
"使用剛體的一個好處是，可以“免費”獲得許多行為而無需編寫任何程式碼。例如，如果"
"您正在製作一個帶有下降塊的《憤怒的小鳥》式遊戲，您只需要建立 RigidBody2D 並調"
"整它們的屬性。堆疊、下降、彈跳將由物理引擎自動計算。"

#, fuzzy
msgid ""
"However, if you do wish to have some control over the body, you should take "
"care - altering the ``position``, ``linear_velocity``, or other physics "
"properties of a rigid body can result in unexpected behavior. If you need to "
"alter any of the physics-related properties, you should use the :ref:"
"`_integrate_forces() <class_RigidBody2D_private_method__integrate_forces>` "
"callback instead of ``_physics_process()``. In this callback, you have "
"access to the body's :ref:`PhysicsDirectBodyState2D "
"<class_PhysicsDirectBodyState2D>`, which allows for safely changing "
"properties and synchronizing them with the physics engine."
msgstr ""
"然而, 如果你確實希望對物體有一些控制, 應該注意改變剛體的 ``position``, "
"``linear_velocity`` 或其他物理屬性可能會導致意外的行為. 如果你需要改變任何與"
"物理相關的屬性, 應該使用 :ref:`_integrate_forces() "
"<class_RigidBody2D_method__integrate_forces>` 回呼函式來代替 "
"``_physics_process()`` . 在這個回呼函式中, 你可以存取body的 :ref:"
"`Physics2DDirectBodyState <class_Physics2DDirectBodyState>`, 它允許安全地改變"
"屬性並與物理引擎同步."

msgid "For example, here is the code for an \"Asteroids\" style spaceship:"
msgstr "例如，以下是《爆破彗星》式太空船的程式碼："

msgid ""
"Note that we are not setting the ``linear_velocity`` or ``angular_velocity`` "
"properties directly, but rather applying forces (``thrust`` and ``torque``) "
"to the body and letting the physics engine calculate the resulting movement."
msgstr ""
"請注意, 我們不是直接設定 ``linear_velocity`` 或 ``angular_velocity`` 屬性, 而"
"是將力( ``thrust`` 和 ``torque`` )施加到物體上並讓物理引擎計算出最終的運動."

msgid ""
"When a rigid body goes to sleep, the ``_integrate_forces()`` function will "
"not be called. To override this behavior, you will need to keep the body "
"awake by creating a collision, applying a force to it, or by disabling the :"
"ref:`can_sleep <class_RigidBody2D_property_can_sleep>` property. Be aware "
"that this can have a negative effect on performance."
msgstr ""
"當一個剛體進入睡眠狀態時, ``_integrate_forces()`` 函式將不會被呼叫. 要重寫這"
"一行為, 您需要通過建立碰撞, 對其施加力或禁用 :ref:`can_sleep "
"<class_RigidBody2D_property_can_sleep>` 屬性來保持物體的啟動. 請注意, 這可能"
"會對性能產生負面影響."

msgid "Contact reporting"
msgstr "接觸報告"

msgid ""
"By default, rigid bodies do not keep track of contacts, because this can "
"require a huge amount of memory if many bodies are in the scene. To enable "
"contact reporting, set the :ref:`max_contacts_reported "
"<class_RigidBody2D_property_max_contacts_reported>` property to a non-zero "
"value. The contacts can then be obtained via :ref:`PhysicsDirectBodyState2D."
"get_contact_count() "
"<class_PhysicsDirectBodyState2D_method_get_contact_count>` and related "
"functions."
msgstr ""
"預設情況下, 剛體不會追蹤接觸點, 因為如果場景中存在許多體, 這可能需要大量的記"
"憶體. 要啟用接觸報告, 請將 :ref:`contacts_reported "
"<class_RigidBody2D_property_contacts_reported>` 屬性設定為非零值. 然後可以通"
"過 :ref:`Physics2DDirectBodyState.get_contact_count() "
"<class_Physics2DDirectBodyState_method_get_contact_count>` 和相關函式獲得聯"
"繫."

msgid ""
"Contact monitoring via signals can be enabled via the :ref:`contact_monitor "
"<class_RigidBody2D_property_contact_monitor>` property. See :ref:"
"`RigidBody2D <class_RigidBody2D>` for the list of available signals."
msgstr ""
"通過訊號的接觸監控, 啟用 :ref:`contact_monitor "
"<class_RigidBody2D_property_contact_monitor>` 屬性. 請參閱 :ref:`RigidBody2D "
"<class_RigidBody2D>` 的可用訊號列表."

msgid "CharacterBody2D"
msgstr "CharacterBody2D"

msgid ""
":ref:`CharacterBody2D <class_CharacterBody2D>` bodies detect collisions with "
"other bodies, but are not affected by physics properties like gravity or "
"friction. Instead, they must be controlled by the user via code. The physics "
"engine will not move a character body."
msgstr ""
":ref:`KinematicBody2D <class_KinematicBody2D>` 物體偵測與其他物體的碰撞, 但不"
"受重力或摩擦等物理屬性的影響. 相反, 它們必須由使用者通過程式碼控制. 物理引擎"
"不會移動運動體."

msgid ""
"When moving a character body, you should not set its ``position`` directly. "
"Instead, you use the ``move_and_collide()`` or ``move_and_slide()`` methods. "
"These methods move the body along a given vector, and it will instantly stop "
"if a collision is detected with another body. After the body has collided, "
"any collision response must be coded manually."
msgstr ""
"移動運動體時, 不應直接設定其 ``position`` . 相反, 您使用 "
"``move_and_collide()`` 或 ``move_and_slide()`` 方法. 這些方法沿著給定的向量移"
"動物體, 如果與另一個物體偵測到碰撞, 它將立即停止. 在物體發生碰撞後, 必須手動"
"編碼任何碰撞回應."

msgid "Character collision response"
msgstr "顯示碰撞區域"

msgid ""
"After a collision, you may want the body to bounce, to slide along a wall, "
"or to alter the properties of the object it hit. The way you handle "
"collision response depends on which method you used to move the "
"CharacterBody2D."
msgstr ""
"碰撞後, 您可能希望物體反彈, 沿著牆壁滑動, 或者改變它所擊中的物體的屬性. 處理"
"碰撞回應的方式取決於您用於移動KinematicBody2D的方法."

msgid ":ref:`move_and_collide <class_PhysicsBody2D_method_move_and_collide>`"
msgstr ""
":ref:`move_and_collide <class_KinematicBody2D_method_move_and_collide>`"

msgid ""
"When using ``move_and_collide()``, the function returns a :ref:"
"`KinematicCollision2D <class_KinematicCollision2D>` object, which contains "
"information about the collision and the colliding body. You can use this "
"information to determine the response."
msgstr ""
"當使用 ``move_and_collide()`` 時, 該函式返回一個 :ref:`KinematicCollision2D "
"<class_KinematicCollision2D>` 物件, 其中包含有關碰撞和碰撞體的資訊. 您可以使"
"用此資訊來確定回應."

msgid ""
"For example, if you want to find the point in space where the collision "
"occurred:"
msgstr "例如, 如果要搜尋發生碰撞的空間點:"

msgid "Or to bounce off of the colliding object:"
msgstr "或者從碰撞物體反彈:"

msgid ":ref:`move_and_slide <class_CharacterBody2D_method_move_and_slide>`"
msgstr ":ref:`move_and_slide <class_KinematicBody2D_method_move_and_slide>`"

msgid ""
"Sliding is a common collision response; imagine a player moving along walls "
"in a top-down game or running up and down slopes in a platformer. While it's "
"possible to code this response yourself after using ``move_and_collide()``, "
"``move_and_slide()`` provides a convenient way to implement sliding movement "
"without writing much code."
msgstr ""
"滑動是一種常見的碰撞回應; 想像一個遊戲角色在上帝視角的遊戲中沿著牆壁移動, 或"
"者在平臺遊戲中上下坡. 雖然可在使用 ``move_and_collide()`` 之後自己編寫這個回"
"應, 但 ``move_and_slide()`` 提供了一種快捷方法來實作滑動且無需編寫太多程式碼."

msgid ""
"``move_and_slide()`` automatically includes the timestep in its calculation, "
"so you should **not** multiply the velocity vector by ``delta``."
msgstr ""
"``move_and_slide()`` 在計算中自動包含時間步長, 因此您 **不** 應將速度向量乘"
"以 ``delta`` ."

msgid ""
"For example, use the following code to make a character that can walk along "
"the ground (including slopes) and jump when standing on the ground:"
msgstr ""
"例如, 使用以下程式碼製作一個可以沿著地面(包括斜坡)行走的角色, 並在站在地面時"
"跳躍:"

msgid ""
"See :ref:`doc_kinematic_character_2d` for more details on using "
"``move_and_slide()``, including a demo project with detailed code."
msgstr ""
"有關使用 ``move_and_slide()`` 的更多詳細資訊, 請參閱 :ref:"
"`doc_kinematic_character_2d` , 包括帶有詳細程式碼的演示專案."

msgid "Translation status"
msgstr "翻譯狀態"
