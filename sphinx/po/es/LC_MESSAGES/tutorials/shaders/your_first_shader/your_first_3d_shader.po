# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Your first 3D shader"
msgstr "Tu primer shader 3D"

#, fuzzy
msgid ""
"You have decided to start writing your own custom Spatial shader. Maybe you "
"saw a cool trick online that was done with shaders, or you have found that "
"the :ref:`StandardMaterial3D <class_StandardMaterial3D>` isn't quite meeting "
"your needs. Either way, you have decided to write your own and now you need "
"to figure out where to start."
msgstr ""
"Has decidido comenzar a escribir tu propio shader espacial personalizado. "
"Quizás viste un truco genial en línea realizado con shaders, o has "
"descubierto que el :ref:`SpatialMaterial <class_SpatialMaterial>` no "
"satisface completamente tus necesidades. De cualquier manera, has decidido "
"escribir el tuyo propio y ahora necesitas saber por dónde empezar."

msgid ""
"This tutorial will explain how to write a Spatial shader and will cover more "
"topics than the :ref:`CanvasItem <doc_your_first_canvasitem_shader>` "
"tutorial."
msgstr ""
"Este tutorial explicará cómo escribir un Spatial shader y cubrirá más temas "
"que el tutorial :ref:`CanvasItem <doc_your_first_canvasitem_shader>`."

msgid ""
"Spatial shaders have more built-in functionality than CanvasItem shaders. "
"The expectation with spatial shaders is that Godot has already provided the "
"functionality for common use cases and all the user needs to do in the "
"shader is set the proper parameters. This is especially true for a PBR "
"(physically based rendering) workflow."
msgstr ""
"Los Spatial shaders tienen más funcionalidad incorporada que los shaders "
"CanvasItem. Lo que se espera de los shaders espaciales es que Godot ya ha "
"proporcionado la funcionalidad para los casos de uso común y todo lo que el "
"usuario necesita hacer en el shader es establecer los parámetros adecuados. "
"Esto es especialmente cierto para un flujo de trabajo de PBR (renderización "
"basada en la física)."

#, fuzzy
msgid ""
"This is a two-part tutorial. In this first part we will create terrain using "
"vertex displacement from a heightmap in the vertex function. In the :ref:"
"`second part <doc_your_second_spatial_shader>` we will take the concepts "
"from this tutorial and set up custom materials in a fragment shader by "
"writing an ocean water shader."
msgstr ""
"Este es un tutorial de dos partes. En esta primera parte vamos a repasar "
"cómo hacer un terreno simple usando el desplazamiento de vértices de un mapa "
"de altura en la función de vértices. En la :ref:`second part "
"<doc_your_second_spatial_shader>` vamos a tomar los conceptos de este "
"tutorial y vamos a caminar a través de cómo configurar los materiales "
"personalizados en un shader de fragmentos escribiendo un shader de agua del "
"océano."

msgid ""
"This tutorial assumes some basic shader knowledge such as types (``vec2``, "
"``float``, ``sampler2D``), and functions. If you are uncomfortable with "
"these concepts it is best to get a gentle introduction from `The Book of "
"Shaders <https://thebookofshaders.com>`_ before completing this tutorial."
msgstr ""
"Este tutorial asume algunos conocimientos básicos de shader como los tipos "
"(``vec2``, ``float``, ``sampler2D``), y las funciones. Si te sientes "
"incómodo con estos conceptos es mejor obtener una introducción suave de `The "
"Book of Shaders <https://thebookofshaders.com>`_ antes de completar este "
"tutorial."

msgid "Where to assign my material"
msgstr "Dónde asignar mi material"

msgid ""
"In 3D, objects are drawn using :ref:`Meshes <class_Mesh>`. Meshes are a "
"resource type that store geometry (the shape of your object) and materials "
"(the color and how the object reacts to light) in units called \"surfaces\". "
"A Mesh can have multiple surfaces, or just one. Typically, you would import "
"a mesh from another program (e.g. Blender). But Godot also has a few :ref:"
"`PrimitiveMeshes <class_primitivemesh>` that allow you to add basic geometry "
"to a scene without importing Meshes."
msgstr ""
"En 3D, los objetos se dibujan usando :ref:`Meshes <class_Mesh>`. Las mallas "
"son un tipo de recurso que almacena la geometría (la forma de su objeto) y "
"los materiales (el color y cómo el objeto reacciona a la luz) en unidades "
"llamadas \"superficies\". Una Malla puede tener múltiples superficies, o "
"sólo una. Típicamente, importarías una malla de otro programa (por ejemplo, "
"Blender). Pero Godot también tiene unos cuantos :ref:`PrimitiveMeshes "
"<class_primitivemesh>` que te permiten añadir geometría básica a una escena "
"sin importar las Mallas."

#, fuzzy
msgid ""
"There are multiple node types that you can use to draw a mesh. The main one "
"is :ref:`MeshInstance3D <class_MeshInstance3D>`, but you can also use :ref:"
"`GPUParticles3D <class_GPUParticles3D>`, :ref:`MultiMeshes "
"<class_MultiMesh>` (with a :ref:`MultiMeshInstance3D "
"<class_MultiMeshInstance3D>`), or others."
msgstr ""
"Hay múltiples tipos de nodos que puedes usar para dibujar una malla. El "
"principal es :ref:`MeshInstance <class_meshinstance>`, pero también puedes "
"usar :ref:`Particles <class_particles>`, :ref:`MultiMeshes "
"<class_MultiMesh>` (con un :ref:`MultiMeshInstance "
"<class_multimeshinstance>`), u otros."

#, fuzzy
msgid ""
"Typically, a material is associated with a given surface in a mesh, but some "
"nodes, like MeshInstance3D, allow you to override the material for a "
"specific surface, or for all surfaces."
msgstr ""
"Típicamente, un material se asocia con una superficie dada en una malla, "
"pero algunos nodos, como MeshInstance, permite sobreescribir el material "
"para una superficie específica, o para todas las superficies."

#, fuzzy
msgid ""
"If you set a material on the surface or mesh itself, then all "
"MeshInstance3Ds that share that mesh will share that material. However, if "
"you want to reuse the same mesh across multiple mesh instances, but have "
"different materials for each instance then you should set the material on "
"the MeshInstance3D."
msgstr ""
"Si colocas un material en la superficie o en la malla misma, entonces todas "
"las MeshInstances que comparten esa malla compartirán ese material. Sin "
"embargo, si desea reutilizar la misma malla en múltiples instancias de la "
"malla, pero tiene diferentes materiales para cada instancia, entonces debe "
"colocar el material en la MeshInstance."

#, fuzzy
msgid ""
"For this tutorial we will set our material on the mesh itself rather than "
"taking advantage of the MeshInstance3D's ability to override materials."
msgstr ""
"Para este tutorial pondremos nuestro material en la malla misma en lugar de "
"aprovechar la habilidad de la MeshInstance para sobreescribir materiales."

msgid "Setting up"
msgstr "Configurando"

#, fuzzy
msgid ""
"Add a new :ref:`MeshInstance3D <class_MeshInstance3D>` node to your scene."
msgstr ""
"Añade un nuevo nodo :ref:`MeshInstance <class_meshinstance>` a tu escena."

msgid ""
"In the inspector tab beside \"Mesh\" click \"[empty]\" and select \"New "
"PlaneMesh\". Then click on the image of a plane that appears."
msgstr ""
"En la pestaña del inspector al lado de \"Mesh\" haga clic en \"[empty]\" y "
"seleccione \"New PlaneMesh\". Luego haga clic en la imagen de un avión que "
"aparece."

msgid "This adds a :ref:`PlaneMesh <class_planemesh>` to our scene."
msgstr "Esto agrega un :ref:`PlaneMesh <class_planemesh>` a nuestra escena."

msgid ""
"Then, in the viewport, click in the upper left corner on the button that "
"says \"Perspective\". A menu will appear. In the middle of the menu are "
"options for how to display the scene. Select 'Display Wireframe'."
msgstr ""
"Luego, en el viewport, haga clic en la esquina superior izquierda en el "
"botón que dice \"Perspectiva\". Aparecerá un menú. En el medio del menú hay "
"opciones para mostrar la escena. Selecciona 'Display Wireframe'."

msgid "This will allow you to see the triangles making up the plane."
msgstr "Esto te permitirá ver los triángulos que componen el avión."

#, fuzzy
msgid ""
"Now set ``Subdivide Width`` and ``Subdivide Depth`` of the :ref:`PlaneMesh "
"<class_planemesh>` to ``32``."
msgstr "Ahora pon ``Subdivide Width`` y ``Subdivide Depth`` en ``32``."

#, fuzzy
msgid ""
"You can see that there are now many more triangles in the :ref:"
"`MeshInstance3D<class_MeshInstance3D>`. This will give us more vertices to "
"work with and thus allow us to add more detail."
msgstr ""
"Puedes ver que ahora hay muchos más triángulos en la :ref:"
"`Mesh<clase_MeshInstance>`. Esto nos dará más vértices con los que trabajar "
"y nos permitirá añadir más detalles."

#, fuzzy
msgid ""
":ref:`PrimitiveMeshes <class_primitivemesh>`, like PlaneMesh, only have one "
"surface, so instead of an array of materials there is only one. Click beside "
"\"Material\" where it says \"[empty]\" and select \"New ShaderMaterial\". "
"Then click the sphere that appears."
msgstr ""
"Superficie, así que en lugar de un array de materiales, solo hay uno. Haz "
"clic al lado de \"Material\" donde dice \"[vacío]\" y selecciona \"Nuevo "
"ShaderMaterial\". Luego, haz clic en la esfera que aparece."

msgid ""
"Now click beside \"Shader\" where it says \"[empty]\" and select \"New "
"Shader\"."
msgstr ""
"Ahora haz clic al lado de \"Shader\" donde dice \"[empty]\" y selecciona "
"\"New Shader\"."

msgid ""
"The shader editor should now pop up and you are ready to begin writing your "
"first Spatial shader!"
msgstr ""
"El editor shader debería aparecer ahora y estás listo para empezar a "
"escribir tu primer shader Espacial!"

msgid "Shader magic"
msgstr "Magia Shader"

#, fuzzy
msgid ""
"The new shader is already generated with a ``shader_type`` variable and the "
"``fragment()`` function. The first thing Godot shaders need is a declaration "
"of what type of shader they are. In this case the ``shader_type`` is set to "
"``spatial`` because this is a spatial shader."
msgstr ""
"¿Notas que ya hay un error? Esto se debe a que el editor de shaders recarga "
"los shader al vuelo. Lo primero que necesitan los shaders Godot es una "
"declaración de qué tipo de shader son. Ponemos la variable ``shader_type`` "
"en ``spatial`` porque es un shader espacial."

#, fuzzy
msgid ""
"For now ignore the ``fragment()`` function and define the ``vertex()`` "
"function. The ``vertex()`` function determines where the vertices of your :"
"ref:`MeshInstance3D<class_MeshInstance3D>` appear in the final scene. We "
"will be using it to offset the height of each vertex and make our flat plane "
"appear like a little terrain."
msgstr ""
"A continuación, definiremos la función ``vertex()``. La función ``vertex()`` "
"determina dónde aparecen los vértices de tu :ref:`Mesh<class_MeshInstance>` "
"en la escena final. La usaremos para desplazar la altura de cada vértice y "
"hacer que nuestro plano llano aparezca como un pequeño terreno."

msgid "We define the vertex shader like so:"
msgstr "Definimos el shader de vértices así:"

msgid ""
"With nothing in the ``vertex()`` function, Godot will use its default vertex "
"shader. We can easily start to make changes by adding a single line:"
msgstr ""
"Sin nada en la función ``vertex()``, Godot usará su shader de vértices por "
"defecto. Podemos empezar a hacer cambios fácilmente añadiendo una sola línea:"

msgid "Adding this line, you should get an image like the one below."
msgstr "Añadiendo esta línea, deberías obtener una imagen como la de abajo."

msgid ""
"Okay, let's unpack this. The ``y`` value of the ``VERTEX`` is being "
"increased. And we are passing the ``x`` and ``z`` components of the "
"``VERTEX`` as arguments to ``cos`` and ``sin``; that gives us a wave-like "
"appearance across the ``x`` and ``z`` axes."
msgstr ""
"Bien, vamos a desempacar esto. El valor ``y`` del ``VERTEX`` se está "
"incrementando. Y estamos pasando los componentes ``x`` y ``z`` del "
"``VERTEX`` como argumentos para ``cos`` y ``sin``; eso nos da una apariencia "
"de onda a través de los ejes ``x`` y ``z``."

msgid ""
"What we want to achieve is the look of little hills; after all. ``cos`` and "
"``sin`` already look kind of like hills. We do so by scaling the inputs to "
"the ``cos`` and ``sin`` functions."
msgstr ""
"Lo que queremos lograr es el aspecto de pequeñas colinas; después de todo. "
"``cos`` y ``sin`` ya se parecen a las colinas. Lo hacemos escalando las "
"entradas a las funciones ``cos`` y ``sin``."

msgid ""
"This looks better, but it is still too spiky and repetitive, let's make it a "
"little more interesting."
msgstr ""
"Esto se ve mejor, pero sigue siendo demasiado puntiagudo y repetitivo, "
"hagámoslo un poco más interesante."

msgid "Noise heightmap"
msgstr "Mapa de altura con ruido"

msgid ""
"Noise is a very popular tool for faking the look of terrain. Think of it as "
"similar to the cosine function where you have repeating hills except, with "
"noise, each hill has a different height."
msgstr ""
"Noise(Ruido) es una herramienta muy popular para fingir el aspecto del "
"terreno. Piense en ello como en la función del coseno, donde tiene colinas "
"que se repiten, excepto que, con el ruido, cada colina tiene una altura "
"diferente."

#, fuzzy
msgid ""
"Godot provides the :ref:`NoiseTexture2D <class_noisetexture2D>` resource for "
"generating a noise texture that can be accessed from a shader."
msgstr ""
"Godot proporciona el recurso :ref:`NoiseTexture <class_noisetexture>` para "
"generar una textura de ruido a la que se puede acceder desde un shader."

msgid ""
"To access a texture in a shader add the following code near the top of your "
"shader, outside the ``vertex()`` function."
msgstr ""
"Para acceder a una textura en un shader agregue el siguiente código cerca de "
"la parte superior de su shader, fuera de la función ``vertex()``."

msgid ""
"This will allow you to send a noise texture to the shader. Now look in the "
"inspector under your material. You should see a section called \"Shader "
"Params\". If you open it up, you'll see a section called \"noise\"."
msgstr ""
"Esto te permitirá enviar una textura de ruido al shader. Ahora mira en el "
"inspector debajo de tu material. Deberías ver una sección llamada \"Shader "
"Params\". Si la abres, verás una sección llamada \"noise\"."

#, fuzzy
msgid ""
"Click beside it where it says \"[empty]\" and select \"New NoiseTexture2D\". "
"Then in your :ref:`NoiseTexture2D <class_noisetexture2D>` click beside where "
"it says \"Noise\" and select \"New FastNoiseLite\"."
msgstr ""
"Haz clic al lado donde dice \"[empty]\" y selecciona \"New NoiseTexture\". "
"Luego en tu NoiseTexture haz clic al lado donde dice \"Noise\" y selecciona "
"\"New OpenSimplexNoise\"."

msgid ""
":ref:`FastNoiseLite <class_fastnoiselite>` is used by the NoiseTexture2D to "
"generate a heightmap."
msgstr ""
":ref:`FastNoiseLite <class_fastnoiselite>` es utilizado por NoiseTexture2D "
"para generar un heightmap (mapa de altura)."

msgid "Once you set it up and should look like this."
msgstr "Una vez que esté todo configurado, debería verse así."

#, fuzzy
msgid ""
"Now, access the noise texture using the ``texture()`` function. "
"``texture()`` takes a texture as the first argument and a ``vec2`` for the "
"position on the texture as the second argument. We use the ``x`` and ``z`` "
"channels of ``VERTEX`` to determine where on the texture to look up. Note "
"that the PlaneMesh coordinates are within the [-1,1] range (for a size of "
"2), while the texture coordinates are within [0,1], so to normalize we "
"divide by the size of the PlaneMesh by 2.0 and add 0.5. ``texture()`` "
"returns a ``vec4`` of the ``r, g, b, a`` channels at the position. Since the "
"noise texture is grayscale, all of the values are the same, so we can use "
"any one of the channels as the height. In this case we'll use the ``r``, or "
"``x`` channel."
msgstr ""
"Ahora, accede a la textura del ruido usando la función ``texture()``. "
"``texture()`` toma una textura como primer argumento y un ``vec2`` para la "
"posición en la textura como segundo argumento. Usamos los canales ``x`` y "
"``z`` de ``VERTEX`` para determinar en qué parte de la textura buscar. "
"Observa que las coordenadas del PlaneMesh están dentro del rango [-1,1] "
"(para un tamaño de 2), mientras que las coordenadas de la textura están "
"dentro de [0,1], así que para normalizar dividimos por el tamaño del "
"PlaneMesh 2.0 y sumamos 0.5. ``texture`` devuelve un ``vec4`` de los canales "
"``r, g, b, a`` en la posición. Como la textura del ruido es en escala de "
"grises, todos los valores son iguales, así que podemos usar cualquiera de "
"los canales como la altura. En este caso usaremos el canal ``r``, o ``x``."

msgid ""
"Note: ``xyzw`` is the same as ``rgba`` in GLSL, so instead of ``texture()."
"x`` above, we could use ``texture().r``. See the `OpenGL documentation "
"<https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)#Vectors>`_ for more "
"details."
msgstr ""
"Nota: ``xyzw`` es lo mismo que ``rgba`` en GLSL, así que en lugar de "
"``texture().x`` arriba, podríamos usar ``texture().r``. Mira la "
"``Documentación OpenGL <https://www.khronos.org/opengl/wiki/"
"Data_Type_(GLSL)#Vectores>`_ para mayor detalle."

msgid "Using this code you can see the texture creates random looking hills."
msgstr ""
"Usando este código puedes ver que la textura crea colinas de aspecto "
"aleatorio."

msgid ""
"Right now it is too spiky, we want to soften the hills a bit. To do that, we "
"will use a uniform. You already used a uniform above to pass in the noise "
"texture, now let's learn how they work."
msgstr ""
"Ahora mismo es demasiado puntiagudo, queremos suavizar un poco las colinas. "
"Para ello, usaremos un uniforme. Ya usaste un uniforme arriba para pasar la "
"textura del ruido, ahora vamos a aprender cómo funcionan."

msgid "Uniforms"
msgstr "Uniforms"

msgid ""
"Uniform variables allow you to pass data from the game into the shader. They "
"are very useful for controlling shader effects. Uniforms can be almost any "
"datatype that can be used in the shader. To use a uniform, you declare it in "
"your :ref:`Shader<class_Shader>` using the keyword ``uniform``."
msgstr ""
"Las variables uniformes permiten pasar datos del juego al shader. Son muy "
"útiles para controlar los efectos shader. Los uniformes pueden ser casi "
"cualquier tipo de dato que se pueda usar en el shader. Para usar un "
"uniforme, lo declaras en tu :ref:`Shader<class_Shader>` usando la palabra "
"clave ``uniform``."

msgid "Let's make a uniform that changes the height of the terrain."
msgstr "Hagamos un uniforme que cambie la altura del terreno."

#, fuzzy
msgid ""
"Godot lets you initialize a uniform with a value; here, ``height_scale`` is "
"set to ``0.5``. You can set uniforms from GDScript by calling the function "
"``set_shader_parameter()`` on the material corresponding to the shader. The "
"value passed from GDScript takes precedence over the value used to "
"initialize it in the shader."
msgstr ""
"Godot te permite inicializar un uniforme con un valor; aquí, la "
"``height_scale`` se establece en ``0.5``. Puedes establecer uniformes desde "
"GDScript llamando a la función ``set_shader_param()`` en el material "
"correspondiente al shader. El valor pasado desde GDScript tiene prioridad "
"sobre el valor usado para inicializarlo en el shader."

#, fuzzy
msgid ""
"Changing uniforms in Spatial-based nodes is different from CanvasItem-based "
"nodes. Here, we set the material inside the PlaneMesh resource. In other "
"mesh resources you may need to first access the material by calling "
"``surface_get_material()``. While in the MeshInstance3D you would access the "
"material using ``get_surface_material()`` or ``material_override``."
msgstr ""
"El cambio de uniformes en los nodos basados en el espacio es diferente de "
"los nodos basados en el CanvasItem. Aquí, ponemos el material dentro del "
"recurso PlaneMesh. En otros recursos de malla puede que necesites acceder "
"primero al material llamando a ``surface_get_material()``. Mientras que en "
"el recurso MeshInstance accederías al material usando "
"``get_surface_material()`` o ``material_override``."

#, fuzzy
msgid ""
"Remember that the string passed into ``set_shader_parameter()`` must match "
"the name of the uniform variable in the :ref:`Shader<class_Shader>`. You can "
"use the uniform variable anywhere inside your :ref:`Shader<class_Shader>`. "
"Here, we will use it to set the height value instead of arbitrarily "
"multiplying by ``0.5``."
msgstr ""
"Recuerda que la string pasada a ``set_shader_param()`` debe coincidir con el "
"nombre de la variable uniforme en el :ref:`Shader<class_Shader>`. Puedes "
"usar la variable uniforme en cualquier lugar dentro de tu :ref:"
"`Shader<class_Shader>`. Aquí, la usaremos para establecer el valor de la "
"altura en lugar de multiplicarla arbitrariamente por ``0.5``."

msgid "Now it looks much better."
msgstr "Ahora se ve mucho mejor."

#, fuzzy
msgid ""
"Using uniforms, we can even change the value every frame to animate the "
"height of the terrain. Combined with :ref:`Tweens <class_Tween>`, this can "
"be especially useful for animations."
msgstr ""
"Usando uniformes, podemos incluso cambiar el valor en cada cuadro para "
"animar la altura del terreno. Combinado con :ref:`Tweens <class_Tween>`, "
"esto puede ser especialmente útil para animaciones simples."

msgid "Interacting with light"
msgstr "Interactuar con la luz"

msgid ""
"First, turn wireframe off. To do so, click in the upper-left of the Viewport "
"again, where it says \"Perspective\", and select \"Display Normal\"."
msgstr ""
"Primero, apaga el marco de alambre. Para ello, haz clic en la parte superior "
"izquierda del Viewport de nuevo, donde dice \"Perspectiva\", y selecciona "
"\"Visualización Normal\"."

msgid ""
"Note how the mesh color goes flat. This is because the lighting on it is "
"flat. Let's add a light!"
msgstr ""
"Fíjese en cómo el color de la malla se vuelve plano. Esto se debe a que la "
"iluminación de la misma es plana. ¡Añadamos una luz!"

#, fuzzy
msgid ""
"First, we will add an :ref:`OmniLight3D<class_OmniLight3D>` to the scene."
msgstr ""
"Primero, agregaremos una :ref:`OmniLight<class_OmniLight>` a la escena."

msgid ""
"You can see the light affecting the terrain, but it looks odd. The problem "
"is the light is affecting the terrain as if it were a flat plane. This is "
"because the light shader uses the normals from the :ref:`Mesh <class_mesh>` "
"to calculate light."
msgstr ""
"Se puede ver la luz que afecta al terreno, pero se ve rara. El problema es "
"que la luz está afectando al terreno como si fuera plano. Esto se debe a que "
"el shader de luz utiliza las normales de la :ref:`Mesh <class_mesh>` para "
"calcular la iluminación."

msgid ""
"The normals are stored in the Mesh, but we are changing the shape of the "
"Mesh in the shader, so the normals are no longer correct. To fix this, we "
"can recalculate the normals in the shader or use a normal texture that "
"corresponds to our noise. Godot makes both easy for us."
msgstr ""
"Los normales se almacenan en la Mesh, pero estamos cambiando la forma de la "
"Malla en el shader, por lo que los normales ya no son correctos. Para "
"arreglar esto, podemos recalcular los normales en el shader o usar una "
"textura normal que corresponda a nuestro ruido. Godot hace ambas cosas "
"fáciles para nosotros."

msgid ""
"You can calculate the new normal manually in the vertex function and then "
"just set ``NORMAL``. With ``NORMAL`` set, Godot will do all the difficult "
"lighting calculations for us. We will cover this method in the next part of "
"this tutorial, for now we will read normals from a texture."
msgstr ""
"Puedes calcular la nueva normalidad manualmente en la función de vértice y "
"luego sólo tienes que poner \"NORMAL\". Con \"NORMAL\", Godot hará todos los "
"cálculos de iluminación difíciles para nosotros. Cubriremos este método en "
"la próxima parte de este tutorial, por ahora leeremos normales de una "
"textura."

msgid ""
"Instead we will rely on the NoiseTexture again to calculate normals for us. "
"We do that by passing in a second noise texture."
msgstr ""
"En cambio, confiaremos en el NoiseTexture de nuevo para calcular las "
"normales por nosotros. Lo hacemos pasando una segunda textura de ruido."

#, fuzzy
msgid ""
"Set this second uniform texture to another :ref:`NoiseTexture2D "
"<class_noisetexture2D>` with another :ref:`FastNoiseLite "
"<class_fastnoiselite>`. But this time, check **As Normalmap**."
msgstr ""
"Establece esta segunda textura de uniforme con otro NoiseTexture utilizando "
"otro OpenSimplexNoise. Pero esta vez, marca la opción \"As Normalmap\"."

msgid ""
"Now, because this is a normalmap and not a per-vertex normal, we are going "
"to assign it in the ``fragment()`` function. The ``fragment()`` function "
"will be explained in more detail in the next part of this tutorial."
msgstr ""
"Ahora, porque este es un mapa normal y no un normal por vértice, vamos a "
"asignarlo en la función ``fragment()``. La función ``fragment()`` se "
"explicará con más detalle en la siguiente parte de este tutorial."

#, fuzzy
msgid ""
"When we have normals that correspond to a specific vertex we set ``NORMAL``, "
"but if you have a normalmap that comes from a texture, set the normal using "
"``NORMAL_MAP``. This way Godot will handle the wrapping of texture around "
"the mesh automatically."
msgstr ""
"Cuando tenemos normales que corresponden a un vértice específico ponemos "
"\"NORMAL\", pero si tienes un mapa de normales que viene de una textura, pon "
"la normal usando ``NORMALMAP``. De esta manera Godot manejará el envolver la "
"textura alrededor de la malla automáticamente."

msgid ""
"Lastly, in order to ensure that we are reading from the same places on the "
"noise texture and the normalmap texture, we are going to pass the ``VERTEX."
"xz`` position from the ``vertex()`` function to the ``fragment()`` function. "
"We do that with varyings."
msgstr ""
"Por último, para asegurarnos de que estamos leyendo de los mismos lugares en "
"la textura del ruido y la textura del mapa normal, vamos a pasar la posición "
"``VERTEX.xz`` de la función ``vertex()`` a la función ``fragment()``. Lo "
"hacemos con variaciones."

msgid ""
"Above the ``vertex()`` define a ``vec2`` called ``tex_position``. And inside "
"the ``vertex()`` function assign ``VERTEX.xz`` to ``tex_position``."
msgstr ""
"Sobre el ``vertex()`` define un ``vec2`` llamado ``tex_position``. Y dentro "
"de la función ``vertex()`` asigna ``VERTEX.xz`` a la ``tex_position``."

msgid ""
"And now we can access ``tex_position`` from the ``fragment()`` function."
msgstr ""
"Y ahora podemos acceder a ``tex_position`` desde la función ``fragment()``."

msgid ""
"With the normals in place the light now reacts to the height of the mesh "
"dynamically."
msgstr ""
"Con los normales en su lugar la luz ahora reacciona a la altura de la malla "
"de forma dinámica."

msgid ""
"We can even drag the light around and the lighting will update automatically."
msgstr ""
"Incluso podemos arrastrar la luz y la iluminación se actualizará "
"automáticamente."

msgid ""
"Here is the full code for this tutorial. You can see it is not very long as "
"Godot handles most of the difficult stuff for you."
msgstr ""
"Aquí está el código completo de este tutorial. Puedes ver que no es muy "
"largo ya que Godot maneja la mayoría de las cosas difíciles para ti."

msgid ""
"That is everything for this part. Hopefully, you now understand the basics "
"of vertex shaders in Godot. In the next part of this tutorial we will write "
"a fragment function to accompany this vertex function and we will cover a "
"more advanced technique to turn this terrain into an ocean of moving waves."
msgstr ""
"Eso es todo para esta parte. Esperemos que ahora entiendas lo básico de los "
"sombreadores de vértices en Godot. En la próxima parte de este tutorial "
"escribiremos una función de fragmento para acompañar esta función de vértice "
"y cubriremos una técnica más avanzada para convertir este terreno en un "
"océano de olas en movimiento."

msgid "Translation status"
msgstr "Estado de traducción"
