# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Screen-reading shaders"
msgstr "屏幕读取着色器"

msgid "Introduction"
msgstr "前言"

msgid ""
"It is often desired to make a shader that reads from the same screen to "
"which it's writing. 3D APIs, such as OpenGL or DirectX, make this very "
"difficult because of internal hardware limitations. GPUs are extremely "
"parallel, so reading and writing causes all sorts of cache and coherency "
"problems. As a result, not even the most modern hardware supports this "
"properly."
msgstr ""
"很多人想要让着色器在写屏幕的同时读取该屏幕的数据。因为内部硬件限制，OpenGL "
"和 DirectX 等 3D API 都很难实现这一功能。GPU 是极其并行的，所以同时进行读写会"
"导致各种缓存和一致性问题。因此，即便是最新的硬件也对此进行无法正确的支持。"

msgid ""
"The workaround is to make a copy of the screen, or a part of the screen, to "
"a back-buffer and then read from it while drawing. Godot provides a few "
"tools that make this process easy."
msgstr ""
"解决办法是将屏幕或屏幕的一部分复制到一个后台缓冲区，然后在绘图时从那里读取。"
"Godot 提供了一些工具，可以使这一过程变得很容易。"

msgid "Screen texture"
msgstr "屏幕纹理"

#, fuzzy
msgid ""
"Godot :ref:`doc_shading_language` has a special texture to access the "
"already rendered contents of the screen. It is used by specifying a hint "
"when declaring a ``sampler2D`` uniform: ``hint_screen_texture``. A special "
"built-in varying ``SCREEN_UV`` can be used to obtain the UV relative to the "
"screen for the current fragment. As a result, this canvas_item fragment "
"shader results in an invisible object, because it only shows what lies "
"behind:"
msgstr ""
"Godot :ref:`doc_shading_language` 有一个特殊的纹理, ``SCREEN_TEXTURE`` (在3D"
"的情况下, ``DEPTH_TEXTURE`` 代表深度). 它以屏幕的UV作为参数, 并返回一个带有颜"
"色的RGB vec3. 一个特殊的内置变量.SCREEN_UV可以用来获取当前片段的UV. 因此, 这"
"是个简单的canvas_item片段着色器:"

msgid ""
"``textureLod`` is used here as we only want to read from the bottom mipmap. "
"If you want to read from a blurred version of the texture instead, you can "
"increase the third argument to ``textureLod`` and change the hint "
"``filter_nearest`` to ``filter_nearest_mipmap`` (or any other filter with "
"mipmaps enabled). If using a filter with mipmaps, Godot will automatically "
"calculate the blurred texture for you."
msgstr ""

msgid ""
"If the filter mode is not changed to a filter mode that contains ``mipmap`` "
"in its name, ``textureLod`` with a LOD parameter greater than ``0.0`` will "
"have the same appearance as with the ``0.0`` LOD parameter."
msgstr ""

msgid "Screen texture example"
msgstr "屏幕纹理示例"

msgid ""
"The screen texture can be used for many things. There is a special demo for "
"*Screen Space Shaders*, that you can download to see and learn. One example "
"is a simple shader to adjust brightness, contrast and saturation:"
msgstr ""
"屏幕纹理可以用来做很多事情。有一个针对\\ *屏幕空间着色器*\\ 的特殊演示项目，"
"你可以下载后查看学习。其中的一个例子就是用简单的着色器来调整亮度、对比度以及"
"饱和度："

msgid "Behind the scenes"
msgstr "幕后"

msgid ""
"While this seems magical, it's not. In 2D, when ``hint_screen_texture`` is "
"first found in a node that is about to be drawn, Godot does a full-screen "
"copy to a back-buffer. Subsequent nodes that use it in shaders will not have "
"the screen copied for them, because this ends up being inefficient. In 3D, "
"the screen is copied after the opaque geometry pass, but before the "
"transparent geometry pass, so transparent objects will not be captured in "
"the screen texture."
msgstr ""
"虽然这看起来很神奇，但其实不然。在 2D 中，第一次在即将绘制的节点中发现 "
"``hint_screen_texture`` 时，Godot 就会将整个屏幕拷贝到后台缓冲之中。后续在着"
"色器中使用它的节点将不会造成屏幕的复制，因为否则的话效率非常低。在 3D 中，进"
"行屏幕拷贝的时机是在不透明几何体阶段之后、透明几何体阶段之前，所以透明的物体"
"不会被捕捉到屏幕纹理之中。"

msgid ""
"As a result, in 2D, if shaders that use ``hint_screen_texture`` overlap, the "
"second one will not use the result of the first one, resulting in unexpected "
"visuals:"
msgstr ""
"因此，在 2D 中，如果使用 ``hint_screen_texture`` 的着色器存在覆盖，那么后一个"
"着色器使用的就不是第一个着色器的结果，会导致意外的图像："

msgid ""
"In the above image, the second sphere (top right) is using the same source "
"for the screen texture as the first one below, so the first one "
"\"disappears\", or is not visible."
msgstr ""
"在上图中，第二个球体（右上）所使用的屏幕纹理和第一个球体所使用的屏幕纹理的来"
"源是一致的，所以第一个球体会“消失”，或者说不可见。"

msgid ""
"In 2D, this can be corrected via the :ref:`BackBufferCopy "
"<class_BackBufferCopy>` node, which can be instantiated between both "
"spheres. BackBufferCopy can work by either specifying a screen region or the "
"whole screen:"
msgstr ""
"在 2D 中，这个问题可以通过 :ref:`BackBufferCopy <class_BackBufferCopy>` 节点"
"修正，在这两个球体之间实例化即可。BackBufferCopy 可以指定屏幕上的某个区域进行"
"复制，也可以复制整个屏幕："

msgid "With correct back-buffer copying, the two spheres blend correctly:"
msgstr "正确复制后台缓冲之后，这两个球体就能够正确混合了："

msgid ""
"In 3D, materials that use ``hint_screen_texture`` are considered transparent "
"themselves and will not appear in the resulting screen texture of other "
"materials. If you plan to instance a scene that uses a material with "
"``hint_screen_texture``, you will need to use a BackBufferCopy node."
msgstr ""

msgid ""
"In 3D, there is less flexibility to solve this particular issue because the "
"screen texture is only captured once. Be careful when using the screen "
"texture in 3D as it won't capture transparent objects and may capture some "
"opaque objects that are in front of the object using the screen texture."
msgstr ""
"在 3D 中，这个问题解决起来就没有那么灵活，因为屏幕纹理只会捕捉一次。在 3D 中"
"使用屏幕纹理时请多加小心，因为它并不会捕获到透明的对象，反而可能捕获到位于使"
"用屏幕纹理的对象之前的不透明对象。"

msgid ""
"You can reproduce the back-buffer logic in 3D by creating a :ref:`Viewport "
"<class_Viewport>` with a camera in the same position as your object, and "
"then use the :ref:`Viewport's <class_Viewport>` texture instead of the "
"screen texture."
msgstr ""
"要在 3D 中重现后台缓冲的逻辑，可以创建一个 :ref:`Viewport <class_Viewport>` "
"并在对象的位置创建一个相机，然后就可以使用该 :ref:`Viewport "
"<class_Viewport>` 的纹理来代替屏幕纹理。"

msgid "Back-buffer logic"
msgstr "后台缓冲逻辑"

msgid ""
"So, to make it clearer, here's how the backbuffer copying logic works in 2D "
"in Godot:"
msgstr ""
"好的，想要对后台缓冲有更清晰的理解的话，Godot 在 2D 中后台缓冲复制的原理是这"
"样的："

msgid ""
"If a node uses ``hint_screen_texture``, the entire screen is copied to the "
"back buffer before drawing that node. This only happens the first time; "
"subsequent nodes do not trigger this."
msgstr ""
"如果某个节点使用了 ``hint_screen_texture``\\ ，那么绘制该节点之前就会将整个屏"
"幕复制到后台缓冲之中。只有第一次才会这么做，后续的节点不会触发。"

msgid ""
"If a BackBufferCopy node was processed before the situation in the point "
"above (even if ``hint_screen_texture`` was not used), the behavior described "
"in the point above does not happen. In other words, automatic copying of the "
"entire screen only happens if ``hint_screen_texture`` is used in a node for "
"the first time and no BackBufferCopy node (not disabled) was found before in "
"tree-order."
msgstr ""
"如果上述情况发生前遇到过 BackBufferCopy 节点（即便尚未使用过 "
"``hint_screen_texture``\\ ），那么也不会执行相关的行为。换句话说，自动复制整"
"个屏幕的条件只有：某个节点中首次使用 ``hint_screen_texture`` 并且按照树顺序不"
"存在更早的（未被禁用的）BackBufferCopy 节点。"

msgid ""
"BackBufferCopy can copy either the entire screen or a region. If set to only "
"a region (not the whole screen) and your shader uses pixels not in the "
"region copied, the result of that read is undefined (most likely garbage "
"from previous frames). In other words, it's possible to use BackBufferCopy "
"to copy back a region of the screen and then read the screen texture from a "
"different region. Avoid this behavior!"
msgstr ""
"BackBufferCopy 可以选择复制整个屏幕或者只复制某个区域。如果设置为区域（非整个"
"屏幕），但是着色器使用了复制区域之外的像素，那么读取到的结果就是未定义的（很"
"可能是上一帧残留的垃圾数据）。换句话说，你确实能够使用 BackBufferCopy 复制屏"
"幕上的某个区域，然后读取屏幕纹理上的其他区域。但请避免这样的行为！"

msgid "Depth texture"
msgstr "深度纹理"

msgid ""
"For 3D shaders, it's also possible to access the screen depth buffer. For "
"this, the ``hint_depth_texture`` hint is used. This texture is not linear; "
"it must be converted using the inverse projection matrix."
msgstr ""
"3D 着色器也可以访问屏幕深度缓冲，使用 ``hint_depth_texture`` 提示即可。该纹理"
"不是线性的；必须通过逆投影矩阵进行转换。"

msgid ""
"The following code retrieves the 3D position below the pixel being drawn:"
msgstr "以下代码会获取正在绘制的像素所在的 3D 位置："

msgid "Normal-roughness texture"
msgstr "法线-粗糙度纹理"

#, fuzzy
msgid ""
"Normal-roughness texture is only supported in the Forward+ rendering method, "
"not Mobile or Compatibility."
msgstr "只有“集群 Forward”渲染后端支持体积雾，“Forward 移动”和“兼容”不支持。"

msgid ""
"Similarly, the normal-roughness texture can be used to read the normals and "
"roughness of objects rendered in the depth prepass. The normal is stored in "
"the ``.xyz`` channels (mapped to the 0-1 range) while the roughness is "
"stored in the ``.w`` channel."
msgstr ""
"类似的，如果对象在深度预阶段中进行了渲染，就可以用法线-粗糙度纹理来读取该对象"
"的法线和粗糙度。法线存储在 ``.xyz`` 通道中（映射到了 0-1 范围内），而粗糙度则"
"存储在 ``.w`` 通道中。"

msgid "Redefining screen textures"
msgstr "重定义屏幕纹理"

msgid ""
"The screen texture hints (``hint_screen_texture``, ``hint_depth_texture``, "
"and ``hint_normal_roughness_texture``) can be used with multiple uniforms. "
"For example, you may want to read from the texture multiple times with a "
"different repeat flag or filter flag."
msgstr ""
"可以对多个 uniform 使用屏幕纹理提示（\\ ``hint_screen_texture``\\ 、\\ "
"``hint_depth_texture``\\ 、\\ ``hint_normal_roughness_texture``\\ ）。例如，"
"你可能会想要使用不同的重复标志和过滤标志多次读取该纹理。"

msgid ""
"The following example shows a shader that reads the screen space normal with "
"linear filtering, but reads the screen space roughness using nearest "
"neighbor filtering."
msgstr ""
"下面的例子中，着色器在读取屏幕空间法线时使用的就是线性过滤，而读取屏幕空间粗"
"糙度时使用的就是最邻近过滤。"

msgid "Translation status"
msgstr "翻译状态"
