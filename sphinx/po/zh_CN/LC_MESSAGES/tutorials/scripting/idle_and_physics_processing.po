# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Idle and Physics Processing"
msgstr "空闲处理与物理处理"

msgid ""
"Games run in a loop. Each frame, you need to update the state of your game "
"world before drawing it on screen. Godot provides two virtual methods in the "
"Node class to do so: :ref:`Node._process() "
"<class_Node_private_method__process>` and :ref:`Node._physics_process() "
"<class_Node_private_method__physics_process>`. If you define either or both "
"in a script, the engine will call them automatically."
msgstr ""
"游戏是通过循环来运行的，每一帧都需要先更新游戏世界的状态，然后再把它绘制到屏"
"幕上。Godot 为 Node 类提供了两个虚方法来完成帧循环处理：\\ :ref:`Node."
"_process() <class_Node_method__process>` 和 :ref:`Node._physics_process() "
"<class_Node_method__physics_process>`\\ 。如果你在脚本中定义了这两个函数的其"
"中之一，或者两者都定义了，引擎就会自动进行调用这个（这些）虚函数。"

msgid "There are two types of processing available to you:"
msgstr "可以使用两种帧循环处理方式："

msgid ""
"**Idle processing** allows you to run code that updates a node every frame, "
"as often as possible."
msgstr ""
"**空闲处理**\\ （Idle processing）可以用来执行每帧更新节点的代码，执行频率会"
"尽可能地快。"

msgid ""
"**Physics processing** happens at a fixed rate, 60 times per second by "
"default. This is independent of your game's actual framerate, and keeps "
"physics running smoothly. You should use it for anything that involves the "
"physics engine, like moving a body that collides with the environment."
msgstr ""
"**物理处理**\\ （Physics processing）的执行频率是固定的，默认为每秒 60 次。物"
"理处理和游戏的实际帧率无关，可以让物理平滑执行，故一切与物理引擎相关的行为都"
"应该用物理处理帧循环函数来进行处理，如移动可能会与环境相碰撞的实体。"

msgid ""
"You can activate idle processing by defining the ``_process()`` method in a "
"script. You can turn it off and back on by calling :ref:`Node.set_process() "
"<class_Node_method_set_process>`."
msgstr ""
"在脚本中定义 ``_process()`` 方法就会激活空闲处理。可以通过调用 :ref:`Node."
"set_process() <class_Node_method_set_process>` 来对空闲处理的启用状态进行控"
"制。"

msgid "The engine calls this method every time it draws a frame:"
msgstr "引擎每需要绘制一帧画面，就会调用一次该方法："

msgid ""
"Keep in mind that the frequency at which the engine calls ``_process()`` "
"depends on your application's framerate, which varies over time and across "
"devices."
msgstr ""
"切记：引擎调用 ``_process()`` 的频率以应用的实际帧率为准，该实际帧率会根据时"
"间的变化而变化，在不同设备上该实际帧率也会有所不同。"

msgid ""
"The function's ``delta`` parameter is the time elapsed in seconds since the "
"previous call to ``_process()``. Use this parameter to make calculations "
"independent of the framerate. For example, you should always multiply a "
"speed value by ``delta`` to animate a moving object."
msgstr ""
"该函数的参数 ``delta`` 表示从上一次调用 ``_process()`` 开始所经过的秒数，借助"
"这个参数就可以进行与帧率无关的计算。例如，为移动物理做动画时，应该始终将速度"
"值乘上 ``delta``\\ 。"

msgid ""
"Physics processing works with a similar virtual function: "
"``_physics_process()``. Use it for calculations that must happen before each "
"physics step, like moving a character that collides with the game world. As "
"mentioned above, ``_physics_process()`` runs at fixed time intervals as much "
"as possible to keep the physics interactions stable. You can change the "
"interval between physics steps in the Project Settings, under Physics -> "
"Common -> Physics Fps. By default, it's set to run 60 times per second."
msgstr ""
"物理处理使用的是类似的虚函数：\\ ``_physics_process()``\\ ，用于必须在每一次"
"物理迭代前进行的计算，比如移动可能会与游戏世界发生碰撞的角色。前面提到过，为"
"了实现平稳的物理交互，\\ ``_physics_process()`` 的执行间隔是尽可能固定的，可"
"以在“项目设置”的“Physics -> Common -> Physics Fps”（物理 -> 常规 -> 物理 "
"FPS）中修改物理迭代之间的间隔，默认设置是每秒 60 次。"

msgid "The engine calls this method before every physics step:"
msgstr "引擎每进行一次物理计算，就会调用一次该方法："

msgid ""
"The function ``_process()`` is not synchronized with physics. Its rate "
"depends on hardware and game optimization. It also runs after the physics "
"step in single-threaded games."
msgstr ""
"``_process()`` 函数不与物理处理同步执行，且其执行频率会受到硬件和游戏优化的影"
"响。在单线程游戏中，会在物理迭代后执行。"

msgid ""
"You can see the ``_process()`` function at work by creating a scene with a "
"single Label node, with the following script attached to it:"
msgstr ""
"要观察 ``_process()`` 的执行，可以创建一个只有单个 Label 节点的场景，然后把下"
"面的脚本附加给这个 Label 节点："

msgid "When you run the scene, you should see a counter increasing each frame."
msgstr "运行场景，你就会看到一个每帧都会增加的计数器。"

msgid "Translation status"
msgstr "翻译状态"
