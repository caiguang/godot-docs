# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using SceneTree"
msgstr "使用 SceneTree"

msgid "Introduction"
msgstr "前言"

msgid ""
"In previous tutorials, everything revolved around the concept of nodes. "
"Scenes are collections of nodes. They become active once they enter the "
"*scene tree*."
msgstr ""
"在之前的教程中，所有内容都是围绕节点这一概念展开的。场景是节点的合集，节点一"
"进入 *场景树* 就会被激活。"

msgid "MainLoop"
msgstr "MainLoop"

msgid ""
"The way Godot works internally is as follows. There is the :ref:`OS "
"<class_OS>` class, which is the only instance that runs at the beginning. "
"Afterwards, all drivers, servers, scripting languages, scene system, etc are "
"loaded."
msgstr ""
"Godot 内部的工作方式是这样的：开始的时候只会有一个 :ref:`OS <class_OS>` 类的"
"实例在运行，然后才会把驱动程序、服务器、脚本语言、场景系统等等这些加载进来。"

msgid ""
"When initialization is complete, :ref:`OS <class_OS>` needs to be supplied "
"a :ref:`MainLoop <class_MainLoop>` to run. Up to this point, all this is "
"internals working (you can check main/main.cpp file in the source code if "
"you are ever interested to see how this works internally)."
msgstr ""
"初始化完成后，就会为 :ref:`OS <class_OS>` 提供一个 :ref:`MainLoop "
"<class_MainLoop>` 来运行。目前为止的所有内容都是内部工作（如果你有兴趣查看内"
"部如何工作，可以在源代码中查看 main/main.cpp 文件）。"

msgid ""
"The user program, or game, starts in the MainLoop. This class has a few "
"methods, for initialization, idle (frame-synchronized callback), fixed "
"(physics-synchronized callback), and input. Again, this is low level and "
"when making games in Godot, writing your own MainLoop seldom makes sense."
msgstr ""
"用户程序或游戏会在 MainLoop 中启动，这个类包含初始化、空闲（帧同步回调）、固"
"定（物理同步回调）、输入等方法。当然这也属于底层，用 Godot 制作游戏时几乎不会"
"遇到需要自行编写 MainLoop 的情况。"

msgid "SceneTree"
msgstr "SceneTree"

msgid ""
"One of the ways to explain how Godot works is that it's a high level game "
"engine over a low level middleware."
msgstr "解释Godot的工作方式的一种方法是, 它是基于低级中间件的高级游戏引擎."

msgid ""
"The scene system is the game engine, while the :ref:`OS <class_OS>` and "
"servers are the low level API."
msgstr "场景系统是游戏引擎, 而 :ref:`OS <class_OS>` 和服务是底层API."

msgid ""
"The scene system provides its own main loop to OS, :ref:`SceneTree "
"<class_SceneTree>`. This is automatically instanced and set when running a "
"scene, no need to do any extra work."
msgstr ""
"场景系统为OS提供了自己的主循环, 即 :ref:`SceneTree <class_SceneTree>`. 运行场"
"景时会自动实例化并设置该场景, 无需执行任何其他工作."

msgid ""
"It's important to know that this class exists because it has a few important "
"uses:"
msgstr "重要的是要知道此类的存在, 因为它有一些重要的用途:"

msgid ""
"It contains the root :ref:`Viewport <class_Viewport>`, to which a scene is "
"added as a child when it's first opened to become part of the *Scene Tree* "
"(more on that next)."
msgstr ""
"它包含根 :ref:`Viewport <class_Viewport>`, 当场景第一次打开成为 *Scene Tree* "
"的一部分时, 会将场景作为子级添加到其中(接下来会有更多)."

msgid ""
"It contains information about the groups and has the means to call all nodes "
"in a group or get a list of them."
msgstr "它包含有关编组的信息, 并具有调用编组中所有节点或获取它们的列表的方法."

msgid ""
"It contains some global state functionality, such as setting pause mode or "
"quitting the process."
msgstr "它包含一些全局状态功能, 例如设置暂停模式或退出进程."

msgid ""
"When a node is part of the Scene Tree, the :ref:`SceneTree "
"<class_SceneTree>` singleton can be obtained by calling :ref:`Node."
"get_tree() <class_Node_method_get_tree>`."
msgstr ""
"当节点是场景树的一部分时, 可以通过调用 :ref:`Node.get_tree() "
"<class_Node_method_get_tree>` 获得 :ref:`SceneTree <class_SceneTree>` 单例."

msgid "Root viewport"
msgstr "根视图"

msgid ""
"The root :ref:`Viewport <class_Viewport>` is always at the top of the scene. "
"From a node, it can be obtained in two different ways:"
msgstr ""
"根 :ref:`Viewport <class_Viewport>` 始终位于场景的顶部. 从一个节点, 可以通过"
"两种不同的方式获得它:"

msgid ""
"This node contains the main viewport. Anything that is a child of a :ref:"
"`Viewport <class_Viewport>` is drawn inside of it by default, so it makes "
"sense that the top of all nodes is always a node of this type otherwise "
"nothing would be seen."
msgstr ""
"此节点包含主视口, 默认情况下, :ref:`Viewport <class_Viewport>` 的任何子节点都"
"将绘制在其中, 因此以Viewport作为根节点是有意义的, 否则将看不到任何内容."

msgid ""
"While other viewports can be created in the scene (for split-screen effects "
"and such), this one is the only one that is never created by the user. It's "
"created automatically inside SceneTree."
msgstr ""
"尽管可以在场景中创建其他视图(用于分屏效果等), 但该视图是唯一不由用户创建的视"
"图. 它是在 ``SceneTree`` 内部自动创建的."

msgid "Scene tree"
msgstr "场景树"

msgid ""
"When a node is connected, directly or indirectly, to the root viewport, it "
"becomes part of the *scene tree*."
msgstr "当节点直接或间接连接到根视图时，它就成为了\\ *场景树*\\ 的一部分。"

msgid ""
"This means that as explained in previous tutorials, it will get the "
"``_enter_tree()`` and ``_ready()`` callbacks (as well as ``_exit_tree()``)."
msgstr ""
"因此，正如在之前的教程中所解释的，它将获得 ``_enter_tree()`` 和 ``_ready()`` "
"回调（以及 ``_exit_tree()`` ）。"

msgid ""
"When nodes enter the *Scene Tree*, they become active. They get access to "
"everything they need to process, get input, display 2D and 3D visuals, "
"receive and send notifications, play sounds, etc. When they are removed from "
"the *scene tree*, they lose these abilities."
msgstr ""
"当节点进入\\ *场景树*\\ 时，它们将变为活动状态。它们可以访问需要处理的所有内"
"容、获取输入、显示 2D 和 3D 视觉效果、收发通知、播放声音等。当从\\ *场景树"
"*\\ 中删除时，它们将失去这些能力。"

msgid "Tree order"
msgstr "树顺序"

msgid ""
"Most node operations in Godot, such as drawing 2D, processing, or getting "
"notifications are done in *tree order*, or top to bottom as seen in the "
"editor (also known as pre-order traversal):"
msgstr ""

msgid ""
"For example, the top node in a scene has its ``_process()`` function called "
"first, then the node below it has its ``_process()`` function called, then "
"the node below that and so on."
msgstr ""

msgid ""
"An important exception is the ``_ready()`` function: each parent node has "
"its ``_ready()`` function called only after all its child nodes have their "
"``_ready()`` functions called, so that the parent knows its children are "
"completely ready to be accessed. This is also known as post-order traversal. "
"In the above image, ``NameLabel`` would be notified first (but only after "
"its children, if it had any!), followed by ``Name``, etc., and ``Panel`` "
"would be notified last."
msgstr ""

msgid ""
"The order of operations can also be overridden using the "
"``process_priority`` node property. Nodes with a lower number are called "
"first. For example, nodes with the priorities \"0, 1, 2, 3\" would be called "
"in that order from left to right."
msgstr ""

msgid "\"Becoming active\" by entering the *Scene Tree*"
msgstr "通过进入\\ *场景树*\\ “变为活动状态”"

msgid "A scene is loaded from disk or created by scripting."
msgstr "从磁盘加载场景或通过脚本创建场景。"

#, fuzzy
msgid ""
"The root node of that scene (only one root, remember?) is added as either a "
"child of the \"root\" Viewport (from SceneTree), or to any of its "
"descendants."
msgstr ""
"该场景的根节点（只有一个根，还记得吗？）作为子级被添加至“根”视图（来自场景"
"树），或添加至其子孙节点。"

msgid ""
"Every node of the newly added scene will receive the \"enter_tree\" "
"notification ( ``_enter_tree()`` callback in GDScript) in top-to-bottom "
"order (pre-order traversal)."
msgstr ""
"新添加的场景的每个节点都将按照从上到下的顺序接收 ``enter_tree`` 通知"
"（GDScript 中的 ``_enter_tree()`` 回调函数）。"

#, fuzzy
msgid ""
"Every node will receive the \"ready\" notification ( ``_ready()`` callback "
"in GDScript) for convenience, once all its children have received the "
"\"ready\" notification (post-order traversal)."
msgstr ""
"当节点及其所有子节点都位于活动场景中时，为方便起见，会提供一个额外的通知 "
"``ready``\\ （GDScript 中的 ``_ready()`` 回调函数）。"

msgid ""
"When a scene (or part of it) is removed, they receive the \"exit scene\" "
"notification ( ``_exit_tree()`` callback in GDScript) in bottom-to-top order "
"(the exact reverse of top-to-bottom order)."
msgstr ""
"删除场景（或场景的一部分）后，它们将按照自底向上的顺序（自顶向下的逆序）收到 "
"``exit scene`` 通知（GDScript中的 ``_exit_tree()`` 回调函数）。"

msgid "Changing current scene"
msgstr "更改当前场景"

#, fuzzy
msgid ""
"After a scene is loaded, you may want to change this scene for another one. "
"One way to do this is to use the :ref:`SceneTree.change_scene_to_file() "
"<class_SceneTree_method_change_scene_to_file>` function:"
msgstr ""
"加载场景后，通常需要更改该场景为另一个场景。简单的方法是使用 :ref:`SceneTree."
"change_scene() <class_SceneTree_method_change_scene>` 函数："

#, fuzzy
msgid ""
"Rather than using file paths, one can also use ready-made :ref:`PackedScene "
"<class_PackedScene>` resources using the equivalent function :ref:`SceneTree."
"change_scene_to_packed(PackedScene scene) "
"<class_SceneTree_method_change_scene_to_packed>`:"
msgstr ""
"除了使用文件路径之外，还可以使用等效的函数 :ref:`SceneTree."
"change_scene_to(PackedScene scene) <class_SceneTree_method_change_scene_to>` "
"来使用现成的 :ref:`PackedScene <class_PackedScene>` 资源："

#, fuzzy
msgid ""
"These are quick and useful ways to switch scenes but have the drawback that "
"the game will stall until the new scene is loaded and running. At some point "
"in the development of your game, it may be preferable to create proper "
"loading screens with progress bar, animated indicators or threaded "
"(background) loading. This must be done manually using :ref:"
"`doc_singletons_autoload` and :ref:`doc_background_loading`."
msgstr ""
"这些方法可以用来快速切换场景，但缺点是游戏会卡住，直到新场景被加载并运行。在"
"游戏开发的某个时刻，最好使用进度条、动画化的指示器或线程（后台）加载来创建适"
"当的加载画面。必须使用自动加载功能（请参阅下一章）和 :ref:"
"`doc_background_loading` 手动完成此操作。"

msgid "Translation status"
msgstr "翻译状态"
