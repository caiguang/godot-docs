# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Static typing in GDScript"
msgstr "GDScript 静态类型编程"

msgid "In this guide, you will learn:"
msgstr "在本指南中，你将学会："

msgid "how to use static typing in GDScript;"
msgstr "如何在 GDScript 中使用静态类型编程;"

msgid "that static types can help you avoid bugs;"
msgstr "静态类型编程可以帮助你避免问题;"

msgid "that static typing improves your experience with the editor."
msgstr "静态类型编程可以提升编辑器的使用体验。"

msgid ""
"Where and how you use this language feature is entirely up to you: you can "
"use it only in some sensitive GDScript files, use it everywhere, or don't "
"use it at all."
msgstr ""
"这项语言功能的使用场合、使用方式完全取决于你：你可以只在部分敏感的 GDScript "
"文件中使用，也可以在所有地方都使用，甚至可以完全不使用。"

msgid ""
"Static types can be used on variables, constants, functions, parameters, and "
"return types."
msgstr "静态类型编程可用于变量、常量、函数、参数和返回类型。"

msgid "A brief look at static typing"
msgstr "静态类型编程简介"

msgid ""
"With static typing, GDScript can detect more errors without even running the "
"code. Also type hints give you and your teammates more information as you're "
"working, as the arguments' types show up when you call a method. Static "
"typing improves editor autocompletion and :ref:`documentation "
"<doc_gdscript_documentation_comments>` of your scripts."
msgstr ""
"使用 GDScript 静态类型编程，Godot 在编写代码时甚至可以帮你检测到更多代码错"
"误，在你工作时为你和你的团队提供更多信息，当你调用方法时，会显示出参数的类"
"型。静态类型编程也能改善编辑器的自动补全体验，其中也包括 :ref:`documentation "
"<doc_gdscript_documentation_comments>`。"

#, fuzzy
msgid ""
"Imagine you're programming an inventory system. You code an ``Item`` class, "
"then an ``Inventory``. To add items to the inventory, the people who work "
"with your code should always pass an ``Item`` to the ``Inventory.add()`` "
"method. With types, you can enforce this::"
msgstr ""
"想象你正在编写背包系统。你编写一个 ``Item``\\ （道具）节点，然后再编写一个 "
"``Inventory``\\ （背包）。要将道具添加到背包中，使用代码的人员应始终将 "
"``Item`` 传递给 ``Inventory.add`` 方法。有了类型，你就可以强制执行以下操作："

msgid ""
"Static types also give you better code completion options. Below, you can "
"see the difference between a dynamic and a static typed completion options."
msgstr ""
"静态类型编程还能为你提供更好的代码补全选项。下面，你可以看到一个名为 "
"``PlayerController`` 类的动态类型和静态类型补全选项之间的区别。"

msgid ""
"You've probably encountered a lack of autocomplete suggestions after a dot:"
msgstr ""
"你之前可能已经将节点存储在了变量中，打了一个句点符号，却没有代码自动补全提"
"示："

msgid "Completion options for dynamic typed code."
msgstr "动态类型的代码补全选项。"

msgid ""
"This is due to dynamic code. Godot cannot know what value type you're "
"passing to the function. If you write the type explicitly however, you will "
"get all methods, properties, constants, etc. from the value:"
msgstr ""
"由于动态代码是动态的，因此 Godot 无法得知你传递给函数的值的类型。可如果你明确"
"地声明了类型，则将从该节点类型获取所有公共方法和变量："

msgid "Completion options for static typed code."
msgstr "静态类型的代码补全选项。"

msgid ""
"If you prefer static typing, we recommend enabling the **Text Editor > "
"Completion > Add Type Hints** editor setting. Also consider enabling `some "
"warnings <Warning system_>`_ that are disabled by default."
msgstr ""
"若偏向静态类型编程，建议开启编辑器选项**文本编辑器 > 补全 > 添加类型提示**，"
"顺便也可以考虑开启默认关闭的 `某些选项 <Warning system_>`_ 。"

msgid ""
"Also, typed GDScript improves performance by using optimized opcodes when "
"operand/argument types are known at compile time. More GDScript "
"optimizations are planned in the future, such as JIT/AOT compilation."
msgstr ""
"同时，在操作数/参数类型在编译时已知时，静态类型编程编写的 GDScript 代码还能通"
"过优化后的操作码提升代码运行性能。未来还计划进行更多 GDScript 方面的优化，如 "
"JIT/AOT 编译。"

msgid ""
"Overall, typed programming gives you a more structured experience. It helps "
"prevent errors and improves the self-documenting aspect of your scripts. "
"This is especially helpful when you're working in a team or on a long-term "
"project: studies have shown that developers spend most of their time reading "
"other people's code, or scripts they wrote in the past and forgot about. The "
"clearer and the more structured the code, the faster it is to understand, "
"the faster you can move forward."
msgstr ""
"总体而言，静态类型编程可为你提供更加结构化的体验，有助于避免代码错误，改善脚"
"本的文档生成能力。当你在团队中或长期项目中工作时，静态类型编程将会特别有用。"
"研究表明，开发人员将大部分时间要么都花在阅读别人的代码上，要么都花在阅读他们"
"以前编写过但后来忘掉的脚本上。代码越清晰、越结构化，开发人员理解得也就越快，"
"项目开发的速度也就越快。"

msgid "How to use static typing"
msgstr "如何使用静态类型编程"

msgid ""
"To define the type of a variable, parameter, or constant, write a colon "
"after the name, followed by its type. E.g. ``var health: int``. This forces "
"the variable's type to always stay the same::"
msgstr ""
"要定义变量、参数、常量的类型，请在名称后写一个英文冒号，再写上类型。例如 "
"``var health: int``\\ 。这样就能够让变量的类型始终保持一致： ::"

msgid ""
"Godot will try to infer types if you write a colon, but you omit the type::"
msgstr "如果你写了冒号但是省略类型，Godot 就会尝试推导类型： ::"

msgid "There is no difference between ``=`` and ``:=`` for constants."
msgstr "对于常量而言， ``=`` 和 ``:=`` 没有区别。"

msgid ""
"You don't need to write type hints for constants, as Godot sets it "
"automatically from the assigned value. But you can still do so to make the "
"intent of your code clearer. Also, this is useful for typed arrays (like "
"``const A: Array[int] = [1, 2, 3]``), since untyped arrays are used by "
"default."
msgstr ""
"常量不需要写类型提示，Godot 会自动根据所赋的值设置该常量的类型，你仍然可以写"
"上类型提示来让代码更整洁。同时，这样写对于类型化数组也还是很有用的（比如 "
"``const A: Array[int] = [1, 2, 3]``\\ ），因为默认使用的是无类型的数组。"

msgid "What can be a type hint"
msgstr "类型提示可以是什么"

msgid "Here is a complete list of what can be used as a type hint:"
msgstr "下面列出的是所有可以用作类型提示的东西："

msgid ""
"``Variant``. Any type. In most cases this is not much different from an "
"untyped declaration, but increases readability. As a return type, forces the "
"function to explicitly return some value."
msgstr ""
"``Variant``\\ ，任何类型。大多数情况下与不写类型声明差不多，但能够增加可读"
"性。作为返回类型时，能够强制函数显式返回值。"

msgid ""
"*(Only return type)* ``void``. Indicates that the function does not return "
"any value."
msgstr "*（仅作返回类型使用）* ``void``\\ 。表示函数不返回任何值。"

msgid ":ref:`Built-in types <doc_gdscript_builtin_types>`."
msgstr ":ref:`内置类型 <doc_gdscript_builtin_types>`\\ 。"

msgid "Native classes (``Object``, ``Node``, ``Area2D``, ``Camera2D``, etc.)."
msgstr ""
"原生类（\\ ``Object``\\ 、\\ ``Node``\\ 、\\ ``Area2D``\\ 、\\ ``Camera2D`` "
"等）。"

msgid ":ref:`Global classes <doc_gdscript_basics_class_name>`."
msgstr ":ref:`全局类 <doc_gdscript_basics_class_name>`\\ 。"

msgid ":ref:`Inner classes <doc_gdscript_basics_inner_classes>`."
msgstr ":ref:`内部类 <doc_gdscript_basics_inner_classes>`\\ 。"

msgid ""
"Global, native and custom named enums. Note that an enum type is just an "
"``int``, there is no guarantee that the value belongs to the set of enum "
"values."
msgstr ""
"全局具名常量与内部具名常量。注意：枚举是 ``int`` 类型的数据，不能保证一个值属"
"于该枚举。"

msgid ""
"Constants (including local ones) if they contain a preloaded class or enum."
msgstr "包含预加载类和枚举的常量（或局部常量）。"

msgid ""
"You can use any class, including your custom classes, as types. There are "
"two ways to use them in scripts. The first method is to preload the script "
"you want to use as a type in a constant::"
msgstr ""
"你可以将任何类（包括自定义类）用作类型。有两种在脚本中使用这些类型的方法：第"
"一种方法是将要用作类型的脚本预加载为常量：::"

msgid ""
"The second method is to use the ``class_name`` keyword when you create. For "
"the example above, your ``rifle.gd`` would look like this::"
msgstr ""
"而第二种方法则是在创建类时使用 ``class_name`` 关键字。对于上面的示例， "
"``Rifle.gd`` 看起来就像这样：::"

msgid ""
"If you use ``class_name``, Godot registers the ``Rifle`` type globally in "
"the editor, and you can use it anywhere, without having to preload it into a "
"constant::"
msgstr ""
"使用 ``class_name`` 时，Godot 会在编辑器中注册一个全局 ``Rifle`` 类型，可以在"
"任何地方使用该类型，而无需将其预加载到常量当中：::"

#, fuzzy
msgid "Specify the return type of a function with the arrow ``->``"
msgstr "使用箭头 ``->`` 定义函数的返回类型"

msgid ""
"To define the return type of a function, write a dash and a right angle "
"bracket ``->`` after its declaration, followed by the return type::"
msgstr ""
"要定义函数的返回类型，请在声明后写一个短划线和一个右尖括号 ``->`` ，后跟返回"
"类型：::"

msgid ""
"The type ``void`` means the function does not return anything. You can use "
"any type, as with variables::"
msgstr "类型 ``void`` 表示函数不返回任何内容。你可以使用任何类型，如变量：::"

msgid "You can also use your own classes as return types::"
msgstr "你还可以使用自定义类作为返回类型：::"

msgid "Covariance and contravariance"
msgstr "协变与逆变"

msgid ""
"When inheriting base class methods, you should follow the `Liskov "
"substitution principle <https://en.wikipedia.org/wiki/"
"Liskov_substitution_principle>`__."
msgstr ""
"继承基类方法时，应遵循 `里氏代换原则 <https://en.wikipedia.org/wiki/"
"Liskov_substitution_principle>`__ 。"

msgid ""
"**Covariance:** When you inherit a method, you can specify a return type "
"that is more specific (**subtype**) than the parent method."
msgstr ""
"**协变：** 继承方法时，你可以为子类方法指定一个比该子类方法的父类方法更为具体"
"的返回值类型（比如**子类**）。"

msgid ""
"**Contravariance:** When you inherit a method, you can specify a parameter "
"type that is less specific (**supertype**) than the parent method."
msgstr ""
"**逆变：** 继承方法时，你可以为子类方法指定一个比该子类方法的父类方法更不具体"
"的返回值类型（比如**超类**）。"

msgid "Example::"
msgstr "示例（以匿名 setter/getter 函数为例）::"

#, fuzzy
msgid "Specify the element type of an ``Array``"
msgstr "定义 Array 元素的类型"

#, fuzzy
msgid "To define the type of an ``Array``, enclose the type name in ``[]``."
msgstr "要定义 Array 的类型，请将类型名称包裹在 ``[]`` 中。"

msgid ""
"An array's type applies to ``for`` loop variables, as well as some operators "
"like ``[]``, ``[]=``, and ``+``. Array methods (such as ``push_back``) and "
"other operators (such as ``==``) are still untyped. Built-in types, native "
"and custom classes, and enums may be used as element types. Nested array "
"types are not supported."
msgstr ""
"数组的类型适用于“for”循环变量以及一些运算符，如“[]”、“[]=”和“+”。部分数组方法"
"（如`push_back``）和运算符（如``==``）依旧对数组类型不敏感。内置类型、引擎原"
"生类型、自定义类型及枚举均可以用作元素类型。不支持嵌套数组类型。"

msgid ""
"Since Godot 4.2, you can also specify a type for the loop variable in a "
"``for`` loop. For instance, you can write::"
msgstr ""
"从 Godot 4.2 开始，你可以显式指定 ``for`` 循环的循环变量类型。比如，你可以这"
"样写：::"

msgid ""
"The array will remain untyped, but the ``name`` variable within the ``for`` "
"loop will always be of ``String`` type."
msgstr ""
"数组仍旧不会限定类型，但 ``for`` 循环的 ``name`` 循环变量则始终为 ``String`` "
"类型。"

msgid "Type casting"
msgstr "类型转换"

msgid ""
"Type casting is an important concept in typed languages. Casting is the "
"conversion of a value from one type to another."
msgstr ""
"类型转换是类型语言的关键概念，转型是指将值从一种类型转换为另一种类型的操作或"
"过程。"

msgid ""
"Imagine an ``Enemy`` in your game, that ``extends Area2D``. You want it to "
"collide with the ``Player``, a ``CharacterBody2D`` with a script called "
"``PlayerController`` attached to it. You use the ``body_entered`` signal to "
"detect the collision. With typed code, the body you detect is going to be a "
"generic ``PhysicsBody2D``, and not your ``PlayerController`` on the "
"``_on_body_entered`` callback."
msgstr ""
"想象你的游戏中的一个敌人， ``extends Area2D`` 。你希望它与游戏角色，即一个附"
"带有一个名为 ``PlayerController`` 的脚本的 ``CharacterBody2D``, 碰撞，那么你"
"可以使用 ``body_entered`` 信号来检测碰撞。使用类型化代码，其检测到的物体"
"（body）将是通用的 ``PhysicsBody2D`` 而非 ``_on_body_entered`` 回调上使用的 "
"``PlayerController`` 。"

msgid ""
"You can check if this ``PhysicsBody2D`` is your ``Player`` with the ``as`` "
"keyword, and using the colon ``:`` again to force the variable to use this "
"type. This forces the variable to stick to the ``PlayerController`` type::"
msgstr ""
"你可以使用 ``as``转型关键字来检查这个 ``PhysicsBody2D`` 是否是你的游戏角色，"
"并再次使用冒号 ``:`` 来强制变量使用这种类型。这样会强制变量使用 "
"``PlayerController`` 类型："

msgid ""
"As we're dealing with a custom type, if the ``body`` doesn't extend "
"``PlayerController``, the ``player`` variable will be set to ``null``. We "
"can use this to check if the body is the player or not. We will also get "
"full autocompletion on the player variable thanks to that cast."
msgstr ""
"在处理自定义类型时，如果 ``body`` 没有继承 ``PlayerController`` 类，则 "
"``player`` 变量将被赋值为 ``null`` 。我们可以用这种操作来检查物体是否为游戏玩"
"家角色。多亏了类型转换，我们还能获得 ``player`` 变量的代码自动补全功能。"

msgid ""
"The ``as`` keyword silently casts the variable to ``null`` in case of a type "
"mismatch at runtime, without an error/warning. While this may be convenient "
"in some cases, it can also lead to bugs. Use the ``as`` keyword only if this "
"behavior is intended. A safer alternative is to use the ``is`` keyword::"
msgstr ""
"在变量类型在运行时中不匹配的情况下， ``as`` 关键字会将变量的值静默转型为 "
"``null`` ，不会触发任何警告与报错，虽然在某些情况下会比较好用，但也会带来一些"
"问题。尽在需要强制转型的时候使用 ``as`` ，否则使用 ``is`` 来代替转型语法：::"

msgid "or ``assert()`` statement::"
msgstr "或者用 ``assert()`` 断言语法：::"

msgid ""
"If you try to cast with a built-in type and it fails, Godot will throw an "
"error."
msgstr ""
"如果你尝试使用内置类型进行转型且转型失败，则将触发 Godot 脚本编辑器底部报错。"

msgid "Safe lines"
msgstr "安全行"

msgid ""
"You can also use casting to ensure safe lines. Safe lines are a tool to tell "
"you when ambiguous lines of code are type-safe. As you can mix and match "
"typed and dynamic code, at times, Godot doesn't have enough information to "
"know if an instruction will trigger an error or not at runtime."
msgstr ""
"你也可以使用转型语法来确保存在安全行，安全行是 Godot 3.1 中加入的新工具，可以"
"告诉你一行歧义代码在什么情况下类型安全。由于你有时会混合使用静态类型代码和动"
"态类型代码，有时如果指令在运行时触发错误，Godot 可能没有足够的信息进行判断。"

msgid ""
"This happens when you get a child node. Let's take a timer for example: with "
"dynamic code, you can get the node with ``$Timer``. GDScript supports `duck-"
"typing <https://stackoverflow.com/a/4205163/8125343>`__, so even if your "
"timer is of type ``Timer``, it is also a ``Node`` and an ``Object``, two "
"classes it extends. With dynamic GDScript, you also don't care about the "
"node's type as long as it has the methods you need to call."
msgstr ""
"当你需要获得子节点时就会发生这种情况。以计时器为例：使用动态代码，你可以使用 "
"``$Timer`` 获取节点。GDScript 支持\\ `鸭子类型 <https://stackoverflow.com/"
"a/4205163/8125343>`__\\ ，即使你的计时器是 ``Timer`` 类型，计时器也继承了 "
"``Node`` 和 ``Object`` 这两个类。使用动态类型的 GDScript，只要节点具有你需要"
"调用的方法，你也不必关心节点的类型。"

msgid ""
"You can use casting to tell Godot the type you expect when you get a node: "
"``($Timer as Timer)``, ``($Player as CharacterBody2D)``, etc. Godot will "
"ensure the type works and if so, the line number will turn green at the left "
"of the script editor."
msgstr ""
"当你得到一个节点时，可以使用强制转型来告诉 Godot 你所期望的类型： ``($Timer "
"as Timer)`` 、 ``($Player as KinematicBody2D)`` 等，Godot 将确认该类型是否有"
"效，如果有效，在脚本编辑器的左侧的行号将会变为绿色。"

msgid "Unsafe vs Safe Line"
msgstr "不安全行 vs 安全行"

msgid "Unsafe line (line 7) vs Safe Lines (line 6 and 8)"
msgstr "不安全代码行（第 7 行）vs 安全代码行（第 6 行和第 8 行）"

msgid ""
"Safe lines do not always mean better or more reliable code. See the note "
"above about the ``as`` keyword. For example::"
msgstr ""
"安全行也并不总表示该行代码更加优秀可靠，参见前文所述的 ``as`` 关键字。比"
"如：::"

msgid ""
"Even though ``node_2`` declaration is marked as an unsafe line, it is more "
"reliable than ``node_1`` declaration. Because if you change the node type in "
"the scene and accidentally forget to change it in the script, the error will "
"be detected immediately when the scene is loaded. Unlike ``node_1``, which "
"will be silently cast to ``null`` and the error will be detected later."
msgstr ""
"虽然 ``node_2`` 的声明被标记为了不安全行，但比起 ``node_1`` 的声明来看却更加"
"可靠，这是因为如果你不小心在场景中更改了节点的类型，又忘记把它改回去的话，就"
"会在场景加载时触发报错。 ``node_1`` 的情况则是会被静默转型成 ``null`` ，触发"
"报错。"

msgid ""
"You can turn off safe lines or change their color in the editor settings."
msgstr "可以在编辑器设置中关闭安全行或更改其颜色。"

msgid "Typed or dynamic: stick to one style"
msgstr "静态编程还是动态编程：坚持一种风格"

msgid ""
"Typed GDScript and dynamic GDScript can coexist in the same project. But "
"it's recommended to stick to either style for consistency in your codebase, "
"and for your peers. It's easier for everyone to work together if you follow "
"the same guidelines, and faster to read and understand other people's code."
msgstr ""
"静态类型的 GDScript 和动态类型的 GDScript 可共存于同一项目，但还是建议二选其"
"一，以确保每个人代码风格的一致性。如果你们遵循相同的规范，那么每个人就都可以"
"更轻松地协作，阅读、理解他人的代码也就会更加迅速。"

msgid ""
"Typed code takes a little more writing, but you get the benefits we "
"discussed above. Here's an example of the same, empty script, in a dynamic "
"style::"
msgstr ""
"虽然静态类型的代码需要敲更多的字，但你将获得前文所述的种种好处。下面是内容一"
"样的空脚本示例，首先是使用动态类型的脚本："

msgid "And with static typing::"
msgstr "其次是使用静态类型的脚本示例："

msgid ""
"As you can see, you can also use types with the engine's virtual methods. "
"Signal callbacks, like any methods, can also use types. Here's a "
"``body_entered`` signal in a dynamic style::"
msgstr ""
"如你所见，你也可以对引擎虚函数的参数进行类型声明。和方法一样，信号的回调参数"
"也可以指定类型，下面是一个动态类型的 ``body_entered`` 信号示例："

msgid "And the same callback, with type hints::"
msgstr "以及具有类型提示的相同回调："

msgid "Warning system"
msgstr "警告系统"

msgid ""
"Detailed documentation about the GDScript warning system has been moved to :"
"ref:`doc_gdscript_warning_system`."
msgstr ""
"关于 GDScript 警告系统的文档已移至 :ref:`doc_gdscript_warning_system`。"

msgid ""
"From version 3.1, Godot gives you warnings about your code as you write it: "
"the engine identifies sections of your code that may lead to issues at "
"runtime, but lets you decide whether or not you want to leave the code as it "
"is."
msgstr ""
"静态类型的 GDScript 的另一个显著优点便是 **警告系统** 。从Godot 3.1 开始，"
"Godot 会在你编写代码时向你发出有关代码的警告，引擎会识别代码中可能导致运行时"
"出现问题的部分，你可以决定是否要保留该部分代码。"

msgid ""
"We have a number of warnings aimed specifically at users of typed GDScript. "
"By default, these warnings are disabled, you can enable them in Project "
"Settings (**Debug > GDScript**, make sure **Advanced Settings** is enabled)."
msgstr ""
"对于静态类型 GDScript 编程的用户，我们提供了大量警告，这些警告默认关闭，但你"
"可以将这些警告在项目设置（**调试 > GDScript**）中开启，在此之前，请确保你已启"
"用了项目设置的**高级设置**模式。"

msgid ""
"You can enable the ``UNTYPED_DECLARATION`` warning if you want to always use "
"static types. Additionally, you can enable the ``INFERRED_DECLARATION`` "
"warning if you prefer a more readable and reliable, but more verbose syntax."
msgstr ""
"若始终进行静态类型编程，你可以启用 ``UNTYPED_DECLARATION`` 警告。此外，你还可"
"以启用 ``INFERRED_DECLARATION`` 警告来让你的代码可读性更强、更有可靠性，但同"
"时也会让你的代码更加冗长。"

msgid ""
"``UNSAFE_*`` warnings make unsafe operations more noticeable, than unsafe "
"lines. Currently, ``UNSAFE_*`` warnings do not cover all cases that unsafe "
"lines cover."
msgstr ""
"``UNSAFE_*`` 警告会让不安全操作比不安全行更容易引人注意。目前, ``UNSAFE_*`` "
"警告并不能涵盖不安行所涵盖的所有情况。"

msgid "Common unsafe operations and their safe counterparts"
msgstr ""

msgid "``UNSAFE_PROPERTY_ACCESS`` and ``UNSAFE_METHOD_ACCESS`` warnings"
msgstr ""

msgid ""
"In this example, we aim to set a property and call a method on an object "
"that has a script attached with ``class_name MyScript`` and that ``extends "
"Node2D``. If we have a reference to the object as a ``Node2D`` (for "
"instance, as it was passed to us by the physics system), we can first check "
"if the property and method exist and then set and call them if they do::"
msgstr ""

msgid ""
"However, this code will produce ``UNSAFE_PROPERTY_ACCESS`` and "
"``UNSAFE_METHOD_ACCESS`` warnings as the property and method are not present "
"in the referenced type - in this case a ``Node2D``. To make these operations "
"safe, you can first check if the object is of type ``MyScript`` using the "
"``is`` keyword and then declare a variable with the type ``MyScript`` on "
"which you can set its properties and call its methods::"
msgstr ""

msgid ""
"Alternatively, you can declare a variable and use the ``as`` operator to try "
"to cast the object. You'll then want to check whether the cast was "
"successful by confirming that the variable was assigned::"
msgstr ""

msgid "``UNSAFE_CAST`` warning"
msgstr ""

msgid ""
"In this example, we would like the label connected to an object entering our "
"collision area to show the area's name. Once the object enters the collision "
"area, the physics system sends a signal with a ``Node2D`` object, and the "
"most straightforward (but not statically typed) solution to do what we want "
"could be achieved like this::"
msgstr ""

msgid ""
"This piece of code produces an ``UNSAFE_PROPERTY_ACCESS`` warning because "
"``label`` is not defined in ``Node2D``. To solve this, we could first check "
"if the ``label`` property exist and cast it to type ``Label`` before "
"settings its text property like so::"
msgstr ""

msgid ""
"However, this produces an ``UNSAFE_CAST`` warning because ``body.label`` is "
"of a ``Variant`` type. To safely get the property in the type you want, you "
"can use the ``Object.get()`` method which returns the object as a "
"``Variant`` value or returns ``null`` if the property doesn't exist. You can "
"then determine whether the property contains an object of the right type "
"using the ``is`` keyword, and finally declare a statically typed variable "
"with the object::"
msgstr ""

#, fuzzy
msgid "Cases where you can't specify types"
msgstr "不能指定类型的情况"

msgid ""
"To wrap up this introduction, let's mention cases where you can't use type "
"hints. This will trigger a **syntax error**."
msgstr ""
"最后，我们将介绍一些不能使用类型提示的情况。以下所有示例 **都会触发报错** 。"

msgid ""
"You can't specify the type of individual elements in an array or a "
"dictionary::"
msgstr "无法指定数组中单个成员的类型，这样会触发报错：::"

msgid "Nested types are not currently supported::"
msgstr "目前不支持数组类型嵌套： ::"

msgid "Typed dictionaries are not currently supported::"
msgstr "目前不支持为字典元素设置类型： ::"

msgid "Summary"
msgstr "总结"

msgid ""
"Typed GDScript is a powerful tool. It helps you write more structured code, "
"avoid common errors, and create scalable and reliable systems. Static types "
"improve GDScript performance and more optimizations are planned for the "
"future."
msgstr ""
"静态类型的 GDScript 是一个十分强大的工具，可以帮助编写更多结构化的代码，避免"
"常见错误，创建灵活的代码系统。将来，由于即将进行的编译器优化，静态类型也将会"
"带来不错的性能提升。"

msgid "Translation status"
msgstr "翻译状态"
