# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "GDScript reference"
msgstr "GDScript 参考"

msgid ""
":ref:`GDScript<doc_gdscript>` is a high-level, `object-oriented <https://en."
"wikipedia.org/wiki/Object-oriented_programming>`_, `imperative <https://en."
"wikipedia.org/wiki/Imperative_programming>`_, and `gradually typed <https://"
"en.wikipedia.org/wiki/Gradual_typing>`_ programming language built for "
"Godot. It uses an indentation-based syntax similar to languages like `Python "
"<https://en.wikipedia.org/wiki/Python_%28programming_language%29>`_. Its "
"goal is to be optimized for and tightly integrated with Godot Engine, "
"allowing great flexibility for content creation and integration."
msgstr ""
":ref:`GDScript<doc_gdscript>` 是一种\\ `面向对象 <https://zh.wikipedia.org/"
"wiki/"
"%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1>`_\\ "
"的高级\\ `指令式 <https://zh.wikipedia.org/wiki/"
"%E6%8C%87%E4%BB%A4%E5%BC%8F%E7%B7%A8%E7%A8%8B>`_\\ \\ `渐进类型 <https://en."
"wikipedia.org/wiki/Gradual_typing>`_\\ 编程语言，专为 Godot 构建。GDScript 的"
"语法基于缩进，与 `Python <https://zh.wikipedia.org/wiki/Python>`_ 等语言类"
"似。设计 GDScript 这门语言旨在对 Godot 引擎进行优化，与 Godot 引擎紧密集成，"
"从而为内容的创建与继承提供灵活的手段。"

msgid "GDScript is entirely independent from Python and is not based on it."
msgstr ""
"GDScript 是完全独立于 Python 存在的，二者之间并不不存在继承与扩展关系。"

msgid "History"
msgstr "历史"

msgid ""
"Documentation about GDScript's history has been moved to the :ref:"
"`Frequently Asked Questions <doc_faq_what_is_gdscript>`."
msgstr ""
"关于 GDScript 历史的文档已移至\\ :ref:`常见问题 "
"<doc_faq_what_is_gdscript>`\\ 。"

msgid "Example of GDScript"
msgstr "GDScript 示例"

msgid ""
"Some people can learn better by taking a look at the syntax, so here's an "
"example of how GDScript looks."
msgstr ""
"考虑到部分开发者了解过编程语法，学起GDScript来可能会快些，因此这里给出一个 "
"GDScript 的简单示例供参考学习。"

msgid ""
"If you have previous experience with statically typed languages such as C, C+"
"+, or C# but never used a dynamically typed one before, it is advised you "
"read this tutorial: :ref:`doc_gdscript_more_efficiently`."
msgstr ""
"如果你以前有过使用 C、 C++ 或 C# 之类的静态类型语言编程经验，却从未使用过动态"
"类型编程语言，建议阅读此教程： :ref:`doc_gdscript_more_efficiently`。"

msgid "Language"
msgstr "语言"

msgid ""
"In the following, an overview is given to GDScript. Details, such as which "
"methods are available to arrays or other objects, should be looked up in the "
"linked class descriptions."
msgstr ""
"下面是有关 GDScript 的一些概述。对于 GDScript 更为详细的信息，如哪些方法可用"
"于数组或其他对象，可以在链接的类描述中查找到。"

msgid "Identifiers"
msgstr "标识符"

msgid ""
"Any string that restricts itself to alphabetic characters (``a`` to ``z`` "
"and ``A`` to ``Z``), digits (``0`` to ``9``) and ``_`` qualifies as an "
"identifier. Additionally, identifiers must not begin with a digit. "
"Identifiers are case-sensitive (``foo`` is different from ``FOO``)."
msgstr ""
"仅限于含字母字符（ ``a`` 到 ``z`` 和 ``A`` 到 ``Z`` ）、 数字（ ``0`` 到 "
"``9`` ）和下划线 ``_`` 的字符串可作为标识符。同时，标识符不能以数字开头，且大"
"小写敏感（如 ``foo`` 和 ``FOO`` 就是两个不同的标识符）。"

msgid ""
"Identifiers may also contain most Unicode characters part of `UAX#31 "
"<https://www.unicode.org/reports/tr31/>`__. This allows you to use "
"identifier names written in languages other than English. Unicode characters "
"that are considered \"confusable\" for ASCII characters and emoji are not "
"allowed in identifiers."
msgstr ""
"标识符现在也允许包含 `UAX#31 <https://www.unicode.org/reports/tr31/>`__ 所提"
"供的部分 Unicode 字符，也就是说，你现在也可以将非英文字符作为标识符使用。然"
"而， Unicode 字符中易与 ASCII 字符混淆的字符以及颜文字则是无法作为标识符使用"
"的。"

msgid "Keywords"
msgstr "关键字"

msgid ""
"The following is the list of keywords supported by the language. Since "
"keywords are reserved words (tokens), they can't be used as identifiers. "
"Operators (like ``in``, ``not``, ``and`` or ``or``) and names of built-in "
"types as listed in the following sections are also reserved."
msgstr ""
"以下是该语言支持的关键字列表。由于关键字是保留字（记号），故不能用作标识符。"
"操作符（如 ``in``\\ 、\\ ``not``\\ 、\\ ``and``\\ 、\\ ``or``\\ ）及下列内置"
"类型的名称也是保留字。"

msgid ""
"Keywords are defined in the `GDScript tokenizer <https://github.com/"
"godotengine/godot/blob/master/modules/gdscript/gdscript_tokenizer.cpp>`_ in "
"case you want to take a look under the hood."
msgstr ""
"想深入了解关键字的话，可在 `GDScript 词法分析器 <https://github.com/"
"godotengine/godot/blob/master/modules/gdscript/gdscript_tokenizer.cpp>`_\\ 中"
"找到对于关键字的定义。"

msgid "Keyword"
msgstr "关键字"

msgid "Description"
msgstr "描述"

msgid "if"
msgstr "if"

msgid "See `if/else/elif`_."
msgstr "见 `if/else/elif`_ 。"

msgid "elif"
msgstr "elif"

msgid "else"
msgstr "else"

msgid "for"
msgstr "for"

msgid "See for_."
msgstr "见 for_ 。"

msgid "while"
msgstr "while"

msgid "See while_."
msgstr "见 while_ 。"

msgid "match"
msgstr "match"

msgid "See match_."
msgstr "见 match_ 。"

msgid "break"
msgstr "break"

msgid "Exits the execution of the current ``for`` or ``while`` loop."
msgstr "退出当前 ``for`` 或 ``while`` 循环的执行。"

msgid "continue"
msgstr "continue"

msgid ""
"Immediately skips to the next iteration of the ``for`` or ``while`` loop."
msgstr "立即跳到 ``for`` 或 ``while`` 循环的下一个迭代。"

msgid "pass"
msgstr "pass"

msgid ""
"Used where a statement is required syntactically but execution of code is "
"undesired, e.g. in empty functions."
msgstr "语法上要求在不希望执行代码的语句中使用，例如在空函数中使用。"

msgid "return"
msgstr "return"

msgid "Returns a value from a function."
msgstr "从函数当中返回一个值。"

msgid "class"
msgstr "class"

msgid "Defines an inner class. See `Inner classes`_."
msgstr "定义一个内部类。见 `内部类`_。"

msgid "class_name"
msgstr "class_name"

msgid ""
"Defines the script as a globally accessible class with the specified name. "
"See `Registering named classes`_."
msgstr "将脚本定义为具有指定名称的全局可访问类。见 `注册具名类`_。"

msgid "extends"
msgstr "extends"

msgid "Defines what class to extend with the current class."
msgstr "定义当前类继承什么类。"

msgid "is"
msgstr "is"

msgid ""
"Tests whether a variable extends a given class, or is of a given built-in "
"type."
msgstr "检测变量是否继承自给定的类，或检测该变量是否为给定的内置类型。"

msgid "in"
msgstr "in"

msgid ""
"Tests whether a value is within a string, array, range, dictionary, or node. "
"When used with ``for``, it iterates through them instead of testing."
msgstr ""
"通常情况下用来检查字符串、列表、范围、字典、节点中是否存在某个值，而和 "
"``for`` 关键字连用时，则用于遍历字符串、列表、范围、字典、节点中的内容。"

msgid "as"
msgstr "as"

msgid "Cast the value to a given type if possible."
msgstr "尝试将值转换为给定类型的值。"

msgid "self"
msgstr "self"

msgid "Refers to current class instance."
msgstr "引用当前类实例。"

msgid "signal"
msgstr "signal"

msgid "Defines a signal."
msgstr "定义信号。"

msgid "func"
msgstr "func"

msgid "Defines a function."
msgstr "定义函数。"

msgid "static"
msgstr "static"

msgid "Defines a static function or a static member variable."
msgstr "将一个函数声明为静态函数，或将一个成员变量声明为静态成员变量。"

msgid "const"
msgstr "const"

msgid "Defines a constant."
msgstr "定义常量。"

msgid "enum"
msgstr "enum"

msgid "Defines an enum."
msgstr "定义枚举。"

msgid "var"
msgstr "var"

msgid "Defines a variable."
msgstr "定义变量。"

msgid "breakpoint"
msgstr "breakpoint"

msgid ""
"Editor helper for debugger breakpoints. Unlike breakpoints created by "
"clicking in the gutter, ``breakpoint`` is stored in the script itself. This "
"makes it persistent across different machines when using version control."
msgstr ""
"用来设置脚本编辑器辅助调试断点的关键字。与在脚本编辑器每行最左侧点击红点创建"
"断点不同， ``breakpoint`` 关键字可以储存在脚本内部。在不同机器上使用版本工具"
"时，由 ``breakpoint`` 关键字创建的断点仍旧有效。"

msgid "preload"
msgstr "preload"

msgid "Preloads a class or variable. See `Classes as resources`_."
msgstr "预加载一个类或变量，参见 `类作为资源`_ 。"

msgid "await"
msgstr "await"

msgid ""
"Waits for a signal or a coroutine to finish. See `Awaiting for signals or "
"coroutines`_."
msgstr "等待信号或协程完成，参见\\ `等待信号和协程`_\\ 。"

msgid "yield"
msgstr "yield"

msgid "Previously used for coroutines. Kept as keyword for transition."
msgstr "以前的版本中用于协程，现保留为关键字，方便迁移。"

msgid "assert"
msgstr "assert"

msgid ""
"Asserts a condition, logs error on failure. Ignored in non-debug builds. See "
"`Assert keyword`_."
msgstr ""
"断言条件，如果失败则记录错误。在非调试版本中忽略掉断言语法。参见 `Assert 关键"
"字`_\\ 。"

msgid "void"
msgstr "void"

msgid "Used to represent that a function does not return any value."
msgstr "用于代表函数不返回任何值。"

msgid "PI"
msgstr "PI"

msgid "PI constant."
msgstr "PI（π）常数。"

msgid "TAU"
msgstr "TAU"

msgid "TAU constant."
msgstr "TAU（τ）常数。"

msgid "INF"
msgstr "INF"

msgid "Infinity constant. Used for comparisons and as result of calculations."
msgstr "无穷常量，用于比较和计算结果。"

msgid "NAN"
msgstr "NAN"

msgid ""
"NAN (not a number) constant. Used as impossible result from calculations."
msgstr "NAN（非数）常量，用作计算后不可能得到的结果。"

msgid "Operators"
msgstr "运算符"

msgid "The following is the list of supported operators and their precedence."
msgstr "下面是支持的运算符列表及其优先级（越靠上运算优先级越高）。"

msgid "**Operator**"
msgstr "**运算符**"

msgid "**Description**"
msgstr "**描述**"

msgid "``(`` ``)``"
msgstr "``(`` ``)``"

msgid "Grouping (highest priority)"
msgstr "分组（优先级最高）"

msgid ""
"Parentheses are not really an operator, but allow you to explicitly specify "
"the precedence of an operation."
msgstr "括号其实不是运算符，但是能够让你显式指定运算的优先级。"

msgid "``x[index]``"
msgstr "``x[index]``"

msgid "Subscription"
msgstr "下标"

msgid "``x.attribute``"
msgstr "``x.attribute``"

msgid "Attribute reference"
msgstr "属性引用"

msgid "``foo()``"
msgstr "``foo()``"

msgid "Function call"
msgstr "函数调用"

msgid "``await x``"
msgstr "``await x``"

msgid "`Awaiting for signals or coroutines`_"
msgstr "`等待信号和协程`_"

msgid "``x is Node``"
msgstr "``x is Node``"

msgid "Type checking"
msgstr "类型检查"

msgid ""
"See also :ref:`is_instance_of() <class_@GDScript_method_is_instance_of>` "
"function."
msgstr ""
"另见 :ref:`is_instance_of() <class_@GDScript_method_is_instance_of>` 函数。"

msgid "``x ** y``"
msgstr "``x ** y``"

msgid "Power"
msgstr "幂（乘方）"

msgid ""
"Multiplies ``x`` by itself ``y`` times, similar to calling :ref:`pow() "
"<class_@GlobalScope_method_pow>` function."
msgstr ""
"将 ``x`` 与其自身相乘 ``y`` 次，类似于调用 :ref:`pow() "
"<class_@GlobalScope_method_pow>` 函数。"

msgid ""
"**Note:** In GDScript, the ``**`` operator is `left-associative <https://en."
"wikipedia.org/wiki/Operator_associativity>`_. See a detailed note after the "
"table."
msgstr ""
"**注意：**\\ 在 GDScript 中，\\ ``**`` 运算符是\\ `左结合 <https://en."
"wikipedia.org/wiki/Operator_associativity>`_\\ 的，详情见表后。"

msgid "``~x``"
msgstr "``~x``"

msgid "Bitwise NOT"
msgstr "按位取反"

msgid "``+x``"
msgstr "``+x``"

msgid "``-x``"
msgstr "``-x``"

msgid "Identity / Negation"
msgstr "一致 / 求负"

msgid "``x * y``"
msgstr "``x * y``"

msgid "``x / y``"
msgstr "``x / y``"

msgid "``x % y``"
msgstr "``x % y``"

msgid "Multiplication / Division / Remainder"
msgstr "乘法/除法/余数"

msgid ""
"The ``%`` operator is additionally used for :ref:`format strings "
"<doc_gdscript_printf>`."
msgstr "``%`` 运算符也用于\\ :ref:`字符串的格式化 <doc_gdscript_printf>`\\ 。"

msgid ""
"**Note:** These operators have the same behavior as C++, which may be "
"unexpected for users coming from Python, JavaScript, etc. See a detailed "
"note after the table."
msgstr ""
"**注意：**\\ 这些运算符的行为与 C++ 一致，对于来自 Python、JavaScript 等语言"
"的用户可能存在意外的行为，详情见表后。"

msgid "``x + y``"
msgstr "``x + y``"

msgid "``x - y``"
msgstr "``x - y``"

msgid "Addition (or Concatenation) / Subtraction"
msgstr "加法（或连接）/减法"

msgid "``x << y``"
msgstr "``x << y``"

msgid "``x >> y``"
msgstr "``x >> y``"

msgid "Bit shifting"
msgstr "位移位"

msgid "``x & y``"
msgstr "``x & y``"

msgid "Bitwise AND"
msgstr "按位与"

msgid "``x ^ y``"
msgstr "``x ^ y``"

msgid "Bitwise XOR"
msgstr "按位异或"

msgid "``x | y``"
msgstr "``x | y``"

msgid "Bitwise OR"
msgstr "按位或"

msgid "``x == y``"
msgstr "``x == y``"

msgid "``x != y``"
msgstr "``x != y``"

msgid "``x < y``"
msgstr "``x < y``"

msgid "``x > y``"
msgstr "``x > y``"

msgid "``x <= y``"
msgstr "``x <= y``"

msgid "``x >= y``"
msgstr "``x >= y``"

msgid "Comparison"
msgstr "比较"

msgid "See a detailed note after the table."
msgstr "详情见表后。"

msgid "``x in y``"
msgstr "``x in y``"

msgid "``x not in y``"
msgstr "``x not in y``"

msgid "Inclusion checking"
msgstr "包含检查"

msgid "``in`` is also used with the for_ keyword as part of the syntax."
msgstr "``in`` 也在 for_ 关键字的语法中使用。"

msgid "``not x``"
msgstr "``not x``"

msgid "``!x``"
msgstr "``!x``"

msgid "Boolean NOT and its :ref:`unrecommended <boolean_operators>` alias"
msgstr "布尔“非”，以及\\ :ref:`不推荐使用 <boolean_operators>`\\ 的别名"

msgid "``x and y``"
msgstr "``x and y``"

msgid "``x && y``"
msgstr "``x && y``"

msgid "Boolean AND and its :ref:`unrecommended <boolean_operators>` alias"
msgstr "布尔“与”，以及\\ :ref:`不推荐使用 <boolean_operators>`\\ 的别名"

msgid "``x or y``"
msgstr "``x or y``"

msgid "``x || y``"
msgstr "``x || y``"

msgid "Boolean OR and its :ref:`unrecommended <boolean_operators>` alias"
msgstr "布尔“或”，以及\\ :ref:`不推荐使用 <boolean_operators>`\\ 的别名"

msgid "``true_expr if cond else false_expr``"
msgstr "``真表达式 if 条件 else 假表达式``"

msgid "Ternary if/else"
msgstr "三元运算符 if/else"

msgid "``x as Node``"
msgstr "``x as Node``"

msgid "`Type casting <casting_>`_"
msgstr "`类型转换 <casting_>`_"

msgid "``x = y``"
msgstr "``x = y``"

msgid "``x += y``"
msgstr "``x += y``"

msgid "``x -= y``"
msgstr "``x -= y``"

msgid "``x *= y``"
msgstr "``x *= y``"

msgid "``x /= y``"
msgstr "``x /= y``"

msgid "``x **= y``"
msgstr "``x **= y``"

msgid "``x %= y``"
msgstr "``x %= y``"

msgid "``x &= y``"
msgstr "``x &= y``"

msgid "``x |= y``"
msgstr "``x |= y``"

msgid "``x ^= y``"
msgstr "``x ^= y``"

msgid "``x <<= y``"
msgstr "``x <<= y``"

msgid "``x >>= y``"
msgstr "``x >>= y``"

msgid "Assignment (lowest priority)"
msgstr "赋值（优先级最低）"

msgid "You cannot use an assignment operator inside an expression."
msgstr "表达式中不能使用赋值运算符。"

msgid "The behavior of some operators may differ from what you expect:"
msgstr "一些运算符的运算机制可能会与你的预期有所不符："

msgid ""
"If both operands of the ``/`` operator are :ref:`int <class_int>`, then "
"integer division is performed instead of fractional. For example ``5 / 2 == "
"2``, not ``2.5``. If this is not desired, use at least one :ref:`float "
"<class_float>` literal (``x / 2.0``), cast (``float(x) / y``), or multiply "
"by ``1.0`` (``x * 1.0 / y``)."
msgstr ""
"若运算符 ``/`` 两端的数值均为 :ref:`int<class_int>`，则进行整数除法而非浮点数"
"除法。例如： ``5 /2 == 2`` 中 ``2`` 为该算式的结果而非 ``2.5`` 为结果。若希望"
"进行浮点数运算，请将该运算符两端的其中一个数值的类型改为 :ref:"
"`float<class_float>` 。例如：直接使用浮点数（ ``x / 2.0`` ）、转换类型"
"（ ``float(x) / y`` ）、乘以 ``1.0`` （ ``x * 1.0 / y`` ）等。"

msgid ""
"The ``%`` operator is only available for ints, for floats use the :ref:"
"`fmod() <class_@GlobalScope_method_fmod>` function."
msgstr ""
"运算符 ``%`` 仅适用于整型数值的取余运算。对于小数的取余运算，请使用 :ref:"
"`fmod() <class_@GlobalScope_method_fmod>` 方法。"

msgid ""
"For negative values, the ``%`` operator and ``fmod()`` use `truncation "
"<https://en.wikipedia.org/wiki/Truncation>`_ instead of rounding towards "
"negative infinity. This means that the remainder has a sign. If you need the "
"remainder in a mathematical sense, use the :ref:`posmod() "
"<class_@GlobalScope_method_posmod>` and :ref:`fposmod() "
"<class_@GlobalScope_method_fposmod>` functions instead."
msgstr ""
"对于负值，``%`` 运算符和 ``fmod()`` 函数使用 `截断算法 <https://en.wikipedia."
"org/wiki/Truncation>`_ 而非向负无穷大舍入，此时余数会带有符号（即余数可能为"
"负）。如果你需要数学意义上的余数，请改用 :ref:`posmod() "
"<class_@GlobalScope_method_posmod>` 和 :ref:`fposmod() "
"<class_@GlobalScope_method_fposmod>` 函数。"

msgid ""
"The ``**`` operator is `left-associative <https://en.wikipedia.org/wiki/"
"Operator_associativity>`_. This means that ``2 ** 2 ** 3`` is equal to ``(2 "
"** 2) ** 3``. Use parentheses to explicitly specify precedence you need, for "
"example ``2 ** (2 ** 3)``."
msgstr ""
"运算符 ``**`` 是 `左结合运算符 <https://en.wikipedia.org/wiki/"
"Operator_associativity>`_ ，也就是说， ``2 ** 2 ** 3`` 这个运算等价于 ``(2 "
"** 2) ** 3`` 。对此，请使用括号来处理该运算的优先级，如 ``2 ** (2 ** 3)`` 。"

msgid ""
"The ``==`` and ``!=`` operators sometimes allow you to compare values of "
"different types (for example, ``1 == 1.0`` is true), but in other cases it "
"can cause a runtime error. If you're not sure about the types of the "
"operands, you can safely use the :ref:`is_same() "
"<class_@GlobalScope_method_is_same>` function (but note that it is more "
"strict about types and references). To compare floats, use the :ref:"
"`is_equal_approx() <class_@GlobalScope_method_is_equal_approx>` and :ref:"
"`is_zero_approx() <class_@GlobalScope_method_is_zero_approx>` functions "
"instead."
msgstr ""
"``==`` 和 ``!=`` 运算符在有些情况下允许你比较不同类型的值（例如，``1 == "
"1.0`` 的结果为真），但在其他情况下可能会发生运行时错误。如果你不能确定操作数"
"的类型，可以安全地使用 :ref:`is_same() <class_@GlobalScope_method_is_same>` "
"函数（但请注意，该函数对类型和引用更加严格）。要比较浮点数，请改用 :ref:"
"`is_equal_approx() <class_@GlobalScope_method_is_equal_approx>` 和 :ref:"
"`is_zero_approx() <class_@GlobalScope_method_is_zero_approx>` 函数。"

msgid "Literals"
msgstr "字面量"

msgid "**Example(s)**"
msgstr "**Example(s)**"

msgid "``null``"
msgstr "``null``"

msgid "Null value"
msgstr "空值"

msgid "``false``, ``true``"
msgstr "``false``, ``true``"

msgid "Boolean values"
msgstr "布尔值"

msgid "``45``"
msgstr "``45``"

msgid "Base 10 integer"
msgstr "十进制整数"

msgid "``0x8f51``"
msgstr "``0x8f51``"

msgid "Base 16 (hexadecimal) integer"
msgstr "十六进制整数"

msgid "``0b101010``"
msgstr "``0b101010``"

msgid "Base 2 (binary) integer"
msgstr "二进制整数"

msgid "``3.14``, ``58.1e-10``"
msgstr "``3.14``, ``58.1e-10``"

msgid "Floating-point number (real)"
msgstr "浮点数（实数）"

msgid "``\"Hello\"``, ``'Hi'``"
msgstr "``\"Hello\"``, ``\"Hi\"``"

msgid "Regular strings"
msgstr "常规字符串"

msgid "``\"\"\"Hello\"\"\"``, ``'''Hi'''``"
msgstr "``\"\"\"Hello\"\"\"``, ``'''Hi'''``"

msgid "Triple-quoted regular strings"
msgstr "常规字符串（用三对引号括住）"

msgid "``r\"Hello\"``, ``r'Hi'``"
msgstr "``r\"Hello\"``, ``r'Hi'``"

msgid "Raw strings"
msgstr "原始字符串"

msgid "``r\"\"\"Hello\"\"\"``, ``r'''Hi'''``"
msgstr "``r\"\"\"Hello\"\"\"``, ``r'''Hi'''``"

msgid "Triple-quoted raw strings"
msgstr "原始字符串（用三对引号括住）"

msgid "``&\"name\"``"
msgstr "``&\"name\"``"

msgid ":ref:`StringName <class_StringName>`"
msgstr ":ref:`StringName <class_StringName>`"

msgid "``^\"Node/Label\"``"
msgstr "``^\"Node/Label\"``"

msgid ":ref:`NodePath <class_NodePath>`"
msgstr ":ref:`NodePath <class_NodePath>`"

msgid ""
"There are also two constructs that look like literals, but actually are not:"
msgstr "也有两种长得像字面量，但实际上不是字面量的量："

msgid "**Example**"
msgstr "**示例**"

msgid "``$NodePath``"
msgstr "``$NodePath``"

msgid "Shorthand for ``get_node(\"NodePath\")``"
msgstr "``get_node(\"NodePath\")`` 的简写"

msgid "``%UniqueNode``"
msgstr "``%UniqueNode``"

msgid "Shorthand for ``get_node(\"%UniqueNode\")``"
msgstr "``get_node(\"%UniqueNode\")`` 的简写"

msgid ""
"Integers and floats can have their numbers separated with ``_`` to make them "
"more readable. The following ways to write numbers are all valid::"
msgstr ""
"整数和浮点数可以用 ``_`` 来分隔，使其更加易读。以下表示数字的方法都是有效"
"的： ::"

msgid "**Regular string literals** can contain the following escape sequences:"
msgstr "**常规字符串字面量** 内可包含以下转义序列："

msgid "**Escape sequence**"
msgstr "**转义序列**"

msgid "**Expands to**"
msgstr "**转义为**"

msgid "``\\n``"
msgstr "``\\n``"

msgid "Newline (line feed)"
msgstr "换行(line feed,LF)"

msgid "``\\t``"
msgstr "``\\t``"

msgid "Horizontal tab character"
msgstr "水平制表符（tab）"

msgid "``\\r``"
msgstr "``\\r``"

msgid "Carriage return"
msgstr "回车（carriage return,CR）"

msgid "``\\a``"
msgstr "``\\a``"

msgid "Alert (beep/bell)"
msgstr "警报（蜂鸣/响铃）"

msgid "``\\b``"
msgstr "``\\b``"

msgid "Backspace"
msgstr "退格键（Backspace）"

msgid "``\\f``"
msgstr "``\\f``"

msgid "Formfeed page break"
msgstr "换页符（form feed,FF）"

msgid "``\\v``"
msgstr "``\\v``"

msgid "Vertical tab character"
msgstr "垂直制表符（tab）"

msgid "``\\\"``"
msgstr "``\\\"``"

msgid "Double quote"
msgstr "双引号"

msgid "``\\'``"
msgstr "``\\'``"

msgid "Single quote"
msgstr "单引号"

msgid "``\\\\``"
msgstr "``\\\\``"

msgid "Backslash"
msgstr "反斜杠"

msgid "``\\uXXXX``"
msgstr "``\\uXXXX``"

msgid "UTF-16 Unicode codepoint ``XXXX`` (hexadecimal, case-insensitive)"
msgstr "Unicode UTF-16 码位 ``XXXX`` （16进制，不区分大小写）"

msgid "``\\UXXXXXX``"
msgstr "``\\UXXXXXX``"

msgid "UTF-32 Unicode codepoint ``XXXXXX`` (hexadecimal, case-insensitive)"
msgstr "Unicode UTF-32 码位 ``XXXXXX`` （16进制，不区分大小写）"

msgid ""
"There are two ways to represent an escaped Unicode character above "
"``0xFFFF``:"
msgstr "有两种方法可以表示 ``0xFFFF`` 以上的转义 Unicode 字符："

msgid ""
"as a `UTF-16 surrogate pair <https://en.wikipedia.org/wiki/"
"UTF-16#Code_points_from_U+010000_to_U+10FFFF>`_ ``\\uXXXX\\uXXXX``."
msgstr ""
"使用 `UTF-16 代理对 <https://en.wikipedia.org/wiki/"
"UTF-16#Code_points_from_U+010000_to_U+10FFFF>`_ ``\\uXXXX\\uXXXX`` 表示。"

msgid "as a single UTF-32 codepoint ``\\UXXXXXX``."
msgstr "使用单个 UTF-32 码位 ``\\UXXXXXX`` 表示。"

msgid ""
"Also, using ``\\`` followed by a newline inside a string will allow you to "
"continue it in the next line, without inserting a newline character in the "
"string itself."
msgstr ""
"此外，在字符串中使用 ``\\`` 后换行可以让该符号后的文字自动换行，而无需在字符"
"串中插入换行符。"

msgid ""
"A string enclosed in quotes of one type (for example ``\"``) can contain "
"quotes of another type (for example ``'``) without escaping. Triple-quoted "
"strings allow you to avoid escaping up to two consecutive quotes of the same "
"type (unless they are adjacent to the string edges)."
msgstr ""
"包含在一种类型的引号（如 ``\"``）中的字符串，无需转义即可包含另一种类型的引号"
"（如 ``'``）。三引号字符串允许你避免转义最多两个连续相同类型的引号 （除非这些"
"引号与字符串边缘相邻）。"

msgid ""
"**Raw string literals** always encode the string as it appears in the source "
"code. This is especially useful for regular expressions. Raw strings do not "
"process escape sequences, but you can \"escape\" a quote or backslash (they "
"replace themselves)."
msgstr ""
"**原始字符串字面量** 始终按照源代码中出现的方式对字符串进行编码，对于正则表达"
"式特别有用。原始字符串不处理转义序列，但你可以“转义”引号或反斜杠（引号和反斜"
"杠会替换自身）。"

msgid "GDScript also supports :ref:`format strings <doc_gdscript_printf>`."
msgstr "GDScript 也支持 :ref:`doc_gdscript_printf`\\。"

msgid "Annotations"
msgstr "注解"

msgid ""
"There are some special tokens in GDScript that act like keywords but are "
"not, they are *annotations* instead. Every annotation start with the ``@`` "
"character and is specified by a name. A detailed description and example for "
"each annotation can be found inside the :ref:`GDScript class reference "
"<class_@GDScript>`."
msgstr ""
"GDScript中有一些特殊标记，虽然起着类似于关键字的作用，但这些标记本身却不是关"
"键字。这些标记就是 *注解* ，每个注解均以 ``@`` 符号开头，并配以注解名称。有关"
"注解的详细说明及其使用范例，请参考 :ref:`GDScript class reference "
"<class_@GDScript>` 。"

msgid ""
"Annotations affect how the script is treated by external tools and usually "
"don't change the behavior."
msgstr "注解会影响外部工具处理脚本的方式，通常不会更改该脚本的行为。"

msgid "For instance, you can use it to export a value to the editor::"
msgstr "比如，你可以将变量导出到编辑器中： ::"

msgid ""
"For more information about exporting properties, read the :ref:`GDScript "
"exports <doc_gdscript_exports>` article."
msgstr ""
"要获取更多关于导出属性的信息，请阅读 :ref:`GDScript exports "
"<doc_gdscript_exports>`。"

msgid ""
"Any constant expression compatible with the required argument type can be "
"passed as an annotation argument value::"
msgstr ""
"所有与注解要求传入的参数类型相符、位置相配的常量表达式均可作为该注解参数传入"
"其中： ::"

msgid ""
"Annotations can be specified one per line or all in the same line. They "
"affect the next statement that isn't an annotation. Annotations can have "
"arguments sent between parentheses and separated by commas."
msgstr ""
"注解可以单行修饰，也可以多行修饰，修饰离该注解最近的非注解语句。注解可以携带"
"参数，每个参数均在注解名后的括号内，彼此之间用逗号隔开。"

msgid "Both of these are the same::"
msgstr "下面两个例子的效果是等价的： ::"

msgid "``@onready`` annotation"
msgstr "``@onready`` 注解"

msgid ""
"When using nodes, it's common to desire to keep references to parts of the "
"scene in a variable. As scenes are only warranted to be configured when "
"entering the active scene tree, the sub-nodes can only be obtained when a "
"call to ``Node._ready()`` is made."
msgstr ""
"使用节点时，经常会需要将场景中某一部分的引用存放在变量中。由于场景只有在进入"
"活动场景树时才会进行正确配置，因此只有在调用 ``Node._ready()`` 时才能获得子节"
"点。"

msgid ""
"This can get a little cumbersome, especially when nodes and external "
"references pile up. For this, GDScript has the ``@onready`` annotation, that "
"defers initialization of a member variable until ``_ready()`` is called. It "
"can replace the above code with a single line::"
msgstr ""
"这种操作比较麻烦，而且节点和外部引用越多，操作起来越显得不便。为此，GDScript "
"提供了 ``@onready`` 注解 ，将成员变量的初始化推迟到该节点调用 ``_ready()`` 的"
"时刻进行。使用该注解，可以用一行代码替换掉上面的代码： ::"

msgid ""
"Applying ``@onready`` and any ``@export`` annotation to the same variable "
"doesn't work as you might expect. The ``@onready`` annotation will cause the "
"default value to be set after the ``@export`` takes effect and will override "
"it::"
msgstr ""
"同时使用 ``@onready`` 和 ``@export`` 这两个注解去修饰同一个变量，其效果并不会"
"如你预期的那样理想，因为 ``@onready`` 注解会使该变量的默认值在 ``@export`` 注"
"解起效后被赋值，导致该默认值被 ``@onready`` 的效果所覆盖： ::"

msgid ""
"Therefore, the ``ONREADY_WITH_EXPORT`` warning is generated, which is "
"treated as an error by default. We do not recommend disabling or ignoring it."
msgstr ""
"为此，本引擎提供了 ``ONREADY_WITH_EXPORT`` 警告选项，默认作为编辑器错误进行处"
"理。我们并不推荐关闭或忽略该警告选项。"

msgid "Comments"
msgstr "注释"

msgid ""
"Anything from a ``#`` to the end of the line is ignored and is considered a "
"comment."
msgstr "``#`` 所在行的所有内容都会被忽略，会视为注释进行处理。"

msgid ""
"In the Godot script editor, special keywords are highlighted within comments "
"to bring the user's attention to specific comments:"
msgstr "在 Godot 的脚本编辑器内，一些特殊关键字会在注释中高亮显示以提醒用户："

msgid ""
"**Critical** *(appears in red)*: ``ALERT``, ``ATTENTION``, ``CAUTION``, "
"``CRITICAL``, ``DANGER``, ``SECURITY``"
msgstr ""
"**关键提示** *（标红）*：``ALERT``、``ATTENTION``、``CAUTION``、"
"``CRITICAL``、``DANGER``、``SECURITY``"

msgid ""
"**Warning** *(appears in yellow)*: ``BUG``, ``DEPRECATED``, ``FIXME``, "
"``HACK``, ``TASK``, ``TBD``, ``TODO``, ``WARNING``"
msgstr ""
"**警告提示** *（标黄）*：``BUG``、``DEPRECATED``、``FIXME``、``HACK``、"
"``TASK``、``TBD``、``TODO``、``WARNING``"

msgid ""
"**Notice** *(appears in green)*: ``INFO``, ``NOTE``, ``NOTICE``, ``TEST``, "
"``TESTING``"
msgstr ""
"**一般提示** *（标绿）*：``INFO``、``NOTE``、``NOTICE``、``TEST``、"
"``TESTING``"

msgid ""
"These keywords are case-sensitive, so they must be written in uppercase for "
"them to be recognized:"
msgstr "这些关键字均大小写敏感，故需要全大写以保证能被引擎所识别："

msgid ""
"The list of highlighted keywords and their colors can be changed in the "
"**Text Editor > Theme > Comment Markers** section of the Editor Settings."
msgstr ""
"可以在编辑器设置的 **文本编辑器 > 主题 > 注释标记** 部分中更改突出显示的关键"
"字列表及其颜色。"

msgid "Code regions"
msgstr "代码区块"

msgid ""
"Code regions are special types of comments that the script editor "
"understands as *foldable regions*. This means that after writing code region "
"comments, you can collapse and expand the region by clicking the arrow that "
"appears at the left of the comment. This arrow appears within a purple "
"square to be distinguishable from standard code folding."
msgstr ""
"代码区块是一种特殊类型的注释，脚本编辑器将其理解为 *可折叠区块*\\，即在编写代"
"码区块注释后，可以通过点击注释左侧出现的箭头来折叠和展开该区块。该箭头用一个"
"紫色方块包围起来，以区别于标准的代码折叠。"

msgid "The syntax is as follows:"
msgstr "语法如下："

msgid ""
"To create a code region quickly, select several lines in the script editor, "
"right-click the selection then choose **Create Code Region**. The region "
"description will be selected automatically for editing."
msgstr ""
"要快速创建代码区块，请在脚本编辑器中选择若干行，右键点击选区，然后选择 **创建"
"代码区块**\\即可。系统将自动选中区块描述以对其进行编辑。"

msgid "It is possible to nest code regions within other code regions."
msgstr "可以将代码区块嵌套在其他代码区块内。"

msgid "Here's a concrete usage example of code regions:"
msgstr "以下是代码区块的具体使用示例："

msgid ""
"This can be useful to organize large chunks of code into easier to "
"understand sections. However, remember that external editors generally don't "
"support this feature, so make sure your code is easy to follow even when not "
"relying on folding code regions."
msgstr ""
"代码区块可以将大块代码组织成更容易理解的部分，但请注意，外部编辑器通常不支持"
"该特性。因此即便不依赖代码区块，也要确保你的代码易于理解。"

msgid ""
"Individual functions and indented sections (such as ``if`` and ``for``) can "
"*always* be collapsed in the script editor. This means you should avoid "
"using a code region to contain a single function or indented section, as it "
"won't bring much of a benefit. Code regions work best when they're used to "
"group multiple elements together."
msgstr ""
"单独的函数和被缩进的部分（例如 ``if`` 和 ``for``） *始终* 可以在脚本编辑器中"
"折叠，故应避免使用代码区块来包含单一函数或被缩进的部分，执意使用也并不会带来"
"太多好处。代码区块在将多个元素分组在一起时效果最佳。"

msgid "Line continuation"
msgstr "行间语句接续"

msgid ""
"A line of code in GDScript can be continued on the next line by using a "
"backslash (``\\``). Add one at the end of a line and the code on the next "
"line will act like it's where the backslash is. Here is an example:"
msgstr ""
"在GDScript中，一行语句可以通过反斜杠（ ``\\`` ）来接续到下一行。将反斜杠加在"
"语句行末尾可以衔接该语句行的代码与下一语句行的代码。例如："

msgid "A line can be continued multiple times like this:"
msgstr "可以按以下方式对单个语句行进行多行接续："

msgid "Built-in types"
msgstr "内置类型"

msgid ""
"Built-in types are stack-allocated. They are passed as values. This means a "
"copy is created on each assignment or when passing them as arguments to "
"functions. The exceptions are ``Object``, ``Array``, ``Dictionary``, and "
"packed arrays (such as ``PackedByteArray``), which are passed by reference "
"so they are shared. All arrays, ``Dictionary``, and some objects (``Node``, "
"``Resource``) have a ``duplicate()`` method that allows you to make a copy."
msgstr ""
"内置类型是分配在栈上的，按值传递，在每次赋值或将其作为参数传递给函数时都会复"
"制其值。例外：对象 ``Object`` 、数组 ``Array`` 、字典 ``Dictionary`` 以及密存"
"数组（如 ``PackedByteArray`` ），这些类型的值是按引用进行传递的，其实例的值相"
"互共享。数组、字典以及部分对象（ ``Node`` 、 ``Resource`` ）均有一个 "
"``duplicate()`` 方法，允许对其具体值进行复制操作。"

msgid "Basic built-in types"
msgstr "基本内置类型"

msgid "A variable in GDScript can be assigned to several built-in types."
msgstr "GDScript 中的变量可以赋值为不同的内置类型。"

msgid "null"
msgstr "null"

msgid ""
"``null`` is an empty data type that contains no information and can not be "
"assigned any other value."
msgstr "``null`` 是一个空数据类型，既不包含任何信息，也不能赋值为其他任何值。"

msgid ":ref:`bool <class_bool>`"
msgstr ":ref:`bool <class_bool>`"

msgid "Short for \"boolean\", it can only contain ``true`` or ``false``."
msgstr "“boolean”（布尔）的缩写，只能包含 ``true`` 或 ``false``\\ 。"

msgid ":ref:`int <class_int>`"
msgstr ":ref:`int<class_int>`"

msgid ""
"Short for \"integer\", it stores whole numbers (positive and negative). It "
"is stored as a 64-bit value, equivalent to ``int64_t`` in C++."
msgstr ""
"英文“integer”（整数）的缩写，存储整数（正整数和负整数）。存储的是 64 位值，等"
"效于 C++ 中的 ``int64_t``\\ 。"

msgid ":ref:`float <class_float>`"
msgstr ":ref:`float<class_float>`"

msgid ""
"Stores real numbers, including decimals, using floating-point values. It is "
"stored as a 64-bit value, equivalent to ``double`` in C++. Note: Currently, "
"data structures such as ``Vector2``, ``Vector3``, and ``PackedFloat32Array`` "
"store 32-bit single-precision ``float`` values."
msgstr ""
"使用浮点值存储实数，包括小数。存储的是 64 位值，等效于 C++ 中的 "
"``double``\\ 。注意：目前 ``Vector2``\\ 、\\ ``Vector3``\\ 、\\ "
"``PackedFloat32Array`` 等数据结构存储的是 32 位单精度 ``float`` 值。"

msgid ":ref:`String <class_String>`"
msgstr ":ref:`String <class_String>`"

msgid ""
"A sequence of characters in `Unicode format <https://en.wikipedia.org/wiki/"
"Unicode>`_."
msgstr ""
"`Unicode 格式 <https://zh.wikipedia.org/zh-cn/Unicode>`_\\ 的字符序列。"

msgid ""
"An immutable string that allows only one instance of each name. They are "
"slower to create and may result in waiting for locks when multithreading. In "
"exchange, they're very fast to compare, which makes them good candidates for "
"dictionary keys."
msgstr ""
"不可变字符串，一个实例仅允许拥有一个名称。该类型的实例创建起来较慢，在多线程"
"环境下可能会导致锁等待。不过，该类型的实例比较起来比字符串快，非常适合在字典"
"中作为键名使用。"

msgid ""
"A pre-parsed path to a node or a node property.  It can be easily assigned "
"to, and from, a String. They are useful to interact with the tree to get a "
"node, or affecting properties like with :ref:`Tweens <class_Tween>`."
msgstr ""
"节点或节点属性的预解析路径，可以轻松地赋值成字符串，亦或从字符串中转换为节点"
"路径。节点路径可用于与节点树交互以获取节点，亦或通过诸如 :ref:`Tween "
"<class_Tween>`\\等方式来影响属性。"

msgid "Vector built-in types"
msgstr "内置向量类型"

msgid ":ref:`Vector2 <class_Vector2>`"
msgstr ":ref:`Vector2 <class_Vector2>`"

msgid ""
"2D vector type containing ``x`` and ``y`` fields. Can also be accessed as an "
"array."
msgstr ""
"2D 向量类型，包含 ``x`` 和 ``y`` 两个字段，也可以像访问数组元素一样访问这两个"
"字段。"

#, fuzzy
msgid ":ref:`Vector2i <class_Vector2i>`"
msgstr ":ref:`Vector2 <class_Vector2>`"

msgid ""
"Same as a Vector2 but the components are integers. Useful for representing "
"items in a 2D grid."
msgstr "同 Vector2，但其分量均为整型数值，在做2D网格中显示物品时非常实用。"

msgid ":ref:`Rect2 <class_Rect2>`"
msgstr ":ref:`Rect2 <class_Rect2>`"

msgid ""
"2D Rectangle type containing two vectors fields: ``position`` and ``size``. "
"Also contains an ``end`` field which is ``position + size``."
msgstr ""
"2D 矩形类型，包含两个向量字段： ``position`` 和 ``size``\\ 。还包含一个 "
"``end`` 字段，即 ``position + size``\\ 。"

msgid ":ref:`Vector3 <class_Vector3>`"
msgstr ":ref:`Vector3 <class_Vector3>`"

msgid ""
"3D vector type containing ``x``, ``y`` and ``z`` fields. This can also be "
"accessed as an array."
msgstr ""
"3D 向量类型，包含 ``x`` 、 ``y`` 和 ``z`` 这三个字段，也可以像访问数组元素一"
"样访问这些字段。"

#, fuzzy
msgid ":ref:`Vector3i <class_Vector3i>`"
msgstr ":ref:`Vector3 <class_Vector3>`"

msgid ""
"Same as Vector3 but the components are integers. Can be use for indexing "
"items in a 3D grid."
msgstr ""
"同 Vector3 ，但其分量均为整型数值，可用于为 3D 网格中的每个物品编制索引。"

msgid ":ref:`Transform2D <class_Transform2D>`"
msgstr ":ref:`Transform2D <class_Transform2D>`"

msgid "3×2 matrix used for 2D transforms."
msgstr "用于 2D 线性变换的3x2矩阵。"

msgid ":ref:`Plane <class_Plane>`"
msgstr ":ref:`Plane <class_Plane>`"

msgid ""
"3D Plane type in normalized form that contains a ``normal`` vector field and "
"a ``d`` scalar distance."
msgstr ""
"3D 平面类型的标准形式，包含一个向量字段 ``normal`` 以及一个 标量距离 ``d`` 。"

msgid ":ref:`Quaternion <class_Quaternion>`"
msgstr ":ref:`Quaternion <class_Quaternion>`"

msgid ""
"Quaternion is a datatype used for representing a 3D rotation. It's useful "
"for interpolating rotations."
msgstr "四元数是一种用于表示 3D 旋转的数据类型，对于内插旋转十分有用。"

msgid ":ref:`AABB <class_AABB>`"
msgstr ":ref:`AABB <class_AABB>`"

msgid ""
"Axis-aligned bounding box (or 3D box) contains 2 vectors fields: "
"``position`` and ``size``. Also contains an ``end`` field which is "
"``position + size``."
msgstr ""
"轴对齐边界框（或 3D 边框），包含两个向量字段: ``position`` 和 ``size``. 还包"
"含一个 ``end`` 字段, 即 ``position + size``."

msgid ":ref:`Basis <class_Basis>`"
msgstr ":ref:`Basis <class_Basis>`"

msgid ""
"3x3 matrix used for 3D rotation and scale. It contains 3 vector fields "
"(``x``, ``y`` and ``z``) and can also be accessed as an array of 3D vectors."
msgstr ""
"3×3矩阵，用于 3D 旋转与缩放。其包含3个向量字段（ ``x``, ``y`` 和 ``z`` ），且"
"可以像3D向量一样按索引访问这些向量字段。"

msgid ":ref:`Transform3D <class_Transform3D>`"
msgstr ":ref:`Transform3D <class_Transform3D>`"

msgid ""
"3D Transform contains a Basis field ``basis`` and a Vector3 field ``origin``."
msgstr ""
"3D 线性变换，包含一个 Basis（基）字段 ``basis`` 和一个 Vector3 字段 "
"``origin``\\ 。"

msgid "Engine built-in types"
msgstr "引擎内置类型"

msgid ":ref:`Color <class_Color>`"
msgstr ":ref:`Color <class_Color>`"

msgid ""
"Color data type contains ``r``, ``g``, ``b``, and ``a`` fields. It can also "
"be accessed as ``h``, ``s``, and ``v`` for hue/saturation/value."
msgstr ""
"颜色数据类型包含 ``r`` 、 ``g`` 、 ``b`` 、 ``a`` 四个字段，也可以用 "
"``h`` 、 ``s`` 、 ``v`` 这三个字段来分别访问色相、饱和度、明度。"

msgid ":ref:`RID <class_RID>`"
msgstr ":ref:`RID <class_RID>`"

msgid "Resource ID (RID). Servers use generic RIDs to reference opaque data."
msgstr "资源ID（RID）。服务使用通用的 RID 来引用不透明数据。"

msgid ":ref:`Object <class_Object>`"
msgstr ":ref:`Object <class_Object>`"

msgid "Base class for anything that is not a built-in type."
msgstr "所有非内置类型的基类型。"

msgid "Container built-in types"
msgstr "容器内置类型"

msgid ":ref:`Array <class_Array>`"
msgstr ":ref:`Array <class_Array>`"

msgid ""
"Generic sequence of arbitrary object types, including other arrays or "
"dictionaries (see below). The array can resize dynamically. Arrays are "
"indexed starting from index ``0``. Negative indices count from the end."
msgstr ""
"任意对象类型的泛型序列，包括其他数组或字典（见下文）。数组可以动态调整大小，"
"其索引从 ``0`` 开始，索引为负整数时则表示从数组尾部开始计数。"

msgid "Typed arrays"
msgstr "类型化数组"

msgid ""
"Godot 4.0 added support for typed arrays. On write operations, Godot checks "
"that element values match the specified type, so the array cannot contain "
"invalid values. The GDScript static analyzer takes typed arrays into "
"account, however array methods like ``front()`` and ``back()`` still have "
"the ``Variant`` return type."
msgstr ""
"Godot 4.0 开始支持类型化数组。向类型化数组中写入数据时，Godot 会检查每个元素"
"是否与该数组所指定的类型相匹配，因此类型化数组不能含有无效数据。而诸如 "
"``front()`` 和 ``back()`` 等方法，虽然 GDScript 静态分析器会将类型化数组考虑"
"在内，却仍会返回 ``Variant`` 类型的数值。"

msgid ""
"Typed arrays have the syntax ``Array[Type]``, where ``Type`` can be any "
"``Variant`` type, native or user class, or enum. Nested array types (like "
"``Array[Array[int]]``) are not supported."
msgstr ""
"类型化数组通过 ``Array[Type]`` 指定，其中类型 ``Type`` 可以是 ``Variant`` 类"
"型、内置类型，也可以是用户自定义类型、枚举类型等。不支持类型化数组嵌套（如 "
"``Array[Array[int]]`` ）。"

msgid "``Array`` and ``Array[Variant]`` are the same thing."
msgstr "``Array`` 等价于 ``Array[Varaint]`` 。"

msgid ""
"Arrays are passed by reference, so the array element type is also an "
"attribute of the in-memory structure referenced by a variable in runtime. "
"The static type of a variable restricts the structures that it can reference "
"to. Therefore, you **cannot** assign an array with a different element type, "
"even if the type is a subtype of the required type."
msgstr ""
"数组是按引用传递的，因此数组元素类型也是运行时变量引用的内存结构的一个属性。"
"变量的静态类型限制了它可以引用的结构。因此，你 **不能**\\为数组内的元素赋予不"
"同的元素类型的值，即使该类型是数组所接受类型的子类型。"

msgid ""
"If you want to *convert* a typed array, you can create a new array and use "
"the :ref:`Array.assign() <class_Array_method_assign>` method::"
msgstr ""
"若需要对类型化数组进行 *转型* ，可以创建一个新数组，并使用 :ref:`Array."
"assign() <class_Array_method_assign>` 方法::"

msgid ""
"The only exception was made for the ``Array`` (``Array[Variant]``) type, for "
"user convenience and compatibility with old code. However, operations on "
"untyped arrays are considered unsafe."
msgstr ""
"``Array`` （ ``Array[Variant]`` ）则是例外，这样做可以保证用户使用的便捷性与"
"与旧版本代码的兼容性。不过，非类型化的数组是不安全的。"

msgid "Packed arrays"
msgstr "密存数组"

msgid ""
"GDScript arrays are allocated linearly in memory for speed. Large arrays "
"(more than tens of thousands of elements) may however cause memory "
"fragmentation. If this is a concern, special types of arrays are available. "
"These only accept a single data type. They avoid memory fragmentation and "
"use less memory, but are atomic and tend to run slower than generic arrays. "
"They are therefore only recommended to use for large data sets:"
msgstr ""
"GDScript 数组在内存中通过线性分配以提高速度，但使用大型数组（包含数万个元素）"
"时却可能会导致内存碎片。如果在意这个问题，可以使用特定类型的密存数组，这些数"
"组只接受单个数据类型，避免了内存碎片的同时使用的内存也更少。然而这些特定类型"
"的数组是原子数组，运行起来通常要比通用数组慢，因此建议将这些数组仅用于大型数"
"据集当中："

msgid ""
":ref:`PackedByteArray <class_PackedByteArray>`: An array of bytes (integers "
"from 0 to 255)."
msgstr ""
":ref:`PackedByteArray <class_PackedByteArray>`\\ ：字节（从 0 到 255 的整数）"
"数组。"

msgid ""
":ref:`PackedInt32Array <class_PackedInt32Array>`: An array of 32-bit "
"integers."
msgstr ":ref:`PackedInt32Array <class_PackedInt32Array>`\\ ：32位整数数组。"

msgid ""
":ref:`PackedInt64Array <class_PackedInt64Array>`: An array of 64-bit "
"integers."
msgstr ":ref:`PackedInt64Array <class_PackedInt64Array>`\\ ：64位整数数组。"

msgid ""
":ref:`PackedFloat32Array <class_PackedFloat32Array>`: An array of 32-bit "
"floats."
msgstr ""
":ref:`PackedFloat32Array <class_PackedFloat32Array>`\\ ：32位浮点数数组。"

msgid ""
":ref:`PackedFloat64Array <class_PackedFloat64Array>`: An array of 64-bit "
"floats."
msgstr ""
":ref:`PackedFloat64Array <class_PackedFloat64Array>`\\ ：64位浮点数数组。"

msgid ""
":ref:`PackedStringArray <class_PackedStringArray>`: An array of strings."
msgstr ":ref:`PackedStringArray <class_PackedStringArray>`\\ ：字符串数组。"

msgid ""
":ref:`PackedVector2Array <class_PackedVector2Array>`: An array of :ref:"
"`Vector2 <class_Vector2>` values."
msgstr ""
":ref:`PackedVector2Array <class_PackedVector2Array>`\\ ：\\ :ref:`Vector2 "
"<class_Vector2>` 类型的数组。"

msgid ""
":ref:`PackedVector3Array <class_PackedVector3Array>`: An array of :ref:"
"`Vector3 <class_Vector3>` values."
msgstr ""
":ref:`PackedVector3Array <class_PackedVector3Array>`\\ ：\\ :ref:`Vector3 "
"<class_Vector3>` 类型的数组。"

msgid ""
":ref:`PackedColorArray <class_PackedColorArray>`: An array of :ref:`Color "
"<class_Color>` values."
msgstr ""
":ref:`PackedColorArray <class_PackedColorArray>`\\ ：\\ :ref:`Color "
"<class_Color>` 类型的数组。"

msgid ":ref:`Dictionary <class_Dictionary>`"
msgstr ":ref:`Dictionary <class_Dictionary>`"

msgid "Associative container which contains values referenced by unique keys."
msgstr "关联容器，其内部数值通过与之对应的唯一的键进行引用。"

msgid ""
"Lua-style table syntax is also supported. Lua-style uses ``=`` instead of ``:"
"`` and doesn't use quotes to mark string keys (making for slightly less to "
"write). However, keys written in this form can't start with a digit (like "
"any GDScript identifier), and must be string literals."
msgstr ""
"字典也支持 Lua 风格的 table 语法。Lua 风格的 GDScript 字典语法在标记字符串键"
"时，使用的是 ``=`` 而非 ``:``\\ ，且不使用引号（这样要写的东西会稍微少一"
"些）。但请注意，以这种形式编写的键和 GDScript 标识符一样不能以数字开头，且必"
"须为字面量。"

msgid ""
"To add a key to an existing dictionary, access it like an existing key and "
"assign to it::"
msgstr ""
"若要向现有字典添加键，可以像访问现有键一样访问要添加的键，并给其赋值： ::"

msgid ""
"The bracket syntax can be used to access properties of any :ref:"
"`class_Object`, not just Dictionaries. Keep in mind it will cause a script "
"error when attempting to index a non-existing property. To avoid this, use "
"the :ref:`Object.get() <class_Object_method_get>` and :ref:`Object.set() "
"<class_Object_method_set>` methods instead."
msgstr ""
"方括号语法不仅可以用在 Dictionary 上，而且还可以用来存取任何 :ref:"
"`class_Object` 的属性。不过要注意：尝试读取不存在的属性会引发脚本错误。要避免"
"这一点，可换用 :ref:`Object.get() <class_Object_method_get>` 和 :ref:`Object."
"set() <class_Object_method_set>` 方法。"

msgid ":ref:`Signal <class_Signal>`"
msgstr ":ref:`Signal <class_Signal>`"

msgid ""
"A signal is a message that can be emitted by an object to those who want to "
"listen to it. The Signal type can be used for passing the emitter around."
msgstr ""
"信号由对象发出，并由对象所监听。 Signal 类型可以用于将信号广播者作为参数进行"
"传递。"

msgid ""
"Signals are better used by getting them from actual objects, e.g. ``$Button."
"button_up``."
msgstr "信号可以直接从对象实例中进行引用，如 ``$Button.button_up`` 。"

msgid ":ref:`Callable <class_Callable>`"
msgstr ":ref:`Callable <class_Callable>`"

msgid ""
"Contains an object and a function, which is useful for passing functions as "
"values (e.g. when connecting to signals)."
msgstr ""
"可调用体包含一个对象及其某个函数，适用于将函数作为数值传递（例如：将可调用体"
"用于信号连接）。"

msgid ""
"Getting a method as a member returns a callable. ``var x = $Sprite2D."
"rotate`` will set the value of ``x`` to a callable with ``$Sprite2D`` as the "
"object and ``rotate`` as the method."
msgstr ""
"像引用成员属性那样引用一个方法的签名会返回可调用体。 如 ``var x = $Sprite2D."
"rotate`` 会将变量 ``x`` 赋值为一个可调用体，该可调用体含有对 ``$Sprite2D`` 对"
"象的方法 ``rotate()`` 的引用。"

msgid "You can call it using the ``call`` method: ``x.call(PI)``."
msgstr "可以调用 ``call`` 方法来调用可调体所指向的方法，如： ``x.call(PI)`` 。"

msgid "Data"
msgstr "数据"

msgid "Variables"
msgstr "变量"

msgid ""
"Variables can exist as class members or local to functions. They are created "
"with the ``var`` keyword and may, optionally, be assigned a value upon "
"initialization."
msgstr ""
"变量可以作为类成员存在，也可以作为函数的局部变量存在，用 ``var`` 关键字创建，"
"可以在初始化时指定一个值。"

msgid ""
"Variables can optionally have a type specification. When a type is "
"specified, the variable will be forced to have always that same type, and "
"trying to assign an incompatible value will raise an error."
msgstr ""
"变量可进行类型指定。指定类型时，将强制该变量始终容纳与被指定类型相同类型的数"
"据。试图分配与该类型不兼容的值将触发报错。"

msgid ""
"Types are specified in the variable declaration using a ``:`` (colon) symbol "
"after the variable name, followed by the type."
msgstr "在变量声明中，在变量名后面使用 ``:``\\ （冒号）+ 类型名 来指定类型。"

msgid ""
"If the variable is initialized within the declaration, the type can be "
"inferred, so it's possible to omit the type name::"
msgstr ""
"如果在声明中初始化变量，则可以推断变量类型，在此情况下可省略类型名称： ::"

msgid ""
"Type inference is only possible if the assigned value has a defined type, "
"otherwise it will raise an error."
msgstr "类型推断只有在指定的值具有定义的类型时才能通过检查，否则将触发报错。"

msgid "Valid types are:"
msgstr "有效的类型有："

msgid "Built-in types (Array, Vector2, int, String, etc.)."
msgstr "内置类型（如 Array 、 Vector2、 int、 String 等）。"

msgid "Engine classes (Node, Resource, Reference, etc.)."
msgstr "引擎自带类型（如 Node 、 Resource 、 Reference 等）。"

msgid ""
"Constant names if they contain a script resource (``MyScript`` if you "
"declared ``const MyScript = preload(\"res://my_script.gd\")``)."
msgstr ""
"包含脚本资源的常量名（如 ``MyScript`` ，前提是声明了 ``const MyScript = "
"preload(\"res://my_script.gd\")`` ）。"

msgid ""
"Other classes in the same script, respecting scope (``InnerClass."
"NestedClass`` if you declared ``class NestedClass`` inside the ``class "
"InnerClass`` in the same scope)."
msgstr ""
"在同一个脚本中的其他内部类，此时需要注意作用域（比如：在相同作用域内，在 "
"``class InnerClass`` 中声明 ``class NestedClass`` 则会得到 ``InnerClass."
"NestedClass`` ）。"

msgid "Script classes declared with the ``class_name`` keyword."
msgstr "通过 ``class_name`` 关键字声明的脚本类。"

msgid "Autoloads registered as singletons."
msgstr "自动加载的节点——单例节点。"

msgid ""
"While ``Variant`` is a valid type specification, it's not an actual type. It "
"only means there's no set type and is equivalent to not having a static type "
"at all. Therefore, inference is not allowed by default for ``Variant``, "
"since it's likely a mistake."
msgstr ""
"虽然 ``Variant`` 类型被引擎视作有效类型，但其并不是一个确切的类型，只是一"
"个“没有固定类型”的代名词。使用 ``Variant`` 类型很有可能会导致报错，因此引擎默"
"认不会对该类型进行推断。"

msgid ""
"You can turn off this check, or make it only a warning, by changing it in "
"the project settings. See :ref:`doc_gdscript_warning_system` for details."
msgstr ""
"你可以在项目设置中将该检查关闭，或将其设为警告。详见 :ref:"
"`doc_gdscript_warning_system`\\。"

#, fuzzy
msgid "Initialization order"
msgstr "最小连接示例："

#, fuzzy
msgid "Member variables are initialized in the following order:"
msgstr "创建一个 Node 节点并附加下面的脚本："

msgid ""
"Depending on the variable's static type, the variable is either ``null`` "
"(untyped variables and objects) or has a default value of the type (``0`` "
"for ``int``, ``false`` for ``bool``, etc.)."
msgstr ""

msgid ""
"The specified values are assigned in the order of the variables in the "
"script, from top to bottom. - *(Only for ``Node``-derived classes)* If the "
"``@onready`` annotation is applied to a variable, its initialization is "
"deferred to step 5."
msgstr ""

#, fuzzy
msgid "If defined, the ``_init()`` method is called."
msgstr "必须定义 ``_init()`` 方法，设置控件节点的结构。"

msgid ""
"When instantiating scenes and resources, the exported values are assigned."
msgstr ""

msgid ""
"*(Only for ``Node``-derived classes)* ``@onready`` variables are initialized."
msgstr ""

msgid ""
"*(Only for ``Node``-derived classes)* If defined, the ``_ready()`` method is "
"called."
msgstr ""

msgid ""
"You can specify a complex expression as a variable initializer, including "
"function calls. Make sure the variables are initialized in the correct "
"order, otherwise your values may be overwritten. For example::"
msgstr ""

#, fuzzy
msgid "Will print::"
msgstr "这将打印:"

msgid ""
"To fix this, move the ``_data`` variable definition above the ``a`` "
"definition or remove the empty dictionary assignment (``= {}``)."
msgstr ""

msgid "Static variables"
msgstr "静态成员变量"

msgid "A class member variable can be declared static::"
msgstr "成员变量可以声明为静态成员变量： ::"

msgid ""
"Static variables belong to the class, not instances. This means that static "
"variables share values between multiple instances, unlike regular member "
"variables."
msgstr ""
"静态成员变量直属于类而非类的实例，即静态成员变量可以在多个类实例之间共享数"
"据，这一点与一般的成员变量有所区别。"

msgid ""
"From inside a class, you can access static variables from any function, both "
"static and non-static. From outside the class, you can access static "
"variables using the class or an instance (the second is not recommended as "
"it is less readable)."
msgstr ""
"在类内，可以在任何函数中访问静态成员变量和非静态变量；而在类外，则可以通过引"
"用类名或类的实例来访问静态成员变量（不推荐“类外”情况下的第二种使用方法，会导"
"致可读性有所下降）。"

msgid ""
"The ``@export`` and ``@onready`` annotations cannot be applied to a static "
"variable. Local variables cannot be static."
msgstr ""
"``@export`` 注解和 ``@onready`` 注解不能修饰静态成员变量。局部变量不能声明为"
"静态局部变量。"

msgid ""
"The following example defines a ``Person`` class with a static variable "
"named ``max_id``. We increment the ``max_id`` in the ``_init()`` function. "
"This makes it easy to keep track of the number of ``Person`` instances in "
"our game."
msgstr ""
"下例中，我们定义了一个 ``Person`` 类，声明了一个静态成员变量 ``max_id`` 。在"
"游戏中，我们可以增加 ``max_id`` 这个静态成员变量来让我们更容易追踪游戏中 "
"``Person`` 实例的数量。"

msgid ""
"In this code, we create two instances of our ``Person`` class and check that "
"the class and every instance have the same ``max_id`` value, because the "
"variable is static and accessible to every instance."
msgstr ""
"下面我们创建两个 ``Person`` 类的实例，会发现类和实例具有相同的 ``max_id`` "
"值，这是因为该成员变量是静态成员变量，能够在每个实例中访问。"

msgid "Static variables can have type hints, setters and getters::"
msgstr "静态成员变量可以指定类型，设置 setter 函数和 getter 函数： ::"

msgid "A base class static variable can also be accessed via a child class::"
msgstr "父类的静态成员变量也可以在子类中访问： ::"

msgid "``@static_unload`` annotation"
msgstr "``@static_unload`` 注解"

msgid ""
"Since GDScript classes are resources, having static variables in a script "
"prevents it from being unloaded even if there are no more instances of that "
"class and no other references left. This can be important if static "
"variables store large amounts of data or hold references to other project "
"resources, such as scenes. You should clean up this data manually, or use "
"the :ref:`@static_unload <class_@GDScript_annotation_@static_unload>` "
"annotation if static variables don't store important data and can be reset."
msgstr ""
"GDScript的类均为资源，静态成员变量会阻止脚本卸载，即便该脚本所对应的类的实例"
"及对其引用并不存在，静态成员变量依旧会阻止脚本卸载。在静态成员变量存储海量数"
"据，还含有对其他对象的引用（比如场景）的情况下，更需要引起格外重视。你可以手"
"动清理掉这些数据，亦或是使用 :ref:`@static_unload "
"<class_@GDScript_annotation_@static_unload>` 注解，让静态成员变量在不存储重要"
"数据时得到重置。"

msgid ""
"Currently, due to a bug, scripts are never freed, even if ``@static_unload`` "
"annotation is used."
msgstr ""
"目前由于某个漏洞导致含静态成员变量的脚本实例即使使用了 ``@static_unload`` 注"
"解也无法被清除的问题。"

msgid ""
"Note that ``@static_unload`` applies to the entire script (including inner "
"classes) and must be placed at the top of the script, before ``class_name`` "
"and ``extends``::"
msgstr ""
"注意： ``@static_unload`` 注解修饰整个脚本（包括内部类），需置于脚本最开头，"
"且位于 ``class_name`` 和 ``extends`` 关键字之前： ::"

msgid "See also `Static functions`_ and `Static constructor`_."
msgstr "亦可见 `Static functions`_ 和 `Static constructor`_ 。"

msgid "Casting"
msgstr "类型转换"

msgid ""
"Values assigned to typed variables must have a compatible type. If it's "
"needed to coerce a value to be of a certain type, in particular for object "
"types, you can use the casting operator ``as``."
msgstr ""
"赋予给指定了类型的变量的值必须具有与其类型相兼容的类型。若需要将值强制转换为"
"特定类型，特别是对于对象类型而言要进行转型，则可以使用强制转型运算符 "
"``as``\\。"

msgid ""
"Casting between object types results in the same object if the value is of "
"the same type or a subtype of the cast type."
msgstr ""
"如果值是对象类型，且为与目标类型相同的类型，亦或为目标类型的子类型，则进行转"
"型后会得到同一个对象。"

msgid ""
"If the value is not a subtype, the casting operation will result in a "
"``null`` value."
msgstr "如果该值的类型不是目标类型的子类型，则强制转型操作将产生 ``null`` 值。"

msgid ""
"For built-in types, they will be forcibly converted if possible, otherwise "
"the engine will raise an error."
msgstr "对于内置类型，如果允许，则将对其进行强制转型，否则将触发报错。"

msgid ""
"Casting is also useful to have better type-safe variables when interacting "
"with the scene tree::"
msgstr "与场景树进行交互时，强制转型对于获取节点也更加类型安全，十分有用： ::"

msgid "Constants"
msgstr "常量"

msgid ""
"Constants are values you cannot change when the game is running. Their value "
"must be known at compile-time. Using the ``const`` keyword allows you to "
"give a constant value a name. Trying to assign a value to a constant after "
"it's declared will give you an error."
msgstr ""
"常量是游戏运行时不可更改的量，其值在编译时必须已知，可使用 ``const`` 关键字为"
"常量值赋予名称。尝试为常量重新赋值将会触发报错。"

msgid "We recommend using constants whenever a value is not meant to change."
msgstr "建议使用常量来储存不应更改的值。"

msgid ""
"Although the type of constants is inferred from the assigned value, it's "
"also possible to add explicit type specification::"
msgstr ""
"常量的类型虽然可以从赋予的值中推断出来，但也可以通过显式添加类型来指定： ::"

msgid "Assigning a value of an incompatible type will raise an error."
msgstr "赋予与指定的类型不相容的值将触发报错。"

msgid ""
"You can also create constants inside a function, which is useful to name "
"local magic values."
msgstr "也可以在函数内使用常量来声明一些局部魔法值。"

msgid ""
"Since objects, arrays and dictionaries are passed by reference, constants "
"are \"flat\". This means that if you declare a constant array or dictionary, "
"it can still be modified afterwards. They can't be reassigned with another "
"value though."
msgstr ""
"由于数组和字典是通过引用进行传递的，因此常量数组、字典是“浅引用”。也就是说，"
"如果你声明了一个常量数组或常量字典，那么你依然可以增删该数组或该字典内部元"
"素，但你不能给该常量重新赋予新的数组或字典。"

msgid "Enums"
msgstr "枚举"

msgid ""
"Enums are basically a shorthand for constants, and are pretty useful if you "
"want to assign consecutive integers to some constant."
msgstr "枚举基本上是一组常量的浓缩，为某些常量连续分配整数时非常有用。"

msgid ""
"If you pass a name to the enum, it will put all the keys inside a constant :"
"ref:`Dictionary <class_Dictionary>` of that name. This means all constant "
"methods of a dictionary can also be used with a named enum."
msgstr ""
"如果将名称传递给枚举，则该枚举将会把所有键纳入该名称的 :ref:`Dictionary "
"<class_Dictionary>` 中。也就是说，字典中的所有常方法均可用于具名枚举当中。"

msgid ""
"Keys in a named enum are not registered as global constants. They should be "
"accessed prefixed by the enum's name (``Name.KEY``)."
msgstr ""
"从 Godot 3.1 开始，不会再将具名枚举的键注册为全局常量，此后，应在枚举常量前缀"
"以枚举名的形式来访问枚举内的枚举常量（ ``Name.KEY`` ）；见后面的例子。"

msgid "Functions"
msgstr "函数"

msgid ""
"Functions always belong to a `class <Classes_>`_. The scope priority for "
"variable look-up is: local → class member → global. The ``self`` variable is "
"always available and is provided as an option for accessing class members, "
"but is not always required (and should *not* be sent as the function's first "
"argument, unlike Python)."
msgstr ""
"函数始终属于 `类 <Classes_>`_ 。查找变量时，函数作用域的查找顺序是：局部 → 类"
"成员 → 全局。引擎始终允许用 ``self`` 作为访问本类及本类成员的关键字，但该关键"
"字在一般情况下并无添加的必要（与 Python 不同, *不* 应将其作为类内函数首选的参"
"数传递）。"

msgid ""
"A function can ``return`` at any point. The default return value is ``null``."
msgstr "函数可以在任何时候用 ``return`` 返回值，默认的返回值为 ``null`` 。"

msgid ""
"If a function contains only one line of code, it can be written on one line::"
msgstr "若函数体只含一行语句，则可以将函数及其函数体缩在同一行语句内编写： ::"

msgid ""
"Functions can also have type specification for the arguments and for the "
"return value. Types for arguments can be added in a similar way to "
"variables::"
msgstr ""
"函数也可带有参数，也可声明返回值的类型。可以使用与声明变量类似的方式添加参数"
"的类型： ::"

msgid ""
"If a function argument has a default value, it's possible to infer the type::"
msgstr "如果函数参数具有默认值，则可以对该参数的类型进行推断： ::"

msgid ""
"The return type of the function can be specified after the arguments list "
"using the arrow token (``->``)::"
msgstr ""
"可以在参数列表之后使用箭头标记（\\ ``->``\\ ）来指定函数的返回值类型： ::"

msgid ""
"Functions that have a return type **must** return a proper value. Setting "
"the type as ``void`` means the function doesn't return anything. Void "
"functions can return early with the ``return`` keyword, but they can't "
"return any value."
msgstr ""
"有返回类型的函数 **必须** 返回与返回值类型相匹配的值。若将返回值类型设置为 "
"``void`` ，则该函数不返回任何内容。无返回值函数可以使用 ``return`` 关键字提前"
"返回，但不能返回任何值。"

msgid ""
"Non-void functions must **always** return a value, so if your code has "
"branching statements (such as an ``if``/``else`` construct), all the "
"possible paths must have a return. E.g., if you have a ``return`` inside an "
"``if`` block but not after it, the editor will raise an error because if the "
"block is not executed, the function won't have a valid value to return."
msgstr ""
"非 void 函数 **必须** 返回一个值，如果你的代码具有分支语句（例如 ``if``/"
"``else`` 构造），则所有可能的路径都必须有返回值。例如，如果在 ``if`` 块内有一"
"个 ``return``\\，但在其后没有，则编辑器将抛出一个错误，因为如果该块未执行，则"
"该函数将没有有效的值返回。"

msgid "Referencing functions"
msgstr "引用函数"

msgid ""
"Functions are first-class items in terms of the :ref:`Callable "
"<class_Callable>` object. Referencing a function by name without calling it "
"will automatically generate the proper callable. This can be used to pass "
"functions as arguments."
msgstr ""
"就 :ref:`Callable <class_Callable>` 对象而言，函数是其第一类对象。通过函数名"
"称来引用一个函数，会自动生成指向该函数的可调用体，而非调用该函数。这种操作可"
"用于将函数作为参数传递。"

msgid ""
"Callables **must** be called with the ``call`` method. You cannot use the "
"``()`` operator directly. This behavior is implemented to avoid performance "
"issues on direct function calls."
msgstr ""
"可调用体 **必须** 使用 ``call`` 方法进行调用，不能直接使用 ``()`` 运算符，以"
"避免直接调用可调用体所指向的函数而造成的性能问题。"

msgid "Lambda functions"
msgstr "Lambda 函数（匿名函数）"

msgid ""
"Lambda functions allow you to declare functions that do not belong to a "
"class. Instead a :ref:`Callable <class_Callable>` object is created and "
"assigned to a variable directly. This can be useful to create Callables to "
"pass around without polluting the class scope."
msgstr ""
"Lambda 函数允许声明不属于类的函数，直接创建 :ref:`Callable <class_Callable>` "
"对象并将其赋值给变量。该操作对于创建可传递的可调用体而不污染该类的作用范围非"
"常有用。"

msgid "Lambda functions can be named for debugging purposes::"
msgstr "Lambda 函数可用于代码调试： ::"

msgid ""
"Note that if you want to return a value from a lambda, an explicit "
"``return`` is required (you can't omit ``return``)::"
msgstr ""

msgid ""
"Lambda functions capture the local environment. Local variables are passed "
"by value, so they won't be updated in the lambda if changed in the local "
"function::"
msgstr ""
"Lambda 函数的函数体会自动捕获局部函数所在的函数体作用域，而局部变量是按值传递"
"的，因此，这些局部变量即便在其所在的函数体作用域内发生更改，也不会影响其在 "
"Lambda 函数中的效果： ::"

msgid ""
"The values of the outer scope behave like constants. Therefore, if you "
"declare an array or dictionary, it can still be modified afterwards."
msgstr ""
"作用在 Lambda 函数体之外的变量值对该 Lambda 函数而言就像常量一样，因此，如果"
"你给变量声明了一个数组类型或字典类型的值，则在 Lambda 函数的声明后仍可修改这"
"些值。"

msgid "Static functions"
msgstr "静态函数"

msgid ""
"A function can be declared static. When a function is static, it has no "
"access to the instance member variables or ``self``. A static function has "
"access to static variables. Also static functions are useful to make "
"libraries of helper functions::"
msgstr ""
"函数可以声明为静态函数。静态函数不能访问实例成员变量，也不能使用 "
"``self``\\ ，非常适用于创建辅助函数库： ::"

msgid "Lambdas cannot be declared static."
msgstr "Lambda 函数不可声明为静态函数。"

msgid "See also `Static variables`_ and `Static constructor`_."
msgstr "见 `Static variables`_ 和 `Static constructor`_ 。"

msgid "Statements and control flow"
msgstr "语句与流程控制"

msgid ""
"Statements are standard and can be assignments, function calls, control flow "
"structures, etc (see below). ``;`` as a statement separator is entirely "
"optional."
msgstr ""
"标准语句可以是赋值、函数调用以及流程控制结构等（见下方）。 ``;`` 为语句分隔"
"符，在使用时完全可选。"

msgid "Expressions"
msgstr "表达式"

msgid ""
"Expressions are sequences of operators and their operands in orderly "
"fashion. An expression by itself can be a statement too, though only calls "
"are reasonable to use as statements since other expressions don't have side "
"effects."
msgstr ""
"表达式是运算符和操作数的有序排列，尽管只有调用时才可以用作语句使用，只要其他"
"表达式没有副作用，其自身也可作为一条语句使用。"

msgid ""
"Expressions return values that can be assigned to valid targets. Operands to "
"some operator can be another expression. An assignment is not an expression "
"and thus does not return any value."
msgstr ""
"表达式返回的数值可赋值给有效目标，而某些运算符的操作数也可以变成一条表达式。"
"赋值语句因无返回值而不能作为表达式使用。"

msgid "Here are some examples of expressions::"
msgstr "以下是一些表达式的示例::"

msgid ""
"Identifiers, attributes, and subscripts are valid assignment targets. Other "
"expressions cannot be on the left side of an assignment."
msgstr ""
"标识符、对象属性和下标均可视为表达式有效的赋值目标，而在赋值语句中，表达式不"
"能位于赋值等号左侧。"

msgid "if/else/elif"
msgstr "if/else/elif"

msgid ""
"Simple conditions are created by using the ``if``/``else``/``elif`` syntax. "
"Parenthesis around conditions are allowed, but not required. Given the "
"nature of the tab-based indentation, ``elif`` can be used instead of "
"``else``/``if`` to maintain a level of indentation."
msgstr ""
"条件句通过使用 ``if``/``else``/``elif`` 语法创建。条件中的括号可写可不写。考"
"虑到基于制表符缩进的性质，可以使用 ``elif`` 而非 ``else``/``if`` 来保持缩进级"
"别相同。"

msgid "Short statements can be written on the same line as the condition::"
msgstr "短的语句可以与条件句写在同一行内： ::"

msgid ""
"Sometimes, you might want to assign a different initial value based on a "
"boolean expression. In this case, ternary-if expressions come in handy::"
msgstr ""
"有时你可能希望基于布尔表达式来赋予不同的初始值，为此，三元表达式将派上用"
"场： ::"

msgid ""
"Ternary-if expressions can be nested to handle more than 2 cases. When "
"nesting ternary-if expressions, it is recommended to wrap the complete "
"expression over multiple lines to preserve readability::"
msgstr ""
"可以通过嵌套三元 if 表达式来处理的超过两种可能性的情况。嵌套时，推荐把三元 "
"if 表达式拆分为多行进行表达以保证代码的可读性： ::"

msgid ""
"You may also wish to check if a value is contained within something. You can "
"use an ``if`` statement combined with the ``in`` operator to accomplish "
"this::"
msgstr ""
"你可能还想要检查某个值是否包含在某些容器之中，可以通过 ``if`` 语句与 ``in`` "
"操作符组合来实现： ::"

msgid ""
"Simple loops are created by using ``while`` syntax. Loops can be broken "
"using ``break`` or continued using ``continue`` (which skips to the next "
"iteration of the loop without executing any further code in the current "
"iteration):"
msgstr ""
"一般的循环通过 ``while`` 语法创建，可以使用 ``break`` 来跳出整个循环，或者使"
"用 ``continue`` 来跳出当前批次的循环并进入下一轮的循环当中（但会将该关键字下"
"方所有在该循环体内的语句全部跳过）："

msgid ""
"To iterate through a range, such as an array or table, a *for* loop is used. "
"When iterating over an array, the current array element is stored in the "
"loop variable. When iterating over a dictionary, the *key* is stored in the "
"loop variable."
msgstr ""
"要迭代一个范围，例如数组或表，请使用 *for* 循环。迭代数组时，当前数组元素被存"
"储在循环变量中。迭代字典时，*键* 被存储在循环变量中。"

msgid ""
"If you want to assign values on an array as it is being iterated through, it "
"is best to use ``for i in array.size()``."
msgstr ""
"若需要在数组迭代时对数组进行赋值操作，则推荐使用 ``for i in array.size()`` 来"
"进行该操作。"

msgid ""
"The loop variable is local to the for-loop and assigning to it will not "
"change the value on the array. Objects passed by reference (such as nodes) "
"can still be manipulated by calling methods on the loop variable."
msgstr ""
"循环变量只属于该循环，为其赋值并不会更改数组的值。如果循环变量是通过引用传递"
"的对象（如节点），则仍可通过调用其方法来操作所指向的对象。"

msgid ""
"A ``match`` statement is used to branch execution of a program. It's the "
"equivalent of the ``switch`` statement found in many other languages, but "
"offers some additional features."
msgstr ""
"``match`` 语句用于分支流程的执行，相当于在许多其他语言中出现的 ``switch`` 语"
"句，但提供了一些附加功能。"

msgid ""
"``match`` is more type strict than the ``==`` operator. For example ``1`` "
"will **not** match ``1.0``. The only exception is ``String`` vs "
"``StringName`` matching: for example, the String ``\"hello\"`` is considered "
"equal to the StringName ``&\"hello\"``."
msgstr ""
"``match`` 对类型的要求比 ``==`` 运算符更严格。例如 ``1`` 和 ``1.0`` 是\\ **不"
"匹配**\\ 的。唯一的例外是 ``String`` 和 ``StringName`` 的匹配：例如会认为字符"
"串 ``\"hello\"`` 和 StringName ``&\"hello\"`` 相等。"

msgid "Basic syntax"
msgstr "基本语法"

msgid "Crash-course for people who are familiar with switch statements"
msgstr "给熟悉 switch 语句的人提供的速成课程"

msgid "Replace ``switch`` with ``match``."
msgstr "将 ``switch`` 替换为 ``match``\\ 。"

msgid "Remove ``case``."
msgstr "删除 ``case``\\ 。"

msgid "Remove any ``break``\\ s."
msgstr "删除 ``break``\\ 。"

msgid "Change ``default`` to a single underscore."
msgstr "将 ``default`` 替换为单个下划线。"

msgid "Control flow"
msgstr "流程控制"

msgid ""
"The patterns are matched from top to bottom. If a pattern matches, the first "
"corresponding block will be executed. After that, the execution continues "
"below the ``match`` statement."
msgstr ""
"将值按从上到下的顺序为每个分支条件进行匹配，如果有一个分支条件匹配，则会执行"
"第一个与之相应的分支条件，之后继续执行 ``match`` 语句下不含该分支条件的其他分"
"支。"

msgid ""
"The special ``continue`` behavior in ``match`` supported in 3.x was removed "
"in Godot 4.0."
msgstr ""
"3.x 版本中， ``continue`` 在 ``match`` 语句中起着特殊作用，而在4.0版本中则移"
"除了这一特殊作用。"

msgid "The following pattern types are available:"
msgstr "可以使用以下模式类型："

msgid "Literal pattern"
msgstr "字面量模式"

msgid "Matches a `literal <Literals_>`_::"
msgstr "匹配\\ `字面量 <Literals_>`_\\ ： ::"

msgid "Expression pattern"
msgstr "表达式模式"

msgid ""
"Matches a constant expression, an identifier, or an attribute access (``A."
"B``)::"
msgstr "匹配表达式常量、标识符、或属性访问（\\ ``A.B``\\ ）： ::"

msgid "Wildcard pattern"
msgstr "通配符模式"

msgid "This pattern matches everything. It's written as a single underscore."
msgstr "匹配所有内容，用一个下划线来表示通配内容。"

msgid ""
"It can be used as the equivalent of the ``default`` in a ``switch`` "
"statement in other languages::"
msgstr "可以与其他语言的 ``switch`` 语句中的 ``default`` 等效： ::"

msgid "Binding pattern"
msgstr "绑定模式"

msgid ""
"A binding pattern introduces a new variable. Like the wildcard pattern, it "
"matches everything - and also gives that value a name. It's especially "
"useful in array and dictionary patterns::"
msgstr ""
"绑定模式引入一个新的变量，与通配符模式类似匹配所有通配内容，并为该通配值提供"
"一个名称，在数组和字典模式中特别有用： ::"

msgid "Array pattern"
msgstr "数组模式"

msgid ""
"Matches an array. Every single element of the array pattern is a pattern "
"itself, so you can nest them."
msgstr ""
"匹配一个数组，数组模式的每个元素本身都可以是一个模式，因此可以对其进行嵌套。"

msgid ""
"The length of the array is tested first, it has to be the same size as the "
"pattern, otherwise the pattern doesn't match."
msgstr "首先检测数组的长度，其长度必须与语句块条件的数组长度相同，否则不匹配。"

msgid ""
"**Open-ended array**: An array can be bigger than the pattern by making the "
"last subpattern ``..``."
msgstr ""
"**开放式数组** : 通过使最后一个子模式为 ``..`` , 可以使被比较数组的长度超过语"
"句块条件的数组的长度."

msgid "Every subpattern has to be comma-separated."
msgstr "每个子模式都必须用逗号分隔开来。"

msgid "Dictionary pattern"
msgstr "字典模式"

msgid ""
"Works in the same way as the array pattern. Every key has to be a constant "
"pattern."
msgstr "作用方式同数组模式，且每个键必须为一个常量模式。"

msgid ""
"The size of the dictionary is tested first, it has to be the same size as "
"the pattern, otherwise the pattern doesn't match."
msgstr "首先检测字典的大小，其大小必须与语句块条件的字典大小相同，否则不匹配。"

msgid ""
"**Open-ended dictionary**: A dictionary can be bigger than the pattern by "
"making the last subpattern ``..``."
msgstr ""
"**开放式字典** : 通过将最后一个子字样改为 ``..`` ，使被比较字典可以比语句块条"
"件的字典更大。"

msgid "Every subpattern has to be comma separated."
msgstr "每个子模式都必须用逗号分隔开。"

msgid ""
"If you don't specify a value, then only the existence of the key is checked."
msgstr "若不指定键的值，则仅检查键的存在。"

msgid "A value pattern is separated from the key pattern with a ``:``."
msgstr "值模式与键模式之间以 ``:`` 分隔。"

msgid "Multiple patterns"
msgstr "多重模式"

msgid ""
"You can also specify multiple patterns separated by a comma. These patterns "
"aren't allowed to have any bindings in them."
msgstr ""
"你还可以用逗号来分隔同一语句块条件里的多个模式，这些模式不允许包含任何绑定。"

msgid "Pattern guards"
msgstr "模式保护"

msgid ""
"Only one branch can be executed per ``match``. Once a branch is chosen, the "
"rest are not checked. If you want to use the same pattern for multiple "
"branches or to prevent choosing a branch with too general pattern, you can "
"specify a guard expression after the list of patterns with the ``when`` "
"keyword::"
msgstr ""
"对含相同分支条件的多个分支而言，每个 ``match`` 结构只能执行其中一条分支，一旦"
"有分支通过匹配，那么剩下的相同条件的分支都将不再执行。如果需要执行多条含相同"
"条件的分支，而避免只执行其中一条的话，可以使用模式保护语句，用 ``when`` 关键"
"字引导： ::"

msgid ""
"If there is no matching pattern for the current branch, the guard expression "
"is **not** evaluated and the patterns of the next branch are checked."
msgstr ""
"若在当前同条件多分支句中找不到匹配的模式，则模式保护语法不会对该同条件多分支"
"句起效，而是转到下一个（同条件多）分支句进行模式匹配。"

msgid "If a matching pattern is found, the guard expression is evaluated."
msgstr ""
"若当前同条件多分支句的模式与给定值匹配，则执行多分支句里的模式保护语句。"

msgid ""
"If it's true, then the body of the branch is executed and ``match`` ends."
msgstr "若保护条件结果为真，则执行该分支下的语句并跳出 ``match`` 结构的执行。"

msgid "If it's false, then the patterns of the next branch are checked."
msgstr "若保护条件不为真，则对下一个同条件分支句的模式进行检测。"

msgid "Classes"
msgstr "类"

msgid ""
"By default, all script files are unnamed classes. In this case, you can only "
"reference them using the file's path, using either a relative or an absolute "
"path. For example, if you name a script file ``character.gd``::"
msgstr ""
"默认情况下，所有脚本文件都是未命名的类，这时只能使用文件的路径来引用这些无名"
"类（相对路径或绝对路径）。如果你将脚本文件命名为 ``character.gd``\\ 的话： ::"

msgid "Registering named classes"
msgstr "注册具名类"

msgid ""
"You can give your class a name to register it as a new type in Godot's "
"editor. For that, you use the ``class_name`` keyword. You can optionally use "
"the ``@icon`` annotation with a path to an image, to use it as an icon. Your "
"class will then appear with its new icon in the editor::"
msgstr ""
"你也可以使用 ``class_name`` 关键字来为你的类起名，将其注册为 Godot 编辑器中的"
"新类型。你还可以配合使用 ``@icon`` 注解，向其括号中输入图片的路径，来将该图片"
"作为该类的图标使用。这样，你的类就会和新的图标一起显示在编辑器中： ::"

msgid ""
"SVG images that are used as custom node icons should have the **Editor > "
"Scale With Editor Scale** and **Editor > Convert Icons With Editor Theme** :"
"ref:`import options <doc_importing_images_editor_import_options>` enabled. "
"This allows icons to follow the editor's scale and theming settings if the "
"icons are designed with the same color palette as Godot's own icons."
msgstr ""

msgid "Here's a class file example:"
msgstr "这是一个类文件示例："

msgid ""
"If you want to use ``extends`` too, you can keep both on the same line::"
msgstr ""
"如果想要在声明类的同时让这个类继承自某个类，则可以将这两个关键字写在同一行"
"内： ::"

msgid ""
"Godot initializes non-static variables every time you create an instance, "
"and this includes arrays and dictionaries. This is in the spirit of thread "
"safety, since scripts can be initialized in separate threads without the "
"user knowing."
msgstr ""
"由于脚本可以在用户不知情的情况下在单独的线程中初始化，出于线程安全考虑，"
"Godot 在每次创建实例时，引擎都会初始化非静态变量，其中就包括数组和字典。"

msgid "Inheritance"
msgstr "继承"

msgid "A class (stored as a file) can inherit from:"
msgstr "类（以文件形式保存）可以继承自："

msgid "A global class."
msgstr "全局类。"

msgid "Another class file."
msgstr "另一个类文件。"

msgid "An inner class inside another class file."
msgstr "另一个类文件中的内部类。"

msgid "Multiple inheritance is not allowed."
msgstr "不允许多重继承。"

msgid "Inheritance uses the ``extends`` keyword::"
msgstr "继承使用 ``extends`` 关键字： ::"

msgid ""
"If inheritance is not explicitly defined, the class will default to "
"inheriting :ref:`class_RefCounted`."
msgstr "如果没有显式指定继承的类，则默认该类继承自 :ref:`class_RefCounted`。"

msgid ""
"To check if a given instance inherits from a given class, the ``is`` keyword "
"can be used::"
msgstr "要检查给定的实例是否继承自给定的类，可以使用 ``is`` 关键字： ::"

msgid ""
"To call a function in a *super class* (i.e. one ``extend``-ed in your "
"current class), use the ``super`` keyword::"
msgstr ""
"要调用 *基类* （即当前类的 ``extends`` 关键字后的类）中的函数，请使用 "
"``super`` 关键字： ::"

msgid ""
"This is especially useful because functions in extending classes replace "
"functions with the same name in their super classes. If you still want to "
"call them, you can use ``super``::"
msgstr ""
"由于子类中的函数会替换基类中同名的函数，因此若仍然想调用在基类中的该函数，则"
"可以使用 ``super`` 关键字： ::"

msgid ""
"If you need to call a different function from the super class, you can "
"specify the function name with the attribute operator::"
msgstr ""
"若需要调用父类方法，可在 ``super`` 关键字后用英文句点连接父节点方法名（带括"
"号）： ::"

msgid ""
"One of the common misconceptions is trying to override *non-virtual* engine "
"methods such as ``get_class()``, ``queue_free()``, etc. This is not "
"supported for technical reasons."
msgstr ""
"目前普遍有人想试图覆盖引擎内置的 *非虚* 方法，如 ``get_class()`` 、 "
"``queue_free()`` 等。出于技术性原因，暂不支持这种操作，理由如下。"

msgid ""
"In Godot 3, you can *shadow* engine methods in GDScript, and it will work if "
"you call this method in GDScript. However, the engine will **not** execute "
"your code if the method is called inside the engine on some event."
msgstr ""
"Godot 3 里的 GDScript 允许你 *隐藏* 引擎方法，而这些被隐藏后重新定义的方法却"
"可以被其他 GDScript 脚本所调用，倘若该方法在引擎内部执行，那么引擎并不会执行"
"你所重新定义的方法。"

msgid ""
"In Godot 4, even shadowing may not always work, as GDScript optimizes native "
"method calls. Therefore, we added the ``NATIVE_METHOD_OVERRIDE`` warning, "
"which is treated as an error by default. We strongly advise against "
"disabling or ignoring the warning."
msgstr ""
"Godot 4 对 GDScript 内置方法调用机制进行了优化，隐藏方法再重新定义一个同名方"
"法这个招数就再也不管用了。鉴于此，我们增添了 ``NATIVE_METHOD_OVERRIDE`` 警告"
"选项，默认设置为一种抛错。我们强烈建议保持该选项开启，不要作为警告而忽略之。"

msgid ""
"Note that this does not apply to virtual methods such as ``_ready()``, "
"``_process()`` and others (marked with the ``virtual`` qualifier in the "
"documentation and the names start with an underscore). These methods are "
"specifically for customizing engine behavior and can be overridden in "
"GDScript. Signals and notifications can also be useful for these purposes."
msgstr ""
"不过需要注意：对于虚方法，比如 ``_ready()``, ``_process()`` 以及其他虚方法"
"（在文档中被标为 ``virtual`` 且以下划线开头的内置方法），则会进行覆盖操作。虚"
"方法是专门用于自定义引擎行为的方法，可被 GDScript 所覆盖。信号、通知也可用于"
"自定义引擎行为。"

msgid "Class constructor"
msgstr "类的构造函数"

msgid ""
"The class constructor, called on class instantiation, is named ``_init``. If "
"you want to call the base class constructor, you can also use the ``super`` "
"syntax. Note that every class has an implicit constructor that it's always "
"called (defining the default values of class variables). ``super`` is used "
"to call the explicit constructor::"
msgstr ""
"类的构造函数在类进行初始化时调用，在 GDScript 中构造函数为虚函数 ``_init`` 。"
"若想要在构造函数中调用父类构造函数，同样可以使用 ``super`` 语法。需要注意：每"
"个类都有一个隐式构造函数，总是由引擎调用，用于定义类变量的默认值，而 "
"``super`` 则用于调用显式构造函数： ::"

msgid "This is better explained through examples. Consider this scenario::"
msgstr "通过示例可以更好地说明这一点。考虑一下这种情况： ::"

msgid "There are a few things to keep in mind here:"
msgstr "这里有几点需要牢记："

msgid ""
"If the inherited class (``state.gd``) defines a ``_init`` constructor that "
"takes arguments (``e`` in this case), then the inheriting class (``idle."
"gd``) *must* define ``_init`` as well and pass appropriate parameters to "
"``_init`` from ``state.gd``."
msgstr ""
"如果被继承的类（\\ ``State.gd``\\ ）定义了一个带有参数（此处的 ``e``\\ ）的 "
"``_init`` 构造函数，那么继承的类（\\ ``Idle.gd``\\ ）也\\ **必须**\\ 定义 "
"``_init`` ，并且要将适当的参数从 ``State.gd`` 传递给 ``_init``\\ 。"

msgid ""
"``idle.gd`` can have a different number of arguments than the base class "
"``state.gd``."
msgstr ""
"``Idle.gd`` 的构造函数的参数数量可以与基类 ``State.gd`` 的构造函数的参数数量"
"有所不同。"

msgid ""
"In the example above, ``e`` passed to the ``state.gd`` constructor is the "
"same ``e`` passed in to ``idle.gd``."
msgstr ""
"在上面的示例中，传递给 ``State.gd`` 构造函数的 ``e`` 与传递给 ``Idle.gd`` 的 "
"``e`` 是相同的。"

msgid ""
"If ``idle.gd``'s ``_init`` constructor takes 0 arguments, it still needs to "
"pass some value to the ``state.gd`` base class, even if it does nothing. "
"This brings us to the fact that you can pass expressions to the base "
"constructor as well, not just variables, e.g.::"
msgstr ""
"如果 ``Idle.gd`` 的 ``_init`` 构造函数接受 0 个参数，该构造函数即使什么也不"
"做，也仍然需要将一些值传递给 ``State.gd`` 父类。当然，我们除了可以给基类构造"
"函数传变量之外，也可以传表达式，例如： ::"

msgid "Static constructor"
msgstr "静态构造函数"

msgid ""
"A static constructor is a static function ``_static_init`` that is called "
"automatically when the class is loaded, after the static variables have been "
"initialized::"
msgstr ""
"静态构造函数用虚函数 ``_static_init`` 表示，该函数会在类被载入时，静态类成员"
"变量初始化后自动调用： ::"

msgid ""
"A static constructor cannot take arguments and must not return any value."
msgstr "静态构造函数不能含有任何参数，不能返回值。"

msgid "Inner classes"
msgstr "内部类"

msgid ""
"A class file can contain inner classes. Inner classes are defined using the "
"``class`` keyword. They are instanced using the ``ClassName.new()`` function."
msgstr ""
"类文件可以包含内部类。内部类使用 ``class`` 关键字定义，用 ``类名.new()`` 函数"
"来进行实例化。"

msgid "Classes as resources"
msgstr "类作为资源"

msgid ""
"Classes stored as files are treated as :ref:`resources <class_GDScript>`. "
"They must be loaded from disk to access them in other classes. This is done "
"using either the ``load`` or ``preload`` functions (see below). Instancing "
"of a loaded class resource is done by calling the ``new`` function on the "
"class object::"
msgstr ""
"存储为文件的类将会视为 :ref:`Resource <class_Resource>`，必须从磁盘加载这些文"
"件之后才能在其他类中访问它们，可以通过调用 ``load`` 或 ``preload`` 函数来完成"
"（后述）。一个加载的类资源通过调用类对象上的 ``new`` 函数来完成实例化： ::"

msgid "Exports"
msgstr "导出"

msgid ""
"Documentation about exports has been moved to :ref:`doc_gdscript_exports`."
msgstr "有关导出的文档已移至 :ref:`doc_gdscript_exports`\\ 。"

msgid "Properties (setters and getters)"
msgstr "属性（setter 函数与 getter 函数）"

msgid ""
"Sometimes, you want a class' member variable to do more than just hold data "
"and actually perform some validation or computation whenever its value "
"changes. It may also be desired to encapsulate its access in some way."
msgstr ""
"有时，你可能不止希望对类成员进行数据存储操作，甚至想要在更改成员值的时候对其"
"进行有效性检查操作或运算操作。你也可能希望以某种方式对该类成员的访问进行封"
"装。"

msgid ""
"For this, GDScript provides a special syntax to define properties using the "
"``set`` and ``get`` keywords after a variable declaration. Then you can "
"define a code block that will be executed when the variable is accessed or "
"assigned."
msgstr ""
"鉴于此， GDScript 提供了一套特别的语法，通过在变量定义后使用 ``set`` 、 "
"``get`` 关键字来对类成员属性的读写进行封装。这样一来，你就可以在 ``set`` "
"（setter 函数）、 ``get`` （getter 函数）语句块里定义代码，在该成员被读写时执"
"行之。"

msgid "Example::"
msgstr "示例（以匿名 setter/getter 函数为例）::"

msgid ""
"Unlike ``setget`` in previous Godot versions, the properties setter and "
"getter are **always** called (except as noted below), even when accessed "
"inside the same class (with or without prefixing with ``self.``). This makes "
"the behavior consistent. If you need direct access to the value, use another "
"variable for direct access and make the property code use that name."
msgstr ""
"与之前的 Godot 版本中的 ``setget`` 不同，即使在同一个类中进行访问（不管有无前"
"缀 ``self.``\\），属性的 setter 和 getter **始终** 会被调用（除非代码下文指"
"出） ，以让 setter 行为一致、getter 行为也一致。如果你需要直接访问该值，请使"
"用另一个变量进行直接访问，并在其属性代码中使用该被访问变量的变量名。"

msgid "Alternative syntax"
msgstr "替代方案（具名 setter/getter 函数）"

msgid ""
"Also there is another notation to use existing class functions if you want "
"to split the code from the variable declaration or you need to reuse the "
"code across multiple properties (but you can't distinguish which property "
"the setter/getter is being called for)::"
msgstr ""
"若想从变量声明中分离 setter/getter 代码，亦或想在多个属性中共享这些代码，则可"
"以借助现有的类函数来完成该操作："

msgid "This can also be done in the same line::"
msgstr "也可以将这个写法缩在同一行内写： ::"

msgid ""
"The setter and getter must use the same notation, mixing styles for the same "
"variable is not allowed."
msgstr ""
"Setter 函数和 Getter 函数在给一个变量定义时必须使用相同的定义格式，不允许混合"
"使用这两种定义格式。"

msgid ""
"You cannot specify type hints for *inline* setters and getters. This is done "
"on purpose to reduce the boilerplate. If the variable is typed, then the "
"setter's argument is automatically of the same type, and the getter's return "
"value must match it. Separated setter/getter functions can have type hints, "
"and the type must match the variable's type or be a wider type."
msgstr ""
"不允许对 *匿名*\\ setter 函数和 getter 函数进行类型指定，以减少代码的重复抄写"
"量。若变量含有指定的类型，则其 setter 函数的参数会自动转换到相同的类型，同时"
"其 getter 函数的返回值类型也必须与该类型相配。具名 setter/getter 函数允许指定"
"类型提示，但这些函数的设值/返回类型必须与该属性的类型或该类型的广义类型相配。"

msgid "When setter/getter is not called"
msgstr "Setter/getter 函数不会被调用的情况"

msgid ""
"When a variable is initialized, the value of the initializer will be written "
"directly to the variable. Including if the ``@onready`` annotation is "
"applied to the variable."
msgstr ""
"变量在进行初始化时，其初始值会直接赋予给该变量，包括 ``@onready`` 注解所修饰"
"的变量也是如此。"

msgid ""
"Using the variable's name to set it inside its own setter or to get it "
"inside its own getter will directly access the underlying member, so it "
"won't generate infinite recursion and saves you from explicitly declaring "
"another variable::"
msgstr ""
"在一个变量的 setter 函数和 getter 函数内访问该变量的变量名，会直接访问该变量"
"所代表的成员属性，不会导致 setter 函数和 getter 函数被无限次迭代调用，同时避"
"免了显式声明另一个变量： ::"

msgid "This also applies to the alternative syntax::"
msgstr "这种情况也同样适用于替代方案::"

msgid ""
"The exception does **not** propagate to other functions called in the setter/"
"getter. For example, the following code **will** cause an infinite "
"recursion::"
msgstr ""
"在匿名 setter/getter 函数中调用具名 setter/getter 函数会导致无限递归调用，如"
"下面的这个情况::"

msgid "Tool mode"
msgstr "工具模式"

msgid ""
"By default, scripts don't run inside the editor and only the exported "
"properties can be changed. In some cases, it is desired that they do run "
"inside the editor (as long as they don't execute game code or manually avoid "
"doing so). For this, the ``@tool`` annotation exists and must be placed at "
"the top of the file::"
msgstr ""
"默认情况下，脚本不会在编辑器内运行，只有更改导出的属性这一操作会在编辑器内运"
"行。在某些情况下，我们确实希望这些代码能在编辑器中运行（只要这些代码不执行游"
"戏逻辑，也可以手动避免之）。为此可以用 ``@tool`` 注解，必须将其写在文件的顶"
"部： ::"

msgid "See :ref:`doc_running_code_in_the_editor` for more information."
msgstr "详情见 :ref:`doc_running_code_in_the_editor`\\ 。"

msgid ""
"Be cautious when freeing nodes with ``queue_free()`` or ``free()`` in a tool "
"script (especially the script's owner itself). As tool scripts run their "
"code in the editor, misusing them may lead to crashing the editor."
msgstr ""
"由于工具脚本是在编辑器中运行代码的，故在工具脚本中使用 ``queue_free()`` 或 "
"``free()`` 释放节点时需要谨慎（尤其是对脚本所有者本身使用的时候更是如此）。对"
"工具脚本滥用释放节点代码可能会导致编辑器崩溃。"

msgid "Memory management"
msgstr "内存管理"

msgid ""
"Godot implements reference counting to free certain instances that are no "
"longer used, instead of a garbage collector, or requiring purely manual "
"management. Any instance of the :ref:`class_RefCounted` class (or any class "
"that inherits it, such as :ref:`class_Resource`) will be freed automatically "
"when no longer in use. For an instance of any class that is not a :ref:"
"`class_RefCounted` (such as :ref:`class_Node` or the base :ref:"
"`class_Object` type), it will remain in memory until it is deleted with "
"``free()`` (or ``queue_free()`` for Nodes)."
msgstr ""
"Godot 通过实现引用计数来释放某些不再使用的实例，而非通过垃圾收集器（GC），或"
"者需要纯手动管理内存释放来实现这一操作。:ref:`class_RefCounted` 类（或继承该"
"类的任何类，例如 :ref:`class_Resource`）的任何实例在不再使用时将自动释放。对"
"于非 :ref:`class_RefCounted` 类（例如 :ref:`class_Node` 或基本 :ref:"
"`class_Object` 类型）的实例，这些实例将保留在内存中，直到使用 ``free()`` （或"
"用于节点的 ``queue_free()``）才会从内存中删除。"

msgid ""
"If a :ref:`class_Node` is deleted via ``free()`` or ``queue_free()``, all of "
"its children will also recursively be deleted."
msgstr ""
"如果通过 ``free()`` 或 ``queue_free()`` 删除 :ref:`class_Node`，则它的所有子"
"节点也将会被递归删除。"

msgid ""
"To avoid reference cycles that can't be freed, a :ref:`class_WeakRef` "
"function is provided for creating weak references, which allow access to the "
"object without preventing a :ref:`class_RefCounted` from freeing. Here is an "
"example:"
msgstr ""
"为了避免造成无法释放的循环引用，Godot 提供了用于创建弱引用的 :ref:"
"`class_WeakRef` 类，可以访问到对象，但是不会阻止 :ref:`class_RefCounted` 的释"
"放。见下例："

msgid ""
"Alternatively, when not using references, the "
"``is_instance_valid(instance)`` can be used to check if an object has been "
"freed."
msgstr ""
"在没有使用引用的情况下，也可以用 ``is_instance_valid(instance)`` 来检查对象是"
"否已被释放。"

msgid "Signals"
msgstr "信号"

msgid ""
"Signals are a tool to emit messages from an object that other objects can "
"react to. To create custom signals for a class, use the ``signal`` keyword."
msgstr ""
"信号是从对象中发出消息的工具，其他对象可以对该信号做出反应。要为一个类创建自"
"定义信号，请使用 ``signal`` 关键字。"

msgid ""
"Signals are a `Callback <https://en.wikipedia.org/wiki/"
"Callback_(computer_programming)>`_ mechanism. They also fill the role of "
"Observers, a common programming pattern. For more information, read the "
"`Observer tutorial <https://gameprogrammingpatterns.com/observer.html>`_ in "
"the Game Programming Patterns ebook."
msgstr ""
"信号是一种\\ `回调 <https://zh.wikipedia.org/zh-cn/"
"%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0>`_\\ 机制，同时还充当观察者的角色，这是"
"一种常见的编程模式。有关更多信息，请阅读《游戏编程模式》电子书中的\\ `观察者"
"教程 <https://gameprogrammingpatterns.com/observer.html>`_\\ 。"

msgid ""
"You can connect these signals to methods the same way you connect built-in "
"signals of nodes like :ref:`class_Button` or :ref:`class_RigidBody3D`."
msgstr ""
"你可以将这些信号连接到方法，就像连接 :ref:`class_Button` 或 :ref:"
"`class_RigidBody3D` 等节点的内置信号一样。"

msgid ""
"In the example below, we connect the ``health_depleted`` signal from a "
"``Character`` node to a ``Game`` node. When the ``Character`` node emits the "
"signal, the game node's ``_on_character_health_depleted`` is called::"
msgstr ""
"在下面的示例中，我们将 ``Character`` 节点的 ``health_depleted`` 信号连接到 "
"``Game`` 节点上。当 ``Character`` 节点发出信号时，Game 节点的 "
"``_on_character_health_depleted`` 就会被调用："

msgid "You can emit as many arguments as you want along with a signal."
msgstr "可以在发出一个信号时给该信号附带任意数量的参数。"

msgid ""
"Here is an example where this is useful. Let's say we want a life bar on "
"screen to react to health changes with an animation, but we want to keep the "
"user interface separate from the player in our scene tree."
msgstr ""
"下面这个示例就是该特性的一个不错的实现。假设我们希望屏幕上的生命条能够通过动"
"画对生命值做出反应，但我们希望在场景树中让用户界面与游戏角色保持独立。"

msgid ""
"In our ``character.gd`` script, we define a ``health_changed`` signal and "
"emit it with :ref:`Signal.emit() <class_Signal_method_emit>`, and from a "
"``Game`` node higher up our scene tree, we connect it to the ``Lifebar`` "
"using the :ref:`Signal.connect() <class_Signal_method_connect>` method::"
msgstr ""
"在我们的 ``character.gd`` 脚本中，我们定义了一个 ``health_changed`` 信号并使"
"用 :ref:`Signal.emit() <class_Signal_method_emit>` 发出它，并从我们场景树中更"
"高的 ``Game`` 节点发出，我们使用 :ref:`Signal.connect() "
"<class_Signal_method_connect>` 方法将其连接到 ``Lifebar``："

msgid ""
"In the ``Game`` node, we get both the ``Character`` and ``Lifebar`` nodes, "
"then connect the character, that emits the signal, to the receiver, the "
"``Lifebar`` node in this case."
msgstr ""
"在 ``Game`` 节点中，我们同时获得 ``Character`` 和 ``Lifebar`` 节点，然后将发"
"出信号的 ``Character`` 连接到接收者节点上，在本例中 ``Lifebar`` 为这一接收者"
"节点。"

msgid ""
"This allows the ``Lifebar`` to react to health changes without coupling it "
"to the ``Character`` node."
msgstr ""
"这样 ``Lifebar`` 就能够对生命值的变化做出反应，无需将其耦合到 ``Character`` "
"节点内。"

msgid ""
"You can write optional argument names in parentheses after the signal's "
"definition::"
msgstr "可以在信号的定义后面添加括号，并在该括号内写入可选的参数名称： ::"

msgid ""
"These arguments show up in the editor's node dock, and Godot can use them to "
"generate callback functions for you. However, you can still emit any number "
"of arguments when you emit signals; it's up to you to emit the correct "
"values."
msgstr ""
"这些参数会显示在编辑器的节点面板中，Godot 会在生成回调函数时自动为你添加这些"
"参数。但是，在发出信号时仍然可以发出任意数量的参数，需要由你来确定该信号需要"
"准确发出的值。"

msgid ""
"GDScript can bind an array of values to connections between a signal and a "
"method. When the signal is emitted, the callback method receives the bound "
"values. These bound arguments are unique to each connection, and the values "
"will stay the same."
msgstr ""
"GDScript 可以将一组值绑定到信号和方法之间的连接之上。发出信号时，回调方法将会"
"接收这组绑定值。这些绑定参数对于每个连接都是唯一的，且其值均保持不变。"

msgid ""
"You can use this array of values to add extra constant information to the "
"connection if the emitted signal itself doesn't give you access to all the "
"data that you need."
msgstr ""
"若发出的信号本身不能让你访问所需的所有数据，则可以使用这组数值将额外的常量信"
"息添加到连接当中。"

msgid ""
"Building on the example above, let's say we want to display a log of the "
"damage taken by each character on the screen, like ``Player1 took 22 damage."
"``. The ``health_changed`` signal doesn't give us the name of the character "
"that took damage. So when we connect the signal to the in-game console, we "
"can add the character's name in the binds array argument::"
msgstr ""
"接着上面的示例，我们要在屏幕上显示每个角色受到的伤害，例如 ``Player1 遭受了 "
"22 伤害。``\\ 。然而 ``health_changed`` 信号并没有给我们提供受到伤害的角色的"
"名称。因此，在我们将信号连接到游戏终端上时，可以在绑定参数这组数据中添加该角"
"色的名称： ::"

msgid ""
"Our ``BattleLog`` node receives each element in the binds array as an extra "
"argument::"
msgstr ""
"我们的 ``BattleLog`` 节点接收信号时，将绑定参数这个数组中的每个元素作为额外的"
"参数传入被连接的函数当中： ::"

msgid "Awaiting for signals or coroutines"
msgstr "等待信号或协程函数"

msgid ""
"The ``await`` keyword can be used to create `coroutines <https://en."
"wikipedia.org/wiki/Coroutine>`_ which wait until a signal is emitted before "
"continuing execution. Using the ``await`` keyword with a signal or a call to "
"a function that is also a coroutine will immediately return the control to "
"the caller. When the signal is emitted (or the called coroutine finishes), "
"it will resume execution from the point on where it stopped."
msgstr ""
"``await`` 关键字可以用来创建\\ `协程 <https://zh.wikipedia.org/wiki/"
"%E5%8D%8F%E7%A8%8B>`_\\ ，会等待某个信号发出之后再继续执行下面的代码。对信号"
"或者对同为协程的函数调用使用 ``await`` 关键字会立即将控制权返回给调用方。发出"
"信号时（或者调用的协程函数完成时），就会从停止的地方继续往下执行代码。"

msgid ""
"For example, to stop execution until the user presses a button, you can do "
"something like this::"
msgstr ""
"例如，要暂停代码执行，直到到用户按下某个按钮后才能继续往下执行剩余代码，你就"
"可以这样写： ::"

msgid ""
"In this case, the ``wait_confirmation`` becomes a coroutine, which means "
"that the caller also needs to await for it::"
msgstr ""
"此时 ``wait_confirmation`` 就会变成协程函数，调用方也需要对它进行等待操"
"作： ::"

msgid ""
"Note that requesting a coroutine's return value without ``await`` will "
"trigger an error::"
msgstr "需要注意：在请求协程函数的返回值时，不带 ``await`` 将会触发报错： ::"

msgid ""
"However, if you don't depend on the result, you can just call it "
"asynchronously, which won't stop execution and won't make the current "
"function a coroutine::"
msgstr ""
"如果你不需要结果，直接异步调用就可以了，既不会阻止代码的正常运行，也不会让当"
"前的函数变成协程函数： ::"

msgid ""
"If you use await with an expression that isn't a signal nor a coroutine, the "
"value will be returned immediately and the function won't give the control "
"back to the caller::"
msgstr ""
"若对不是信号和协程函数的表达式使用 await，则会立即返回对应的值，函数也不会将"
"控制权转交回调用方： ::"

msgid ""
"This also means that returning a signal from a function that isn't a "
"coroutine will make the caller await on that signal::"
msgstr "也就是说，如果从非协程函数中返回信号，那么调用方就会等待那个信号： ::"

msgid ""
"Unlike ``yield`` in previous Godot versions, you cannot obtain the function "
"state object. This is done to ensure type safety. With this type safety in "
"place, a function cannot say that it returns an ``int`` while it actually "
"returns a function state object during runtime."
msgstr ""
"与之前版本 Godot 中的 ``yield`` 不同，出于类型安全的考虑，现版本无法获取函数"
"状态对象。实现了这种类型安全之后，就不能说函数在返回 ``int`` 的同时还可能在运"
"行时返回函数状态对象了。"

msgid "Assert keyword"
msgstr "Assert 关键字"

msgid ""
"The ``assert`` keyword can be used to check conditions in debug builds. "
"These assertions are ignored in non-debug builds. This means that the "
"expression passed as argument won't be evaluated in a project exported in "
"release mode. Due to this, assertions must **not** contain expressions that "
"have side effects. Otherwise, the behavior of the script would vary "
"depending on whether the project is run in a debug build."
msgstr ""
"``assert`` 关键字可用于在调试版本中检查断言条件，而在非调试版本中则会忽略掉这"
"些断言，意味着在发布模式下导出的项目中断言语法不会评估作为参数传递的表达式。"
"因此，断言 **决不能** 包含具有副作用的表达式，否则，脚本的行为将取决于该项目"
"是否在调试版本中运行。"

msgid ""
"When running a project from the editor, the project will be paused if an "
"assertion error occurs."
msgstr "在编辑器中运行项目时，如果发生断言错误，则会暂停该项目的运行。"

msgid ""
"You can optionally pass a custom error message to be shown if the assertion "
"fails::"
msgstr "你还可以传入自定义错误消息，这些消息会在断言失败时显示： ::"

msgid "Translation status"
msgstr "翻译状态"
