# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Nodes and scene instances"
msgstr "节点与场景实例"

msgid ""
"This guide explains how to get nodes, create nodes, add them as a child, and "
"instantiate scenes from code."
msgstr ""
"本指南将介绍如何获取节点、创建节点，如何将节点添加为子项，以及如何使用代码实"
"例化场景。"

msgid "Getting nodes"
msgstr "获取节点"

msgid ""
"You can get a reference to a node by calling the :ref:`Node.get_node() "
"<class_Node_method_get_node>` method. For this to work, the child node must "
"be present in the scene tree. Getting it in the parent node's ``_ready()`` "
"function guarantees that."
msgstr ""
"你可以通过调用 :ref:`Node.get_node() <class_Node_method_get_node>` 方法来获取"
"对某个节点的引用，此时子节点必须在场景树中才能获取成功。在父节点的 "
"``_ready()`` 函数中获取就可以保证这一点。"

msgid ""
"If, for example,  you have a scene tree like this, and you want to get a "
"reference to the Sprite2D and Camera2D nodes to access them in your script."
msgstr ""
"例如，如果有这样的场景树，你希望获得对 Sprite2D 和 Camera2D 节点的引用，以便"
"在脚本中访问这些节点。"

msgid "To do so, you can use the following code."
msgstr "那么，你便可以使用如下代码。"

msgid ""
"Note that you get nodes using their name, not their type. Above, "
"\"Sprite2D\" and \"Camera2D\" are the nodes' names in the scene."
msgstr ""
"请注意：你是通过名称来获取节点的，而非通过节点的类型来获取的。上面"
"的“Sprite2D”和“Camera2D”都是这些节点在场景中的名字。"

msgid ""
"If you rename the Sprite2D node as Skin in the Scene dock, you have to "
"change the line that gets the node to ``get_node(\"Skin\")`` in the script."
msgstr ""
"如果你在“场景”面板中将“Sprite2D”节点重命名为“Skin”，那么就必须在脚本里把获得"
"节点的那一行语句改成 ``get_node(\"Skin\")``\\ 。"

msgid "Node paths"
msgstr "节点路径"

msgid ""
"When getting a reference to a node, you're not limited to getting a direct "
"child. The ``get_node()`` function supports paths, a bit like when working "
"with a file browser. Add a slash to separate nodes."
msgstr ""
"获取节点的引用时，并不仅限于直接子节点。\\ ``get_node()`` 函数支持使用节点路"
"径来获取节点。节点路径有点类似文件浏览器里的路径，可以用斜杠来分隔节点。"

msgid ""
"Take the following example scene, with the script attached to the "
"UserInterface node."
msgstr "在下面这个实例场景中，脚本是附加在 UserInterface 节点上的。"

msgid "To get the AnimationPlayer node, you would use the following code."
msgstr "要获取 AnimationPlayer 节点，你可以使用如下代码。"

msgid ""
"As with file paths, you can use \"..\" to get a parent node. The best "
"practice is to avoid doing that though not to break encapsulation. You can "
"also start the path with a forward slash to make it absolute, in which case "
"your topmost node would be \"/root\", the application's predefined root "
"viewport."
msgstr ""
"和文件路径一样，你也可以使用“..”来获取父节点，最好不要这么做，以免破坏封装。"
"你还可以让路径以斜杠开头，这样的路径叫做绝对路径，其最上层的节点就是“/root”，"
"即程序预定义的根视口。"

msgid "Syntactic sugar"
msgstr "语法糖"

msgid ""
"You can use two shorthands to shorten your code in GDScript. Firstly, "
"putting the ``@onready`` annotation before a member variable makes it "
"initialize right before the ``_ready()`` callback."
msgstr ""
"GDScript 中有两个快速写法来缩短节点获取代码的长度。首先是在成员变量的前面写"
"上 ``@onready`` 注解，这样这个变量就会刚好在 ``_ready()`` 回调之前初始化。"

msgid ""
"There is also a short notation for ``get_node()``: the dollar sign, \"$\". "
"You place it before the name or path of the node you want to get."
msgstr ""
"还有一个快速写法就是 ``get_node()`` 的缩写：美元符号“$”，可以把它放在想要获取"
"的名称或者节点路径之前。"

msgid "Creating nodes"
msgstr "创建节点"

msgid ""
"To create a node from code, call its ``new()`` method like for any other "
"class-based datatype."
msgstr "要通过代码创建节点，请像对象类型一样，调用其 ``new()`` 方法。"

msgid ""
"You can store the newly created node's reference in a variable and call "
"``add_child()`` to add it as a child of the node to which you attached the "
"script."
msgstr ""
"你可以将新创建的节点的引用保存在一个变量中，然后调用 ``add_child()`` 方法，将"
"其添加为脚本所在节点的子节点。"

msgid ""
"To delete a node and free it from memory, you can call its ``queue_free()`` "
"method. Doing so queues the node for deletion at the end of the current "
"frame after it has finished processing. At that point, the engine removes "
"the node from the scene and frees the object in memory."
msgstr ""
"要删除节点、将其从内存中释放，可以调用其 ``queue_free()`` 方法。这样，该节点"
"的删除操作就会被排进一个队列当中，在当前帧处理完成之后就会执行队列中的节点删"
"除操作。删除时，引擎会把该节点从场景（树）中删除，然后释放内存中相应的对象。"

msgid ""
"Before calling ``sprite2d.queue_free()``, the remote scene tree looks like "
"this."
msgstr "在调用 ``sprite2d.queue_free()`` 之前，远程场景树是这样的。"

msgid ""
"After the engine freed the node, the remote scene tree doesn't display the "
"sprite anymore."
msgstr "在引擎释放节点后，远程场景树就不会再显示这个精灵节点了。"

msgid ""
"You can alternatively call ``free()`` to immediately destroy the node. You "
"should do this with care as any reference to it will instantly become "
"``null``. We recommend using ``queue_free()`` unless you know what you're "
"doing."
msgstr ""
"你也可以调用 ``free()`` 来立即删除该节点。调用时需要小心：所有对它的引用都会"
"立即变成 ``null``\\ ，除非你知道自己在干什么，否则建议使用 "
"``queue_free()``\\ 。"

msgid ""
"When you free a node, it also frees all its children. Thanks to this, to "
"delete an entire branch of the scene tree, you only have to free the topmost "
"parent node."
msgstr ""
"释放节点时也会释放其所有子节点。得益于此，只需删除最顶端的父节点，就可以在场"
"景树中删除该节点及其所有子孙节点了。"

msgid "Instancing scenes"
msgstr "实例化场景"

msgid ""
"Scenes are templates from which you can create as many reproductions as "
"you'd like. This operation is called instancing, and doing it from code "
"happens in two steps:"
msgstr ""
"场景就是模板，你可以用场景来创建出任意数量的复制品，这种的操作就叫作实例化"
"（instancing）。在代码中进行实例化总共分两步："

msgid "Loading the scene from the local drive."
msgstr "从本地硬盘中加载场景。"

msgid ""
"Creating an instance of the loaded :ref:`PackedScene <class_PackedScene>` "
"resource."
msgstr "创建已加载好的 :ref:`PackedScene <class_PackedScene>` 资源的实例。"

msgid ""
"Preloading the scene can improve the user's experience as the load operation "
"happens when the compiler reads the script and not at runtime. This feature "
"is only available with GDScript."
msgstr ""
"预加载场景可以提升用户体验，因为加载操作是发生在编译器读取脚本的时候进行的，"
"而非在游戏运行时进行，这个特性是 GDScript 所独有的。"

msgid ""
"At that point, ``scene`` is a packed scene resource, not a node. To create "
"the actual node, you need to call :ref:`PackedScene.instantiate() "
"<class_PackedScene_method_instantiate>`. It returns a tree of nodes that you "
"can use as a child of your current node."
msgstr ""
"此时的 ``scene`` 是个打包场景资源，并非节点。要创建实际的节点，你还需要调用 :"
"ref:`PackedScene.instantiate() <class_PackedScene_method_instantiate>`\\ 来创"
"建节点，该方法会返回该打包场景的节点树的根节点。你可以将其添加为当前节点的子"
"节点。"

msgid ""
"The advantage of this two-step process is you can keep a packed scene loaded "
"and create new instances on the fly. For example, to quickly instance "
"several enemies or bullets."
msgstr ""
"这两步过程的优点在于：打包的场景可以保持加载状态，且可以随时使用。例如，你可"
"以对大量敌人或子弹快速进行实例化。"

msgid "Translation status"
msgstr "翻译状态"
