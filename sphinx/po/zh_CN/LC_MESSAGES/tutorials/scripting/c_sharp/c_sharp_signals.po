# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "C# signals"
msgstr "C# 信号"

msgid ""
"For a detailed explanation of signals in general, see the :ref:`doc_signals` "
"section in the step by step tutorial."
msgstr "有关信号的详细解释，请参阅逐步教程中的 :ref:`doc_signals` 部分。"

msgid ""
"While it is still possible to use signals through the ``Connect``/"
"``Disconnect`` API, C# gives us a more idiomatic way to implement the :ref:"
"`observer pattern<doc_key_concepts_signals>`."
msgstr ""
"虽然仍然可以通过 ``Connect``/``Disconnect`` API 使用信号，但 C# 为我们提供了"
"一种更符合习惯的方式来实现 :ref:`观察者模式 <doc_key_concepts_signals>` 。"

msgid "Signals as C# events"
msgstr "信号作为 C# 事件"

msgid ""
"To provide more type-safety, Godot signals are also all available through "
"`events <https://learn.microsoft.com/en-us/dotnet/csharp/events-overview>`_. "
"You can handle these events, as any other event, with the ``+=`` and ``-=`` "
"operators."
msgstr ""
"为了提供更多的类型安全，Godot 信号也都可以通过 `事件 <https://learn."
"microsoft.com/zh-cn/dotnet/csharp/events-overview>`_ 获取。你可以用 ``+=`` "
"和 ``-=`` 运算符来处理这些事件，就像其他任何事件一样。"

msgid ""
"In addition, you can always access signal names associated with a node type "
"through its nested ``SignalName`` class. This is useful when, for example, "
"you want to await on a signal (see :ref:`doc_c_sharp_differences_await`)."
msgstr ""
"此外，你可以通过节点类型的嵌套 ``SignalName`` 类来访问与之相关的信号名称。这"
"在你想要等待一个信号时很有用，例如（参见 :ref:"
"`doc_c_sharp_differences_await` ）。"

msgid ""
"While all engine signals connected as events are automatically disconnected "
"when nodes are freed, custom signals aren't. Meaning that: you will need to "
"manually disconnect (using ``-=``) all the custom signals you connected as "
"C# events (using ``+=``)."
msgstr ""

msgid "Custom signals as C# events"
msgstr "自定义信号作为 C# 事件"

msgid ""
"To declare a custom event in your C# script, use the ``[Signal]`` attribute "
"on a public delegate type. Note that the name of this delegate needs to end "
"with ``EventHandler``."
msgstr ""
"要在你的 C# 脚本中声明一个自定义事件，你需要在一个公共委托类型上使用 "
"``[Signal]`` 特性。注意，这个委托的名称必须以 ``EventHandler`` 结尾。"

msgid ""
"Once this is done, Godot will create the appropriate events automatically "
"behind the scenes. You can then use said events as you'd do for any other "
"Godot signal. Note that events are named using your delegate's name minus "
"the final ``EventHandler`` part."
msgstr ""
"一旦完成这一步，Godot 就会在后台自动创建相应的事件。你可以像使用任何其他 "
"Godot 信号一样使用这些事件。注意，事件的名称是用你的委托的名称减去最后的 "
"``EventHandler`` 部分来命名的。"

msgid ""
"If you want to connect to these signals in the editor, you will need to "
"(re)build the project to see them appear."
msgstr ""
"如果你想在编辑器中连接到这些信号，你需要（重新）构建项目以查看它们的出现。"

msgid ""
"You can click the **Build** button in the upper-right corner of the editor "
"to do so."
msgstr "你可以使用右上角的按钮来。"

msgid "Signal emission"
msgstr "信号发射"

msgid ""
"To emit signals, use the ``EmitSignal`` method. Note that, as for signals "
"defined by the engine, your custom signal names are listed under the nested "
"``SignalName`` class."
msgstr ""
"要发射信号，使用 ``EmitSignal`` 方法。请注意，就像引擎定义的信号一样，你的自"
"定义信号名称列在嵌套的 ``SignalName`` 类下。"

msgid ""
"In contrast with other C# events, you cannot use ``Invoke`` to raise events "
"tied to Godot signals."
msgstr ""
"与其他 C# 事件不同，你不能使用 ``Invoke`` 来触发与 Godot 信号绑定的事件。"

msgid ""
"Signals support arguments of any :ref:`Variant-compatible "
"<doc_c_sharp_variant>` type."
msgstr "信号支持任何 :ref:`Variant 兼容 <doc_c_sharp_variant>` 类型的参数。"

#, fuzzy
msgid ""
"Consequently, any ``Node`` or ``RefCounted`` will be compatible "
"automatically, but custom data objects will need to inherit from "
"``GodotObject`` or one of its subclasses."
msgstr ""
"因此，任何 ``Node`` 或 ``Reference`` 都会自动兼容，但自定义数据对象需要继承"
"自 ``GodotObject`` 或其子类之一。"

msgid "Bound values"
msgstr "绑定值"

msgid ""
"Sometimes you'll want to bind values to a signal when the connection is "
"established, rather than (or in addition to) when the signal is emitted. To "
"do so, you can use an anonymous function like in the following example."
msgstr ""
"有时你会想在连接建立时将值绑定到信号，而不是（或者除了）在信号发出时。要做到"
"这一点，你可以使用一个匿名函数，如下面的例子所示。"

msgid ""
"Here, the :ref:`Button.Pressed <class_BaseButton_signal_pressed>` signal do "
"not take any argument. But we want to use the same ``ModifyValue`` for both "
"the \"plus\" and \"minus\" buttons. So we bind the modifier value at the "
"time we're connecting the signals."
msgstr ""
"在这里， :ref:`Button.Pressed <class_BaseButton_signal_pressed>` 信号不需要任"
"何参数。但我们想要对“加”和“减”按钮使用相同的 ``ModifyValue`` 。所以我们在连接"
"信号的时候绑定了修饰值。"

msgid "Signal creation at runtime"
msgstr "运行时创建信号"

msgid ""
"Finally, you can create custom signals directly while your game is running. "
"Use the ``AddUserSignal`` method for that. Be aware that it should be "
"executed before any use of said signals (either connecting to them or "
"emitting them). Also, note that signals created this way won't be visible "
"through the ``SignalName`` nested class."
msgstr ""
"最后，你可以在游戏运行时直接创建自定义信号。使用 ``AddUserSignal`` 方法来实现"
"这一功能。注意，这个方法应该在使用这些信号（无论是连接还是发射）之前执行。另"
"外，注意这种方式创建的信号不会通过 ``SignalName`` 嵌套类显示。"

msgid "Translation status"
msgstr "翻译状态"
