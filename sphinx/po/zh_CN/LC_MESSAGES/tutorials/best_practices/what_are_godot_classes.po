# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Applying object-oriented principles in Godot"
msgstr "在 Godot 中应用面向对象原则"

msgid ""
"The engine offers two main ways to create reusable objects: scripts and "
"scenes. Neither of these technically define classes under the hood."
msgstr ""
"Godot 引擎主要提供了两种创建可复用对象的方式：脚本和场景。严格来说，这两种方"
"式都没有真的在底层定义类。"

msgid ""
"Still, many best practices using Godot involve applying object-oriented "
"programming principles to the scripts and scenes that compose your game. "
"That is why it's useful to understand how we can think of them as classes."
msgstr ""
"尽管如此，在许多使用 Godot 的最佳方法中，依然涉及将面向对象的编程原则应用到游"
"戏的脚本和场景中。这就是为什么我们需要了解如何将它们视为类。"

msgid ""
"This guide briefly explains how scripts and scenes work in the engine's core "
"to help you understand how they work under the hood."
msgstr ""
"本指南简要介绍了脚本和场景在引擎核心中的工作方式,，以帮助你了解它们在底层是如"
"何工作的。"

msgid "How scripts work in the engine"
msgstr "脚本在引擎中的工作原理"

msgid ""
"The engine provides built-in classes like :ref:`Node <class_Node>`. You can "
"extend those to create derived types using a script."
msgstr ""
"引擎提供了内置的类，如 :ref:`Node <class_Node>` 。你可以使用脚本扩展这些类来"
"创建派生类型。"

msgid ""
"These scripts are not technically classes. Instead, they are resources that "
"tell the engine a sequence of initializations to perform on one of the "
"engine's built-in classes."
msgstr ""
"这些脚本严格来说并不是类，而是一种资源，用来告知引擎在某一内置类的基础上执行"
"一系列初始化。"

msgid ""
"Godot's internal classes have methods that register a class's data with a :"
"ref:`ClassDB <class_ClassDB>`. This database provides runtime access to "
"class information. ``ClassDB`` contains information about classes like:"
msgstr ""
"Godot 的内部类可以将一个类的数据注册进一个名为 :ref:`ClassDB "
"<class_ClassDB>` 的数据库，该数据库让我们可以在运行时访问类的信息。 "
"``ClassDB`` 包含有关类的信息，例如："

msgid "Properties."
msgstr "属性。"

msgid "Methods."
msgstr "方法。"

msgid "Constants."
msgstr "常量。"

msgid "Signals."
msgstr "信号。"

msgid ""
"This ``ClassDB`` is what objects check against when performing an operation "
"like accessing a property or calling a method. It checks the database's "
"records and the object's base types' records to see if the object supports "
"the operation."
msgstr ""
"当对象在执行访问属性或调用方法等操作时，它就会检查 ``ClassDB`` 中对象和对象基"
"类的记录，以确定对象是否支持该操作。"

msgid ""
"Attaching a :ref:`Script <class_Script>` to your object extends the methods, "
"properties, and signals available from the ``ClassDB``."
msgstr ""
"将 :ref:`Script <class_Script>` 附加到你的对象上，可以扩展 ``ClassDB`` 中该对"
"象的方法、属性和信号。"

msgid ""
"Even scripts that don't use the ``extends`` keyword implicitly inherit from "
"the engine's base :ref:`RefCounted <class_RefCounted>` class. As a result, "
"you can instantiate scripts without the ``extends`` keyword from code. Since "
"they extend ``RefCounted`` though, you cannot attach them to a :ref:`Node "
"<class_Node>`."
msgstr ""
"脚本即使没有使用 ``extends`` 关键字，也会隐式地继承引擎的基础 :ref:"
"`RefCounted <class_RefCounted>` 类。因此，你可以从代码中实例化不使用 "
"``extends`` 关键字的脚本。不过由于扩展的是 ``RefCounted``\\ ，你是无法把它们"
"附加到 :ref:`Node <class_Node>` 上的。"

msgid "Scenes"
msgstr "场景"

msgid ""
"The behavior of scenes has many similarities to classes, so it can make "
"sense to think of a scene as a class. Scenes are reusable, instantiable, and "
"inheritable groups of nodes. Creating a scene is similar to having a script "
"that creates nodes and adds them as children using ``add_child()``."
msgstr ""
"场景的行为与类有很多相似之处，所以把场景看成一个类也是合理的。场景是可复用、"
"可实例化、可继承的节点组。创建场景就类似于，有一个脚本去创建一些节点，并使用 "
"``add_child()`` 将它们添加为子节点。"

msgid ""
"We often pair a scene with a scripted root node that makes use of the "
"scene's nodes. As such, the script extends the scene by adding behavior "
"through imperative code."
msgstr ""
"我们经常为场景搭配一个带有脚本的根节点，并在脚本中使用这个场景下的节点。在这"
"种情况下，脚本是通过使用命令式代码为场景添加行为来扩展场景的。"

msgid "The content of a scene helps to define:"
msgstr "场景的内容有助于定义："

msgid "What nodes are available to the script."
msgstr "脚本可使用哪些节点。"

msgid "How they are organized."
msgstr "它们是如何组织的。"

msgid "How they are initialized."
msgstr "它们是如何初始化的。"

msgid "What signal connections they have with each other."
msgstr "它们彼此之间有什么信号连接。"

msgid ""
"Why is any of this important to scene organization? Because instances of "
"scenes *are* objects. As a result, many object-oriented principles that "
"apply to written code also apply to scenes: single responsibility, "
"encapsulation, and others."
msgstr ""
"为什么这些对组织场景很重要？因为场景的实例\\ *都是*\\ 对象。因此，许多适用于"
"书面代码的面向对象原则也适用于场景：单一职责、封装等。"

msgid ""
"The scene is *always an extension of the script attached to its root node*, "
"so you can interpret it as part of a class."
msgstr ""
"场景\\ *就是对附着在根节点上的脚本的扩展*\\ ，所以你可以将其解释为类的一部"
"分。"

msgid ""
"Most of the techniques explained in this best practices series build on this "
"point."
msgstr "此系列最佳实践中所解释的大部分技术都建立在这一点上。"

msgid "Translation status"
msgstr "翻译状态"
