# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "When to use scenes versus scripts"
msgstr "何时使用场景与脚本"

msgid ""
"We've already covered how scenes and scripts are different. Scripts define "
"an engine class extension with imperative code, scenes with declarative code."
msgstr ""
"我们已经介绍了场景和脚本的不同之处. 脚本使用命令性代码定义引擎类扩展, 而场景"
"使用声明性代码."

msgid ""
"Each system's capabilities are different as a result. Scenes can define how "
"an extended class initializes, but not what its behavior actually is. Scenes "
"are often used in conjunction with a script, the scene declaring a "
"composition of nodes, and the script adding behaviour with imperative code."
msgstr ""
"因此，每个系统的功能都不尽相同。场景可以定义扩展类的初始化方式，但不能定义其"
"实际行为。场景通常与脚本结合使用，场景声明节点的组成，而脚本则用命令式代码添"
"加行为。"

msgid "Anonymous types"
msgstr "匿名类型"

msgid ""
"It *is* possible to completely define a scenes' contents using a script "
"alone. This is, in essence, what the Godot Editor does, only in the C++ "
"constructor of its objects."
msgstr ""
"单独使用脚本 *可以* 完全定义场景的内容. 从本质上讲,Godot编辑器所做的, 仅在其"
"对象的C++构造函数中."

msgid ""
"But, choosing which one to use can be a dilemma. Creating script instances "
"is identical to creating in-engine classes whereas handling scenes requires "
"a change in API:"
msgstr ""
"但是, 选择哪个来使用, 可能是一个两难问题. 创建脚本实例与创建引擎类相同, 而处"
"理场景需要更改API:"

msgid ""
"Also, scripts will operate a little slower than scenes due to the speed "
"differences between engine and script code. The larger and more complex the "
"node, the more reason there is to build it as a scene."
msgstr ""
"此外, 由于引擎和脚本代码之间的速度差异, 脚本的运行速度将比场景慢一些. 节点越"
"大和越复杂, 将它构建为场景的理由就越多."

msgid "Named types"
msgstr "命名的类型"

msgid ""
"Scripts can be registered as a new type within the editor itself. This "
"displays it as a new type in the node or resource creation dialog with an "
"optional icon. This way, the user's ability to use the script is much more "
"streamlined. Rather than having to..."
msgstr ""
"脚本可以在编辑器中被注册为一个新类型。这样做之后，在节点或资源创建对话框中，"
"它就会被显示为一个新类型，并带有可选图标。这样，用户就可以更加便捷地使用脚"
"本，而不是必须…"

msgid "Know the base type of the script they would like to use."
msgstr "了解他们想要使用的脚本的基本类型."

msgid "Create an instance of that base type."
msgstr "创建一个该基本类型的实例."

msgid "Add the script to the node."
msgstr "将脚本添加到节点."

msgid ""
"With a registered script, the scripted type instead becomes a creation "
"option like the other nodes and resources in the system. The creation dialog "
"even has a search bar to look up the type by name."
msgstr ""
"通过注册一个脚本，该脚本类型将像系统中的其他节点和资源一样成为一个可以被创建"
"的选项。创建对话框甚至还有一个搜索栏，可以按名称查找类型。"

msgid "There are two systems for registering types:"
msgstr "用于注册类型的系统有两种："

msgid ":ref:`Custom Types <doc_making_plugins>`"
msgstr ":ref:`自定义类型 <doc_making_plugins>`"

msgid "Editor-only. Typenames are not accessible at runtime."
msgstr "仅限编辑器. 类型名称在运行时中不可访问."

msgid "Does not support inherited custom types."
msgstr "不支持继承的自定义类型."

msgid "An initializer tool. Creates the node with the script. Nothing more."
msgstr "一个初始化工具. 使用脚本创建节点. 仅此而已."

msgid ""
"Editor has no type-awareness of the script or its relationship to other "
"engine types or scripts."
msgstr "编辑器没有对该脚本的类型感知, 或其与其他引擎类型或脚本的关系."

msgid "Allows users to define an icon."
msgstr "允许用户定义一个图标."

msgid ""
"Works for all scripting languages because it deals with Script resources in "
"abstract."
msgstr "适用于所有脚本语言, 因为它抽象处理脚本资源."

msgid ""
"Set up using :ref:`EditorPlugin.add_custom_type "
"<class_EditorPlugin_method_add_custom_type>`."
msgstr ""
"设置使用 :ref:`EditorPlugin.add_custom_type "
"<class_EditorPlugin_method_add_custom_type>`."

msgid ":ref:`Script Classes <doc_gdscript_basics_class_name>`"
msgstr ":ref:`Script 类 <doc_gdscript_basics_class_name>`"

msgid "Editor and runtime accessible."
msgstr "编辑器和运行时均可访问."

msgid "Displays inheritance relationships in full."
msgstr "显示全部继承关系."

msgid ""
"Creates the node with the script, but can also change types or extend the "
"type from the editor."
msgstr "使用脚本创建节点, 但也可以从编辑器更改或扩展类型."

msgid ""
"Editor is aware of inheritance relationships between scripts, script "
"classes, and engine C++ classes."
msgstr "编辑器知道脚本, 脚本类和引擎c++类之间的继承关系."

msgid ""
"Engine developers must add support for languages manually (both name "
"exposure and runtime accessibility)."
msgstr "引擎开发人员必须手动添加对语言的支持(名称公开和运行时可访问性两者)."

msgid "Godot 3.1+ only."
msgstr "仅适用于Godot 3.1+版本."

msgid ""
"The Editor scans project folders and registers any exposed names for all "
"scripting languages. Each scripting language must implement its own support "
"for exposing this information."
msgstr ""
"编辑器扫描项目文件夹, 并为所有脚本语言注册任何公开的名称. 为公开此信息, 每种"
"脚本语言都必须实现自己的支持."

msgid ""
"Both methodologies add names to the creation dialog, but script classes, in "
"particular, also allow for users to access the typename without loading the "
"script resource. Creating instances and accessing constants or static "
"methods is viable from anywhere."
msgstr ""
"这两种方法都向创建对话框添加名称, 特别是脚本类, 还允许用户在不加载脚本资源的"
"情况下访问类别名称. 在任何地方都可以创建实例, 和访问常量或静态方法."

msgid ""
"With features like these, one may wish their type to be a script without a "
"scene due to the ease of use it grants users. Those developing plugins or "
"creating in-house tools for designers to use will find an easier time of "
"things this way."
msgstr ""
"有了这些功能, 由于它赋予用户易用性, 人们可能希望它们的类型是没有场景的脚本. "
"那些正在开发的插件或创建供设计人员使用的内部工具, 将以这种方式使事情变得更轻"
"松."

msgid ""
"On the downside, it also means having to use largely imperative programming."
msgstr "不足之处在于, 这也意味着很大程度上必须使用命令式编程."

msgid "Performance of Script vs PackedScene"
msgstr "Script 与 PackedScene 的性能"

msgid ""
"One last aspect to consider when choosing scenes and scripts is execution "
"speed."
msgstr "在选择场景和脚本时, 最后一个需要考虑的方面是执行速度."

msgid ""
"As the size of objects increases, the scripts' necessary size to create and "
"initialize them grows much larger. Creating node hierarchies demonstrates "
"this. Each Node's logic could be several hundred lines of code in length."
msgstr ""
"随着对象内容的增加, 脚本创建和初始化所需的内容也会大大增加. 创建节点层次结构"
"就说明了这一点. 每个Node的逻辑可能有几百行代码."

msgid ""
"The code example below creates a new ``Node``, changes its name, assigns a "
"script to it, sets its future parent as its owner so it gets saved to disk "
"along with it, and finally adds it as a child of the ``Main`` node:"
msgstr ""
"下面的代码示例创建一个新的 ``Node``, 更改名称, 分配脚本, 将其未来的父级设置为"
"其所有者, 以便保存到磁盘中, 最后将其添加为 \"主\" 节点的子级:"

msgid ""
"Script code like this is much slower than engine-side C++ code. Each "
"instruction makes a call to the scripting API which leads to many "
"\"lookups\" on the back-end to find the logic to execute."
msgstr ""
"这样的脚本代码比引擎端的C++代码要慢很多. 每条指令都要调用脚本API, 导致后端要"
"进行多次 \"查找\", 以找到要执行的逻辑."

msgid ""
"Scenes help to avoid this performance issue. :ref:`PackedScene "
"<class_PackedScene>`, the base type that scenes inherit from, defines "
"resources that use serialized data to create objects. The engine can process "
"scenes in batches on the back-end and provide much better performance than "
"scripts."
msgstr ""
"场景有助于避免这个性能问题。\\ :ref:`PackedScene <class_PackedScene>` （场景"
"包）是场景继承的基础类型，定义了使用序列化数据创建对象的资源。引擎可以在后端"
"批量处理场景，并提供比脚本好得多的性能。"

msgid "Conclusion"
msgstr "总结"

msgid "In the end, the best approach is to consider the following:"
msgstr "最后, 最好的方法是考虑以下几点:"

msgid ""
"If one wishes to create a basic tool that is going to be re-used in several "
"different projects and which people of all skill levels will likely use "
"(including those who don't label themselves as \"programmers\"), then "
"chances are that it should probably be a script, likely one with a custom "
"name/icon."
msgstr ""
"如果希望创建一个基本工具, 它将在几个不同的项目中重用, 以及可能提供给不同技能"
"水平的人使用.(包括那些不认为自己是个程序员的用户), 它很可能是一个脚本, 有一个"
"自定义名称/图标."

msgid ""
"If one wishes to create a concept that is particular to their game, then it "
"should always be a scene. Scenes are easier to track/edit and provide more "
"security than scripts."
msgstr ""
"如果有人想创造一个特定于他们的游戏的概念, 那么它应该是一个场景. 场景比脚本更"
"容易跟踪/编辑, 并提供更多的安全性."

msgid ""
"If one would like to give a name to a scene, then they can still sort of do "
"this by declaring a script class and giving it a scene as a constant. The "
"script becomes, in effect, a namespace:"
msgstr ""
"如果你想命名一个场景，那么你可以通过声明一个脚本类并给它一个场景作为常量来实"
"现这一点。实际上，该脚本变成了一个命名空间："

msgid "Translation status"
msgstr "翻译状态"
