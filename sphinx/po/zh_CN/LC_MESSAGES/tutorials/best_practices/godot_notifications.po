# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Godot notifications"
msgstr "Godot 通知"

msgid ""
"Every Object in Godot implements a :ref:`_notification "
"<class_Object_private_method__notification>` method. Its purpose is to allow "
"the Object to respond to a variety of engine-level callbacks that may relate "
"to it. For example, if the engine tells a :ref:`CanvasItem "
"<class_CanvasItem>` to \"draw\", it will call "
"``_notification(NOTIFICATION_DRAW)``."
msgstr ""
"Godot 中的每个对象都实现了 :ref:`_notification "
"<class_Object_private_method__notification>` 方法。其目的是允许对象响应可能与"
"之相关的各种引擎级回调。例如，如果引擎告诉 :ref:`CanvasItem "
"<class_CanvasItem>` 去“绘制”，则它将调用 "
"``_notification(NOTIFICATION_DRAW)``。"

msgid ""
"Some of these notifications, like draw, are useful to override in scripts. "
"So much so that Godot exposes many of them with dedicated functions:"
msgstr ""
"在所有这些通知之中，有很多类似“绘制”这样经常需要在脚本中去覆盖的通知，多到 "
"Godot 要提供专用函数的地步："

msgid "``_ready()``: ``NOTIFICATION_READY``"
msgstr "``_ready()``: ``NOTIFICATION_READY``"

msgid "``_enter_tree()``: ``NOTIFICATION_ENTER_TREE``"
msgstr "``_enter_tree()``: ``NOTIFICATION_ENTER_TREE``"

msgid "``_exit_tree()``: ``NOTIFICATION_EXIT_TREE``"
msgstr "``_exit_tree()``: ``NOTIFICATION_EXIT_TREE``"

msgid "``_process(delta)``: ``NOTIFICATION_PROCESS``"
msgstr "``_process(delta)``: ``NOTIFICATION_PROCESS``"

msgid "``_physics_process(delta)``: ``NOTIFICATION_PHYSICS_PROCESS``"
msgstr "``_physics_process(delta)``: ``NOTIFICATION_PHYSICS_PROCESS``"

msgid "``_draw()``: ``NOTIFICATION_DRAW``"
msgstr "``_draw()``: ``NOTIFICATION_DRAW``"

msgid ""
"What users might *not* realize is that notifications exist for types other "
"than Node alone, for example:"
msgstr "用户可能\\ *不会*\\ 意识到 Node 之外的类型也有通知，例如："

msgid ""
":ref:`Object::NOTIFICATION_POSTINITIALIZE "
"<class_Object_constant_NOTIFICATION_POSTINITIALIZE>`: a callback that "
"triggers during object initialization. Not accessible to scripts."
msgstr ""
":ref:`Object::NOTIFICATION_POSTINITIALIZE "
"<class_Object_constant_NOTIFICATION_POSTINITIALIZE>`\\ ：在对象初始化期间触发"
"的回调。脚本无法访问。"

msgid ""
":ref:`Object::NOTIFICATION_PREDELETE "
"<class_Object_constant_NOTIFICATION_PREDELETE>`: a callback that triggers "
"before the engine deletes an Object, i.e. a \"destructor\"."
msgstr ""
":ref:`Object::NOTIFICATION_PREDELETE "
"<class_Object_constant_NOTIFICATION_PREDELETE>`\\ ：在引擎删除 Object 之前触"
"发的回调，即析构函数。"

msgid ""
"And many of the callbacks that *do* exist in Nodes don't have any dedicated "
"methods, but are still quite useful."
msgstr "并且，在节点中也有很多很有用的回调，但是这些回调不存在专门的方法。"

msgid ""
":ref:`Node::NOTIFICATION_PARENTED "
"<class_Node_constant_NOTIFICATION_PARENTED>`: a callback that triggers "
"anytime one adds a child node to another node."
msgstr ""
":ref:`Node::NOTIFICATION_PARENTED "
"<class_Node_constant_NOTIFICATION_PARENTED>`: 将子节点添加到另一个节点时，会"
"触发此回调。"

msgid ""
":ref:`Node::NOTIFICATION_UNPARENTED "
"<class_Node_constant_NOTIFICATION_UNPARENTED>`: a callback that triggers "
"anytime one removes a child node from another node."
msgstr ""
":ref:`Node::NOTIFICATION_UNPARENTED "
"<class_Node_constant_NOTIFICATION_UNPARENTED>`: 将子节点从另一个节点下删除"
"时，会触发此回调。"

msgid ""
"One can access all these custom notifications from the universal "
"``_notification()`` method."
msgstr "你可以在通用的 ``_notification()`` 方法中访问所有这些自定义通知。"

msgid ""
"Methods in the documentation labeled as \"virtual\" are also intended to be "
"overridden by scripts."
msgstr "文档中被标记为“virtual”的方法（即虚方法）可以被脚本覆盖重写。"

msgid ""
"A classic example is the :ref:`_init <class_Object_private_method__init>` "
"method in Object. While it has no ``NOTIFICATION_*`` equivalent, the engine "
"still calls the method. Most languages (except C#) rely on it as a "
"constructor."
msgstr ""
"一个经典的例子是 ``Object`` 中的 :ref:`_init "
"<class_Object_private_method__init>` 方法。虽然它没有等效的 "
"``NOTIFICATION_*`` 通知，但是引擎仍然会调用该方法。大多数语言（C#除外）都将其"
"用作构造函数。"

msgid ""
"So, in which situation should one use each of these notifications or virtual "
"functions?"
msgstr "所以说，应该在哪些情况下使用这些通知或虚函数呢？"

msgid "_process vs. _physics_process vs. \\*_input"
msgstr "_process vs. _physics_process vs. \\*_input"

msgid ""
"Use ``_process()`` when one needs a framerate-dependent delta time between "
"frames. If code that updates object data needs to update as often as "
"possible, this is the right place. Recurring logic checks and data caching "
"often execute here, but it comes down to the frequency at which one needs "
"the evaluations to update. If they don't need to execute every frame, then "
"implementing a Timer-timeout loop is another option."
msgstr ""
"当需要使用“依赖于帧速率的 delta 时间增量”时，请使用 ``_process`` 。如果需要尽"
"可能频繁地更新对象数据，也应该在这里处理。频繁执行的逻辑检查和数据缓存操作，"
"大多数都在这里执行。但也需要注意执行频率，如果不需要每帧都执行，则可以选择用"
"定时器循环来替代。"

msgid ""
"Use ``_physics_process()`` when one needs a framerate-independent delta time "
"between frames. If code needs consistent updates over time, regardless of "
"how fast or slow time advances, this is the right place. Recurring kinematic "
"and object transform operations should execute here."
msgstr ""
"当需要与帧速率无关的时间增量时，请使用 ``_physics_process`` 。如果代码需要随"
"着时间的推移进行一致的更新，不管时间推进速度是快还是慢，那么就应该在这里执行"
"代码。频繁执行的运动学和对象变换操作，应在此处执行。"

msgid ""
"While it is possible, to achieve the best performance, one should avoid "
"making input checks during these callbacks. ``_process()`` and "
"``_physics_process()`` will trigger at every opportunity (they do not "
"\"rest\" by default). In contrast, ``*_input()`` callbacks will trigger only "
"on frames in which the engine has actually detected the input."
msgstr ""
"为了获得最佳性能，应尽可能避免在这些回调期间进行输入检查。 ``_process`` 和 "
"``_physics_process`` 每次都会触发（默认情况下这些更新回调不会 “休眠”）。相"
"反， ``*_input`` 回调仅在引擎实际检测到输入的帧上触发。"

msgid ""
"One can check for input actions within the input callbacks just the same. If "
"one wants to use delta time, one can fetch it from the related delta time "
"methods as needed."
msgstr ""
"在 input 回调中同样可以检查输入动作。如果要使用增量时间，则可以使用相关的增量"
"时间获取方法来获取。"

msgid "_init vs. initialization vs. export"
msgstr "_init vs. 初始化 vs. 导出"

msgid ""
"If the script initializes its own node subtree, without a scene, that code "
"should execute in ``_init()``. Other property or SceneTree-independent "
"initializations should also run here."
msgstr ""
"如果脚本初始化它自己的没有场景的节点子树，则该代码将会在 ``_init()`` 中执行。"
"其他属性或独立于 ``SceneTree`` 的初始化也应在此处运行。"

msgid "The C# equivalent to GDScript's ``_init()`` method is the constructor."
msgstr "与 GDScript 的 _init() 方法等效的 C# 方法是构造函数。"

msgid ""
"``_init()`` triggers before ``_enter_tree()`` or ``_ready()``, but after a "
"script creates and initializes its properties. When instantiating a scene, "
"property values will set up according to the following sequence:"
msgstr ""
"``_init()`` 在 ``_enter_tree()`` 或 ``_ready()`` 之前触发，但在脚本创建并初始"
"化其属性之后。实例化场景时，属性值将按照以下顺序设置："

msgid ""
"**Initial value assignment:** the property is assigned its initialization "
"value, or its default value if one is not specified. If a setter exists, it "
"is not used."
msgstr ""
"**初始值赋值：**\\ 一个属性被赋值为它的显式默认值，若无指定，则赋予缺省值。如"
"果存在setter函数，它并不会被使用。"

msgid ""
"**``_init()`` assignment:** the property's value is replaced by any "
"assignments made in ``_init()``, triggering the setter."
msgstr ""
"**``_init()`` 赋值:** 某个属性的值被任何在``_init()``中的赋值操作导致变更时，"
"触发其setter函数。"

msgid ""
"**Exported value assignment:** an exported property's value is again "
"replaced by any value set in the Inspector, triggering the setter."
msgstr ""
"**导出值赋值:** 一个导出属性的值如再次因Inspector中的任何设值操作导致变更，触"
"发其setter函数。"

msgid ""
"As a result, instantiating a script versus a scene may affect both the "
"initialization *and* the number of times the engine calls the setter."
msgstr ""
"因此，实例化一个脚本而非场景，将同时影响初始化 *和* 引擎调用setter函数的次"
"数。"

msgid "_ready vs. _enter_tree vs. NOTIFICATION_PARENTED"
msgstr "_ready、_enter_tree、NOTIFICATION_PARENTED对比"

msgid ""
"When instantiating a scene connected to the first executed scene, Godot will "
"instantiate nodes down the tree (making ``_init()`` calls) and build the "
"tree going downwards from the root. This causes ``_enter_tree()`` calls to "
"cascade down the tree. Once the tree is complete, leaf nodes call "
"``_ready``. A node will call this method once all child nodes have finished "
"calling theirs. This then causes a reverse cascade going up back to the "
"tree's root."
msgstr ""
"首次实例化一个场景并添加到场景树时，Godot将实例化节点（调用 ``_init``）为树，"
"同时自上而下地调用 ``_enter_tree``。当树构建完成后，再自下而上地调用 "
"``_ready``，最终反向回到树的顶点。"

msgid ""
"When instantiating a script or a standalone scene, nodes are not added to "
"the SceneTree upon creation, so no ``_enter_tree()`` callbacks trigger. "
"Instead, only the ``_init()`` call occurs. When the scene is added to the "
"SceneTree, the ``_enter_tree()`` and ``_ready()`` calls occur."
msgstr ""
"当实例化脚本或独立的场景时，节点不会在创建时被添加到 SceneTree 中，所以未触"
"发 ``_enter_tree`` 回调。而只有 ``_init`` 调用发生。当场景被添加到 SceneTree "
"时，才会调用 ``_enter_tree`` 和 ``_ready`` 。"

msgid ""
"If one needs to trigger behavior that occurs as nodes parent to another, "
"regardless of whether it occurs as part of the main/active scene or not, one "
"can use the :ref:`PARENTED <class_Node_constant_NOTIFICATION_PARENTED>` "
"notification. For example, here is a snippet that connects a node's method "
"to a custom signal on the parent node without failing. Useful on data-"
"centric nodes that one might create at runtime."
msgstr ""
"如果需要触发作为节点设置父级到另一个节点而发生的行为, 无论它是否作为在主要/活"
"动场景中的部分发生, 都可以使用 :ref:`PARENTED "
"<class_Node_constant_NOTIFICATION_PARENTED>` 通知. 例如, 这有一个将节点方法连"
"接到其父节点上自定义信号, 而不会失败的代码段。对可能在运行时创建并以数据为中"
"心的节点很有用。"

msgid "Translation status"
msgstr "翻译状态"
