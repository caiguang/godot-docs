# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Autoloads versus regular nodes"
msgstr "自动加载与常规节点"

msgid ""
"Godot offers a feature to automatically load nodes at the root of your "
"project, allowing you to access them globally, that can fulfill the role of "
"a Singleton: :ref:`doc_singletons_autoload`. These autoloaded nodes are not "
"freed when you change the scene from code with :ref:`SceneTree."
"change_scene_to_file <class_SceneTree_method_change_scene_to_file>`."
msgstr ""
"Godot 提供了一个在项目根节点自动加载节点的功能，允许你在全局范围内访问它们，"
"从而完成单例作用 :ref:`doc_singletons_autoload` 。当你在代码中使用 :ref:"
"`SceneTree.change_scene_to_file "
"<class_SceneTree_method_change_scene_to_file>` 更改场景时，这些自动加载的节点"
"不会被释放。"

msgid ""
"In this guide, you will learn when to use the Autoload feature, and "
"techniques you can use to avoid it."
msgstr "在本指南中, 你将学习到何时使用自动加载功能, 以及避免使用该功能的方法."

msgid "The cutting audio issue"
msgstr "切割音频问题"

msgid ""
"Other engines can encourage the use of creating manager classes, singletons "
"that organize a lot of functionality into a globally accessible object. "
"Godot offers many ways to avoid global state thanks to the node tree and "
"signals."
msgstr ""
"其他引擎可能鼓励使用创建管理类, 单例将很多功能组织到一个全局可访问的对象中. "
"由于节点树和信号,Godot提供了许多避免全局状态的方法."

msgid ""
"For example, let's say we are building a platformer and want to collect "
"coins that play a sound effect. There's a node for that: the :ref:"
"`AudioStreamPlayer <class_AudioStreamPlayer>`. But if we call the "
"``AudioStreamPlayer`` while it is already playing a sound, the new sound "
"interrupts the first."
msgstr ""
"例如, 假设我们正在构建一个平台游戏, 并希望收集能够播放声音效果的硬币, 那么就"
"有一个节点 :ref:`AudioStreamPlayer <class_AudioStreamPlayer>`. 如果在 "
"``AudioStreamPlayer`` 已经在播放声音时调用它, 新的声音就会打断第一个声音."

msgid ""
"A solution is to code a global, autoloaded sound manager class. It generates "
"a pool of ``AudioStreamPlayer`` nodes that cycle through as each new request "
"for sound effects comes in. Say we call that class ``Sound``, you can use it "
"from anywhere in your project by calling ``Sound.play(\"coin_pickup."
"ogg\")``. This solves the problem in the short term but causes more problems:"
msgstr ""
"一种解决方案是写一个全局的、自动加载的音效管理器类。它会生成一个 "
"``AudioStreamPlayer`` 的节点池，每当一个新的音效请求出现时，它就会在这个节点"
"池中找到可用的节点来播放。我们不妨就把该类命名为 ``Sound`` ，你可以通过 "
"``Sound.play(\"coin_pickup.ogg\")`` 从你项目中的任何位置使用它。这在短期内解"
"决了问题但是却造成了更多的麻烦："

msgid ""
"**Global state**: one object is now responsible for all objects' data. If "
"the ``Sound`` class has errors or doesn't have an AudioStreamPlayer "
"available, all the nodes calling it can break."
msgstr ""
"**全局状态** : 一个对象现在负责所有对象的数据. 如果音效有错误, 或没有一个可用"
"的 ``AudioStreamPlayer`` , 一切都会崩溃."

msgid ""
"**Global access**: now that any object can call ``Sound.play(sound_path)`` "
"from anywhere, there's no longer an easy way to find the source of a bug."
msgstr ""
"**全局访问** : 意味着任何对象都可以从任何地方调用 ``Sound."
"play(sound_path)`` , 便不容易找到错误的来源了."

msgid ""
"**Global resource allocation**: with a pool of ``AudioStreamPlayer`` nodes "
"stored from the start, you can either have too few and face bugs, or too "
"many and use more memory than you need."
msgstr ""
"**全局资源分配** : 由于从一开始就存储了一个 ``AudioStreamPlayer`` 节点池, 如"
"果数量太少会遇到bug, 而数量太多则会占用更多的内存."

msgid ""
"About global access, the problem is that any code anywhere could pass wrong "
"data to the ``Sound`` autoload in our example. As a result, the domain to "
"explore to fix the bug spans the entire project."
msgstr ""
"全局访问的问题在于，任何地方的代码都可能将错误的数据传递给我们例子中的 "
"``Sound`` 自动加载。因此，为了修复这个 bug，你需要检索的区域涵盖了整个项目。"

msgid ""
"When you keep code inside a scene, only one or two scripts may be involved "
"in audio."
msgstr "当你将代码保存在场景中时, 音频可能仅涉及一个或两个脚本."

msgid ""
"Contrast this with each scene keeping as many ``AudioStreamPlayer`` nodes as "
"it needs within itself and all these problems go away:"
msgstr ""
"与之形成对比的是, 每个场景在其内部, 保留尽可能多的 ``AudioStreamPlayer`` 节"
"点, 所有这些问题都会消失:"

msgid ""
"Each scene manages its own state information. If there is a problem with the "
"data, it will only cause issues in that one scene."
msgstr "每个场景管理自己的状态信息. 如果数据有问题, 则只会在该场景中引起问题."

msgid ""
"Each scene accesses only its own nodes. Now, if there is a bug, it's easy to "
"find which node is at fault."
msgstr "每个场景只访问自己的节点. 那么如果有一个bug, 很容易找到哪个节点有问题."

msgid "Each scene allocates exactly the amount of resources it needs."
msgstr "每个场景只分配所需数量的资源."

msgid "Managing shared functionality or data"
msgstr "管理共享功能或数据"

msgid ""
"Another reason to use an Autoload can be that you want to reuse the same "
"method or data across many scenes."
msgstr ""
"使用自动加载的另一个原因可能是你希望在许多场景中重复使用相同的方法或数据."

msgid ""
"In the case of functions, you can create a new type of ``Node`` that "
"provides that feature for an individual scene using the :ref:`class_name "
"<doc_gdscript_basics_class_name>` keyword in GDScript."
msgstr ""
"对于函数，可以使用 GDScript 中的 :ref:`class_name "
"<doc_gdscript_basics_class_name>` 关键字创建一种新的 ``Node`` 类型，为单个场"
"景提供该功能。"

msgid "When it comes to data, you can either:"
msgstr "当涉及到数据时, 你可以:"

msgid ""
"Create a new type of :ref:`Resource <class_Resource>` to share the data."
msgstr "创建一个新类型的 :ref:`Resource <class_Resource>` 来共享数据."

msgid ""
"Store the data in an object to which each node has access, for example using "
"the ``owner`` property to access the scene's root node."
msgstr ""
"将数据存储在每个节点可以访问的对象中, 例如使用 ``owner`` 属性来访问场景的根节"
"点."

msgid "When you should use an Autoload"
msgstr "何时应使用自动加载"

msgid ""
"GDScript supports the creation of ``static`` functions using ``static "
"func``. When combined with ``class_name``, this makes it possible to create "
"libraries of helper functions without having to create an instance to call "
"them. The limitation of static functions is that they can't reference member "
"variables, non-static functions or ``self``."
msgstr ""
"GDScript 支持使用 ``static func`` 创建 ``static`` （静态） 函数。 当与 "
"``class_name`` 结合使用时，（静态函数）可以创建辅助函数库，而无需创建实例来调"
"用它们。 静态函数也具有限制，它们不能引用成员变量、非静态（non-static）函数"
"或 ``self`` 。"

msgid ""
"Since Godot 4.1, GDScript also supports ``static`` variables using ``static "
"var``. This means you can now share a variables across instances of a class "
"without having to create a separate autoload."
msgstr ""
"从 Godot 4.1 开始，GDScript 还支持使用 ``static var`` 的 ``static`` （静态）"
"变量。 这意味着你现在可以在类的实例之间共享变量，而无需创建单独的自动加载。"

msgid ""
"Still, autoloaded nodes can simplify your code for systems with a wide "
"scope. If the autoload is managing its own information and not invading the "
"data of other objects, then it's a great way to create systems that handle "
"broad-scoped tasks. For example, a quest or a dialogue system."
msgstr ""
"尽管如此，对于那些涵盖范围广泛的系统来说，使用自动加载的节点仍然可以简化你的"
"代码。如果自动加载的节点管理自己的信息并且不侵入其他对象的数据，那么这就是一"
"个创建处理广泛任务的系统（例如，任务或对话系统）的好方法。"

msgid ""
"An autoload is *not* necessarily a singleton. Nothing prevents you from "
"instantiating copies of an autoloaded node. An autoload is only a tool that "
"makes a node load automatically as a child of the root of your scene tree, "
"regardless of your game's node structure or which scene you run, e.g. by "
"pressing the :kbd:`F6` key."
msgstr ""
"自动加载 *不* 完全是一个单例。没有什么可以阻止你实例化自动加载的节点的副本。"
"它只是一个使节点作为场景树的根的子节点自动加载的工具，而与游戏的节点结构或运"
"行哪个场景（比如通过按 :kbd:`F6` 键运行当前场景）无关。"

msgid ""
"As a result, you can get the autoloaded node, for example an autoload called "
"``Sound``, by calling ``get_node(\"/root/Sound\")``."
msgstr ""
"因此，你可以像这样，通过调用 ``get_node(\"/root/Sound\")`` 来获取名为 "
"``Sound`` 的自动加载节点。"

msgid "Translation status"
msgstr "翻译状态"
