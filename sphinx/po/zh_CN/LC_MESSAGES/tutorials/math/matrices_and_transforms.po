# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Matrices and transforms"
msgstr "矩阵与变换"

msgid "Introduction"
msgstr "前言"

msgid ""
"Before reading this tutorial, we recommend that you thoroughly read and "
"understand the :ref:`doc_vector_math` tutorial, as this tutorial requires a "
"knowledge of vectors."
msgstr ""
"在阅读本教程之前，我们推荐你从头到尾阅读 :ref:`doc_vector_math` 教程，因为本"
"教程需要向量的知识，故需要对其内容有较为全面的理解。"

msgid ""
"This tutorial is about *transformations* and how we represent them in Godot "
"using matrices. It is not a full in-depth guide to matrices. Transformations "
"are most of the time applied as translation, rotation, and scale, so we will "
"focus on how to represent those with matrices."
msgstr ""
"本教程会介绍\\ *变换*\\ 以及如何在 Godot 中使用矩阵来表示变换，并不会深入完整"
"地介绍矩阵与变换。变换在大多数情况下应用于平移、旋转、缩放，我们将会重点讲述"
"如何使用矩阵来表示平移、旋转和缩放。"

msgid ""
"Most of this guide focuses on 2D, using :ref:`class_Transform2D` and :ref:"
"`class_Vector2`, but the way things work in 3D is very similar."
msgstr ""
"虽然本教程主要侧重于 2D 的变换，用的是 :ref:`class_Transform2D` 和 :ref:"
"`class_Vector2`\\ ，但是对于 3D 中的变换，其工作方式也与 2D 的十分相似。"

msgid ""
"As mentioned in the previous tutorial, it is important to remember that in "
"Godot, the Y axis points *down* in 2D. This is the opposite of how most "
"schools teach linear algebra, with the Y axis pointing up."
msgstr ""
"正如之前的教程中所提到的，在 Godot 中，要记住 2D 的 Y 轴的正方向是\\ *向下"
"*\\ 的，而学校里教的线性代数的坐标系，其 Y 轴正方向是向上的，这两个 Y 轴的方"
"向是相反的，这一点需要注意。"

msgid ""
"The convention is that the X axis is red, the Y axis is green, and the Z "
"axis is blue. This tutorial is color-coded to match these conventions, but "
"we will also represent the origin vector with a blue color."
msgstr ""
"我们习惯 X 轴用红色表示、Y 轴用绿色表示、Z 轴用蓝色表示，本教程中的颜色都遵循"
"这个惯例，不过我们也在原点向量上使用蓝色表示。"

msgid "Matrix components and the Identity matrix"
msgstr "矩阵分量和单位矩阵"

msgid ""
"The identity matrix represents a transform with no translation, no rotation, "
"and no scale. Let's start by looking at the identity matrix and how its "
"components relate to how it visually appears."
msgstr ""
"单位矩阵代表一个没有平移、没有旋转、没有缩放的变换，现在就让我们看看单位矩阵"
"以及其分量是如何与其视觉表现相联系的吧。"

msgid ""
"Matrices have rows and columns, and a transformation matrix has specific "
"conventions on what each does."
msgstr "矩阵有行和列，变换矩阵对行和列有特定的规定。"

msgid ""
"In the image above, we can see that the red X vector is represented by the "
"first column of the matrix, and the green Y vector is likewise represented "
"by the second column. A change to the columns will change these vectors. We "
"will see how they can be manipulated in the next few examples."
msgstr ""
"在上图中，我们可以看到红色的 X 向量由矩阵的第一列数对表示，绿色的 Y 向量则由"
"第二列数对表示，改变这几列数对就会改变这些数对所对应的向量。接下来，我们将会"
"在几个例子中看到如何操作这些数对。"

msgid ""
"You should not worry about manipulating rows directly, as we usually work "
"with columns. However, you can think of the rows of the matrix as showing "
"which vectors contribute to moving in a given direction."
msgstr ""
"由于我们通常使用列来进行操作，因此不必担心直接操作行可能会带来的问题。不过，"
"你也可以把矩阵的行看作是一组表示在给定的方向上移动的向量。"

msgid ""
"When we refer to a value such as ``t.x.y``, that's the Y component of the X "
"column vector. In other words, the bottom-left of the matrix. Similarly, ``t."
"x.x`` is top-left, ``t.y.x`` is top-right, and ``t.y.y`` is bottom-right, "
"where ``t`` is the Transform2D."
msgstr ""
"我们指定诸如 `t.x.y` 这样的值时，表示这是 X 列向量的 Y 分量，换言之，就是这个"
"矩阵的左下角。类似地， `t.x.x` 就是左上角， `t.y.x` 就是右上角，那么 `t.y.y` "
"自然就是右下角。这里的 `t` 是一个 Transform2D。"

msgid "Scaling the transformation matrix"
msgstr "缩放变换矩阵"

msgid ""
"Applying a scale is one of the easiest operations to understand. Let's start "
"by placing the Godot logo underneath our vectors so that we can visually see "
"the effects on an object:"
msgstr ""
"应用缩放变换是最容易理解的操作之一，既然如此，那就让我们开始动手尝试吧！把 "
"Godot logo 放置于我们的向量之下，这样我们就可以直观地看出变换该对象上的应用效"
"果："

msgid ""
"Now, to scale the matrix, all we need to do is multiply each component by "
"the scale we want. Let's scale it up by 2. 1 times 2 becomes 2, and 0 times "
"2 becomes 0, so we end up with this:"
msgstr ""
"现在，要缩放矩阵，我们唯一需要做的就是将每个矩阵分量乘以我们想要缩放的比例。"
"现在来将这个矩阵缩放两倍，1 × 2 = 2，0 × 2 = 0，于是我们便得到了这个结果："

msgid "To do this in code, we multiply each of the vectors:"
msgstr "要在代码中实现这点，我们可以让缩放倍数去乘上每个列向量："

msgid ""
"If we wanted to return it to its original scale, we can multiply each "
"component by 0.5. That's pretty much all there is to scaling a "
"transformation matrix."
msgstr ""
"如果我们想要让该变换缩回到原来的尺度，那么我们可以让每个分向量乘以 0.5（即"
"1/2）。以上便是缩放变换矩阵的所有基本介绍了。"

msgid ""
"To calculate the object's scale from an existing transformation matrix, you "
"can use ``length()`` on each of the column vectors."
msgstr ""
"要从已存在的变换矩阵中计算对象的缩放尺度，可以对该矩阵的每个列向量使用 "
"`length()` 方法。"

msgid ""
"In actual projects, you can use the ``scaled()`` method to perform scaling."
msgstr "在实际项目中，你可以使用 `scaled()` 方法去执行缩放变换操作。"

msgid "Rotating the transformation matrix"
msgstr "旋转变换矩阵"

msgid ""
"We'll start the same way as earlier, with the Godot logo underneath the "
"identity matrix:"
msgstr ""
"我们将以与前面相同的方式开始本节内容，先在单位矩阵下方叠加一个 Godot logo "
"吧："

msgid ""
"As an example, let's say we want to rotate our Godot logo clockwise by 90 "
"degrees. Right now the X axis points right and the Y axis points down. If we "
"rotate these in our head, we would logically see that the new X axis should "
"point down and the new Y axis should point left."
msgstr ""
"举个例子，假设我们想让 Godot logo 顺时针旋转 90 度，而现在 X 轴正方形向右，Y "
"轴正方向向下。如果我们在脑海中模拟旋转这两个轴，那么我们脑海中就理应会想到："
"旋转后的 X 轴正方向应该向下，旋转后的 Y 轴正方向应该向左。"

msgid ""
"You can imagine that you grab both the Godot logo and its vectors, and then "
"spin it around the center. Wherever you finish spinning, the orientation of "
"the vectors determines what the matrix is."
msgstr ""
"你可以这样子想：你用手抓住 Godot 的 logo 和其变换矩阵的列向量，然后绕着logo的"
"中心点旋转这个logo以及这些向量。无论你在哪里完成该旋转，向量的方向都将会决定"
"矩阵最终呈现的模样。"

msgid ""
"We need to represent \"down\" and \"left\" in normal coordinates, so means "
"we'll set X to (0, 1) and Y to (-1, 0). These are also the values of "
"``Vector2.DOWN`` and ``Vector2.LEFT``. When we do this, we get the desired "
"result of rotating the object:"
msgstr ""
"我们需要在标准坐标系中表示“下方向”和“左方向”，故我们将 X 设为 (0, 1)，将 Y 设"
"为 (-1, 0)。这些也正是 Vector2.DOWN 和 Vector2.LEFT 的值。这样做的话，我们就"
"会得到旋转对象后所想看到的结果："

msgid ""
"If you have trouble understanding the above, try this exercise: Cut a square "
"of paper, draw X and Y vectors on top of it, place it on graph paper, then "
"rotate it and note the endpoints."
msgstr ""
"如果你还是难以理解上面的内容，那就试着做下这个小实践：剪一个正方形的纸，在上"
"面画 X 向量和 Y 向量，然后把它放在图表纸上，旋转这张正方形的纸，并记下其端"
"点。"

msgid ""
"To perform rotation in code, we need to be able to calculate the values "
"programmatically. This image shows the formulas needed to calculate the "
"transformation matrix from a rotation angle. Don't worry if this part seems "
"complicated, I promise it's the hardest thing you need to know."
msgstr ""
"要在代码中执行旋转，我们需要能以编程的方式计算旋转后的变换值。下图展示了由旋"
"转角度计算旋转变换矩阵所需的公式。如果看下图觉得很复杂，不用担心，这保准是你"
"需要知道的那个最难理解矩阵旋转的地方。"

msgid ""
"Godot represents all rotations with radians, not degrees. A full turn is "
"`TAU` or `PI*2` radians, and a quarter turn of 90 degrees is `TAU/4` or "
"`PI/2` radians. Working with `TAU` usually results in more readable code."
msgstr ""
"Godot 用弧度（radians）表示所有的旋转，不用角度。完整转一圈是 `TAU` 或 "
"`PI*2` 弧度，90 度（四分之一圈）是 `TAU/4` 或 `PI/2` 弧度。使用 `TAU` 通常会"
"让代码更易读。"

msgid ""
"Fun fact: In addition to Y being *down* in Godot, rotation is represented "
"clockwise. This means that all the math and trig functions behave the same "
"as a Y-is-up CCW system, since these differences \"cancel out\". You can "
"think of rotations in both systems being \"from X to Y\"."
msgstr ""
"有趣的事实：在 Godot 中，不仅 Y 是\\ *朝下*\\ 的，连旋转也成了顺时针的，也就"
"是说，Godot 2D 所有的数学和三角函数行为都与 Y 轴朝上的 CCW 坐标系相同，因为这"
"些差异“相互抵消”了。你可以认为在标准平面直角坐标系和 Godot 2D 的直角坐标系这"
"两个坐标系中的旋转都是“从 X 到 Y”。"

msgid ""
"In order to perform a rotation of 0.5 radians (about 28.65 degrees), we plug "
"in a value of 0.5 to the formula above and evaluate to find what the actual "
"values should be:"
msgstr ""
"为了执行 0.5 弧度的旋转（约 28.65 度），我们只需将 0.5 代入上面的公式中，然后"
"计算出实际的数值："

msgid "Here's how that would be done in code (place the script on a Node2D):"
msgstr "这是在代码中完成的方法（将脚本放在 Node2D 上）："

#, fuzzy
msgid ""
"To calculate the object's rotation from an existing transformation matrix, "
"you can use ``atan2(t.x.y, t.x.x)``, where t is the Transform2D."
msgstr ""
"要从现有的变换矩阵中计算对象的旋转，可以使用 `atan2(t.x.y, t.x.x)`\\ ，其中 "
"t 是 Transform2D。"

#, fuzzy
msgid ""
"In actual projects, you can use the ``rotated()`` method to perform "
"rotations."
msgstr "在实际项目中，可以使用 `rotated()` 方法进行旋转。"

msgid "Basis of the transformation matrix"
msgstr "变换矩阵的基"

#, fuzzy
msgid ""
"So far we have only been working with the ``x`` and ``y``, vectors, which "
"are in charge of representing rotation, scale, and/or shearing (advanced, "
"covered at the end). The X and Y vectors are together called the *basis* of "
"the transformation matrix. The terms \"basis\" and \"basis vectors\" are "
"important to know."
msgstr ""
"到目前为止，我们只使用 `x` 和 `y` 向量，它们负责表示旋转、缩放和/或剪切（高"
"级，会在文末提及）。X 和 Y 向量合称变换矩阵的\\ *基*\\ （Basis）。“基”和“基向"
"量”都是非常重要的术语。"

#, fuzzy
msgid ""
"You might have noticed that :ref:`class_Transform2D` actually has three :ref:"
"`class_Vector2` values: ``x``, ``y``, and ``origin``. The ``origin`` value "
"is not part of the basis, but it is part of the transform, and we need it to "
"represent position. From now on we'll keep track of the origin vector in all "
"examples. You can think of origin as another column, but it's often better "
"to think of it as completely separate."
msgstr ""
"你可能已经注意到 :ref:`class_Transform2D` 实际上有三个 :ref:`class_Vector2` "
"值：\\ `x`\\ 、\\ `y`\\ 、\\ `origin`\\ 。其中 `origin` 值不是基的一部分，而"
"是变换的一部分，我们需要用它来表示位置。从现在开始，我们将在所有例子中记录原"
"点向量。您可以将原点看作另一列，但把它认为是完全独立的通常更好。"

#, fuzzy
msgid ""
"Note that in 3D, Godot has a separate :ref:`class_Basis` structure for "
"holding the three :ref:`class_Vector3` values of the basis, since the code "
"can get complex and it makes sense to separate it from :ref:"
"`class_Transform3D` (which is composed of one :ref:`class_Basis` and one "
"extra :ref:`class_Vector3` for the origin)."
msgstr ""
"请注意在 3D 中，Godot 有一个单独的 :ref:`class_Basis` 结构，里面包含矩阵基的"
"三个 :ref:`class_Vector3` 的值。因为代码可能变得复杂，因此将它们从 :ref:"
"`class_Transform`\\ （由一个 :ref:`class_Basis` 和一个额外的原点 :ref:"
"`class_Vector3` 组成）中拆分出来是值得的。"

msgid "Translating the transformation matrix"
msgstr "变换矩阵的平移"

#, fuzzy
msgid ""
"Changing the ``origin`` vector is called *translating* the transformation "
"matrix. Translating is basically a technical term for \"moving\" the object, "
"but it explicitly does not involve any rotation."
msgstr ""
"对 `origin` 向量的修改称为对变换矩阵的\\ *平移*\\ 。平移其实上是“移动”对象的"
"一个技术术语，但它不会包含任何旋转。"

msgid ""
"Let's work through an example to help understand this. We will start with "
"the identity transform like last time, except we will keep track of the "
"origin vector this time."
msgstr ""
"让我们通过一个例子来帮助理解这一点。我们将像上次一样从恒等变换开始，但这次我"
"们将记录原点向量。"

#, fuzzy
msgid ""
"If we want to move the object to a position of (1, 2), we need to set its "
"``origin`` vector to (1, 2):"
msgstr ""
"如果希望对象移动到 (1, 2) 的位置，只需将其 `origin` 向量设置为 (1, 2)："

#, fuzzy
msgid ""
"There is also a ``translated()`` method, which performs a different "
"operation to adding or changing ``origin`` directly. The ``translated()`` "
"method will translate the object *relative to its own rotation*. For "
"example, an object rotated 90 degrees clockwise will move to the right when "
"``translated()`` with ``Vector2.UP``."
msgstr ""
"还有一个 `translated()` 方法，它执行的是与直接增加或更改 `origin` 不同的操"
"作。这个 `translated()` 方法将让该对象相对于它自己的旋转进行平移。例如，顺时"
"针旋转了 90 度的对象如果用 `Vector2.UP` 调用了 `translated()`\\ ，那么它就会"
"向右移动。"

msgid ""
"Godot's 2D uses coordinates based on pixels, so in actual projects you will "
"want to translate by hundreds of units."
msgstr ""
"Godot 的 2D 使用基于像素的坐标，所以在实际项目中，你会想要转换成数百个单位。"

msgid "Putting it all together"
msgstr "融会贯通"

#, fuzzy
msgid ""
"We're going to apply everything we mentioned so far onto one transform. To "
"follow along, create a project with a Sprite2D node and use the Godot logo "
"for the texture resource."
msgstr ""
"我们将把到目前为止提到的所有内容都应用到一个变换上。接下来，使用 Sprite 节点"
"创建一个简单的项目，并使用 Godot 徽标作为其纹理资源。"

msgid ""
"Let's set the translation to (350, 150), rotate by -0.5 rad, and scale by 3. "
"I've posted a screenshot, and the code to reproduce it, but I encourage you "
"to try and reproduce the screenshot without looking at the code!"
msgstr ""
"让我们将平移设置为 (350, 150)，旋转设为 -0.5 rad，缩放设为 3。我把屏幕截图和"
"重现代码都发出来了，但我鼓励你不看代码来尝试重现屏幕截图！"

msgid "Shearing the transformation matrix (advanced)"
msgstr "剪切变换矩阵（高级）"

msgid ""
"If you are only looking for how to *use* transformation matrices, feel free "
"to skip this section of the tutorial. This section explores an uncommonly "
"used aspect of transformation matrices for the purpose of building an "
"understanding of them."
msgstr ""
"如果你只想了解如何\\ *使用*\\ 变换矩阵，请随意跳过本教程的这一节。本节探讨变"
"换矩阵的一个不常用的方面，目的是为了你建立对它们的理解。"

msgid "Node2D provides a shearing property out of the box."
msgstr ""

msgid ""
"You may have noticed that a transform has more degrees of freedom than the "
"combination of the above actions. The basis of a 2D transformation matrix "
"has four total numbers in two :ref:`class_Vector2` values, while a rotation "
"value and a Vector2 for scale only has 3 numbers. The high-level concept for "
"the missing degree of freedom is called *shearing*."
msgstr ""
"你可能已经注意到，变换的自由度比上述操作的组合要多。2D 变换矩阵的基在两个 :"
"ref:`class_Vector2` 值中总共有四个数，而旋转值和缩放的 Vector2 只有三个数字。"
"缺失自由度的高级概念称为\\ *剪切*\\ （Shearing）。"

msgid ""
"Normally, you will always have the basis vectors perpendicular to each "
"other. However, shearing can be useful in some situations, and understanding "
"shearing helps you understand how transforms work."
msgstr ""
"通常，你将始终拥有彼此垂直的基向量。但是，剪切在某些情况下可能很有用，了解剪"
"切可以帮助你理解变换的工作原理。"

msgid ""
"To show you visually how it will look, let's overlay a grid onto the Godot "
"logo:"
msgstr "为了直观地向你展示它的外观, 让我们在Godot徽标上叠加一个网格:"

msgid ""
"Each point on this grid is obtained by adding the basis vectors together. "
"The bottom-right corner is X + Y, while the top-right corner is X - Y. If we "
"change the basis vectors, the entire grid moves with it, as the grid is "
"composed of the basis vectors. All lines on the grid that are currently "
"parallel will remain parallel no matter what changes we make to the basis "
"vectors."
msgstr ""
"此网格上的每个点都是通过将基向量相加而获得的。右下角是 X + Y，而右上角是 X - "
"Y。如果我们更改基向量，整个栅格也会随之移动，因为栅格是由基向量组成的。无论我"
"们对基向量做什么更改，栅格上当前平行的所有直线都将保持平行。"

msgid "As an example, let's set Y to (1, 1):"
msgstr "例如, 让我们将Y设置为(1,1):"

msgid ""
"You can't set the raw values of a Transform2D in the editor, so you *must* "
"use code if you want to shear the object."
msgstr "不能在编辑器中设置Transform2D的原始值, 所以想要剪切对象, 必须使用代码."

msgid ""
"Due to the vectors no longer being perpendicular, the object has been "
"sheared. The bottom-center of the grid, which is (0, 1) relative to itself, "
"is now located at a world position of (1, 1)."
msgstr ""
"由于向量不再垂直, 因此对象已被剪切. 栅格的底部中心(相对于自身为(0,1))现在位于"
"世界位置(1,1)."

msgid ""
"The intra-object coordinates are called UV coordinates in textures, so let's "
"borrow that terminology for here. To find the world position from a relative "
"position, the formula is U * X + V * Y, where U and V are numbers and X and "
"Y are the basis vectors."
msgstr ""
"对象内部坐标在纹理中称为UV坐标, 因此我们借用此处的术语. 要从相对位置找到世界"
"位置, 公式为U*X+V*Y, 其中U和V是数字,X和Y是基向量."

msgid ""
"The bottom-right corner of the grid, which is always at the UV position of "
"(1, 1), is at the world position of (2, 1), which is calculated from X*1 + "
"Y*1, which is (1, 0) + (1, 1), or (1 + 1, 0 + 1), or (2, 1). This matches up "
"with our observation of where the bottom-right corner of the image is."
msgstr ""
"栅格的右下角始终位于UV位置(1,1), 位于世界位置(2,1), 该位置是从X*1+Y*1(即"
"(1,0)+(1,1)或(1+1,0+1)或(2,1)计算得出的. 这与我们观察到的图像右下角的位置相吻"
"合."

msgid ""
"Similarly, the top-right corner of the grid, which is always at the UV "
"position of (1, -1), is at the world position of (0, -1), which is "
"calculated from X*1 + Y*-1, which is (1, 0) - (1, 1), or (1 - 1, 0 - 1), or "
"(0, -1). This matches up with our observation of where the top-right corner "
"of the image is."
msgstr ""
"同样, 栅格的右上角始终位于UV位置(1, -1), 位于世界位置(0, -1), 该位置是从"
"X*1+Y*-1计算得出的,X*1+Y*-1是(1,0)-(1,1)或(1-1,0-1)或(0, -1). 这与我们观察到"
"的图像右上角的位置相吻合."

msgid ""
"Hopefully you now fully understand the how a transformation matrix affects "
"the object, and the relationship between the basis vectors and how the "
"object's \"UV\" or \"intra-coordinates\" have their world position changed."
msgstr ""
"希望你现在完全了解变换矩阵如何影响对象，以及基向量之间的关系以及对象"
"的“UV”或“内部坐标”如何更改其世界位置。"

msgid ""
"In Godot, all transform math is done relative to the parent node. When we "
"refer to \"world position\", that would be relative to the node's parent "
"instead, if the node had a parent."
msgstr ""
"在Godot中, 所有变换数学运算都是相对于父节点完成的. 当我们提到 \"世界位置\" "
"时, 如果节点有父节点, 那么它将相对于节点的父位置."

msgid ""
"If you would like additional explanation, you should check out 3Blue1Brown's "
"excellent video about linear transformations: https://www.youtube.com/watch?"
"v=kYB8IZa5AuE"
msgstr ""
"如果你想要更多的解释，你可以查看 3Blue1Brown 关于线性变换的精彩视频：\\ "
"http://www.bilibili.com/video/BV1ys411472E?p=4"

msgid "Practical applications of transforms"
msgstr "变换的实际应用"

#, fuzzy
msgid ""
"In actual projects, you will usually be working with transforms inside "
"transforms by having multiple :ref:`class_Node2D` or :ref:`class_Node3D` "
"nodes parented to each other."
msgstr ""
"在实际项目中，您通常会通过将多个 :ref:`class_Node2D` 或 :ref:`class_Spatial` "
"节点设置为彼此的父级来处理变换中的变换。"

#, fuzzy
msgid ""
"However, it's useful to understand how to manually calculate the values we "
"need. We will go over how you could use :ref:`class_Transform2D` or :ref:"
"`class_Transform3D` to manually calculate transforms of nodes."
msgstr ""
"但是, 有时手动计算我们需要的值非常有用. 我们将介绍如何使用 :ref:"
"`CLASS_Transform2D` 或 :ref:`CLASS_Transform` 手动计算节点转换."

msgid "Converting positions between transforms"
msgstr "在变换之间转换位置"

msgid ""
"There are many cases where you'd want to convert a position in and out of a "
"transform. For example, if you have a position relative to the player and "
"would like to find the world (parent-relative) position, or if you have a "
"world position and want to know where it is relative to the player."
msgstr ""
"在许多情况下，你可能需要将某个位置转换为变换前或者变换后的位置。例如，如果你"
"有一个相对于玩家的位置并想要查找世界（相对于玩家来说是父级）位置，或者如果你"
"有一个世界位置并想知道它相对于玩家的位置。"

#, fuzzy
msgid ""
"We can find what a vector relative to the player would be defined in world "
"space as using the ``*`` operator:"
msgstr ""
"通过“xform”方法，我们可以找到相对于玩家的向量如果定义在世界空间中的话应该是什"
"么："

#, fuzzy
msgid ""
"And we can use the ``*`` operator in the opposite order to find a what world "
"space position would be if it was defined relative to the player:"
msgstr ""
"我们可以使用 \"xform_inv\" 方法来查找世界空间位置(如果它是相对于玩家定义的):"

msgid ""
"If you know in advance that the transform is positioned at (0, 0), you can "
"use the \"basis_xform\" or \"basis_xform_inv\" methods instead, which skip "
"dealing with translation."
msgstr ""
"如果你事先知道变换位于 (0, 0) 处，则可以改"
"用“basis_xform”或“basis_xform_inv”方法，这将跳过处理平移的过程。"

msgid "Moving an object relative to itself"
msgstr "相对于对象本身移动对象"

msgid ""
"A common operation, especially in 3D games, is to move an object relative to "
"itself. For example, in first-person shooter games, you would want the "
"character to move forward (-Z axis) when you press :kbd:`W`."
msgstr ""
"一种常见的操作，尤其是在 3D 游戏中，是相对于自身移动对象。例如，在第一人称射"
"击游戏中，当你按下 :kbd:`W` 键时，你希望角色向前移动（-Z 轴）。"

#, fuzzy
msgid ""
"Since the basis vectors are the orientation relative to the parent, and the "
"origin vector is the position relative to the parent, we can add multiples "
"of the basis vectors to move an object relative to itself."
msgstr ""
"由于基向量是相对于父对象的方向，而原点向量是相对于父对象的位置，因此我们可以"
"简单地将基向量的倍数相加，以相对于对象本身移动对象。"

msgid "This code moves an object 100 units to its own right:"
msgstr "此代码会让对象向它自己的右边移动 100 个单位："

msgid "For moving in 3D, you would need to replace \"x\" with \"basis.x\"."
msgstr "要在 3D 中移动，需要将“x”替换为“basis.x”。"

#, fuzzy
msgid ""
"In actual projects, you can use ``translate_object_local`` in 3D or "
"``move_local_x`` and ``move_local_y`` in 2D to do this."
msgstr ""
"在实际工程中，您可以使用 3D 中的 `translate_object_local` 或者 2D 中的 "
"`move_local_x` 和 `move_local_y` 来实现。"

msgid "Applying transforms onto transforms"
msgstr "将变换应用于变换"

msgid ""
"One of the most important things to know about transforms is how you can use "
"several of them together. A parent node's transform affects all of its "
"children. Let's dissect an example."
msgstr ""
"关于转换, 需要了解的最重要的事情之一是如何将几个转换一起使用. 父节点的变换会"
"影响其所有子节点. 让我们来剖析一个例子."

msgid ""
"In this image, the child node has a \"2\" after the component names to "
"distinguish them from the parent node. It might look a bit overwhelming with "
"so many numbers, but remember that each number is displayed twice (next to "
"the arrows and also in the matrices), and that almost half of the numbers "
"are zero."
msgstr ""
"在此图像中, 子节点的组件名称后面有一个 \"2\", 以将其与父节点区分开来. 这么多"
"数字可能看起来有点令人不知所措, 但请记住, 每个数字都会显示两次(在箭头旁边和矩"
"阵中), 而且几乎一半的数字都是零."

msgid ""
"The only transformations going on here are that the parent node has been "
"given a scale of (2, 1), the child has been given a scale of (0.5, 0.5), and "
"both nodes have been given positions."
msgstr ""
"这里进行的唯一转换是父节点的比例为(2,1), 子节点的比例为(0.5,0.5), 两个节点都"
"指定了位置."

#, fuzzy
msgid ""
"All child transformations are affected by the parent transformations. The "
"child has a scale of (0.5, 0.5), so you would expect it to be a 1:1 ratio "
"square, and it is, but only relative to the parent. The child's X vector "
"ends up being (1, 0) in world space, because it is scaled by the parent's "
"basis vectors. Similarly, the child node's ``origin`` vector is set to (1, "
"1), but this actually moves it (2, 1) in world space, due to the parent "
"node's basis vectors."
msgstr ""
"所有子变换都受父变换的影响。子对象的比例为 (0.5, 0.5)，因此您会认为它是 1:1 "
"的比例正方形，确实如此，但仅相对于父对象。子对象的 X 向量最终在世界空间中为 "
"(1, 0)，因为它是由父对象的基础向量缩放的。类似地，子节点的 `origin` 向量被设"
"置为(1,1)，但由于父节点的基向量，这实际上会在世界空间中移动 (2, 1)。"

msgid ""
"To calculate a child transform's world space transform manually, this is the "
"code we would use:"
msgstr "要手动计算子变换的世界空间变换, 我们将使用以下代码:"

#, fuzzy
msgid ""
"In actual projects, we can find the world transform of the child by applying "
"one transform onto another using the ``*`` operator:"
msgstr ""
"在实际工程中, 我们可以通过 `*` 运算符将一个变换应用到另一个变换中, 从而找到孩"
"子的世界变换:"

msgid "When multiplying matrices, order matters! Don't mix them up."
msgstr "当矩阵相乘时, 顺序很重要！别把它们弄混了."

msgid "Lastly, applying the identity transform will always do nothing."
msgstr "最后, 应用身份变换始终不起任何作用."

msgid ""
"If you would like additional explanation, you should check out 3Blue1Brown's "
"excellent video about matrix composition: https://www.youtube.com/watch?"
"v=XkY2DOUCWMU"
msgstr ""
"如果你想了解更多信息，可以查看 3Blue1Brown 关于矩阵组成的精彩视频：\\ http://"
"www.bilibili.com/video/BV1ys411472E?p=5"

msgid "Inverting a transformation matrix"
msgstr "求逆变换矩阵"

#, fuzzy
msgid ""
"The \"affine_inverse\" function returns a transform that \"undoes\" the "
"previous transform. This can be useful in some situations. Let's take a look "
"at a few examples."
msgstr ""
"\"affine_inverse\" 函数返回一个 \"撤销\" 前一个转换的转换. 这在某些情况下可能"
"很有用, 但只提供几个示例会更容易."

msgid ""
"Multiplying an inverse transform by the normal transform undoes all "
"transformations:"
msgstr "将反变换乘以法线变换将撤消所有变换:"

#, fuzzy
msgid ""
"Transforming a position by a transform and its inverse results in the same "
"position:"
msgstr "通过转换转换位置及其反转会导致相同的位置(与 \"xform_inv\" 相同):"

msgid "How does it all work in 3D?"
msgstr "这一切是如何在 3D 模式下工作的？"

#, fuzzy
msgid ""
"One of the great things about transformation matrices is that they work very "
"similarly between 2D and 3D transformations. All the code and formulas used "
"above for 2D work the same in 3D, with 3 exceptions: the addition of a third "
"axis, that each axis is of type :ref:`class_Vector3`, and also that Godot "
"stores the :ref:`class_Basis` separately from the :ref:`class_Transform3D`, "
"since the math can get complex and it makes sense to separate it."
msgstr ""
"变换矩阵的一个伟大之处在于, 它们在2D和3D变换之间的工作方式非常相似. 上面用于"
"2D的所有代码和公式在3D中的工作方式都相同, 只有3个不同之处: 增加了第三个轴, 每"
"个轴的类型为 :ref:`CLASS_Vector3`, 并且Godot将 :ref:`CLASS_Basis` 与 :ref:"
"`CLASS_Transform` 分开存储, 因为数学运算可能会很复杂, 因此将其分开是有意义的."

msgid ""
"All of the concepts for how translation, rotation, scale, and shearing work "
"in 3D are all the same compared to 2D. To scale, we take each component and "
"multiply it; to rotate, we change where each basis vector is pointing; to "
"translate, we manipulate the origin; and to shear, we change the basis "
"vectors to be non-perpendicular."
msgstr ""
"与二维相比, 有关平移, 旋转, 缩放和剪切在三维中的工作方式的所有概念都是相同"
"的. 要缩放, 我们取每个分量并将其相乘；要旋转, 我们更改每个基向量指向的位置；"
"要平移, 我们操纵原点；要剪切, 我们将基向量更改为不垂直."

msgid ""
"If you would like, it's a good idea to play around with transforms to get an "
"understanding of how they work. Godot allows you to edit 3D transform "
"matrices directly from the inspector. You can download this project which "
"has colored lines and cubes to help visualize the :ref:`class_Basis` vectors "
"and the origin in both 2D and 3D: https://github.com/godotengine/godot-demo-"
"projects/tree/master/misc/matrix_transform"
msgstr ""
"如果你愿意, 最好尝试一下转换, 以了解它们是如何工作的. Godot 允许你直接从检查"
"器编辑 3D 变换矩阵. 你可以下载此项目, 其中包含彩色线条和立方体, 以帮助在 2D "
"和 3D 中可视化 :ref:`class_Basis` 向量和原点: https://github.com/godotengine/"
"godot-demo-projects/tree/master/misc/matrix_transform"

#, fuzzy
msgid ""
"You cannot edit Node2D's transform matrix directly in Godot 4.0's inspector. "
"This may be changed in a future release of Godot."
msgstr ""
"不能在Godot 3.2的检查器中直接编辑Node2D的变换矩阵. 在Godot的未来版本中, 这一"
"点可能会有所改变."

msgid ""
"If you would like additional explanation, you should check out 3Blue1Brown's "
"excellent video about 3D linear transformations: https://www.youtube.com/"
"watch?v=rHLEWRxRGiM"
msgstr ""
"如果你想要更多的解释，你可以查看 3Blue1Brown 关于 3D 线性变换的精彩视频：\\ "
"http://www.bilibili.com/video/BV1ys411472E?p=6"

msgid "Representing rotation in 3D (advanced)"
msgstr "表示 3D 中的旋转（高级）"

msgid ""
"The biggest difference between 2D and 3D transformation matrices is how you "
"represent rotation by itself without the basis vectors."
msgstr ""
"2D 和 3D 变换矩阵之间最大的区别在于你如何在没有基向量的情况下自行表示旋转。"

#, fuzzy
msgid ""
"With 2D, we have an easy way (atan2) to switch between a transformation "
"matrix and an angle. In 3D, rotation is too complex to represent as one "
"number. There is something called Euler angles, which can represent "
"rotations as a set of 3 numbers, however, they are limited and not very "
"useful, except for trivial cases."
msgstr ""
"对于2D, 我们有一个在变换矩阵和角度之间切换的简单方法(Atan2). 在3D中, 我们不能"
"简单地将旋转表示为一个数字. 有一种叫做欧拉角的东西, 它可以将旋转表示为一组3个"
"数字, 但它们是有限的, 除了微不足道的情况外, 它们并不是很有用."

#, fuzzy
msgid ""
"In 3D we do not typically use angles, we either use a transformation basis "
"(used pretty much everywhere in Godot), or we use quaternions. Godot can "
"represent quaternions using the :ref:`class_Quaternion` struct. My "
"suggestion to you is to completely ignore how they work under-the-hood, "
"because they are very complicated and unintuitive."
msgstr ""
"在 3D 中，我们通常不使用角度，我们要么使用变换的基（在 Godot 中几乎到处都使"
"用），要么使用四元数。Godot 可以使用 :ref:`class_Quat` 结构表示四元数。我给你"
"的建议是完全忽略它们是如何在幕后工作的，因为它们非常复杂和不直观。"

msgid ""
"However, if you really must know how it works, here are some great "
"resources, which you can follow in order:"
msgstr ""
"然而, 如果你真的想知道它是如何工作的, 这里有一些很棒的参考资料, 你可以按顺序"
"跟随它们:"

msgid "https://www.youtube.com/watch?v=mvmuCPvRoWQ"
msgstr "http://www.bilibili.com/video/BV1fx41187tZ"

msgid "https://www.youtube.com/watch?v=d4EgbgTm0Bg"
msgstr "http://www.bilibili.com/video/BV1SW411y7W1"

msgid "https://eater.net/quaternions"
msgstr "https://eater.net/quaternions"

msgid "Translation status"
msgstr "翻译状态"
