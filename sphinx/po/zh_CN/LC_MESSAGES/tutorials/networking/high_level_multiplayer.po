# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "High-level multiplayer"
msgstr "高级多人游戏"

msgid "High-level vs low-level API"
msgstr "高层与底层 API"

msgid ""
"The following explains the differences of high- and low-level networking in "
"Godot as well as some fundamentals. If you want to jump in head-first and "
"add networking to your first nodes, skip to `Initializing the network`_ "
"below. But make sure to read the rest later on!"
msgstr ""
"下面解释了 Godot 高阶、低阶网络的区别以及一些基本原理。如果你想一头扎进去，直"
"接为你的最初的节点添加网络功能，请跳到下面的\\ `初始化网络`_\\ 。但是请确保稍"
"后阅读其余部分！"

#, fuzzy
msgid ""
"Godot always supported standard low-level networking via :abbr:`UDP (User "
"Datagram Protocol)`, :abbr:`TCP (Transmission Control Protocol)` and some "
"higher-level protocols such as :abbr:`HTTP (Hypertext Transfer Protocol)` "
"and :abbr:`SSL (Secure Sockets Layer)`. These protocols are flexible and can "
"be used for almost anything. However, using them to synchronize game state "
"manually can be a large amount of work. Sometimes that work can't be avoided "
"or is worth it, for example when working with a custom server implementation "
"on the backend. But in most cases, it's worthwhile to consider Godot's high-"
"level networking API, which sacrifices some of the fine-grained control of "
"low-level networking for greater ease of use."
msgstr ""
"Godot始终支持通过UDP, TCP 和一些更高级别的协议(如SSL和HTTP)进行标准的低级网络"
"连接. 这些协议非常灵活, 几乎可以用于任何事情. 然而, 使用它们来手动同步游戏状"
"态可能需要大量的工作. 有时这种工作是无法避免的, 或者是值得的, 例如在后台使用"
"自定义服务器实现时. 但在大多数情况下, 考虑Godot的高级网络API是值得的, 它牺牲"
"了对低级网络的一些细粒度控制, 以获得更大的易用性."

msgid "This is due to the inherent limitations of the low-level protocols:"
msgstr "这是底层协议的固有限制所造成的："

msgid ""
"TCP ensures packets will always arrive reliably and in order, but latency is "
"generally higher due to error correction. It's also quite a complex protocol "
"because it understands what a \"connection\" is, and optimizes for goals "
"that often don't suit applications like multiplayer games. Packets are "
"buffered to be sent in larger batches, trading less per-packet overhead for "
"higher latency. This can be useful for things like HTTP, but generally not "
"for games. Some of this can be configured and disabled (e.g. by disabling "
"\"Nagle's algorithm\" for the TCP connection)."
msgstr ""
"TCP 能够确保数据包总是可靠、有序地到达，但是由于错误纠正，延迟通常更高。它也"
"是一个相当复杂的协议，因为它理解什么是“连接”，它优化的目标也经常不是多人游戏"
"这种应用程序。数据包会被缓冲成更大的批次发送，用更高的延迟来交换更小的单数据"
"包开销。这对于 HTTP 之类的东西可能很有用，但对于游戏通常不太有用。其中一些可"
"以配置和禁用（例如禁用 TCP 连接的“Nagle 算法”）。"

msgid ""
"UDP is a simpler protocol, which only sends packets (and has no concept of a "
"\"connection\"). No error correction makes it pretty quick (low latency), "
"but packets may be lost along the way or received in the wrong order. Added "
"to that, the MTU (maximum packet size) for UDP is generally low (only a few "
"hundred bytes), so transmitting larger packets means splitting them, "
"reorganizing them and retrying if a part fails."
msgstr ""
"UDP 是一个更简单的协议，它只发送数据包（没有“连接”的概念）。因为没有错误纠"
"正，所以非常快（低延迟），但数据包就可能在发生丢失或以错误的顺序接收的情况。"
"此外，UDP 的 MTU（Maximum Packet Size，最大数据包大小）通常很低（只有几百字"
"节），因此传输更大的数据包意味着需要对它们进行分割、重新组织、某一部分失败时"
"还要进行重试。"

msgid ""
"In general, TCP can be thought of as reliable, ordered, and slow; UDP as "
"unreliable, unordered and fast. Because of the large difference in "
"performance, it often makes sense to re-build the parts of TCP wanted for "
"games (optional reliability and packet order), while avoiding the unwanted "
"parts (congestion/traffic control features, Nagle's algorithm, etc). Due to "
"this, most game engines come with such an implementation, and Godot is no "
"exception."
msgstr ""
"一般来说,TCP 可以被认为是可靠的, 有序的和缓慢的; UDP则是不可靠, 无序, 但是速"
"度快. 由于性能上的巨大差异, 在避免不需要的部分(拥塞/流量控制特性, Nagle算法"
"等)的同时, 重新构建游戏所需的TCP部分(可选的可靠性和包顺序)通常是合理的. 正因"
"为如此, 大多数游戏引擎都带有这样的实现,Godot也不例外."

msgid ""
"In summary, you can use the low-level networking API for maximum control and "
"implement everything on top of bare network protocols or use the high-level "
"API based on :ref:`SceneTree <class_SceneTree>` that does most of the heavy "
"lifting behind the scenes in a generally optimized way."
msgstr ""
"综上所述, 你可以使用低级网络API来实现最大限度的控制, 并在完全裸露的网络协议之"
"上实现所有功能, 或者使用基于 :ref:`SceneTree <class_SceneTree>` 的高级API, 后"
"者以通常以一种比较优化的方式在后台完成大部分繁重的工作."

msgid ""
"Most of Godot's supported platforms offer all or most of the mentioned high- "
"and low-level networking features. As networking is always largely hardware "
"and operating system dependent, however, some features may change or not be "
"available on some target platforms. Most notably, the HTML5 platform "
"currently offers WebSockets and WebRTC support but lacks some of the higher-"
"level features, as well as raw access to low-level protocols like TCP and "
"UDP."
msgstr ""
"Godot 支持的大多数平台都提供所有或大部分上述的高、低网络功能。但是，由于网络"
"在很大程度上依赖于硬件和操作系统，在某些目标平台上一些特性可能会改变或者不可"
"用。最值得注意的是 HTML5 平台目前只提供 WebSocket 和 WebRTC 支持，缺乏一些高"
"级功能，以及对 TCP 和 UDP 等低级协议的原始访问。"

msgid ""
"More about TCP/IP, UDP, and networking: https://gafferongames.com/post/"
"udp_vs_tcp/"
msgstr ""
"更多关于TCP/IP, UDP和网络的信息: https://gafferongames.com/post/udp_vs_tcp/"

msgid ""
"Gaffer On Games has a lot of useful articles about networking in Games "
"(`here <https://gafferongames.com/categories/game-networking/>`__), "
"including the comprehensive `introduction to networking models in games "
"<https://gafferongames.com/post/"
"what_every_programmer_needs_to_know_about_game_networking/>`__."
msgstr ""
"Gaffer On Games有很多关于游戏中网络的有用文章( `这里 <https://gafferongames."
"com/categories/game-networking/>`__ ), 包括全面的 `游戏中的网络模型介绍 "
"<https://gafferongames.com/post/"
"what_every_programmer_needs_to_know_about_game_networking/>`__ ."

msgid ""
"If you want to use your low-level networking library of choice instead of "
"Godot's built-in networking, see here for an example: https://github.com/"
"PerduGames/gdnet3"
msgstr ""
"如果你想使用你选择的底层网络库来代替Godot的内置网络, 请参阅这里的示例 : "
"https://github.com/PerduGames/gdnet3"

#, fuzzy
msgid ""
"Adding networking to your game comes with some responsibility. It can make "
"your application vulnerable if done wrong and may lead to cheats or "
"exploits. It may even allow an attacker to compromise the machines your "
"application runs on and use your servers to send spam, attack others or "
"steal your users' data if they play your game."
msgstr ""
"在您的游戏中加入社交网络需要承担一定的责任. 如果做错了, 它会使您的应用程序很"
"容易受到攻击, 并可能导致欺骗或利用. 它甚至可能允许攻击者破坏您的应用程序运行"
"在的机器, 并使用您的服务器发送垃圾邮件, 攻击其他人或窃取您的用户数据, 如果他"
"们玩您的游戏."

msgid ""
"This is always the case when networking is involved and has nothing to do "
"with Godot. You can of course experiment, but when you release a networked "
"application, always take care of any possible security concerns."
msgstr ""
"当涉及到网络而与Godot无关时, 情况总是如此. 当然, 你可以进行试验, 但是在发布网"
"络应用程序时, 请始终注意任何可能的安全问题."

msgid "Mid-level abstraction"
msgstr "中级抽象"

msgid ""
"Before going into how we would like to synchronize a game across the "
"network, it can be helpful to understand how the base network API for "
"synchronization works."
msgstr ""
"在讨论我们希望如何跨网络同步游戏之前, 了解用于同步的基本网络API是如何工作的可"
"能会有所帮助."

#, fuzzy
msgid ""
"Godot uses a mid-level object :ref:`MultiplayerPeer "
"<class_MultiplayerPeer>`. This object is not meant to be created directly, "
"but is designed so that several C++ implementations can provide it."
msgstr ""
"Godot使用了一个中层对象 :ref:`NetworkedMultiplayerPeer "
"<class_NetworkedMultiplayerPeer>`. 这个对象并不是直接创建的, 但经过设计, 以便"
"多个C++实现可以提供它."

msgid ""
"This object extends from :ref:`PacketPeer <class_PacketPeer>`, so it "
"inherits all the useful methods for serializing, sending and receiving data. "
"On top of that, it adds methods to set a peer, transfer mode, etc. It also "
"includes signals that will let you know when peers connect or disconnect."
msgstr ""
"这个对象扩展自 :ref:`PacketPeer <class_PacketPeer>`, 因此它继承了所有用于序列"
"化, 发送和接收数据的方法. 除此之外, 它还添加了设置节点, 传输模式等的方法. 它"
"同时还包括当节点连接或断开时将通知你的信号."

#, fuzzy
msgid ""
"This class interface can abstract most types of network layers, topologies "
"and libraries. By default, Godot provides an implementation based on ENet (:"
"ref:`ENetMultiplayerPeer <class_ENetMultiplayerPeer>`), one based on WebRTC "
"(:ref:`WebRTCMultiplayerPeer <class_WebRTCMultiplayerPeer>`), and one based "
"on WebSocket (:ref:`WebSocketPeer <class_WebSocketPeer>`), but this could be "
"used to implement mobile APIs (for ad hoc WiFi, Bluetooth) or custom device/"
"console-specific networking APIs."
msgstr ""
"这个类接口可以抽象出大多数类型的网络层, 拓扑结构和库。默认情况下，Godot提供了"
"一个基于ENet的实现( :ref:`NetworkedMultiplayerEnet "
"<class_NetworkedMultiplayerENet>`), 一个基于WebRTC的实现( :ref:"
"`WebRTCMultiplayer <class_WebRTCMultiplayer>`), 还有一个基于WebSocket的实现"
"( :ref:`WebSocketMultiplayerPeer<class_WebSocketMultiplayerPeer>`)，但这可以"
"用来实现移动API(用于特设的WiFi, 蓝牙)或自定义设备/控制台特定的网络API。"

#, fuzzy
msgid ""
"For most common cases, using this object directly is discouraged, as Godot "
"provides even higher level networking facilities. This object is still made "
"available in case a game has specific needs for a lower-level API."
msgstr ""
"大多数常见情况下, 不鼓励直接使用这个对象, 因为Godot提供了更高级别的网络使用. "
"只有当游戏对较低级别的API有特殊需求的情况下, 才使用它."

msgid "Hosting considerations"
msgstr "托管注意事项"

msgid ""
"When hosting a server, clients on your :abbr:`LAN (Local Area Network)` can "
"connect using the internal IP address which is usually of the form ``192.168."
"*.*``. This internal IP address is **not** reachable by non-LAN/Internet "
"clients."
msgstr ""

msgid ""
"On Windows, you can find your internal IP address by opening a command "
"prompt and entering ``ipconfig``. On macOS, open a Terminal and enter "
"``ifconfig``. On Linux, open a terminal and enter ``ip addr``."
msgstr ""

msgid ""
"If you're hosting a server on your own machine and want non-LAN clients to "
"connect to it, you'll probably have to *forward* the server port on your "
"router. This is required to make your server reachable from the Internet "
"since most residential connections use a `NAT <https://en.wikipedia.org/wiki/"
"Network_address_translation>`__. Godot's high-level multiplayer API only "
"uses UDP, so you must forward the port in UDP, not just TCP."
msgstr ""

msgid ""
"After forwarding an UDP port and making sure your server uses that port, you "
"can use `this website <https://icanhazip.com/>`__ to find your public IP "
"address. Then give this public IP address to any Internet clients that wish "
"to connect to your server."
msgstr ""

msgid ""
"Godot's high-level multiplayer API uses a modified version of ENet which "
"allows for full IPv6 support."
msgstr ""

msgid "Initializing the network"
msgstr "初始化网络"

#, fuzzy
msgid ""
"High level networking in Godot is managed by the :ref:`SceneTree "
"<class_SceneTree>`."
msgstr ""
"在Godot中, 控制联网的对象与控制所有与树相关的东西的对象是相同的: :ref:"
"`SceneTree <class_SceneTree>`."

msgid ""
"Each node has a ``multiplayer`` property, which is a reference to the "
"``MultiplayerAPI`` instance configured for it by the scene tree. Initially, "
"every node is configured with the same default ``MultiplayerAPI`` object."
msgstr ""

msgid ""
"It is possible to create a new ``MultiplayerAPI`` object and assign it to a "
"``NodePath`` in the the scene tree, which will override ``multiplayer`` for "
"the node at that path and all of its descendants. This allows sibling nodes "
"to be configured with different peers, which makes it possible to run a "
"server and a client simultaneously in one instance of Godot."
msgstr ""

msgid ""
"To initialize networking, a ``MultiplayerPeer`` object must be created, "
"initialized as a server or client, and passed to the ``MultiplayerAPI``."
msgstr ""

#, fuzzy
msgid "To terminate networking:"
msgstr "停止联网功能:"

msgid ""
"When exporting to Android, make sure to enable the ``INTERNET`` permission "
"in the Android export preset before exporting the project or using one-click "
"deploy. Otherwise, network communication of any kind will be blocked by "
"Android."
msgstr ""
"当导出到 Android 时，在导出项目或使用一键部署之前，确保在 Android 导出预设中"
"启用 ``INTERNET`` 权限。否则，任何形式的网络通信都会被 Android 系统阻止。"

msgid "Managing connections"
msgstr "管理连接"

msgid ""
"Every peer is assigned a unique ID. The server's ID is always 1, and clients "
"are assigned a random positive integer."
msgstr ""

msgid ""
"Responding to connections or disconnections is possible by connecting to "
"``MultiplayerAPI``'s signals:"
msgstr ""

msgid ""
"``peer_connected(id: int)`` This signal is emitted with the newly connected "
"peer's ID on each other peer, and on the new peer multiple times, once with "
"each other peer's ID."
msgstr ""

msgid ""
"``peer_disconnected(id: int)`` This signal is emitted on every remaining "
"peer when one disconnects."
msgstr ""

#, fuzzy
msgid "The rest are only emitted on clients:"
msgstr "有以下注意事项:"

msgid "``connected_to_server()``"
msgstr "``connected_to_server()``"

msgid "``connection_failed()``"
msgstr "``connection_failed()``"

msgid "``server_disconnected()``"
msgstr "``server_disconnected()``"

msgid "To get the unique ID of the associated peer:"
msgstr ""

#, fuzzy
msgid "To check whether the peer is server or client:"
msgstr "检查树是否被初始化为服务器或客户端:"

msgid "Remote procedure calls"
msgstr "远程过程调用"

msgid ""
"Remote procedure calls, or RPCs, are functions that can be called on other "
"peers. To create one, use the ``@rpc`` annotation before a function "
"definition. To call an RPC, use ``Callable``'s method ``rpc()`` to call in "
"every peer, or ``rpc_id()`` to call in a specific peer."
msgstr ""

msgid "RPCs will not serialize objects or callables."
msgstr ""

msgid ""
"For a remote call to be successful, the sending and receiving node need to "
"have the same ``NodePath``, which means they must have the same name. When "
"using ``add_child()`` for nodes which are expected to use RPCs, set the "
"argument ``force_readable_name`` to ``true``."
msgstr ""

msgid ""
"If a function is annotated with ``@rpc`` on the client script (resp. server "
"script), then this function must also be declared on the server script "
"(resp. client script). Both RPCs must have the same signature which is "
"evaluated with a checksum of **all RPCs**. All RPCs in a script are checked "
"at once, and all RPCs must be declared on both the client scripts and the "
"server scripts, **even functions that are currently not in use**."
msgstr ""

msgid ""
"The signature of the RPC includes the ``@rpc()`` declaration, the function, "
"return type, AND the nodepath. If an RPC resides in a script attached to ``/"
"root/Main/Node1``, then it must reside in precisely the same path and node "
"on both the client script and the server script. Function arguments "
"(example: ``func sendstuff():`` and ``func sendstuff(arg1, arg2):`` **will "
"pass** signature matching)."
msgstr ""

msgid ""
"If these conditions are not met (if all RPCs do not pass signature "
"matching), the script may print an error or cause unwanted behavior. The "
"error message may be unrelated to the RPC function you are currently "
"building and testing."
msgstr ""

msgid ""
"See further explanation and troubleshooting on `this post <https://github."
"com/godotengine/godot/issues/57869#issuecomment-1034215138>`__."
msgstr ""

msgid ""
"The annotation can take a number of arguments, which have default values. "
"``@rpc`` is equivalent to:"
msgstr ""

#, fuzzy
msgid "The parameters and their functions are as follows:"
msgstr "最常见的用例如下:"

msgid "``mode``:"
msgstr "``mode``："

msgid ""
"``\"authority\"``: Only the multiplayer authority (the server) can call "
"remotely."
msgstr ""

msgid ""
"``\"any_peer\"``: Clients are allowed to call remotely. Useful for "
"transferring user input."
msgstr ""

msgid "``sync``:"
msgstr "``remotesync`` ："

#, fuzzy
msgid "``\"call_remote\"``: The function will not be called on the local peer."
msgstr "**注意**\\ ：如果引擎崩溃或无响应，该函数不会被调用。"

msgid ""
"``\"call_local\"``: The function can be called on the local peer. Useful "
"when the server is also a player."
msgstr ""

msgid "``transfer_mode``:"
msgstr "``transform`` ："

msgid ""
"``\"unreliable\"`` Packets are not acknowledged, can be lost, and can arrive "
"at any order."
msgstr ""

msgid ""
"``\"unreliable_ordered\"`` Packets are received in the order they were sent "
"in. This is achieved by ignoring packets that arrive later if another that "
"was sent after them has already been received. Can cause packet loss if used "
"incorrectly."
msgstr ""

msgid ""
"``\"reliable\"`` Resend attempts are sent until packets are acknowledged, "
"and their order is preserved. Has a significant performance penalty."
msgstr ""

msgid "``transfer_channel`` is the channel index."
msgstr ""

msgid ""
"The first 3 can be passed in any order, but ``transfer_channel`` must always "
"be last."
msgstr ""

msgid ""
"The function ``multiplayer.get_remote_sender_id()`` can be used to get the "
"unique id of an rpc sender, when used within the function called by rpc."
msgstr ""

msgid "Channels"
msgstr "通道"

msgid ""
"Modern networking protocols support channels, which are separate connections "
"within the connection. This allows for multiple streams of packets that do "
"not interfere with each other."
msgstr ""

msgid ""
"For example, game chat related messages and some of the core gameplay "
"messages should all be sent reliably, but a gameplay message should not wait "
"for a chat message to be acknowledged. This can be achieved by using "
"different channels."
msgstr ""

msgid ""
"Channels are also useful when used with the unreliable ordered transfer "
"mode. Sending packets of variable size with this transfer mode can cause "
"packet loss, since packets which are slower to arrive are ignored. "
"Separating them into multiple streams of homogeneous packets by using "
"channels allows ordered transfer with little packet loss, and without the "
"latency penalty caused by reliable mode."
msgstr ""

msgid ""
"The default channel with index 0 is actually three different channels - one "
"for each transfer mode."
msgstr ""

msgid "Example lobby implementation"
msgstr "大厅的示例实现"

msgid ""
"This is an example lobby that can handle peers joining and leaving, notify "
"UI scenes through signals, and start the game after all clients have loaded "
"the game scene."
msgstr ""

msgid ""
"The game scene's root node should be named Game. In the script attached to "
"it:"
msgstr ""

msgid "Exporting for dedicated servers"
msgstr "为专用服务器导出"

msgid ""
"Once you've made a multiplayer game, you may want to export it to run it on "
"a dedicated server with no GPU available. See :ref:"
"`doc_exporting_for_dedicated_servers` for more information."
msgstr ""
"一旦你制作了一个多人游戏, 你可能会想导出它到一个没有GPU的专用服务器上运行. 参"
"见 :ref:`doc_exporting_for_dedicated_servers` 获取更多信息."

msgid ""
"The code samples on this page aren't designed to run on a dedicated server. "
"You'll have to modify them so the server isn't considered to be a player. "
"You'll also have to modify the game starting mechanism so that the first "
"player who joins can start the game."
msgstr ""
"这个页面上的代码样本并不是为了在专用服务器上运行而设计的. 必须修改它们, 使服"
"务器不被认为是一个玩家, 还必须修改游戏启动机制, 使第一个加入的玩家可以启动游"
"戏."

msgid "Translation status"
msgstr "翻译状态"
