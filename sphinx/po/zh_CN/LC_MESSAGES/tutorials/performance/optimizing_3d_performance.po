# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "optimization"
msgstr "优化"

msgid "Optimizing 3D performance"
msgstr "优化 3D 性能"

msgid "Culling"
msgstr "剔除"

msgid ""
"Godot will automatically perform view frustum culling in order to prevent "
"rendering objects that are outside the viewport. This works well for games "
"that take place in a small area, however things can quickly become "
"problematic in larger levels."
msgstr ""
"Godot会自动执行视图视锥剔除, 以防止渲染视口外的物体. 这对于发生在小范围内的游"
"戏来说效果很好, 然而在较大的关卡中, 事情很快就会变得很麻烦."

msgid "Occlusion culling"
msgstr "遮挡剔除"

msgid ""
"Walking around a town for example, you may only be able to see a few "
"buildings in the street you are in, as well as the sky and a few birds "
"flying overhead. As far as a naive renderer is concerned however, you can "
"still see the entire town. It won't just render the buildings in front of "
"you, it will render the street behind that, with the people on that street, "
"the buildings behind that. You quickly end up in situations where you are "
"attempting to render 10× or 100× more than what is visible."
msgstr ""
"比如走在一个小镇上, 你可能只能看到你所在的街道上的几栋建筑, 以及天空和几只飞"
"过头顶的鸟. 然而就一个天真的渲染器而言, 你仍然可以看到整个小镇. 它不会只渲染"
"你前面的建筑, 它会渲染那后面的街道, 与那条街上的人, 那后面的建筑. 你很快就会"
"遇到这样的情况: 你试图渲染比可见的东西多10倍或100倍的东西."

#, fuzzy
msgid ""
"Things aren't quite as bad as they seem, because the Z-buffer usually allows "
"the GPU to only fully shade the objects that are at the front. This is "
"called *depth prepass* and is enabled by default in Godot when using the "
"Forward+ or Compatibility rendering methods. However, unneeded objects are "
"still reducing performance."
msgstr ""
"事情并没有看上去那么糟糕，因为 Z 缓冲通常只允许 GPU 完全遮挡在前面的物体。这"
"被称为\\ *深度预处理*\\ （depth prepass），在使用 GLES3 渲染器时，Godot 默认"
"启用。然而，不需要的对象仍然在降低性能。"

msgid ""
"One way we can potentially reduce the amount to be rendered is to **take "
"advantage of occlusion**. Godot 4.0 and later offers a new approach to "
"occlusion culling using occluder nodes. See :ref:`doc_occlusion_culling` for "
"instructions on setting up occlusion culling in your scene."
msgstr ""

#, fuzzy
msgid ""
"In some cases, you may have to adapt your level design to add more occlusion "
"opportunities. For example, you may have to add more walls to prevent the "
"player from seeing too far away, which would decrease performance due to the "
"lost opportunities for occlusion culling."
msgstr ""
"在某些情况下，你可以通过调整你的关卡设计来增加更多的遮挡机会。例如，你可以增"
"加更多的墙来防止玩家看得太远，否则就会因为失去了遮挡机会而降低性能。"

msgid "Transparent objects"
msgstr "透明物体"

msgid ""
"Godot sorts objects by :ref:`Material <class_Material>` and :ref:`Shader "
"<class_Shader>` to improve performance. This, however, can not be done with "
"transparent objects. Transparent objects are rendered from back to front to "
"make blending with what is behind work. As a result, **try to use as few "
"transparent objects as possible**. If an object has a small section with "
"transparency, try to make that section a separate surface with its own "
"material."
msgstr ""
"Godot通过 :ref:`Material <class_Material>` 和 :ref:`Shader <class_Shader>` 对"
"对象进行排序以提高性能. 然而, 这对透明物体来说是不可能的. 透明物体从后往前渲"
"染, 以便与后面的物体混合. 因此, **尽量少使用透明对象** . 如果一个物体有一小部"
"分是透明的, 尽量让这部分成为一个独立的表面, 有自己的材质."

msgid ""
"For more information, see the :ref:`GPU optimizations "
"<doc_gpu_optimization>` doc."
msgstr "更多信息请参阅 :ref:`GPU 优化 <doc_gpu_optimization>` 文档。"

msgid "Level of detail (LOD)"
msgstr "细节程度（LOD）"

msgid ""
"In some situations, particularly at a distance, it can be a good idea to "
"**replace complex geometry with simpler versions**. The end user will "
"probably not be able to see much difference. Consider looking at a large "
"number of trees in the far distance. There are several strategies for "
"replacing models at varying distance. You could use lower poly models, or "
"use transparency to simulate more complex geometry."
msgstr ""
"在某些情况下, 特别是在远处, 用简单的版本**代替复杂的几何图形可能是个好主意. "
"最终用户可能看不出什么区别. 考虑看看远处的大量树木. 有几种策略可以替换不同距"
"离的模型. 你可以使用较低的多边形模型, 或者使用透明度来模拟更复杂的几何体."

msgid "Godot 4 offers several ways to control level of detail:"
msgstr "Godot 4 提供了多种控制细节层次的方法："

msgid "An automatic approach on mesh import using :ref:`doc_mesh_lod`."
msgstr "使用 :ref:`doc_mesh_lod` 进行网格导入的自动方法。"

msgid ""
"A manual approach configured in the 3D node using :ref:"
"`doc_visibility_ranges`."
msgstr ""

msgid ""
":ref:`Decals <doc_using_decals>` and :ref:`lights <doc_lights_and_shadows>` "
"can also benefit from level of detail using their respective **Distance "
"Fade** properties."
msgstr ""

msgid ""
"While they can be used independently, these approaches are most effective "
"when used together. For example, you can set up visibility ranges to hide "
"particle effects that are too far away from the player to notice. At the "
"same time, you can rely on mesh LOD to make the particle effect's meshes "
"rendered with less detail at a distance."
msgstr ""

msgid ""
"Visibility ranges are also a good way to set up *impostors* for distant "
"geometry (see below)."
msgstr ""

msgid "Billboards and imposters"
msgstr "Billboard 和 imposter"

#, fuzzy
msgid ""
"The simplest version of using transparency to deal with LOD is billboards. "
"For example, you can use a single transparent quad to represent a tree at "
"distance. This can be very cheap to render, unless of course, there are many "
"trees in front of each other. In this case, transparency may start eating "
"into fill rate (for more information on fill rate, see :ref:"
"`doc_gpu_optimization`)."
msgstr ""
"使用透明度来处理LOD的最简单版本是广告牌. 例如, 你可以用一个单一的透明四边形来"
"表示一棵树的距离. 这可以是非常便宜的渲染, 当然, 除非前面有很多树. 在这种情况"
"下, 透明度可能会开始吞噬填充率(关于填充率的更多信息, 请参见 :ref:"
"`doc_gpu_optimization`)."

msgid ""
"An alternative is to render not just one tree, but a number of trees "
"together as a group. This can be especially effective if you can see an area "
"but cannot physically approach it in a game."
msgstr ""
"另一种方法是不只渲染一棵树, 而是将一些树作为一组来渲染. 如果你能看到一个区"
"域, 但在游戏中不能实际接近它, 这可能是特别有效的."

msgid ""
"You can make imposters by pre-rendering views of an object at different "
"angles. Or you can even go one step further, and periodically re-render a "
"view of an object onto a texture to be used as an imposter. At a distance, "
"you need to move the viewer a considerable distance for the angle of view to "
"change significantly. This can be complex to get working, but may be worth "
"it depending on the type of project you are making."
msgstr ""
"你可以通过预先渲染对象的不同角度的视图来制作冒牌货. 或者你甚至可以更进一步, "
"周期性地将一个物体的视图重新渲染到一个纹理上, 作为一个冒牌货使用. 在远处, 你"
"需要将观察者移动相当长的距离, 视角才会发生显著变化. 这可能是复杂的工作, 但可"
"能是值得的, 这取决于你正在制作的项目类型."

msgid "Use instancing (MultiMesh)"
msgstr "使用实例化（MultiMesh）"

msgid ""
"If several identical objects have to be drawn in the same place or nearby, "
"try using :ref:`MultiMesh <class_MultiMesh>` instead. MultiMesh allows the "
"drawing of many thousands of objects at very little performance cost, making "
"it ideal for flocks, grass, particles, and anything else where you have "
"thousands of identical objects."
msgstr ""
"如果必须在同一地点或附近绘制多个相同的对象, 请尝试使用 :ref:`MultiMesh "
"<class_MultiMesh>` 来代替.MultiMesh允许以很小的性能代价来绘制成千上万的对象, "
"这使得它非常适合用于绘制羊群, 草地, 粒子以及其他任何有成千上万相同对象的地方."

#, fuzzy
msgid ""
"See also the :ref:`Using MultiMesh <doc_using_multimesh>` documentation."
msgstr "另请参阅 :ref:`Using MultiMesh <doc_using_multimesh>` 文档."

msgid "Bake lighting"
msgstr "烘焙照明"

#, fuzzy
msgid ""
"Lighting objects is one of the most costly rendering operations. Realtime "
"lighting, shadows (especially multiple lights), and :ref:`global "
"illumination <doc_introduction_to_global_illumination>` are especially "
"expensive. They may simply be too much for lower power mobile devices to "
"handle."
msgstr ""
"对物体进行照明是最昂贵的渲染操作之一. 实时光照, 阴影(尤其是很多灯光)和 GI 都"
"特别昂贵. 对于低功率的移动设备来说, 它们可能根本无法处理."

#, fuzzy
msgid ""
"**Consider using baked lighting**, especially for mobile. This can look "
"fantastic, but has the downside that it will not be dynamic. Sometimes, this "
"is a tradeoff worth making."
msgstr ""
"**考虑使用烘焙照明** , 尤其是移动端, 这看起来很棒, 但有一个缺点, 那就是它不是"
"动态的, 有时, 这需要做出的权衡."

msgid ""
"See :ref:`doc_using_lightmap_gi` for instructions on using baked lightmaps. "
"For best performance, you should set lights' bake mode to **Static** as "
"opposed to the default **Dynamic**, as this will skip real-time lighting on "
"meshes that have baked lighting."
msgstr ""

msgid ""
"The downside of lights with the **Static** bake mode is that they can't cast "
"shadows onto meshes with baked lighting. This can make scenes with outdoor "
"environments and dynamic objects look flat. A good balance between "
"performance and quality is to keep **Dynamic** for the :ref:"
"`class_DirectionalLight3D` node, and use **Static** for most (if not all) "
"omni and spot lights."
msgstr ""

msgid "Animation and skinning"
msgstr "动画和皮肤"

#, fuzzy
msgid ""
"Animation and vertex animation such as skinning and morphing can be very "
"expensive on some platforms. You may need to lower the polycount "
"considerably for animated models, or limit the number of them on screen at "
"any given time. You can also reduce the animation rate for distant or "
"occluded meshes, or pause the animation entirely if the player is unlikely "
"to notice the animation being stopped."
msgstr ""
"在某些平台上, 动画和顶点动画(如换肤和变形)可能非常昂贵. 你可能需要大大降低动"
"画模型的多边形数量, 或者任何时候限制屏幕上的模型数量."

msgid ""
"The :ref:`class_VisibleOnScreenEnabler3D` and :ref:"
"`class_VisibleOnScreenNotifier3D` nodes can be useful for this purpose."
msgstr ""

msgid "Large worlds"
msgstr "庞大的世界"

msgid ""
"If you are making large worlds, there are different considerations than what "
"you may be familiar with from smaller games."
msgstr "如果你要制作大型游戏, 则与小型游戏可能会有所不同."

msgid ""
"Large worlds may need to be built in tiles that can be loaded on demand as "
"you move around the world. This can prevent memory use from getting out of "
"hand, and also limit the processing needed to the local area."
msgstr ""
"大型的世界可能需要用碎片建立, 可以在你在世界中移动时按需加载, 这可以防止内存"
"使用失控, 也可以将所需的处理限制在局部区域."

#, fuzzy
msgid ""
"There may also be rendering and physics glitches due to floating point error "
"in large worlds. This can be resolved using :ref:"
"`doc_large_world_coordinates`. If using large world coordinates is an "
"option, you may be able to use techniques such as orienting the world around "
"the player (rather than the other way around), or shifting the origin "
"periodically to keep things centred around ``Vector3(0, 0, 0)``."
msgstr ""
"在大型世界中, 由于浮点错误, 也可能会出现渲染和物理故障, 你可能会使用一些技"
"术, 比如将世界围绕着玩家的方向(而不是相反), 或者定期移动原点以保持以 "
"``Vector3(0, 0, 0)`` 为中心."

msgid "Translation status"
msgstr "翻译状态"
