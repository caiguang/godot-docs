# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "2D lights and shadows"
msgstr "2D 灯光和阴影"

msgid "Introduction"
msgstr "前言"

msgid ""
"By default, 2D scenes in Godot are unshaded, with no lights and shadows "
"visible. While this is fast to render, unshaded scenes can look bland. Godot "
"provides the ability to use real-time 2D lighting and shadows, which can "
"greatly enhance the sense of depth in your project."
msgstr ""
"默认情况下，Godot 中的 2D 场景采用无光照着色，看不到灯光和阴影。虽然渲染速度"
"很快，但无阴影的场景看起来会很平淡。Godot 提供了可以使用实时 2D 照明和阴影的"
"功能，可以大大增强项目的层次感。"

msgid "No 2D lights or shadows, scene is unshaded"
msgstr "无 2D 灯光或阴影，场景采用无光照着色"

msgid "2D lights enabled (without shadows)"
msgstr "已启用无阴影的 2D 灯光"

msgid "2D lights and shadows enabled"
msgstr "2D 灯光和阴影以启用"

msgid "Nodes"
msgstr "节点"

msgid "There are several nodes involved in a complete 2D lighting setup:"
msgstr "完整的二维照明设置涉及多个节点："

msgid ""
":ref:`CanvasModulate <class_CanvasModulate>` (to darken the rest of the "
"scene)"
msgstr ":ref:`CanvasModulate<class_CanvasModulate>` 用于使场景变暗"

msgid ""
":ref:`PointLight2D <class_PointLight2D>` (for omnidirectional or spot lights)"
msgstr ":ref:`PointLight2D <class_PointLight2D>`\\ （用于全向或点光源）"

msgid ""
":ref:`DirectionalLight2D <class_DirectionalLight2D>` (for sunlight or "
"moonlight)"
msgstr ""
":ref:`DirectionalLight2D <class_DirectionalLight2D>`\\ （用于日光或月光）"

msgid ""
":ref:`LightOccluder2D <class_LightOccluder2D>` (for light shadow casters)"
msgstr ":ref:`LightOccluder2D <class_LightOccluder2D>`"

msgid "Other 2D nodes that receive lighting, such as Sprite2D or TileMap."
msgstr "其他可接收光照的 2D 节点，如 Sprite2D 或 TileMap。"

msgid ""
":ref:`CanvasModulate <class_CanvasModulate>` is used to darken the scene by "
"specifying a color that will act as the base \"ambient\" color. This is the "
"final lighting color in areas that are *not* reached by any 2D light. "
"Without a CanvasModulate node, the final scene would look too bright as 2D "
"lights would only brighten the existing unshaded appearance (which appears "
"fully lit)."
msgstr ""
":ref:`CanvasModulate<class_CanvasModulate>` 用于指定一种颜色作为“环境”基色，"
"从而使场景变暗。这是任何 2D 灯光都 **无法** 到达区域的最终照明颜色。如果没有 "
"CanvasModulate 节点，由于 2D 灯光只会照亮现有的无阴影外观（看起来完全亮了），"
"最终场景看起来会过于明亮。"

msgid ""
":ref:`Sprite2Ds <class_Sprite2D>` are used to display the textures for the "
"light blobs, the background, and for the shadow casters."
msgstr ""
":ref:`Sprite2Ds <class_Sprite2D>` 用于显示灯泡、背景和阴影投射器的纹理。"

msgid ""
":ref:`PointLight2Ds <class_PointLight2D>` are used to light the scene. The "
"way a light typically works is by adding a selected texture over the rest of "
"the scene to simulate lighting."
msgstr ""
":ref:`Light2Ds <class_Light2D>` 用于点亮场景。光通常的工作方式是在场景的其余"
"部分添加选定的纹理以模拟光照。但它可以以其他方式使用，例如屏蔽部分场景。"

msgid ""
":ref:`LightOccluder2Ds <class_LightOccluder2D>` are used to tell the shader "
"which parts of the scene cast shadows. These occluders can be placed as "
"independent nodes or can be part of a TileMap node."
msgstr ""
":ref:`LightOccluder2Ds <class_LightOccluder2D>` 用于告诉着色器场景的哪些部分"
"投射阴影。 这些遮挡物可以放置为独立节点，也可以作为 TileMap 节点的一部分。"

msgid ""
"The shadows appear only on areas covered by the :ref:`PointLight2D "
"<class_PointLight2D>` and their direction is based on the center of the :ref:"
"`Light <class_PointLight2D>`."
msgstr ""
"阴影仅出现在 :ref:`PointLight2D <class_PointLight2D>` 覆盖的区域上，并且其方"
"向基于 :ref:`Light <class_PointLight2D>` 的中心。"

msgid ""
"The background color does **not** receive any lighting. If you want light to "
"be cast on the background, you need to add a visual representation for the "
"background, such as a Sprite2D."
msgstr ""
"背景色 **不会** 接收任何光照。如果要在背景上投射灯光，则需要为背景添加可视化"
"表示，例如 Sprite2D。"

msgid ""
"The Sprite2D's **Region** properties can be helpful to quickly create a "
"repeating background texture, but remember to also set **Texture > Repeat** "
"to **Enabled** in the Sprite2D's properties."
msgstr ""
"Sprite2D 的 **Region** 属性有助于快速创建重复的背景纹理，但要记住在 Sprite2D "
"属性中将 **Texture > Repeat** 设置为 **Enabled** 。"

msgid "Point lights"
msgstr "点光源"

msgid ""
"Point lights (also called positional lights) are the most common element in "
"2D lighting. Point lights can be used to represent light from torches, fire, "
"projectiles, etc."
msgstr ""
"点光源（也称位置光源）是 2D 照明中最常见的元素。点光源可用于表示火把、火、射"
"弹等发出的光。"

msgid "PointLight2D offers the following properties to tweak in the inspector:"
msgstr "PointLight2D 提供了以下属性，可在检查器中进行调整："

msgid ""
"**Texture:** The texture to use as a light source. The texture's size "
"determines the size of the light. The texture may have an alpha channel, "
"which is useful when using Light2D's **Mix** blend mode, but it is not "
"required if using the **Add** (default) or **Subtract** blend modes."
msgstr ""
"**纹理：** 用作光源的纹理。纹理的大小决定光源的大小。纹理可以有一个 alpha 通"
"道，这在使用 Light2D 的 **Mix** 混合模式时非常有用，但在使用 **Add** （默认）"
"或 **Subtract** 混合模式时则不需要。"

msgid ""
"**Offset:** The offset for the light texture. Unlike when you move the light "
"node, changing the offset does *not* cause shadows to move."
msgstr ""
"**偏移量：** 灯光纹理的偏移量。与移动灯光节点不同，改变偏移量 *不会* 导致阴影"
"移动。"

msgid ""
"**Texture Scale:** The multiplier for the light's size. Higher values will "
"make the light extend out further. Larger lights have a higher performance "
"cost as they affect more pixels on screen, so consider this before "
"increasing a light's size."
msgstr ""
"**纹理缩放：** 灯光大小的乘法器。数值越大，灯光越亮。较大的灯光会影响屏幕上更"
"多的像素，因此在增大灯光尺寸前要考虑到这一点。"

msgid ""
"**Height:** The light's virtual height with regards to normal mapping. By "
"default, the light is very close to surfaces receiving lights. This will "
"make lighting hardly visible if normal mapping is used, so consider "
"increasing this value. Adjusting the light's height only makes a visible "
"difference on surfaces that use normal mapping."
msgstr ""
"**高度：** 灯光在法线贴图中的虚拟高度。默认情况下，灯光与接收灯光的表面非常接"
"近。如果使用法线贴图，这将使灯光几乎不可见，因此可以考虑增加此值。只有在使用"
"法线贴图的表面上，调整灯光的高度才会产生明显的不同。"

msgid ""
"If you don't have a pre-made texture to use in a light, you can use this "
"\"neutral\" point light texture (right-click > **Save Image As…**):"
msgstr ""
"如果没有预制纹理可用于灯光，可以使用这种 “中性 ”点光源纹理（右键单击 > **图像"
"另存为...** ）："

msgid "Neutral point light texture"
msgstr "紫外线对质地轻"

msgid ""
"If you need different falloff, you can procedurally create a texture by "
"assigning a **New GradientTexture2D** on the light's **Texture** property. "
"After creating the resource, expand its **Fill** section and set the fill "
"mode to **Radial**. You will then have to adjust the gradient itself to "
"start from opaque white to transparent white, and move its starting location "
"to be in the center."
msgstr ""
"如果你需要不同的渐变，可以通过在灯光的 **纹理** 属性上分配 **新建 "
"GradientTexture2D** 来程序化地创建纹理。创建资源后，展开其 **Fill** 部分并将"
"填充模式设置为 **Radial** 。然后，你需要调整渐变本身，使其从不透明的白色开始"
"到透明的白色，并将其起始位置移动到中心。"

msgid "Directional light"
msgstr "平行光"

msgid ""
"New in Godot 4.0 is the ability to have directional lighting in 2D. "
"Directional lighting is used to represent sunlight or moonlight. Light rays "
"are casted parallel to each other, as if the sun or moon was infinitely far "
"away from the surface that is receiving the light."
msgstr ""
"Godot 4.0 的新功能是在 2D 中实现定向照明。定向照明用于表现阳光或月光。光线相"
"互平行投射，就好像太阳或月亮离受光表面无限远一样。"

msgid "DirectionalLight2D offers the following properties:"
msgstr "DirectionalLight2D 提供以下的属性："

msgid ""
"**Height:** The light's virtual height with regards to normal mapping "
"(``0.0`` = parallel to surfaces, ``1.0`` = perpendicular to surfaces). By "
"default, the light is fully parallel with the surfaces receiving lights. "
"This will make lighting hardly visible if normal mapping is used, so "
"consider increasing this value. Adjusting the light's height only makes a "
"visual difference on surfaces that use normal mapping. **Height** does not "
"affect shadows' appearance."
msgstr ""
"**高度：** 灯光在法线贴图中的虚拟高度（ ``0.0`` = 平行于曲面， ``1.0`` = 垂直"
"于曲面）。默认情况下，灯光与接收灯光的表面完全平行。如果使用法线贴图，这将使"
"灯光几乎不可见，因此可以考虑增大此值。调整灯光的高度只会对使用法线贴图的表面"
"产生视觉差异。 **高度** 不会影响阴影的外观。"

msgid ""
"**Max Distance:** The maximum distance from the camera center objects can be "
"before their shadows are culled (in pixels). Decreasing this value can "
"prevent objects located outside the camera from casting shadows (while also "
"improving performance). Camera2D zoom is not taken into account by **Max "
"Distance**, which means that at higher zoom values, shadows will appear to "
"fade out sooner when zooming onto a given point."
msgstr ""
"**最大距离：** 物体距离摄像机中心的最大距离（单位：像素）。减小该值可以防止对"
"位于摄像机外的物体投射阴影（同时还能提高性能）。 **最大距离** 不考虑 "
"Camera2D 的缩放，这意味着在较高的缩放值下，当缩放至给定点时，阴影会更快消失。"

msgid ""
"Directional shadows will always appear to be infinitely long, regardless of "
"the value of the **Height** property. This is a limitation of the shadow "
"rendering method used for 2D lights in Godot."
msgstr ""
"无论 **Height** 属性的值是多少，定向阴影看起来总是无限长。这是 Godot 中用于 "
"2D 灯光的阴影渲染方法的限制。"

msgid ""
"To have directional shadows that are not infinitely long, you should disable "
"shadows in the DirectionalLight2D and use a custom shader that reads from "
"the 2D signed distance field instead. This distance field is automatically "
"generated from LightOccluder2D nodes present in the scene."
msgstr ""
"不想获得无限长的定向阴影，应禁用 DirectionalLight2D 中的阴影，并使用自定义着"
"色器来读取 2D 带符号距离场。该距离场从场景中的 LightOccluder2D 节点自动生成。"

msgid "Common light properties"
msgstr "常用灯光属性"

msgid ""
"Both PointLight2D and DirectionalLight2D offer common properties, which are "
"part of the Light2D base class:"
msgstr ""
"PointLight2D 和 DirectionalLight2D 都提供共同的属性，这些属性是 Light2D 基类"
"的一部分："

msgid ""
"**Enabled:** Allows toggling the light's visibility. Unlike hiding the light "
"node, disabling this property will not hide the light's children."
msgstr ""
"**启用：** 允许切换灯光的可见性。与隐藏灯光节点不同，禁用此属性不会隐藏灯光的"
"子节点。"

msgid ""
"**Editor Only:** If enabled, the light is only visible within the editor. It "
"will be automatically disabled in the running project."
msgstr ""
"**仅编辑器：**\\ 如果启用，灯光仅在编辑器中可见。在运行的项目中将自动禁用。"

msgid "**Color:** The light's color."
msgstr "**颜色：** 灯光的颜色。"

msgid ""
"**Energy:** The light's intensity multiplier. Higher values result in a "
"brighter light."
msgstr "**能量：** 灯光强度乘数。数值越大，光线越亮。"

msgid ""
"**Blend Mode:** The blending formula used for light computations. The "
"default **Add** is suited for most use cases. **Subtract** can be used for "
"negative lights, which are not physically accurate but can be used for "
"special effects. The **Mix** blend mode mixes the value of pixels "
"corresponding to the light's texture with the values of pixels under it by "
"linear interpolation."
msgstr ""
"**混合模式：** 用于光线计算的混合公式。默认的 **添加（Add）** 适合大多数使用"
"情况。 **减（Subtract）** 可用于负光，负光在物理上并不精确，但可用于特殊效"
"果。 **混合（Mix）** 模式通过线性插值将灯光纹理对应的像素值与灯光下方的像素值"
"混合。"

msgid "**Range > Z Min:** The lowest Z index affected by the light."
msgstr "**范围 > Z 下限：** 受光线影响的最小 Z 值。"

msgid "**Range > Z Max:** The highest Z index affected by the light."
msgstr "**范围 > Z 上限：** 受光线影响的最大 Z 值。"

msgid "**Range > Layer Min:** The lowest visual layer affected by the light."
msgstr "**范围 > 层下限：** 受光线影响的最小层数值。"

msgid "**Range > Layer Max:** The highest visual layer affected by the light."
msgstr "**范围 > 层上限：** 受光线影响的最大层数值。"

msgid ""
"**Range > Item Cull Mask:** Controls which nodes receive light from this "
"node, depending on the other nodes' enabled visual layers **Occluder Light "
"Mask**. This can be used to prevent certain objects from receiving light."
msgstr ""
"**范围 > 对象遮罩：** 根据其他节点的可视层选项**Occluder Light Mask**（遮挡掩"
"膜），控制那些节点接收到来自这个节点的光线。通过这种方式可以让某些物体不被光"
"线照射。"

msgid "Setting up shadows"
msgstr "设置阴影"

msgid ""
"After enabling the **Shadow > Enabled** property on a PointLight2D or "
"DirectionalLight2D node, you will not see any visual difference initially. "
"This is because no nodes in your scene have any *occluders* yet, which are "
"used as a basis for shadow casting."
msgstr ""
"启用一个 PointLight2D 或者 DirectionalLight2D 节点的 **Shadow > Enabled** 属"
"性之后，你将看不到任何变化。这是因为在你的场景中还没有任何节点拥有投射阴影需"
"要使用的 *遮挡器* 。"

msgid ""
"For shadows to appear in the scene, LightOccluder2D nodes must be added to "
"the scene. These nodes must also have occluder polygons that are designed to "
"match the sprite's outline."
msgstr ""
"要在场景中显示阴影，必须在场景中添加 LightOccluder2D 节点。这些节点还必须具有"
"与精灵轮廓相匹配的遮光多边形。"

msgid ""
"Along with their polygon resource (which must be set to have any visual "
"effect), LightOccluder2D nodes have 2 properties:"
msgstr ""
"除了多边形资源（必须设置多边形资源才能产生视觉效果）之外，LightOccluder2D 节"
"点还有两个属性："

msgid ""
"**SDF Collision:** If enabled, the occluder will be part of a real-time "
"generated *signed distance field* that can be used in custom shaders. When "
"not using custom shaders that read from this SDF, enabling this makes no "
"visual difference and has no performance cost, so this is enabled by default "
"for convenience."
msgstr ""
"**SDF碰撞：**\\ 如果启用，则遮挡器将成为可在自定义着色器中使用的实时生成的 *"
"签名距离字段* （signed distance field）的一部分。当不使用从此 SDF 中读取的自"
"定义着色器时，启用这个功能不会带来视觉上的差异，并且没有性能成本，因此默认情"
"况下为方便起见它是启用的。"

msgid ""
"**Occluder Light Mask:** This is used in tandem with PointLight2D and "
"DirectionalLight2D's **Shadow > Item Cull Mask** property to control which "
"objects cast shadows for each light. This can be used to prevent specific "
"objects from casting shadows."
msgstr ""
"**遮挡器光照蒙版：** 这与 PointLight2D 和 DirectionalLight2D 的 ** Shadow > "
"Item Cull Mask ** 属性一起使用，以控制哪些对象为每个光源投射阴影。 这可用于防"
"止特定对象投射阴影。"

msgid "There are two ways to create light occluders:"
msgstr "有两种方法可以来创建光线遮挡器："

msgid "Automatically generating a light occluder"
msgstr "自动生成光遮蔽器"

msgid ""
"Occluders can be created automatically from Sprite2D nodes by selecting the "
"node, clicking the **Sprite2D** menu at the top of the 2D editor then "
"choosing **Create LightOccluder2D Sibling**."
msgstr ""
"遮挡器可以自动地 Sprite2D 节点上创建，需要选中节点，单击2D编辑器顶部的 "
"**Sprite2D** 菜单，然后选择 **创建 LightOccluder2D 兄弟节点** 从而自动进行。"

msgid ""
"In the dialog that appears, an outline will surround your sprite's edges. If "
"the outline matches the sprite's edges closely, you can click **OK**. If the "
"outline is too far away from the sprite's edges (or is \"eating\" into the "
"sprite's edges), adjust **Grow (pixels)** and **Shrink (pixels)**, then "
"click **Update Preview**. Repeat this operation until you get satisfactory "
"results."
msgstr ""
"在出现的窗口中，一个外框将会包裹在你的精灵的边缘。如果外框贴合在了你的精灵的"
"边缘上，你可以点击**确定**。如果外框离你的精灵边缘太远（或者它穿过了你的精灵"
"的边缘），调整**扩展（像素）**和**收缩（像素）**，然后点击**更新预览**。重复"
"这一个操作直到你对结果满意为止。"

msgid "Manually drawing a light occluder"
msgstr "手动绘制光遮蔽器"

msgid ""
"Create a LightOccluder2D node, then select the node and click the \"+\" "
"button at the top of the 2D editor. When asked to create a polygon resource, "
"answer **Yes**. You can then start drawing an occluder polygon by clicking "
"to create new points. You can remove existing points by right-clicking them, "
"and you can create new points from the existing line by clicking on the line "
"then dragging."
msgstr ""
"创建一个 LightOccluder2D 节点，然后选择该节点并单击 2D 编辑器顶部的“+”按钮。 "
"当要求创建多边形资源时，回答 **是** 。 然后，你可以通过单击创建新点来开始绘制"
"遮挡多边形。你可以通过右键单击现有点来删除它们，也可以通过单击线条然后拖动来"
"从现有线条创建新点。"

msgid ""
"The following properties can be adjusted on 2D lights that have shadows "
"enabled:"
msgstr "启用阴影的 2D 灯光能够调整以下属性："

msgid ""
"**Color:** The color of shaded areas. By default, shaded areas are fully "
"black, but this can be changed for artistic purposes. The color's alpha "
"channel controls how much the shadow is tinted by the specified color."
msgstr ""
"**Color：**\\ 阴影区域的颜色。默认情况下，阴影区域是全黑的，但这可以出于艺术"
"目的而改变。颜色的 alpha 通道控制的是阴影被指定颜色着色的程度。"

msgid ""
"**Filter:** The filter mode to use for shadows. The default **None** is the "
"fastest to render, and is well suited for games with a pixel art aesthetic "
"(due to its \"blocky\" visuals). If you want a soft shadow, use **PCF5** "
"instead. **PCF13** is even softer, but is the most demanding to render. "
"PCF13 should only be used for a few lights at once due to its high rendering "
"cost."
msgstr ""
"**Filter：**\\ 阴影所使用的过滤模式。默认值为 **None**\\ ，渲染速度最快，并且"
"非常适合像素艺术风格的游戏（因为它具有“方块”视觉效果）。如果你想要柔和的阴"
"影，请使用 **PCF5**\\ 。\\ **PCF13** 则更柔和，但渲染需求更高。由于渲染成本较"
"高，\\ **PCF13** 只应用于少量光源同时存在的情况下。"

msgid ""
"**Filter Smooth:** Controls how much softening is applied to shadows when "
"**Filter** is set to **PCF5** or **PCF13**. Higher values result in a softer "
"shadow, but may cause banding artifacts to be visible (especially with PCF5)."
msgstr ""
"**Filter Smooth：**\\ 过滤平滑。控制的是当 **Filter** 为 **PCF5** 或* "
"*PCF13** 时，应用于阴影的柔化程度。较高的值会导致阴影更加柔和，但可能会出现带"
"状伪影（特别是使用 PCF5 时）。"

msgid ""
"**Item Cull Mask:** Controls which LightOccluder2D nodes cast shadows, "
"depending on their respective **Occluder Light Mask** properties."
msgstr ""
"**Item Cull Mask：**\\ 项目剔除遮罩。控制的是哪些 LightOccluder2D 节点能够投"
"射阴影，取决于对应的 **Occluder Light Mask**\\ （遮挡器灯光遮罩）属性。"

msgid "Hard shadows"
msgstr "硬阴影"

msgid "Soft shadows (PCF13, Filter Smooth 1.5)"
msgstr "柔和阴影（PCF13，滤镜平滑度 1.5）"

msgid ""
"Soft shadows with streaking artifacts due to Filter Smooth being too high "
"(PCF5, Filter Smooth 4)"
msgstr "由于滤波平滑度太高（PCF5，滤波平滑度 4），阴影变得柔和，并出现条纹伪影"

msgid "Occluder draw order"
msgstr "遮挡器绘制顺序"

msgid ""
"**LightOccluder2Ds follows the usual 2D drawing order.** This is important "
"for 2D lighting, as this is how you control whether the occluder should "
"occlude the sprite itself or not."
msgstr ""
"**LightOccluder2D 遵循常规的 2D 绘图顺序。**\\ 这对于 2D 灯光而言非常重要，因"
"为可以用来控制遮挡器是否应该遮挡精灵本身。"

msgid ""
"If the LightOccluder2D node is a *sibling* of the sprite, the occluder will "
"occlude the sprite itself if it's placed *below* the sprite in the scene "
"tree."
msgstr ""
"如果 LightOccluder2D 节点是精灵的\\ *兄弟*\\ 节点，并且场景树中的遮挡器被放在"
"精灵的\\ *下方*\\ ，会遮挡住精灵本身。"

msgid ""
"If the LightOccluder2D node is a *child* of the sprite, the occluder will "
"occlude the sprite itself if **Show Behind Parent** is disabled on the "
"LightOccluder2D node (which is the default)."
msgstr ""
"如果 LightOccluder2D 节点是一个精灵的子节点，如果在 LightOccluder2D 节点中禁"
"用了 **Show Behind Parent**\\ （显示在父级之后）这个遮挡器将遮挡住精灵本身"
"（该选项默认禁用）。"

msgid "Normal and specular maps"
msgstr "法线和镜面贴图"

msgid ""
"Normal maps and specular maps can greatly enhance the sense of depth of your "
"2D lighting. Similar to how these work in 3D rendering, normal maps can help "
"make lighting look less flat by varying its intensity depending on the "
"direction of the surface receiving light (on a per-pixel basis). Specular "
"maps further help improve visuals by making some of the light reflect back "
"to the viewer."
msgstr ""
"法线贴图和镜面贴图可以大大提升你的2D光照的立体感。与3D渲染类似，法线贴图可以"
"根据接收光线的表面方向来改变光线的强度，从而使照明效果不再平面化（按像素进行"
"调整）。镜面贴图通过让一部分光线反射回观察者来进一步改善视觉效果。"

msgid ""
"Both PointLight2D and DirectionalLight2D support normal mapping and specular "
"mapping. Since Godot 4.0, normal and specular maps can be assigned to any 2D "
"element, including nodes that inherit from Node2D or Control."
msgstr ""
"PointLight2D 和 DirectionalLight2D 都支持法线贴图和镜面贴图。自 Godot 4.0 "
"起，法线贴图和镜面贴图可分配给任何 2D 元素，包括继承自 Node2D 或 Control 的节"
"点。"

msgid ""
"A normal map represents the direction in which each pixel is \"pointing\" "
"towards. This information is then used by the engine to correctly apply "
"lighting to 2D surfaces in a physically plausible way. Normal maps are "
"typically created from hand-painted height maps, but they can also be "
"automatically generated from other textures."
msgstr ""
"法线贴图表示每个像素 “指向” 的方向。引擎会利用这些信息，以物理上合理的方式将"
"光照正确应用到 2D 表面。法线贴图通常由手绘的高度贴图创建，但也可以由其他纹理"
"自动生成。"

msgid ""
"A specular map defines how much each pixel should reflect light (and in "
"which color, if the specular map contains color). Brighter values will "
"result in a brighter reflection at that given spot on the texture. Specular "
"maps are typically created with manual editing, using the diffuse texture as "
"a base."
msgstr ""
"镜面贴图定义了每个像素对光线的反射程度（如果镜面贴图包含颜色，则定义反射的颜"
"色）。亮度值越高，纹理上指定位置的反射就越亮。镜面贴图通常以漫反射纹理为基"
"础，通过手动编辑创建。"

msgid ""
"If you don't have normal or specular maps for your sprites, you can generate "
"them using the free and open source `Laigter <https://azagaya.itch.io/"
"laigter>`__ tool."
msgstr ""
"如果在你的精灵中没有使用法线贴图或者镜面贴图，可以使用免费的开源工具`Laigter "
"<https://azagaya.itch.io/laigter>`来生成。"

msgid ""
"To set up normal maps and/or specular maps on a 2D node, create a new "
"CanvasTexture resource for the property that draws the node's texture. For "
"example, on a Sprite2D:"
msgstr ""
"要在 2D 节点上设置法线贴图和/或镜面贴图，请为绘制节点纹理的属性创建一个新的 "
"CanvasTexture 资源。例如，在一个 Sprite2D 节点上创建一个新的 CanvasTexture 资"
"源："

msgid "Creating a CanvasTexture resource for a Sprite2D node"
msgstr "为 Sprite2D 节点创建 CanvasTexture 资源"

msgid ""
"Expand the newly created resource. You can find several properties you will "
"need to adjust:"
msgstr "展开新创建的资源。你可以找到需要调整的几个属性："

msgid ""
"**Diffuse > Texture:** The base color texture. In this property, load the "
"texture you're using for the sprite itself."
msgstr ""
"**Diffuse > Texture：**\\ （漫反射 > 纹理）基础的颜色贴图。在这个属性中，加载"
"你将使用在精灵本身的纹理。"

msgid ""
"**Normal Map > Texture:** The normal map texture. In this property, load a "
"normal map texture you've generated from a height map (see the tip above)."
msgstr ""
"**Normal Map > Texture：**\\ （法线贴图 > 纹理）法线贴图的纹理。在这个属性"
"中，你可以加载从高度图生成的法线贴图纹理（见上面的提示）。"

msgid ""
"**Specular > Texture:** The specular map texture, which controls the "
"specular intensity of each pixel on the diffuse texture. The specular map is "
"usually grayscale, but it can also contain color to multiply the color of "
"reflections accordingly. In this property, load a specular map texture "
"you've created (see the tip above)."
msgstr ""
"**Specular > Texture：**\\ （镜面反射 > 纹理）镜面贴图纹理，可以控制漫反射纹"
"理上每个像素的镜面反射强度。镜面贴图通常使用灰度反射，但是它也可以包含色彩来"
"增强反射的颜色。在这个属性中，加载一个已创建的镜面贴图纹理（见上面的提示）。"

msgid "**Specular > Color:** The color multiplier for specular reflections."
msgstr "**Specular > Color：**\\ （镜面反射 > 颜色）镜面反射的颜色乘数。"

msgid ""
"**Specular > Shininess:** The specular exponent to use for reflections. "
"Lower values will increase the brightness of reflections and make them more "
"diffuse, while higher values will make reflections more localized. High "
"values are more suited for wet-looking surfaces."
msgstr ""
"**Specular > Shininess：**\\ （镜面反射 > 光泽度）用于镜面反射的高光指数。值"
"越低，反射的明亮度和扩散性会增加，而值越高，反射会更加局部化。较高的值适用于"
"湿润表面。"

msgid ""
"**Texture > Filter:** Can be set to override the texture filtering mode, "
"regardless of what the node's property is set to (or the **Rendering > "
"Textures > Canvas Textures > Default Texture Filter** project setting)."
msgstr ""
"**Texture > Filter：**\\ （纹理 > 过滤器）可以设置为覆盖纹理过滤模式，无论节"
"点属性设置如何（或\\ **渲染 > 纹理 > 画布纹理 > 默认纹理过滤**\\ 项目设置）。"

msgid ""
"**Texture > Repeat:** Can be set to override the texture filtering mode, "
"regardless of what the node's property is set to (or the **Rendering > "
"Textures > Canvas Textures > Default Texture Repeat** project setting)."
msgstr ""
"**Texture > Repeat：**\\ （纹理 > 重复）可以设置为覆盖纹理过滤模式，无论节点"
"的属性如何设置（或者\\ **渲染 > 纹理 > 画布纹理 > 默认纹理重复**\\ 项目设"
"置）。"

msgid ""
"After enabling normal mapping, you may notice that your lights appear to be "
"weaker. To resolve this, increase the **Height** property on your "
"PointLight2D and DirectionalLight2D nodes. You may also want to increase the "
"lights's **Energy** property slightly to get closer to how your lighting's "
"intensity looked prior to enabling normal mapping."
msgstr ""
"启用法线贴图后，你可能会注意到灯光会显得较弱。为了解决这个问题，可以增加 "
"PointLight2D 和 DirectionalLight2D 节点上的 **Height** 属性。也可以略微增加灯"
"光的 **Energy** 属性，以接近启用法线贴图之前的照明强度。"

msgid "Using additive sprites as a faster alternative to 2D lights"
msgstr "使用添加式精灵作为 2D 灯光的快速替代品"

msgid ""
"If you run into performance issues when using 2D lights, it may be worth "
"replacing some of them with Sprite2D nodes that use additive blending. This "
"is particularly suited for short-lived dynamic effects, such as bullets or "
"explosions."
msgstr ""
"如果在使用 2D 灯光时遇到性能问题，不妨将其中一些节点替换为使用叠加混合的 "
"Sprite2D 节点。这尤其适用于短暂的动态效果，如子弹或爆炸。"

msgid ""
"Additive sprites are much faster to render, since they don't need to go "
"through a separate rendering pipeline. Additionally, it is possible to use "
"this approach with AnimatedSprite2D (or Sprite2D + AnimationPlayer), which "
"allows for animated 2D \"lights\" to be created."
msgstr ""
"添加式精灵的渲染速度要快得多，因为它们不需要通过单独的渲染管道。此外，这种方"
"法还可以与 AnimatedSprite2D（或 Sprite2D + AnimationPlayer）一起使用，这样就"
"可以创建动画二维 “灯光”。"

msgid "However, additive sprites have a few downsides compared to 2D lights:"
msgstr "不过，与 2D 灯光相比，添加式精灵有一些缺点："

msgid ""
"The blending formula is inaccurate compared to \"actual\" 2D lighting. This "
"is usually not a problem in sufficiently lit areas, but this prevents "
"additive sprites from correctly lighting up areas that are fully dark."
msgstr ""
"与 “实际 ”二维光照相比，混合公式并不准确。这在光线充足的区域通常不是问题，但"
"这会妨碍添加精灵去正确照亮那些完全黑暗的区域。"

msgid "Additive sprites cannot cast shadows, since they are not lights."
msgstr "添加式精灵不能投射阴影，因为它们不是灯光。"

msgid "Additive sprites ignore normal and specular maps used on other sprites."
msgstr "添加式精灵会忽略其他精灵上使用的法线贴图和镜面贴图。"

msgid ""
"To display a sprite with additive blending, create a Sprite2D node and "
"assign a texture to it. In the inspector, scroll down to the **CanvasItem > "
"Material** section, unfold it and click the dropdown next to the "
"**Material** property. Choose **New CanvasItemMaterial**, click the newly "
"created material to edit it, then set **Blend Mode** to **Add**."
msgstr ""
"要显示一个混合叠加效果的精灵，需要创建一个 Sprite2D 节点并分配一个纹理给它。"
"在检视窗口中，往下滚动到 **CanvasItem > Material** 部分，展开它并点击 "
"**Material** 属性旁边的下拉菜单。选择 **New CanvasItemMaterial**，点击新建的"
"材质来编辑它，然后将 **Blend Mode** 设置为 **Add**。"

msgid "Translation status"
msgstr "翻译状态"
