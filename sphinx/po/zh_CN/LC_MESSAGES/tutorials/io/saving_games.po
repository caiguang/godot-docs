# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Saving games"
msgstr "保存游戏"

msgid "Introduction"
msgstr "前言"

msgid ""
"Save games can be complicated. For example, it may be desirable to store "
"information from multiple objects across multiple levels. Advanced save game "
"systems should allow for additional information about an arbitrary number of "
"objects. This will allow the save function to scale as the game grows more "
"complex."
msgstr ""
"保存游戏可能很复杂. 比如, 我们可能会想要储存跨多个关卡的多个物品的信息. 更高"
"级的保存游戏可能需要存储关于具有任意数量的对象的附加信息. 当游戏变得更加复杂"
"时, 这将让保存函数可以随着游戏一同变得更加复杂."

msgid ""
"If you're looking to save user configuration, you can use the :ref:"
"`class_ConfigFile` class for this purpose."
msgstr ""
"如果你想保存玩家的设置，可以用 :ref:`class_ConfigFile` 来实现这个目的。"

#, fuzzy
msgid ""
"You can see how saving and loading works in action using the `Saving and "
"Loading (Serialization) demo project <https://github.com/godotengine/godot-"
"demo-projects/blob/master/loading/serialization>`__."
msgstr ""
"如果您更善于通过查看示例学习，可以在\\ `这里 <https://github.com/godotengine/"
"godot-demo-projects/tree/master/mobile/android_iap>`__\\ 找到演示项目。"

msgid "Identify persistent objects"
msgstr "识别持久化对象"

msgid ""
"Firstly, we should identify what objects we want to keep between game "
"sessions and what information we want to keep from those objects. For this "
"tutorial, we will use groups to mark and handle objects to be saved, but "
"other methods are certainly possible."
msgstr ""
"首先，我们应该确定在游戏会话中要保存那些对象，以及我们要保存这些对象中的哪些"
"信息。本教程中，我们将使用“分组”来标记和处理要保存的对象，但当然也有其他可行"
"的方法。"

msgid ""
"We will start by adding objects we wish to save to the \"Persist\" group. We "
"can do this through either the GUI or script. Let's add the relevant nodes "
"using the GUI:"
msgstr ""
"首先我们将想要保存的对象添加到“Persist”组。我们既可以通过 GUI 也可以通过脚本"
"完成此操作。让我们使用 GUI 来添加相关节点吧："

msgid ""
"Once this is done, when we need to save the game, we can get all objects to "
"save them and then tell them all to save with this script:"
msgstr ""
"完成这个操作后，我们需要保存游戏时，就可以获取所有需要保存的对象，然后通过这"
"个脚本让这些对象去保存数据："

msgid "Serializing"
msgstr "序列化"

#, fuzzy
msgid ""
"The next step is to serialize the data. This makes it much easier to read "
"from and store to disk. In this case, we're assuming each member of group "
"Persist is an instanced node and thus has a path. GDScript has helper class :"
"ref:`JSON<class_json>` to convert between dictionary and string, Our node "
"needs to contain a save function that returns this data. The save function "
"will look like this:"
msgstr ""
"下一步是序列化数据。这使得从硬盘读取数据和存储数据到硬盘变得更加容易。在这种"
"情况下, 我们假设 Persist 组的每个成员都是一个实例化的节点，因此它们都有一个路"
"径。GDScript 有相关的辅助函数，如 :ref:`to_json() "
"<class_@GDScript_method_to_json>` 和 :ref:`parse_json() "
"<class_@GDScript_method_parse_json>`，所以我们使用 Dictionary 来表示数据。我"
"们的节点需要包含一个返回 Dictionary 的保存函数。保存函数看上去大概会像这样："

msgid ""
"This gives us a dictionary with the style ``{ \"variable_name\":"
"value_of_variable }``, which will be useful when loading."
msgstr ""
"我们得到一个样式为 ``{ \"variable_name\":that_variables_value }`` 的字典, 它"
"在加载游戏数据时会被用到."

msgid "Saving and reading data"
msgstr "保存和读取数据"

#, fuzzy
msgid ""
"As covered in the :ref:`doc_filesystem` tutorial, we'll need to open a file "
"so we can write to it or read from it. Now that we have a way to call our "
"groups and get their relevant data, let's use the class :ref:"
"`JSON<class_json>` to convert it into an easily stored string and store them "
"in a file. Doing it this way ensures that each line is its own object, so we "
"have an easy way to pull the data out of the file as well."
msgstr ""
"正如在 :ref:`doc_filesystem` 教程中所述, 我们需要打开一个文件来向其中写入或读"
"取数据. 既然我们有办法调用我们的组并获取它们的相关数据, 那么就让我们使用 :"
"ref:`to_json() <class_@GDScript_method_to_json>` 将数据转换成一个容易存储的字"
"符串并将它存储在文件中吧. 这样做可以确保每一行都是一个完整的对象的信息, 这样"
"的话将数据从文件中提取出来也会更加容易."

#, fuzzy
msgid ""
"Game saved! Now, to load, we'll read each line. Use the :ref:"
"`parse<class_JSON_method_parse>` method to read the JSON string back to a "
"dictionary, and then iterate over the dict to read our values. But we'll "
"need to first create the object and we can use the filename and parent "
"values to achieve that. Here is our load function:"
msgstr ""
"游戏保存好了！ 加载也很简单. 为此, 我们将读取每一行, 使用parse_json() 将其读"
"回到一个字典中, 然后遍历字典以读取保存的值. 首先我们需要创建对象, 这可以通过"
"使用文件名和父值来实现. 这就是我们的加载函数:"

msgid ""
"Now we can save and load an arbitrary number of objects laid out almost "
"anywhere across the scene tree! Each object can store different data "
"depending on what it needs to save."
msgstr ""
"现在我们可以保存和加载几乎任何位于场景树中的任意数量的对象了！ 每个对象可以根"
"据需要保存的内容存储不同的数据."

msgid "Some notes"
msgstr "一些注释"

msgid ""
"We have glossed over setting up the game state for loading. It's ultimately "
"up to the project creator where much of this logic goes. This is often "
"complicated and will need to be heavily customized based on the needs of the "
"individual project."
msgstr ""
"我们可能忽略了 \"将游戏状态设置到适合以加载数据\" 这一步. 最终, 这一步怎么做"
"的决定权在项目创建者手里. 这通常很复杂, 需要根据单个项目的需求对此步骤进行大"
"量定制."

msgid ""
"Additionally, our implementation assumes no Persist objects are children of "
"other Persist objects. Otherwise, invalid paths would be created. To "
"accommodate nested Persist objects, consider saving objects in stages. Load "
"parent objects first so they are available for the :ref:`add_child() "
"<class_node_method_add_child>` call when child objects are loaded. You will "
"also need a way to link children to parents as the :ref:`NodePath "
"<class_nodepath>` will likely be invalid."
msgstr ""
"另外, 此实现假定没有Persist对象是其他Persist对象的子对象. 否则会产生无效路"
"径. 如果这是项目的需求之一, 可以考虑分阶段保存对象(父对象优先), 以便在加载子"
"对象时可用它们将确保它们可用于 :ref:`add_child() "
"<class_node_method_add_child>` 调用. 由于 :ref:`NodePath <class_nodepath>` 可"
"能无效, 因此可能还需要某种方式将子项链接到父项."

msgid "JSON vs binary serialization"
msgstr "JSON 与二进制序列化"

msgid ""
"For simple game state, JSON may work and it generates human-readable files "
"that are easy to debug."
msgstr "简单的游戏状态可能可以使用 JSON，生成的是人类可读的文件，便于调试。"

msgid ""
"But JSON has many limitations. If you need to store more complex game state "
"or a lot of it, :ref:`binary serialization<doc_binary_serialization_api>` "
"may be a better approach."
msgstr ""
"但是 JSON 也存在限制。如果你需要存储比较复杂的游戏状态，或者量比较大，使用"
"\\ :ref:`二进制序列化 <doc_binary_serialization_api>`\\ 可能更合适。"

msgid "JSON limitations"
msgstr "JSON 的限制"

msgid "Here are some important gotchas to know about when using JSON."
msgstr "以下是一些使用 JSON 时会遇到的大坑。"

msgid ""
"**Filesize:** JSON stores data in text format, which is much larger than "
"binary formats."
msgstr "**文件大小：**\\ JSON 使用文本格式存储数据，比二进制格式要大很多。"

msgid ""
"**Data types:** JSON only offers a limited set of data types. If you have "
"data types that JSON doesn't have, you will need to translate your data to "
"and from types that JSON can handle. For example, some important types that "
"JSON can't parse are: ``Vector2``, ``Vector3``, ``Color``, ``Rect2``, and "
"``Quaternion``."
msgstr ""
"**数据类型：**\\ JSON 只提供了有限的数据类型。如果你用到了 JSON 没有的数据类"
"型，就需要自己在这个类型和 JSON 能够处理的类型之间来回转换。例如 JSON 无法解"
"析以下重要的类型：\\ ``Vector2``\\ 、\\ ``Vector3``\\ 、\\ ``Color``\\ 、\\ "
"``Rect2``\\ 、\\ ``Quaternion``\\ 。"

msgid ""
"**Custom logic needed for encoding/decoding:** If you have any custom "
"classes that you want to store with JSON, you will need to write your own "
"logic for encoding and decoding those classes."
msgstr ""
"**编解码需要自定义逻辑：**\\ 如果你想要用 JSON 存储自定义的类，就需要自己编写"
"这些类的编解码逻辑。"

msgid "Binary serialization"
msgstr "二进制序列化"

msgid ""
":ref:`Binary serialization<doc_binary_serialization_api>` is an alternative "
"approach for storing game state, and you can use it with the functions "
"``get_var`` and ``store_var`` of :ref:`class_FileAccess`."
msgstr ""
"也可以使用\\ :ref:`二进制序列化 <doc_binary_serialization_api>`\\ 来存储游戏"
"状态，可以使用 :ref:`class_FileAccess`` 的 ``get_var`` 和 ``store_var`` 来实"
"现。"

msgid "Binary serialization should produce smaller files than JSON."
msgstr "二进制序列化生成的文件比 JSON 小。"

msgid "Binary serialization can handle most common data types."
msgstr "二进制序列化能够处理大多数常见数据类型。"

msgid ""
"Binary serialization requires less custom logic for encoding and decoding "
"custom classes."
msgstr "二进制序列化在编解码自定义类时需要更少的自定义逻辑。"

msgid ""
"Note that not all properties are included. Only properties that are "
"configured with the :ref:"
"`PROPERTY_USAGE_STORAGE<class_@GlobalScope_constant_PROPERTY_USAGE_STORAGE>` "
"flag set will be serialized. You can add a new usage flag to a property by "
"overriding the :ref:"
"`_get_property_list<class_Object_private_method__get_property_list>` method "
"in your class. You can also check how property usage is configured by "
"calling ``Object._get_property_list``. See :ref:"
"`PropertyUsageFlags<enum_@GlobalScope_PropertyUsageFlags>` for the possible "
"usage flags."
msgstr ""

msgid "Translation status"
msgstr "翻译状态"
