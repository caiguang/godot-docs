# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Multiple resolutions"
msgstr "多分辨率"

msgid "The problem of multiple resolutions"
msgstr "多分辨率问题"

msgid ""
"Developers often have trouble understanding how to best support multiple "
"resolutions in their games. For desktop and console games, this is more or "
"less straightforward, as most screen aspect ratios are 16:9 and resolutions "
"are standard (720p, 1080p, 1440p, 4K, …)."
msgstr ""
"开发人员经常会遇到麻烦, 不知道如何在他们的游戏中最好地支持多种分辨率. 对于桌"
"面和控制台游戏, 这或多或少是简单的, 因为大多数屏幕长宽比是16:9, 分辨率是标准"
"的720p, 1080p, 1440p, 4K,......."

msgid ""
"For mobile games, at first, it was easy. For many years, the iPhone and iPad "
"used the same resolution. When *Retina* was implemented, they just doubled "
"the pixel density; most developers had to supply assets in default and "
"double resolutions."
msgstr ""
"对于手机游戏来说，起初，这很容易。许多年来，iPhone 和 iPad 使用相同的分辨率。"
"当实行 *Retina* 后，他们只是将像素密度提高了一倍；大多数开发商不得不以默认和"
"双倍的分辨率提供资产。"

msgid ""
"Nowadays, this is no longer the case, as there are plenty of different "
"screen sizes, densities, and aspect ratios. Non-conventional sizes are also "
"becoming increasingly popular, such as ultrawide displays."
msgstr ""
"如今, 情况已不再如此, 因为有很多不同的屏幕尺寸, 密度和长宽比. 非传统的尺寸也"
"越来越受欢迎, 如超宽显示屏."

msgid ""
"For 3D games, there is not much of a need to support multiple resolutions "
"(from the aesthetic point of view). The 3D geometry will just fill the "
"screen based on the field of view, disregarding the aspect ratio. The main "
"reason one may want to support this, in this case, is for *performance* "
"reasons (running in lower resolution to increase frames per second)."
msgstr ""
"对于3D游戏来说, 没有太大的必要支持多种分辨率(从审美角度来看).3D几何图形将根据"
"视场填充屏幕, 而不考虑长宽比. 在这种情况下, 人们可能想要支持的主要原因是为了 "
"*性能* 的原因(以较低的分辨率运行以增加每秒的帧数)."

msgid ""
"For 2D and game UIs, this is a different matter, as art needs to be created "
"using specific pixel sizes in software such as Photoshop, GIMP or Krita."
msgstr ""
"对于2D和游戏UI, 这是一个不同的问题, 因为设计需要在Photoshop, GIMP或Krita等软"
"件中使用特定的像素尺寸来创建."

msgid ""
"Since layouts, aspect ratios, resolutions, and pixel densities can change so "
"much, it is no longer possible to design UIs for every specific screen. "
"Another method must be used."
msgstr ""
"由于布局, 长宽比, 分辨率和像素密度会有很大的变化, 因此不再可能为每个特定的屏"
"幕设计UI. 必须使用另一种方法."

msgid "One size fits all"
msgstr "万全之策"

msgid ""
"The most common approach is to use a single *base* resolution and then fit "
"it to everything else. This resolution is how most players are expected to "
"play the game (given their hardware). For mobile, Google has useful `stats "
"<https://developer.android.com/about/dashboards>`_ online, and for desktop, "
"Steam `also does <https://store.steampowered.com/hwsurvey/>`_."
msgstr ""
"最常见的方法是使用一个单一的 *基础* 分辨率, 然后将其适用于其他所有情况. 这个"
"分辨率是大多数玩家预期的玩游戏的方式, 鉴于他们的硬件. 对于移动设备, 谷歌在网"
"上有有用的 `统计资料 <https://developer.android.com/about/dashboards>`__ , 对"
"于桌面设备,Steam `也有 <https://store.steampowered.com/hwsurvey/>`__ ."

msgid ""
"As an example, Steam shows that the most common *primary display resolution* "
"is 1920×1080, so a sensible approach is to develop a game for this "
"resolution, then handle scaling for different sizes and aspect ratios."
msgstr ""
"举个例子,Steam显示最常见的 *主要显示分辨率是* 1920×1080, 所以明智的做法是为这"
"个分辨率开发一个游戏, 然后期处理不同尺寸和长宽比的缩放."

msgid "Godot provides several useful tools to do this easily."
msgstr "Godot 还提供了一系列通用的容器."

#, fuzzy
msgid ""
"You can see how Godot's support for multiple resolutions works in action "
"using the `Multiple Resolutions and Aspect Ratios demo project <https://"
"github.com/godotengine/godot-demo-projects/tree/master/gui/"
"multiple_resolutions>`__."
msgstr ""
"如果您更善于通过查看示例学习，可以在\\ `这里 <https://github.com/godotengine/"
"godot-demo-projects/tree/master/mobile/android_iap>`__\\ 找到演示项目。"

msgid "Base size"
msgstr "基本大小"

msgid ""
"A base size for the window can be specified in the Project Settings under "
"**Display → Window**."
msgstr "窗口的基本尺寸可以在项目设置中的 **Display → Window** 下指定."

msgid ""
"However, what it does is not completely obvious; the engine will *not* "
"attempt to switch the monitor to this resolution. Rather, think of this "
"setting as the \"design size\", i.e. the size of the area that you work with "
"in the editor. This setting corresponds directly to the size of the blue "
"rectangle in the 2D editor."
msgstr ""
"然而, 它的作用并不完全明显; 引擎将 *不* 尝试将显示器切换到此分辨率. 相反, 将"
"此设置视为 \"设计大小\", 即你在编辑器中使用的区域的大小. 此设置直接对应于2D编"
"辑器中蓝色矩形的大小."

msgid ""
"There is often a need to support devices with screen and window sizes that "
"are different from this base size. Godot offers many ways to control how the "
"viewport will be resized and stretched to different screen sizes."
msgstr ""
"通常需要支持具有与该基本大小不同的屏幕和窗口大小的设备. Godot提供了许多方法来"
"控制视口的大小调整和拉伸到不同的屏幕大小."

msgid ""
"To configure the stretch base size at runtime from a script, use the "
"``get_tree().root.content_scale_size`` property (see :ref:`Window."
"content_scale_size <class_Window_property_content_scale_size>`). Changing "
"this value can indirectly change the size of 2D elements. However, to "
"provide an user-accessible scaling option, using :ref:"
"`doc_multiple_resolutions_stretch_scale` is recommended as it's easier to "
"adjust."
msgstr ""

msgid ""
"Godot follows a modern approach to multiple resolutions. The engine will "
"never change the monitor's resolution on its own. While changing the "
"monitor's resolution is the most efficient approach, it's also the least "
"reliable approach as it can leave the monitor stuck on a low resolution if "
"the game crashes. This is especially common on macOS or Linux which don't "
"handle resolution changes as well as Windows."
msgstr ""
"Godot遵循了现代多种分辨率的方法. 引擎永远不会自行改变显示器的分辨率. 虽然改变"
"显示器的分辨率是最有效的方法, 但这也是最不可靠的方法, 因为如果游戏崩溃, 它可"
"能会让显示器卡在一个低分辨率上. 这在macOS或Linux上很常见, 因为它们对分辨率变"
"化的处理不如Windows."

msgid ""
"Changing the monitor's resolution also removes any control from the game "
"developer over filtering and aspect ratio stretching, which can be important "
"to ensure correct display for pixel art games."
msgstr ""
"更改显示器的分辨率还会取消游戏开发者对过滤和纵横比拉伸的控制, 这对于确保像素"
"游戏的正确显示画面非常重要."

msgid ""
"On top of that, changing the monitor's resolution makes alt-tabbing in and "
"out of a game much slower since the monitor has to change resolutions every "
"time this is done."
msgstr ""
"最重要的是, 更改显示器的分辨率会使游戏的Alt-Tab键切换速度变慢, 因为每次切换时"
"显示器都必须更改分辨率."

msgid "Resizing"
msgstr "调整大小"

#, fuzzy
msgid ""
"There are several types of devices, with several types of screens, which in "
"turn have different pixel density and resolutions. Handling all of them can "
"be a lot of work, so Godot tries to make the developer's life a little "
"easier. The :ref:`Viewport <class_Viewport>` node has several functions to "
"handle resizing, and the root node of the scene tree is always a viewport "
"(scenes loaded are instanced as a child of it, and it can always be accessed "
"by calling ``get_tree().root`` or ``get_node(\"/root\")``)."
msgstr ""
"市面上有着各种各样的设备, 拥有各种类型的屏幕, 依次有着不同的像素密度和分辨"
"率. 处理所有的类型工作量巨大, 所以Godot试图让开发者的生活变得更简单. :ref:"
"`Viewport <class_Viewport>` 节点提供了几个处理大小调整的函数, 而场景树的根节"
"点始终是一个Viewport (场景将作为它的子节点被实例化, 并且始终可以通过调用 "
"``get_tree().get_root()`` 或 ``get_node(\"/root\")`` 来访问它."

#, fuzzy
msgid ""
"In any case, while changing the root Viewport params is probably the most "
"flexible way to deal with the problem, it can be a lot of work, code and "
"guessing, so Godot provides a set of parameters in the project settings to "
"handle multiple resolutions."
msgstr ""
"在任何情况下，虽然更改根 Viewport 的参数可能是解决问题的最灵活方法，但这样做"
"的可能包含大量工作、大量代码、大量推测过程，因此 Godot 在项目设置中提供了一组"
"简单的参数来处理多分辨率问题。"

msgid "Stretch settings"
msgstr "拉伸设置"

msgid ""
"Stretch settings are located in the project settings and provide several "
"options:"
msgstr "拉伸设置位于项目设置中, 提供了几个选项:"

msgid "Stretch Mode"
msgstr "拉伸模式"

msgid ""
"The **Stretch Mode** setting defines how the base size is stretched to fit "
"the resolution of the window or screen."
msgstr "**Stretch Mode** 设置定义了基本尺寸如何被伸展以适应窗口或屏幕的分辨率."

msgid ""
"The animations below use a \"base size\" of just 16×9 pixels to demonstrate "
"the effect of different stretch modes. A single sprite, also 16×9 pixels in "
"size, covers the entire viewport, and a diagonal :ref:`Line2D "
"<class_Line2D>` is added on top of it:"
msgstr ""
"下面的动画使用仅16×9像素的 \"基本大小\" 来演示不同拉伸模式的效果. 单个精灵, "
"大小也是16×9像素, 覆盖整个视口, 并在其上添加一个对角线 :ref:`Line2D "
"<class_Line2D>` :"

msgid ""
"**Stretch Mode = Disabled** (default): No stretching happens. One unit in "
"the scene corresponds to one pixel on the screen. In this mode, the "
"**Stretch Aspect** setting has no effect."
msgstr ""
"**Stretch Mode = Disabled** (默认). 不发生拉伸. 场景中的一个单位对应于屏幕上"
"的一个像素. 在这种模式下, **Stretch Aspect** 设置没有效果."

#, fuzzy
msgid ""
"**Stretch Mode = Canvas Items**: In this mode, the base size specified in "
"width and height in the project settings is stretched to cover the whole "
"screen (taking the **Stretch Aspect** setting into account). This means that "
"everything is rendered directly at the target resolution. 3D is unaffected, "
"while in 2D, there is no longer a 1:1 correspondence between sprite pixels "
"and screen pixels, which may result in scaling artifacts."
msgstr ""
"**Stretch Mode = 2D**\\ ：在这种模式下，项目设置中所指定的宽高尺寸会被拉伸到"
"覆盖整个屏幕（会考虑 **Stretch Aspect** 设置）。这意味着所有的东西都直接在目"
"标分辨率下进行渲染。3D 不受影响，而在2D中，精灵像素和屏幕像素之间不再有 1:1 "
"的对应关系，这可能会导致缩放的伪影。"

msgid ""
"**Stretch Mode = Viewport**: Viewport scaling means that the size of the "
"root :ref:`Viewport <class_Viewport>` is set precisely to the base size "
"specified in the Project Settings' **Display** section. The scene is "
"rendered to this viewport first. Finally, this viewport is scaled to fit the "
"screen (taking the **Stretch Aspect** setting into account)."
msgstr ""
"**Stretch Mode = Viewport** : 视口缩放意味着根 :ref:`Viewport "
"<class_Viewport>` 的尺寸被精确地设置为在项目设置的 **Display** 部分指定的基本"
"尺寸. 场景首先被渲染到这个视口. 最后, 这个视口被缩放以适应屏幕(考虑 "
"**Stretch Aspect** 的设置)."

#, fuzzy
msgid ""
"To configure the stretch mode at runtime from a script, use the ``get_tree()."
"root.content_scale_mode`` property (see :ref:`Window.content_scale_mode "
"<class_Window_property_content_scale_mode>` and the :ref:`ContentScaleMode "
"<enum_Window_ContentScaleMode>` enum)."
msgstr ""
"要在运行时从脚本中配置拉伸, 请使用 ``get_tree().set_screen_stretch()`` 方法"
"(见 :ref:`SceneTree.set_screen_stretch() "
"<class_SceneTree_method_set_screen_stretch>` )."

msgid "Stretch Aspect"
msgstr "拉伸比例"

msgid ""
"The second setting is the stretch aspect. Note that this only takes effect "
"if **Stretch Mode** is set to something other than **Disabled**."
msgstr ""
"第二个设置是拉伸纵横比. 请注意, 只有在 **Stretch Mode** 被设置为 "
"**Disabled** 以外的情况下, 这才会生效."

msgid ""
"In the animations below, you will notice gray and black areas. The black "
"areas are added by the engine and cannot be drawn into. The gray areas are "
"part of your scene, and can be drawn to. The gray areas correspond to the "
"region outside the blue frame you see in the 2D editor."
msgstr ""
"在下面的动画中, 你会注意到灰色和黑色区域. 黑色区域由引擎添加, 无法绘制. 灰色"
"区域是场景的一部分, 可以绘制. 灰色区域对应于你在2D编辑器中看到的蓝色框架外的"
"区域."

msgid ""
"**Stretch Aspect = Ignore**: Ignore the aspect ratio when stretching the "
"screen. This means that the original resolution will be stretched to exactly "
"fill the screen, even if it's wider or narrower. This may result in "
"nonuniform stretching: things looking wider or taller than designed."
msgstr ""
"**Stretch Aspect = Ignore** : 在拉伸屏幕时忽略长宽比. 这意味着原始分辨率将被"
"拉伸以完全填满屏幕, 即使它更宽或更窄. 这可能会导致不均匀的拉伸, 事物看起来比"
"设计的更宽或更高."

msgid ""
"**Stretch Aspect = Keep**: Keep aspect ratio when stretching the screen. "
"This means that the viewport retains its original size regardless of the "
"screen resolution, and black bars will be added to the top/bottom of the "
"screen (\"letterboxing\") or the sides (\"pillarboxing\")."
msgstr ""
"**Stretch Aspect = Keep** : 在拉伸屏幕的时候保持长宽比. 这意味着无论屏幕分辨"
"率如何, 视口都会保留原来的尺寸, 黑条会被添加到屏幕的顶部或底部(\"宽屏模式 \")"
"或侧面(\" 竖屏模式\")."

msgid ""
"This is a good option if you know the aspect ratio of your target devices in "
"advance, or if you don't want to handle different aspect ratios."
msgstr ""
"如果你事先知道目标设备的宽高比, 或者你不想处理不同的宽高比, 这是一个不错的选"
"择."

msgid ""
"**Stretch Aspect = Keep Width**: Keep aspect ratio when stretching the "
"screen. If the screen is wider than the base size, black bars are added at "
"the left and right (pillarboxing). But if the screen is taller than the base "
"resolution, the viewport will be grown in the vertical direction (and more "
"content will be visible to the bottom). You can also think of this as "
"\"Expand Vertically\"."
msgstr ""
"**Stretch Aspect = Keep Width** : 在拉伸屏幕时保持长宽比. 如果屏幕比基本尺寸"
"宽, 则会在左右两边添加黑条(竖屏模式). 但如果屏幕比基本分辨率高, 视口将在垂直"
"方向上增长(更多的内容将在底部可见). 你也可以把它看作是 \"垂直扩展\" ."

msgid ""
"This is usually the best option for creating GUIs or HUDs that scale, so "
"some controls can be anchored to the bottom (:ref:`doc_size_and_anchors`)."
msgstr ""
"这通常是创建可扩展的GUI或HUD的最佳选择, 因此一些控件可以锚定到底部( :ref:"
"`doc_size_and_anchors`)."

msgid ""
"**Stretch Aspect = Keep Height**: Keep aspect ratio when stretching the "
"screen. If the screen is taller than the base size, black bars are added at "
"the top and bottom (letterboxing). But if the screen is wider than the base "
"resolution, the viewport will be grown in the horizontal direction (and more "
"content will be visible to the right). You can also think of this as "
"\"Expand Horizontally\"."
msgstr ""
"**Stretch Aspect = Keep Height** : 在拉伸屏幕时保持长宽比. 如果屏幕比基本尺寸"
"高, 则会在顶部和底部添加黑条(宽屏模式). 但如果屏幕比基本分辨率宽, 视口将在水"
"平方向上增长(更多的内容将在右边可见). 你也可以把它看作是 \"水平扩展\" ."

msgid ""
"This is usually the best option for 2D games that scroll horizontally (like "
"runners or platformers)."
msgstr "这通常是水平滚动的2D游戏的最佳选择(如跑步者或平台游戏者)."

msgid ""
"**Stretch Aspect = Expand**: Keep aspect ratio when stretching the screen, "
"but keep neither the base width nor height. Depending on the screen aspect "
"ratio, the viewport will either be larger in the horizontal direction (if "
"the screen is wider than the base size) or in the vertical direction (if the "
"screen is taller than the original size)."
msgstr ""
"**Stretch Aspect = Expand** : 在拉伸屏幕时保持长宽比, 但既不保持基本宽度也不"
"保持高度. 根据屏幕的长宽比, 视口将在水平方向(如果屏幕比基本尺寸宽)或垂直方向"
"上变大(如果屏幕比原始尺寸高)."

msgid ""
"To support both portrait and landscape mode with a similar automatically "
"determined scale factor, set your project's base resolution to be a *square* "
"(1:1 aspect ratio) instead of a rectangle. For instance, if you wish to "
"design for 1280×720 as the base resolution but wish to support both portrait "
"and landscape mode, use 720×720 as the project's base window size in the "
"Project Settings."
msgstr ""
"为了以类似的自动确定的比例系数支持纵向和横向模式，请将你的项目的基本分辨率设"
"置为 *方形* （1:1长宽比）而不是矩形。例如，如果你希望以1280×720为基本分辨率进"
"行设计，但又希望同时支持纵向和横向模式，那么在项目设置中使用720×720作为项目的"
"基本窗口尺寸。"

msgid ""
"To allow the user to choose their preferred screen orientation at run-time, "
"remember to set **Display > Window > Handheld > Orientation** to ``sensor``."
msgstr ""
"为了让用户在运行时选择自己喜欢的屏幕方向，记得将**Display > Window > "
"Handheld > Orientation** 设置为 ``sensor`` (传感器)."

#, fuzzy
msgid ""
"To configure the stretch aspect at runtime from a script, use the "
"``get_tree().root.content_scale_aspect`` property (see :ref:`Window."
"content_scale_aspect <class_Window_property_content_scale_aspect>` and the :"
"ref:`ContentScaleAspect <enum_Window_ContentScaleAspect>` enum)."
msgstr ""
"要在运行时从脚本中配置拉伸, 请使用 ``get_tree().set_screen_stretch()`` 方法"
"(见 :ref:`SceneTree.set_screen_stretch() "
"<class_SceneTree_method_set_screen_stretch>` )."

msgid "Stretch Scale"
msgstr "拉伸缩放"

#, fuzzy
msgid ""
"The **Scale** setting allows you to add an extra scaling factor on top of "
"what the **Stretch** options above already provide. The default value of "
"``1.0`` means that no additional scaling occurs."
msgstr ""
"**Shrink** 设置允许你在上面的 **Stretch** 选项已经提供的基础上增加一个额外的"
"缩放系数. 默认值为1意味着不发生缩放."

#, fuzzy
msgid ""
"For example, if you set **Scale** to ``2.0`` and leave **Stretch Mode** on "
"**Disabled**, each unit in your scene will correspond to 2×2 pixels on the "
"screen. This is a good way to provide scaling options for non-game "
"applications."
msgstr ""
"例如, 如果你将 **Shrink** 设置为4, 并将 **Stretch Mode** 置于 **Disabled** 状"
"态, 那么你的场景中的每个单元将对应于屏幕上的4×4像素."

msgid ""
"If **Stretch Mode** is set to **canvas_items**, 2D elements will be scaled "
"relative to the base window size, then multiplied by the **Scale** setting. "
"This can be exposed to players to allow them to adjust the automatically "
"determined scale to their liking, for better accessibility."
msgstr ""

msgid ""
"If **Stretch Mode** is set to **viewport**, the viewport's resolution is "
"divided by **Scale**. This makes pixels look larger and reduces rendering "
"resolution (with a given window size), which can improve performance."
msgstr ""

#, fuzzy
msgid ""
"To configure the stretch scale at runtime from a script, use the "
"``get_tree().root.content_scale_factor`` property (see :ref:`Window."
"content_scale_factor <class_Window_property_content_scale_factor>`)."
msgstr ""
"要在运行时从脚本中配置拉伸, 请使用 ``get_tree().set_screen_stretch()`` 方法"
"(见 :ref:`SceneTree.set_screen_stretch() "
"<class_SceneTree_method_set_screen_stretch>` )."

msgid "Stretch Scale Mode"
msgstr "拉伸缩放模式"

msgid ""
"Since Godot 4.2, the **Stretch Scale Mode** setting allows you to constrain "
"the automatically determined scale factor (as well as the manually specified "
"**Stretch Scale** setting) to integer values. By default, this setting is "
"set to ``fractional``, which allows any scale factor to be applied "
"(including fractional values such as ``2.5``). When set to ``integer``, the "
"value is rounded down to the nearest integer. For example, instead of using "
"a scale factor of ``2.5``, it would be rounded down to ``2.0``. This is "
"useful to prevent distortion when displaying pixel art."
msgstr ""

msgid ""
"Compare this pixel art which is displayed with the ``viewport`` stretch "
"mode, with the stretch scale mode set to ``fractional``:"
msgstr ""

msgid "Fractional scaling example (incorrect pixel art appearance)"
msgstr ""

msgid ""
"Checkerboard doesn't look \"even\". Line widths in the logo and text varies "
"wildly."
msgstr ""

msgid ""
"This pixel art is also displayed with the ``viewport`` stretch mode, but the "
"stretch scale mode is set to ``integer`` this time:"
msgstr ""

msgid "Integer scaling example (correct pixel art appearance)"
msgstr ""

msgid "Checkerboard looks perfectly even. Line widths are consistent."
msgstr ""

msgid ""
"For example, if your viewport base size is 640×360 and the window size is "
"1366×768:"
msgstr ""

msgid ""
"When using ``fractional``, the viewport is displayed at a resolution of "
"1366×768 (scale factor is roughly 2.133×). The entire window space is used. "
"Each pixel in the viewport corresponds to 2.133×2.133 pixels in the "
"displayed area. However, since displays can only display \"whole\" pixels, "
"this will lead to uneven pixel scaling which results in incorrect appearance "
"of pixel art."
msgstr ""

msgid ""
"When using ``integer``, the viewport is displayed at a resolution of "
"1280×720 (scale factor is 2×). The remaining space is filled with black bars "
"on all four sides, so that each pixel in the viewport corresponds to 2×2 "
"pixels in the displayed area."
msgstr ""

msgid ""
"This setting is effective with any stretch mode. However, when using the "
"``disabled`` stretch mode, it will only affect the **Stretch Scale** setting "
"by rounding it *down* to the nearest integer value. This can be used for 3D "
"games that have a pixel art UI, so that the visible area in the 3D viewport "
"doesn't reduce in size (which occurs when using ``canvas_items`` or "
"``viewport`` stretch mode with the ``integer`` scale mode)."
msgstr ""

msgid ""
"Games should use the **Exclusive Fullscreen** window mode, as opposed to "
"**Fullscreen** which is designed to prevent Windows from automatically "
"treating the window as if it was exclusive fullscreen."
msgstr ""

msgid ""
"**Fullscreen** is meant to be used by GUI applications that want to use per-"
"pixel transparency without a risk of having it disabled by the OS. It "
"achieves this by leaving a 1-pixel line at the bottom of the screen. By "
"contrast, **Exclusive Fullscreen** uses the actual screen size and allows "
"Windows to reduce jitter and input lag for fullscreen games."
msgstr ""

msgid ""
"When using integer scaling, this is particularly important as the 1-pixel "
"height reduction from the **Fullscreen** mode can cause integer scaling to "
"use a smaller scale factor than expected."
msgstr ""

msgid "Common use case scenarios"
msgstr "常见使用场景"

msgid ""
"The following settings are recommended to support multiple resolutions and "
"aspect ratios well."
msgstr "如果要适配多种分辨率和纵横比，推荐使用以下设置。"

msgid "Desktop game"
msgstr "桌面游戏"

msgid "**Non-pixel art:**"
msgstr "**非像素风：**"

#, fuzzy
msgid ""
"Set the base window width to ``1920`` and window height to ``1080``. If you "
"have a display smaller than 1920×1080, set **Window Width Override** and "
"**Window Height Override** to lower values to make the window smaller when "
"the project starts."
msgstr ""
"将基础窗口宽度设置为 ``1920``\\ 、窗口高度设置为 ``1080``\\ 。如果你的显示器"
"小于 1920×1080，就将 **Test Width** 和 **Test Height**\\ （测试宽度和测试高"
"度）设置为较小的值，项目启动时就会将窗口调小。"

msgid ""
"Alternatively, if you're targeting high-end devices primarily, set the base "
"window width to ``3840`` and window height to ``2160``. This allows you to "
"provide higher resolution 2D assets, resulting in crisper visuals at the "
"cost of higher memory usage and file sizes. Note that this will make non-"
"mipmapped textures grainy on low resolution devices, so make sure to follow "
"the instructions described in :ref:"
"`doc_multiple_resolutions_reducing_aliasing_on_downsampling`."
msgstr ""
"或者如果你主要针对的是高端设备，那么就把基础窗口宽度设置为 ``3840``\\ 、窗口"
"高度设置为 ``2160`` 。这样你就可以提供更高分辨率的 2D 资产，用更高的内存占用"
"和文件大小换取更清晰的画面。注意，这样做会让未做 mipmap 的纹理在低分辨率设备"
"上具有颗粒感，请参考 :ref:"
"`doc_multiple_resolutions_reducing_aliasing_on_downsampling` 进行操作。"

#, fuzzy
msgid "Set the stretch mode to ``canvas_items``."
msgstr "将拉伸模式（Stretch Mode）设置为 ``viewport`` （视图）。"

msgid ""
"Set the stretch aspect to ``expand``. This allows for supporting multiple "
"aspect ratios and makes better use of tall smartphone displays (such as 18:9 "
"or 19:9 aspect ratios)."
msgstr ""
"将拉伸比例（Stretch Aspect）设置为 ``expand`` （扩展）。这样可以支持多种分辨"
"率，并且能够更好地利用较长的智能手机屏幕（例如 18:9 和 19:9 的长宽比）。"

msgid ""
"Configure Control nodes' anchors to snap to the correct corners using the "
"**Layout** menu."
msgstr "使用 **布局** 菜单将 Control 节点的锚点吸附到正确的角落。"

msgid "**Pixel art:**"
msgstr "**像素风：**"

#, fuzzy
msgid ""
"Set the base window size to the viewport size you intend to use. Most pixel "
"art games use viewport sizes between 256×224 and 640×480. 640×360 is a good "
"baseline, as it scales to 1280×720, 1920×1080, 2560×1440, and 3840×2160 "
"without any black bars when using integer scaling. Higher viewport sizes "
"will require using higher resolution artwork, unless you intend to show more "
"of the game world at a given time."
msgstr ""
"将基础窗口大小设置为你想要使用的视图尺寸。多数像素风游戏使用的视图尺寸在 "
"256×224 和 640×480 之间。视图尺寸越大，所需资产的分辨率也就越高，除非你想要显"
"示更大的游戏世界区域。"

msgid "Set the stretch mode to ``viewport``."
msgstr "将拉伸模式（Stretch Mode）设置为 ``viewport`` （视图）。"

msgid ""
"Set the stretch aspect to ``keep`` to enforce a single aspect ratio (with "
"black bars). As an alternative, you can set the stretch aspect to ``expand`` "
"to support multiple aspect ratios."
msgstr ""
"将拉伸比例（Stretch Aspect）设置为 ``keep`` （保持）可以（通过添加黑条的方"
"式）强制使用固定的长宽比。如果你想支持不同长宽比的话，也可以把拉伸模式设置为 "
"``expand`` （扩展）。"

msgid ""
"If using the ``expand`` stretch aspect, Configure Control nodes' anchors to "
"snap to the correct corners using the **Layout** menu."
msgstr ""
"如果选用 ``expand`` 拉伸比例，使用 **布局** 菜单将 Control 节点的锚点吸附到正"
"确的角落。"

msgid ""
"Set the stretch scale mode to ``integer``. This prevents uneven pixel "
"scaling from occurring, which makes pixel art not display as intended."
msgstr ""

#, fuzzy
msgid ""
"The ``viewport`` stretch mode provides low-resolution rendering that is then "
"stretched to the final window size. If you are OK with sprites being able to "
"move or rotate in \"sub-pixel\" positions or wish to have a high resolution "
"3D viewport, you should use the ``canvas_items`` stretch mode instead of the "
"``viewport`` stretch mode."
msgstr ""
"``viewport`` 拉伸模式会先以较低分辨率渲染，然后拉伸到最终窗口的大小。如果你能"
"够接受精灵可以移动或者旋转到“次像素”位置，或者希望有高分辨率的 3D 视图，可以"
"把 ``viewport`` 拉伸模式换成 ``2d`` 模式。"

msgid "Mobile game in landscape mode"
msgstr "横屏的手机游戏"

msgid ""
"Godot is configured to use landscape mode by default. This means you don't "
"need to change the display orientation project setting."
msgstr "Godot 默认使用横屏模式，所以你无需在项目设置中调整显示方向。"

msgid "Set the base window width to ``1280`` and window height to ``720``."
msgstr "将基础窗口宽度设置为 ``1280``\\ ，窗口高度设置为 ``720``\\ 。"

msgid ""
"Alternatively, if you're targeting high-end devices primarily, set the base "
"window width to ``1920`` and window height to ``1080``. This allows you to "
"provide higher resolution 2D assets, resulting in crisper visuals at the "
"cost of higher memory usage and file sizes. Many devices have even higher "
"resolution displays (1440p), but the difference with 1080p is barely visible "
"given the small size of smartphone displays. Note that this will make non-"
"mipmapped textures grainy on low resolution devices, so make sure to follow "
"the instructions described in :ref:"
"`doc_multiple_resolutions_reducing_aliasing_on_downsampling`."
msgstr ""
"或者如果你主要针对的是高端设备，那么就把基础窗口宽度设置为 ``1920``\\ 、窗口"
"高度设置为 ``1080``\\ 。这样你就可以提供更高分辨率的 2D 资产，用更高的内存占"
"用和文件大小换取更清晰的画面。很多设备拥有更高分辨率的显示屏（1440p），但因为"
"智能手机的屏幕比较小，所以很难看出和 1080p 的区别。注意，这样做会让未做 "
"mipmap 的纹理在低分辨率设备上具有颗粒感，请参考 :ref:"
"`doc_multiple_resolutions_reducing_aliasing_on_downsampling` 进行操作。"

msgid ""
"To better support tablets and foldable phones (which frequently feature "
"displays with aspect ratios close to 4:3), consider using a base resolution "
"that has a 4:3 aspect ratio while following the rest of the instructions "
"here. For instance, you can set the base window width to ``1280`` and the "
"base window height to ``960``."
msgstr ""

msgid "Mobile game in portrait mode"
msgstr "竖屏的手机游戏"

#, fuzzy
msgid "Set the base window width to ``720`` and window height to ``1280``."
msgstr "将基础窗口宽度设置为 ``720``\\ ，窗口高度设置为 ``1080``\\ 。"

msgid ""
"Alternatively, if you're targeting high-end devices primarily, set the base "
"window width to ``1080`` and window height to ``1920``. This allows you to "
"provide higher resolution 2D assets, resulting in crisper visuals at the "
"cost of higher memory usage and file sizes. Many devices have even higher "
"resolution displays (1440p), but the difference with 1080p is barely visible "
"given the small size of smartphone displays. Note that this will make non-"
"mipmapped textures grainy on low resolution devices, so make sure to follow "
"the instructions described in :ref:"
"`doc_multiple_resolutions_reducing_aliasing_on_downsampling`."
msgstr ""
"或者如果你主要针对的是高端设备，那么就把基础窗口宽度设置为 ``1080``\\ 、窗口"
"高度设置为 ``1920``\\ 。这样你就可以提供更高分辨率的 2D 资产，用更高的内存占"
"用和文件大小换取更清晰的画面。很多设备拥有更高分辨率的显示屏（1440p），但因为"
"智能手机的屏幕比较小，所以很难看出和 1080p 的区别。注意，这样做会让未做 "
"mipmap 的纹理在低分辨率设备上具有颗粒感，请参考 :ref:"
"`doc_multiple_resolutions_reducing_aliasing_on_downsampling` 进行操作。"

msgid "Set **Display > Window > Handheld > Orientation** to ``portrait``."
msgstr ""
"将 **Display > Window > Handheld > Orientation** 设置为 ``portrait`` （竖"
"屏）。"

msgid ""
"To better support tablets and foldable phones (which frequently feature "
"displays with aspect ratios close to 4:3), consider using a base resolution "
"that has a 3:4 aspect ratio while following the rest of the instructions "
"here. For instance, you can set the base window width to ``960`` and the "
"base window height to ``1280``."
msgstr ""

msgid "Non-game application"
msgstr "非游戏应用"

msgid ""
"Set the base window width and height to the smallest window size that you "
"intend to target. This is not required, but this ensures that you design "
"your UI with small window sizes in mind."
msgstr ""
"将基础窗口宽高设置为你想要支持的最小窗口尺寸。这不是必须的，但是可以保证你在"
"设计 UI 时考虑较小的窗口尺寸。"

msgid "Keep the stretch mode to its default value, ``disabled``."
msgstr "保持拉伸模式（Stretch Mode）为默认值 ``disabled``\\ （禁用）。"

msgid ""
"Keep the stretch aspect to its default value, ``ignore`` (its value won't be "
"used since the stretch mode is ``disabled``)."
msgstr ""
"保持拉伸比例（Stretch Aspect）为默认值 ``ignore（忽略）`` （因为拉伸模式是 "
"``disabled`` ，所以这里的值不会被用到）。"

msgid ""
"You can define a minimum window size by setting ``OS.min_window_size`` in a "
"script's ``_ready()`` function. This prevents the user from resizing the "
"application below a certain size, which could break the UI layout."
msgstr ""
"你可以在脚本的 ``_ready()`` 函数中通过设置 ``OS.min_window_size`` 来定义窗口"
"的最小尺寸。这样可以防止用户将应用窗口缩得过小，导致 UI 布局的问题。"

msgid ""
"Godot doesn't support manually overriding the 2D scale factor yet, so it is "
"not possible to have hiDPI support in non-game applications. Due to this, it "
"is recommended to leave **Allow Hidpi** disabled in non-game applications to "
"allow for the OS to use its low-DPI fallback."
msgstr ""
"Godot 尚未支持手动设置 2D 缩放比例，所以无法在非游戏应用中支持 hiDPI。因此，"
"推荐为非游戏应用禁用 **Allow Hidpi** 选项，操作系统会回退到低 DPI。"

msgid "hiDPI support"
msgstr "支持 hiDPI 高分辨率屏幕"

msgid ""
"By default, Godot projects aren't considered DPI-aware by the operating "
"system. This is done to improve performance on low-end systems, since the "
"operating system's DPI fallback scaling will be faster than letting the "
"application scale itself (even when using the ``viewport`` stretch mode)."
msgstr ""
"默认情况下，操作系统会认为 Godot 项目是 DPI 无关的。因为操作系统的 DPI 回退缩"
"放比让应用程序自己做缩放要快很多（即便用的是 ``viewport`` 拉伸模式），所以这"
"样做可以提高在低端系统上的性能。"

msgid ""
"However, the OS-provided DPI fallback scaling doesn't play well with "
"fullscreen mode. If you want crisp visuals on hiDPI displays or if project "
"uses fullscreen, it's recommended to enable **Display > Window > Dpi > Allow "
"Hidpi** in the Project Settings."
msgstr ""
"不过操作系统的 DPI 回退缩放功能在全屏模式下并不好用。如果你想在 hiDPI 显示器"
"下得到清晰的画面，又或者想要支持全屏，那么推荐启用项目设置中的 **Display > "
"Window > Dpi > Allow Hidpi** 。"

msgid ""
"**Allow Hidpi** is only effective on Windows and macOS. It's ignored on all "
"other platforms."
msgstr ""
"**Allow Hidpi（允许 hiDPI）** 仅在 Windows 和 macOS 上有效，其它平台会忽略这"
"个选项。"

msgid ""
"The Godot editor itself is always marked as DPI-aware. Running the project "
"from the editor will only be DPI-aware if **Allow Hidpi** is enabled in the "
"Project Settings."
msgstr ""
"Godot 编辑器本身是打开了这个选项，与 DPI 相关的。但在编辑器中运行项目时，只有"
"在项目设置里启用 **Allow Hidpi** 才会让项目与 DPI 相关。"

msgid "Reducing aliasing on downsampling"
msgstr "减少缩减取样的混叠"

msgid ""
"If the game has a very high base resolution (e.g. 3840×2160), aliasing might "
"appear when downsampling to something considerably lower like 1280×720."
msgstr ""
"如果游戏的基本分辨率很高（如 3840×2160），当采样降到相当低的分辨率（如 "
"1280×720）时，可能会出现锯齿。可以通过在加载时将所有图像缩小 2 倍来减少锯齿的"
"出现。这可以通过在加载游戏数据之前调用下面的方法来实现。"

#, fuzzy
msgid ""
"To resolve this, you can :ref:`enable mipmaps "
"<doc_importing_images_mipmaps>` on all your 2D textures. However, enabling "
"mipmaps will increase memory usage which can be an issue on low-end mobile "
"devices."
msgstr ""
"或者, 也可以在所有2D纹理上启用mipmap. 然而, 启用mipmap会增加内存的使用量, 这"
"个在低端移动设备上可能会出现问题."

msgid "Handling aspect ratios"
msgstr "处理纵横比"

msgid ""
"Once scaling for different resolutions is accounted for, make sure that your "
"*user interface* also scales for different aspect ratios. This can be done "
"using :ref:`anchors <doc_size_and_anchors>` and/or :ref:`containers "
"<doc_gui_containers>`."
msgstr ""
"一旦考虑到不同分辨率的缩放, 请确保你的 *user interface* 也能为不同的长宽比进"
"行缩放. 这可以使用 :ref:`anchors <doc_size_and_anchors>` 和/或 :ref:"
"`containers <doc_gui_containers>` 来完成."

msgid "Field of view scaling"
msgstr "视场角缩放"

msgid ""
"The 3D Camera node's **Keep Aspect** property defaults to the **Keep "
"Height** scaling mode (also called *Hor+*). This is usually the best value "
"for desktop games and mobile games in landscape mode, as widescreen displays "
"will automatically use a wider field of view."
msgstr ""
"3D相机节点的 **Keep Aspect** 属性默认为 **Keep Height** 缩放模式(也称为 "
"*Hor+* ). 在横屏模式下, 这通常是桌面游戏和手机游戏的最佳选择, 因为宽屏显示器"
"会自动使用更宽的视野."

msgid ""
"However, if your 3D game is intended to be played in portrait mode, it may "
"make more sense to use **Keep Width** instead (also called *Vert-*). This "
"way, smartphones with an aspect ratio taller than 16:9 (e.g. 19:9) will use "
"a *taller* field of view, which is more logical here."
msgstr ""
"然而, 如果你的3D游戏打算使用纵向模式, 那么使用 **Keep Width保持宽度** 称为"
"( *Vert-* )可能会更有意义. 这样, 宽高比大于16:9(例如19:9)的智能手机将使用 *更"
"高* 的视野, 这在这里更符合逻辑."

msgid "Scaling 2D and 3D elements differently using Viewports"
msgstr "使用 Viewport 以不同的方式缩放 2D 和 3D 元素"

msgid ""
"Using multiple Viewport nodes, you can have different scales for various "
"elements. For instance, you can use this to render the 3D world at a low "
"resolution while keeping 2D elements at the native resolution. This can "
"improve performance significantly while keeping the HUD and other 2D "
"elements crisp."
msgstr ""
"使用多个视图窗口节点, 可以对不同的元素使用不同的比例. 例如, 你可以使用此选项"
"以低分辨率渲染3D世界, 同时将2D元素保持在原生分辨率. 这可以显著提高性能, 同时"
"保持HUD和其他2D元素的清晰度."

#, fuzzy
msgid ""
"This is done by using the root Viewport node only for 2D elements, then "
"creating a Viewport node to display the 3D world and displaying it using a "
"SubViewportContainer or TextureRect node. There will effectively be two "
"viewports in the final project. One upside of using TextureRect over "
"SubViewportContainer is that it allows enable linear filtering. This makes "
"scaled 3D viewports look better in many cases."
msgstr ""
"这是通过只对2D元素使用根Viewport节点, 然后创建一个Viewport节点来显示3D世界并"
"使用ViewportContainer或TextureRect节点来实现的. 最终项目中实际上将有两个视图"
"窗口. 与ViewportContainer相比, 使用TextureRect的一个好处是它允许启用线性过"
"滤. 这使得缩放的3D视图窗口在许多情况下看起来更好."

msgid ""
"See the `3D viewport scaling demo <https://github.com/godotengine/godot-demo-"
"projects/tree/master/viewport/3d_scaling>`__ for examples."
msgstr ""
"有关示例, 请参见 `3D 视口缩放演示 <https://github.com/godotengine/godot-demo-"
"projects/tree/master/viewport/3d_scaling>`__ ."

msgid "Translation status"
msgstr "翻译状态"
