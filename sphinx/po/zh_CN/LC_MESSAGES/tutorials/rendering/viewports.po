# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using Viewports"
msgstr "使用 Viewport"

msgid "Introduction"
msgstr "前言"

#, fuzzy
msgid ""
"Think of a :ref:`Viewport <class_Viewport>` as a screen onto which the game "
"is projected. In order to see the game, we need to have a surface on which "
"to draw it. That surface is the Root Viewport."
msgstr ""
"将 :ref:`Viewports <class_Viewport>` 想成投影游戏的荧幕. 为了看到游戏, 我们需"
"要有一个表面来绘制它, 这个表面是作为根节点的 :ref:`Viewport "
"<class_Viewport>`."

#, fuzzy
msgid ""
":ref:`SubViewports <class_SubViewport>` are a kind of Viewport that can be "
"added to the scene so that there are multiple surfaces to draw on. When we "
"are drawing to a SubViewport, we call it a render target. We can access the "
"contents of a render target by accessing its corresponding :ref:`texture "
"<class_Viewport_method_get_texture>`. By using a SubViewport as render "
"target, we can either render multiple scenes simultaneously or we can render "
"to a :ref:`ViewportTexture <class_ViewportTexture>` which is applied to an "
"object in the scene, for example a dynamic skybox."
msgstr ""
":ref:`Viewports <class_Viewport>` 也可以添加到场景中, 以便绘制多个区域. 当我"
"们绘制到一个不是根节点的 :ref:`Viewport <class_Viewport>` 时, 我们将该视口称"
"为渲染目标. 我们可以通过访问它对应的 :ref:`texture <class_ViewportTexture>` "
"属性来访问渲染目标的内容. 将任一 :ref:`Viewport <class_Viewport>` 作为渲染目"
"标时, 我们要么可以同时渲染多个场景, 要么可以渲染到场景中某个对象的 :ref:"
"`texture <class_ViewportTexture>` 上, 例如渲染到动态天空盒的材质上."

#, fuzzy
msgid ""
":ref:`SubViewports <class_SubViewport>` have a variety of use cases, "
"including:"
msgstr ":ref:`Viewport <class_Viewport>` 有多种使用情况, 包括:"

msgid "Rendering 3D objects within a 2D game"
msgstr "在2D游戏中渲染3D物体"

msgid "Rendering 2D elements in a 3D game"
msgstr "在3D游戏中渲染2D元素"

msgid "Rendering dynamic textures"
msgstr "渲染动态纹理"

msgid "Generating procedural textures at runtime"
msgstr "在运行时生成程序式纹理"

msgid "Rendering multiple cameras in the same scene"
msgstr "在同一场景中渲染多个摄像机"

msgid ""
"What all these use cases have in common is that you are given the ability to "
"draw objects to a texture as if it were another screen and can then choose "
"what to do with the resulting texture."
msgstr ""
"所有这些用例的共同点是, 你被赋予了在纹理上绘制物体的能力, 就好像它是另一个屏"
"幕一样, 然后可以选择如何处理产生的纹理."

msgid ""
"Another kind of Viewports in Godot are :ref:`Windows <class_Window>`. They "
"allow their content to be projected onto a window. While the Root Viewport "
"is a Window, they are less flexible. If you want to use the texture of a "
"Viewport, you'll be working with :ref:`SubViewports <class_SubViewport>` "
"most of the time."
msgstr ""

msgid "Input"
msgstr "输入"

#, fuzzy
msgid ""
":ref:`Viewports <class_Viewport>` are also responsible for delivering "
"properly adjusted and scaled input events to their children nodes. By "
"default :ref:`SubViewports <class_SubViewport>` don't automatically receive "
"input, unless they receive it from their direct :ref:`SubViewportContainer "
"<class_SubViewportContainer>` parent node. In this case, input can be "
"disabled with the :ref:`Disable Input "
"<class_Viewport_property_gui_disable_input>` property."
msgstr ""
":ref:`Viewport <class_Viewport>` 也负责将正确调整和缩放的输入事件传递给他们所"
"有的子节点. 通常, 输入是由树中最近的 :ref:`Viewport <class_Viewport>` 接收"
"的, 但是你可以通过将 'Disable Input' 选为 'on' 来设置 :ref:`Viewport "
"<class_Viewport>` 不接收输入；这将允许树中最近的 :ref:`Viewport "
"<class_Viewport>` 捕捉输入."

#, fuzzy
msgid ""
"For more information on how Godot handles input, please read the :ref:`Input "
"Event Tutorial <doc_inputevent>`."
msgstr ""
"关于 Godot 如何处理输入的更多信息，请阅读\\ :ref:`输入事件教程 "
"<doc_inputevent>`\\ 。"

msgid "Listener"
msgstr "Listener"

#, fuzzy
msgid ""
"Godot supports 3D sound (in both 2D and 3D nodes). More on this can be found "
"in the :ref:`Audio Streams Tutorial <doc_audio_streams>`. For this type of "
"sound to be audible, the :ref:`Viewport <class_Viewport>` needs to be "
"enabled as a listener (for 2D or 3D). If you are using a :ref:`SubViewport "
"<class_SubViewport>` to display your :ref:`World3D <class_World3D>` or :ref:"
"`World2D <class_World2D>`, don't forget to enable this!"
msgstr ""
"Godot 支持 3D 声音（在 2D 和 3D 节点中都支持）；更多信息可以在\\ :ref:`音频流"
"教程 <doc_audio_streams>`\\ 中找到。为了使这种类型的声音能够被听到, :ref:"
"`Viewport <class_Viewport>` 需要被启用为一个监听器(对于2D或3D). 如果你使用一"
"个自定义的 :ref:`Viewport <class_Viewport>` 来显示你的 :ref:`World "
"<class_World>`, 别忘了启用这个功能！"

msgid "Cameras (2D & 3D)"
msgstr "摄像机（2D 和 3D）"

#, fuzzy
msgid ""
"When using a :ref:`Camera3D <class_Camera3D>` or :ref:`Camera2D "
"<class_Camera2D>`, it will always display on the closest parent :ref:"
"`Viewport <class_Viewport>` (going towards the root). For example, in the "
"following hierarchy:"
msgstr ""
"当使用 :ref:`Camera <class_Camera>` / :ref:`Camera2D <class_Camera2D>` 时, 摄"
"像机将始终显示在最近的父节点上 :ref:`Viewport <class_Viewport>` (朝向根节"
"点). 例如, 在下面的层次结构中:"

#, fuzzy
msgid ""
"``CameraA`` will display on the Root :ref:`Viewport <class_Viewport>` and it "
"will draw ``MeshA``. ``CameraB`` will be captured by the :ref:`SubViewport "
"<class_SubViewport>` along with ``MeshB``. Even though ``MeshB`` is in the "
"scene hierarchy, it will still not be drawn to the Root Viewport. Similarly, "
"``MeshA`` will not be visible from the SubViewport because SubViewports only "
"capture nodes below them in the hierarchy."
msgstr ""
"CameraA将显示根节点的 :ref:`Viewport <class_Viewport>` , 它将绘制MeshA. "
"CameraB将被 :ref:`Viewport <class_Viewport>` 节点以及MeshB捕获. 即使MeshB在场"
"景层次结构中, 它仍然不会被绘制到根节点的 :ref:`Viewport <class_Viewport>` "
"中. 类似地, 在 :ref:`Viewport <class_Viewport>` 节点中不会看到MeshA, 因为 :"
"ref:`Viewport <class_Viewport>` 节点仅捕获层次结构中它下面的节点."

#, fuzzy
msgid ""
"There can only be one active camera per :ref:`Viewport <class_Viewport>`, so "
"if there is more than one, make sure that the desired one has the :ref:"
"`current <class_Camera3D_property_current>` property set, or make it the "
"current camera by calling:"
msgstr ""
"每个视口 :ref:`Viewport <class_Viewport>` 只能有一个激活的摄像机, 因此, 如果"
"有多个摄像机时, 请确保你需要的那个摄像机的 \"current\" 属性被设置上, 或者通过"
"调用以下语句来使其成为当前摄像机:"

#, fuzzy
msgid ""
"By default, cameras will render all objects in their world. In 3D, cameras "
"can use their :ref:`cull_mask <class_Camera3D_property_cull_mask>` property "
"combined with the :ref:`VisualInstance3D's <class_VisualInstance3D>` :ref:"
"`layer <class_VisualInstance3D_property_layers>` property to restrict which "
"objects are rendered."
msgstr ""
"默认情况下, 相机将渲染其世界中的所有对象. 在3D中, 相机可以使用他们的 :ref:"
"`cull_mask <class_Camera_property_cull_mask>` 属性和 :ref:`VisualInstance's "
"<class_VisualInstance>` :ref:`layer <class_VisualInstance_property_layers>` "
"属性来限制哪些对象被渲染."

msgid "Scale & stretching"
msgstr "缩放和拉伸"

#, fuzzy
msgid ""
":ref:`SubViewports <class_SubViewport>` have a :ref:"
"`size<class_SubViewport_property_size>` property, which represents the size "
"of the SubViewport in pixels. For SubViewports which are children of :ref:"
"`SubViewportContainers <class_SubViewportContainer>`, these values are "
"overridden, but for all others, this sets their resolution."
msgstr ""
":ref:`Viewport <class_Viewport>` 有一个“size”属性，表示 :ref:`Viewport "
"<class_Viewport>` 的尺寸，单位为像素。对于 :ref:`SubViewportContainer "
"<class_SubViewportContainer>` 的子 :ref:`Viewport <class_Viewport>` 节点而"
"言，这些值会被覆盖，但其他情况下，这个属性设置的就是分辨率。"

#, fuzzy
msgid ""
"It is also possible to scale the 2D content and make the :ref:`SubViewport "
"<class_SubViewport>` resolution different from the one specified in size, by "
"calling:"
msgstr ""
"也可以通过调用 :ref:`Viewport <class_Viewport>` 来缩放2D内容, 并使其分辨率与"
"指定的尺寸不同:"

#, fuzzy
msgid ""
"For information on scaling and stretching with the Root Viewport visit the :"
"ref:`Multiple Resolutions Tutorial <doc_multiple_resolutions>`"
msgstr ""
"根节点的 :ref:`Viewport <class_Viewport>` 用到项目设置中的拉伸选项。有关缩放"
"和拉伸的更多信息，请访问\\ :ref:`多分辨率教程 <doc_multiple_resolutions>`"

msgid "Worlds"
msgstr "世界"

msgid ""
"For 3D, a :ref:`Viewport <class_Viewport>` will contain a :ref:`World3D "
"<class_World3D>`. This is basically the universe that links physics and "
"rendering together. Node3D-based nodes will register using the World3D of "
"the closest Viewport. By default, newly created Viewports do not contain a "
"World3D but use the same as their parent Viewport. The Root Viewport always "
"contains a World3D, which is the one objects are rendered to by default."
msgstr ""

msgid ""
"A :ref:`World3D <class_World3D>` can be set in a :ref:`Viewport "
"<class_Viewport>` using the :ref:`World "
"3D<class_Viewport_property_world_3d>` property, that will separate all "
"children nodes of this :ref:`Viewport <class_Viewport>` and will prevent "
"them from interacting with the parent Viewport's World3D. This is especially "
"useful in scenarios where, for example, you might want to show a separate "
"character in 3D imposed over the game (like in StarCraft)."
msgstr ""

#, fuzzy
msgid ""
"As a helper for situations where you want to create :ref:`Viewports "
"<class_Viewport>` that display single objects and don't want to create a :"
"ref:`World3D <class_World3D>`, Viewport has the option to use its :ref:`Own "
"World3D <class_Viewport_property_own_world_3d>`. This is useful when you "
"want to instance 3D characters or objects in :ref:`World2D <class_World2D>`."
msgstr ""
"作为您想要创建的情况的帮助 :ref:`Viewports <class_Viewport>` 显示单个对象而不"
"想创建 :ref:`World <class_World>`, :ref:`Viewport <class_Viewport>` 可以选择"
"使用自己的 :ref:`World <class_World>`. 当您想要在2D :ref:`World "
"<class_World2D>` 中实例化3D角色或对象时, 这非常有用."

#, fuzzy
msgid ""
"For 2D, each :ref:`Viewport <class_Viewport>` always contains its own :ref:"
"`World2D <class_World2D>`. This suffices in most cases, but in case sharing "
"them may be desired, it is possible to do so by setting :ref:"
"`world_2d<class_Viewport_property_world_2d>` on the Viewport through code."
msgstr ""
"对于 2D，每个 :ref:`Viewport <class_Viewport>` 总是包含它自己的 :ref:"
"`World2D <class_World2D>`\\ 。这在大多数情况下都足够了，但是如果需要共享，可"
"以手动设置 :ref:`Viewport <class_Viewport>` 的 :ref:`World2D "
"<class_World2D>`\\ 。"

msgid ""
"For an example of how this works, see the demo projects `3D in 2D <https://"
"github.com/godotengine/godot-demo-projects/tree/master/viewport/3d_in_2d>`_ "
"and `2D in 3D <https://github.com/godotengine/godot-demo-projects/tree/"
"master/viewport/2d_in_3d>`_ respectively."
msgstr ""
"关于如何工作的例子, 请分别参阅演示项目 `3D in 2D <https://github.com/"
"godotengine/godot-demo-projects/tree/master/viewport/3d_in_2d>`_ 和 `2D in "
"3D <https://github.com/godotengine/godot-demo-projects/tree/master/"
"viewport/2d_in_3d>`_ ."

msgid "Capture"
msgstr "捕获"

#, fuzzy
msgid ""
"It is possible to query a capture of the :ref:`Viewport <class_Viewport>` "
"contents. For the Root Viewport, this is effectively a screen capture. This "
"is done with the following code:"
msgstr ""
"可以查询 :ref:`Viewport <class_Viewport>` 内容的捕获. 对于根 :ref:`Viewport "
"<class_Viewport>` , 这实际上是一个屏幕截图. 这可以通过以下代码完成:"

msgid ""
"But if you use this in ``_ready()`` or from the first frame of the :ref:"
"`Viewport's <class_Viewport>` initialization, you will get an empty texture "
"because there is nothing to get as texture. You can deal with it using (for "
"example):"
msgstr ""
"但是如果你在 ``_ready()`` 中使用, 或者从 :ref:`Viewport 的 <class_Viewport>` "
"初始化的第一帧开始使用, 你会得到一个空的纹理, 因为没有什么可以作为纹理获得. "
"你可以用来处理它, 例如:"

msgid "Viewport Container"
msgstr "视口容器"

#, fuzzy
msgid ""
"If the :ref:`SubViewport <class_SubViewport>` is a child of a :ref:"
"`SubViewportContainer <class_SubViewportContainer>`, it will become active "
"and display anything it has inside. The layout looks like this:"
msgstr ""
"如果 :ref:`Viewport <class_Viewport>` 是 :ref:`ViewportContainer "
"<class_viewportcontainer>` 的子节点, 它将变为活动状态并显示其内部的任何内容. "
"布局看起来像这样:"

#, fuzzy
msgid ""
"The :ref:`SubViewport <class_SubViewport>` will cover the area of its "
"parent :ref:`SubViewportContainer <class_SubViewportContainer>` completely "
"if :ref:`Stretch<class_SubViewportContainer_property_stretch>` is set to "
"``true`` in the SubViewportContainer."
msgstr ""
"如果 :ref:`ViewportContainer <class_viewportcontainer>` 的 :ref:"
"`Stretch<class_viewportcontainer_property_stretch>` 为 ``true``\\ ，那么 :"
"ref:`Viewport <class_Viewport>` 就会完全覆盖这个父 :ref:`ViewportContainer "
"<class_viewportcontainer>`。注意：该 :ref:`ViewportContainer "
"<class_viewportcontainer>` 的大小不能小于 :ref:`Viewport <class_Viewport>` 的"
"大小。"

msgid ""
"The size of the :ref:`SubViewportContainer <class_SubViewportContainer>` "
"cannot be smaller than the size of the :ref:`SubViewport "
"<class_SubViewport>`."
msgstr ""

msgid "Rendering"
msgstr "渲染"

#, fuzzy
msgid ""
"Due to the fact that the :ref:`Viewport <class_Viewport>` is an entryway "
"into another rendering surface, it exposes a few rendering properties that "
"can be different from the project settings. You can choose to use a "
"different level of :ref:`MSAA <class_Viewport_property_msaa_2d>` for each "
"Viewport. The default behavior is ``Disabled``."
msgstr ""
"由于以下事实 :ref:`Viewport <class_Viewport>` 是进入另一个渲染表面的入口, 它"
"会暴露一些可能与项目设置不同的渲染属性. 第一个是MSAA, 你可以选择为每个使用不"
"同级别的MSAA :ref:`Viewport <class_Viewport>`, 默认行为是DISABLED. 你还可以设"
"置 :ref:`Viewport <class_Viewport>` 以使用HDR, 当你想要在纹理中存储超出0.0 - "
"1.0范围的值时,HDR非常有用."

#, fuzzy
msgid ""
"If you know that the :ref:`Viewport <class_Viewport>` is only going to be "
"used for 2D, you can :ref:`Disable 3D<class_Viewport_property_disable_3d>`. "
"Godot will then restrict how the Viewport is drawn. Disabling 3D is slightly "
"faster and uses less memory compared to enabled 3D. It's a good idea to "
"disable 3D if your viewport doesn't render anything in 3D."
msgstr ""
"如果你知道 :ref:`Viewport <class_Viewport>` 将被如何使用，可以把它的用法设置"
"为 3D 或 2D。这样 Godot 就会根据选择限制 :ref:`Viewport <class_Viewport>` 的"
"绘制方式；默认是 3D。与 3D 使用模式相比，2D使用模式的速度稍快，占用的内存也"
"少。如果视口没有在 3D 中渲染任何东西，将 :ref:`Viewport <class_Viewport>` 的"
"使用属性设置为 2D 是一个好主意。"

#, fuzzy
msgid ""
"If you need to render 3D shadows in the viewport, make sure to set the "
"viewport's :ref:"
"`positional_shadow_atlas_size<class_Viewport_property_positional_shadow_atlas_size>` "
"property to a value higher than ``0``. Otherwise, shadows won't be rendered. "
"By default, the equivalent project setting is set to ``4096`` on desktop "
"platforms and ``2048`` on mobile platforms."
msgstr ""
"如果需要在视图中渲染3D阴影, 请确保将视图的 *Shadow Atlas Size阴影贴图集大小* "
"属性设置为大于0的值. 否则, 阴影将不会被渲染. 作为参考, 项目设置默认定义为"
"4096."

#, fuzzy
msgid ""
"Godot also provides a way of customizing how everything is drawn inside :ref:"
"`Viewports <class_Viewport>` using :ref:`Debug "
"Draw<class_Viewport_property_debug_draw>`. Debug Draw allows you to specify "
"a mode which determines how the Viewport will display things drawn inside "
"it. Debug Draw is ``Disabled`` by default. Some other options are "
"``Unshaded``, ``Overdraw``, and ``Wireframe``. For a full list, refer to "
"the :ref:`Viewport Documentation<class_Viewport_property_debug_draw>`."
msgstr ""
"Godot还提供了一种自定义内部绘制方式的方法 :ref:`Viewports <class_Viewport>` "
"使用\"Debug Draw\". Debug Draw允许您指定以下四个选项之一 :ref:`Viewport "
"<class_Viewport>` 将显示在其中绘制的内容. 默认情况下禁用Debug Draw."

msgid "**Debug Draw = Disabled** (default): The scene is drawn normally."
msgstr ""

#, fuzzy
msgid ""
"**Debug Draw = Unshaded**: Unshaded draws the scene without using lighting "
"information so all the objects appear flatly colored in their albedo color."
msgstr ""
"其他三个选项是Unhaded,Overdraw和Wireframe. 无阴影在不使用光照信息的情况下绘制"
"场景, 因此所有对象都显示为其反射颜色的扁平颜色."

#, fuzzy
msgid ""
"**Debug Draw = Overdraw**: Overdraw draws the meshes semi-transparent with "
"an additive blend so you can see how the meshes overlap."
msgstr "Overdraw 使用加法混合绘制半透明的网格，以便你可以看到网格重叠的方式。"

#, fuzzy
msgid ""
"**Debug Draw = Wireframe**: Wireframe draws the scene using only the edges "
"of triangles in the meshes."
msgstr "最后, 绘制的场景中线框仅使用网格中里边缘的三角形."

msgid ""
"Debug Draw modes are currently **not** supported when using the "
"Compatibility rendering method. They will appear as regular draw modes."
msgstr ""

msgid "Render target"
msgstr "渲染目标"

#, fuzzy
msgid ""
"When rendering to a :ref:`SubViewport <class_SubViewport>`, whatever is "
"inside will not be visible in the scene editor. To display the contents, you "
"have to draw the SubViewport's :ref:`ViewportTexture "
"<class_ViewportTexture>` somewhere. This can be requested via code using "
"(for example):"
msgstr ""
"当渲染到一个 :ref:`Viewport <class_Viewport>` 时, 里面的东西在场景编辑器中是"
"看不到的. 为了显示内容, 你必须在某个地方绘制 :ref:`Viewport's "
"<class_Viewport>` :ref:`ViewportTexture <class_ViewportTexture>`. 这可以通过"
"代码使用, 例如:"

msgid ""
"Or it can be assigned in the editor by selecting \"New ViewportTexture\""
msgstr "或者可以通过选择\"New ViewportTexture\"在编辑器中指定它"

msgid ""
"and then selecting the :ref:`Viewport <class_Viewport>` you want to use."
msgstr "然后选择你想要使用的 :ref:`Viewport <class_Viewport>`."

#, fuzzy
msgid ""
"Every frame, the :ref:`Viewport's <class_Viewport>` texture is cleared away "
"with the default clear color (or a transparent color if :ref:`Transparent "
"BG<class_Viewport_property_transparent_bg>` is set to ``true``). This can be "
"changed by setting :ref:`Clear "
"Mode<class_SubViewport_property_render_target_clear_mode>` to ``Never`` or "
"``Next Frame``. As the name implies, Never means the texture will never be "
"cleared, while next frame will clear the texture on the next frame and then "
"set itself to Never."
msgstr ""
"每一帧, :ref:`Viewport <class_Viewport>` 的纹理都会被清除, 并使用默认的透明色"
"(或者如果 :ref:`Transparent Bg<class_Viewport_property_transparent_bg>` 被设"
"置为 ``true`` ). 这可以通过设置 :ref:`Clear "
"Mode<class_Viewport_property_render_target_clear_mode>` 为Never或Next Frame来"
"改变. 顾名思义,Never意味着纹理将永远不会被清除, 而Next Frame将在下一帧清除纹"
"理, 然后将自己设置为Never."

#, fuzzy
msgid ""
"By default, re-rendering of the :ref:`SubViewport <class_SubViewport>` "
"happens when its :ref:`ViewportTexture <class_ViewportTexture>` has been "
"drawn in a frame. If visible, it will be rendered, otherwise, it will not. "
"This behavior can be changed by setting :ref:`Update "
"Mode<class_SubViewport_property_render_target_update_mode>` to ``Never``, "
"``Once``, ``Always``, or ``When Parent Visible``. Never and Always will "
"never or always re-render respectively. Once will re-render the next frame "
"and change to Never afterwards. This can be used to manually update the "
"Viewport. This flexibility allows users to render an image once and then use "
"the texture without incurring the cost of rendering every frame."
msgstr ""
"默认情况下，\\ :ref:`Viewport <class_Viewport>` 的重新渲染会发生在 :ref:"
"`Viewport <class_Viewport>` 的 :ref:`ViewportTexture "
"<class_ViewportTexture>` 在一帧中被绘制时。可见是会渲染；不可见时则不会。这个"
"行为可以改为手动渲染（单次）或者无论是否可见总是渲染。这种灵活性使用户可以渲"
"染一次图像，然后使用纹理，而不需要承担每一帧渲染的消耗。"

msgid ""
"Make sure to check the Viewport demos. They are available in the viewport "
"folder of the demos archive, or at https://github.com/godotengine/godot-demo-"
"projects/tree/master/viewport."
msgstr ""
"一定要查看Viewport系列演示！ 它们位于演示存档中的Viewport文件夹，或https://"
"github.com/godotengine/godot-demo-projects/tree/master/viewport。"

msgid "Translation status"
msgstr "翻译状态"
