# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "3D rendering limitations"
msgstr "3D 渲染的局限性"

msgid "Introduction"
msgstr "前言"

msgid ""
"Due to their focus on performance, real-time rendering engines have many "
"limitations. Godot's renderer is no exception. To work effectively with "
"those limitations, you need to understand them."
msgstr ""
"出于对性能的要求, 实时渲染引擎有很多局限性.Godot的渲染器也不例外. 为了更有效"
"地工作, 你需要了解这些局限性."

msgid "Texture size limits"
msgstr "纹理尺寸限制"

msgid ""
"On desktops and laptops, textures larger than 8192×8192 may not be supported "
"on older devices. You can check your target GPU's limitations on `GPUinfo."
"org <https://www.gpuinfo.org/>`__."
msgstr ""
"在台式机和笔记本电脑上，旧设备可能不支持大于 8192×8192 的纹理。你可以在 "
"`GPUinfo.org <https://www.gpuinfo.org/>`__ 上检查你的目标 GPU 的限制。"

msgid ""
"Mobile GPUs are typically limited to 4096×4096 textures. Also, some mobile "
"GPUs don't support repeating non-power-of-two-sized textures. Therefore, if "
"you want your texture to display correctly on all platforms, you should "
"avoid using textures larger than 4096×4096 and use a power of two size if "
"the texture needs to repeat."
msgstr ""
"移动端GPU通常仅支持小于4096×4096的纹理. 此外, 一些移动端GPU不支持对非二的幂次"
"大小的纹理进行重复(repeat)操作. 因此, 如果你想让你的纹理在所有平台上正确显"
"示, 你应该避免使用比4096×4096大的纹理, 如果纹理需要重复, 应该使用两倍的大小."

msgid ""
"To limit the size of a specific texture that may be too large to render, you "
"can set the **Process > Size Limit** import option to a value greater than "
"``0``. This will reduce the texture's dimensions on import (preserving "
"aspect ratio) without affecting the source file."
msgstr ""
"要限制可能因为尺寸太大而无法渲染的特定纹理的大小，你可以将 **Process > Size "
"Limit** 导入选项设置为大于 ``0`` 的值。 这将减少导入时纹理的尺寸（保留纵横"
"比），而不影响源文件。"

msgid "Color banding"
msgstr "带状颜色"

msgid ""
"When using the Forward+ or Forward Mobile rendering methods, Godot's 3D "
"engine renders internally in HDR. However, the rendering output will be "
"tonemapped to a low dynamic range so it can be displayed on the screen. This "
"can result in visible banding, especially when using untextured materials. "
"For performance reasons, color precision is also lower when using the "
"Forward Mobile rendering method compared to Forward+."
msgstr ""
"当使用 Forward+ 或 Forward 移动渲染方法时，Godot 的 3D 引擎在内部以 HDR 进行"
"渲染。但是，渲染输出将色调映射到一个低动态范围，以便可以在屏幕上显示。这可能"
"会导致可见的条带效应（banding），尤其是在使用无纹理的材质时。出于性能原因，"
"与 Forward+ 相比，使用 Forward 移动渲染方法时颜色精度也较低。"

msgid ""
"When using the Compatibility rendering method, HDR is not used and the color "
"precision is the lowest of all rendering methods. This also applies to 2D "
"rendering, where banding may be visible when using smooth gradient textures."
msgstr ""
"使用兼容性渲染方法时，不使用 HDR，并且颜色精度是所有渲染方法中最低的。这也适"
"用于 2D 渲染，在 2D 渲染中，使用平滑渐变纹理时可以看到条带。"

msgid "There are two main ways to alleviate banding:"
msgstr "有两个主要的方法来缓解条带:"

msgid ""
"If using the Forward+ or Forward Mobile rendering methods, enable **Use "
"Debanding** in the advanced Project Settings. This applies a fullscreen "
"debanding shader as a post-processing effect and is very cheap."
msgstr ""
"如果使用 Forward+ 或 Forward 移动渲染方法，请在高级项目设置中启用 **Use "
"Debanding** 。 这会应用全屏去色带着色器作为后处理效果，并且非常经济合算。"

msgid ""
"Alternatively, bake some noise into your textures. This is mainly effective "
"in 2D, e.g. for vignetting effects. In 3D, you can also use a `custom "
"debanding shader <https://github.com/fractilegames/godot-gles2-debanding-"
"material>`__ to be applied on your *materials*. This technique works even if "
"your project is rendered with low color precision, which means it will work "
"when using the Mobile and Compatibility rendering methods."
msgstr ""
"或者，将一些噪点烘焙到纹理中。这主要在 2D 中有效，例如用于渐晕（vignetting）"
"效果。在 3D 中，你还可以使用一个`自定义去色带着色器 <https://github.com/"
"fractilegames/godot-gles2-debanding-material>`__ 应用于你的 *材质* 。即使你的"
"项目以低颜色精度渲染，此技术也能发挥作用，这意味着它在使用移动和兼容性渲染方"
"法时也能发挥作用。"

msgid "Color banding comparison (contrast increased for more visibility)"
msgstr "色彩带对比（增加对比度以提高可视性）"

msgid ""
"See `Banding in Games: A Noisy Rant (PDF) <https://loopit.dk/"
"banding_in_games.pdf>`__ for more details about banding and ways to combat "
"it."
msgstr ""
"参见 `Banding in Games: A Noisy Rant (PDF) <https://loopit.dk/"
"banding_in_games.pdf>`__ 获取更多有关条带效应的细节和解决方案。"

msgid "Depth buffer precision"
msgstr "深度缓冲精度"

msgid ""
"To sort objects in 3D space, rendering engines rely on a *depth buffer* "
"(also called *Z-buffer*). This buffer has a finite precision: 24-bit on "
"desktop platforms, sometimes 16-bit on mobile platforms (for performance "
"reasons). If two different objects end up on the same buffer value, then Z-"
"fighting will occur. This will materialize as textures flickering back and "
"forth as the camera moves or rotates."
msgstr ""
"为了在 3D 空间中排序对象，渲染引擎使用了\\ *深度缓冲区*\\ （也称为 *Z 缓冲区"
"*\\ ）。这个缓冲区具有有限的精度：在桌面平台上是 24 位，在移动平台上有时是 "
"16 位（出于性能原因）。如果两个不同的对象最终具有相同的缓冲值，那么就会发生 "
"Z 冲突（Z-fighting），此时移动或旋转相机，将观察到纹理来回闪烁。"

msgid ""
"To make the depth buffer more precise over the rendered area, you should "
"*increase* the Camera node's **Near** property. However, be careful: if you "
"set it too high, players will be able to see through nearby geometry. You "
"should also *decrease* the Camera node's **Far** property to the lowest "
"permissible value for your use case, though keep in mind it won't impact "
"precision as much as the **Near** property."
msgstr ""
"为了使深度缓冲在渲染区域上更精确，你应该\\ *增加*\\ 摄像机节点的 **Near** 属"
"性。但是要小心，如果你设置得太高，玩家就会看穿附近的几何体。同时，还应该\\ *"
"减少*\\ 摄像机节点的 **Far** 属性到你用例允许的最低值，尽管它不会像 **Near** "
"属性那样影响精度。"

msgid ""
"If you only need high precision when the player can see far away, you could "
"change it dynamically based on the game conditions. For instance, if the "
"player enters an airplane, the **Near** property can be temporarily "
"increased to avoid Z-fighting in the distance. It can then be decreased once "
"the player leaves the airplane."
msgstr ""
"如果你只需要当玩家能够看到很远的地方时才提供高精度, 你可以根据游戏条件动态改"
"变它. 例如, 如果玩家进入飞机, **Near** 属性可以暂时增加, 以避免远处的z冲突现"
"象(z-fighting). 当玩家离开飞机时, 它便会被减少."

msgid ""
"Depending on the scene and viewing conditions, you may also be able to move "
"the Z-fighting objects further apart without the difference being visible to "
"the player."
msgstr ""
"根据场景和玩家视野条件, 你还可以在玩家不会看出差异的情况下将产生z冲突的对象移"
"得更远."

msgid ""
"Z-fighting comparison (before and after tweaking the scene by offsetting the "
"Label3D away from the floor)"
msgstr "Z 冲突对比（通过将 Label3D 从地板偏移来调整场景前后）"

msgid "Transparency sorting"
msgstr "透明度排序"

msgid ""
"In Godot, transparent materials are drawn after opaque materials. "
"Transparent objects are sorted back to front before being drawn based on the "
"Node3D's position, not the vertex position in world space. Due to this, "
"overlapping objects may often be sorted out of order. To fix improperly "
"sorted objects, tweak the material's :ref:`Render Priority "
"<class_Material_property_render_priority>` property or the node's :ref:"
"`Sorting Offset <class_VisualInstance3D_property_sorting_offset>`. Render "
"Priority will force specific materials to appear in front of or behind other "
"transparent materials, while Sorting Offset will move the object forward or "
"backward for the purpose of sorting. Even then, these may not always be "
"sufficient."
msgstr ""
"在 Godot 中，透明材质是在不透明材质之后绘制的。透明对象在绘制之前会从后向前排"
"序，排序依据是该 Node3D 的位置，而不是世界空间中顶点的位置。因此, 互相有重叠"
"的对象可能会出现排序错误的情况。要修复排序不当的对象，可以调整材质的 :ref:`渲"
"染优先级 <class_Material_property_render_priority>` 属性，或节点的 :ref:`排序"
"偏置<class_VisualInstance3D_property_sorting_offset>` 属性。渲染优先级将强制"
"特定材质出现在其他透明材质的前面或后面，而排序偏置将向前或向后移动对象以进行"
"排序。即便如此，这可能也并不总是能解决问题。"

msgid ""
"Some rendering engines feature *order-independent transparency* techniques "
"to alleviate this, but this is costly on the GPU. Godot currently doesn't "
"provide this feature. There are still several ways to avoid this problem:"
msgstr ""
"一些渲染引擎会使用\\ *顺序无关的透明*\\ 技术来缓解这个问题，但这类技术对于 "
"GPU 而言开销很大。Godot 目前没有提供这个功能，但仍然有几种方法可以避免这个问"
"题："

msgid ""
"Only make materials transparent if you actually need it. If a material only "
"has a small transparent part, consider splitting it into a separate "
"material. This will allow the opaque part to cast shadows and will also "
"improve performance."
msgstr ""
"只有在你真正需要的时候才让材质透明。如果一种材质只有一个很小的透明部分，请考"
"虑将它分割成一个单独的材质。这将允许不透明部分投射阴影，也可以提高性能。"

msgid ""
"If your texture mostly has fully opaque and fully transparent areas, you can "
"use alpha testing instead of alpha blending. This transparency mode is "
"faster to render and doesn't suffer from transparency issues. Enable "
"**Transparency > Transparency** to **Alpha Scissor** in StandardMaterial3D, "
"and adjust **Transparency > Alpha Scissor Threshold** accordingly if needed. "
"Note that MSAA will not antialias the texture's edges unless alpha "
"antialiasing is enabled in the material's properties. However, FXAA, TAA and "
"supersampling will be able to antialias the texture's edges regardless of "
"whether alpha antialiasing is enabled on the material."
msgstr ""
"如果你的纹理大部分都是完全不透明和完全透明的区域，则可以使用 Alpha 测试而不"
"是 Alpha 混合。这种透明模式渲染速度更快，并且不会出现透明度问题。在 "
"StandardMaterial3D 中启用 **Transparency > Transparency** 至 **Alpha "
"Scissor** ，并根据需要相应调整 **Transparency > Alpha Scissor Threshold** 。"
"请注意，除非在材质属性中启用了 alpha 抗锯齿，否则 MSAA 不会对纹理边缘进行抗锯"
"齿。但是，无论材质上是否启用了 alpha 抗锯齿功能，FXAA、TAA 和超级采样都能够对"
"纹理边缘进行抗锯齿处理。"

msgid ""
"If you need to render semi-transparent areas of the texture, alpha scissor "
"isn't suitable. Instead, setting the StandardMaterial3D's **Transparency > "
"Transparency** property to **Depth Pre-Pass** can sometimes work (at a "
"performance cost). You can also try the **Alpha Hash** mode."
msgstr ""
"如果你需要渲染纹理上的半透明区域，Alpha Scissor 就不适用了。将 "
"StandardMaterial3D 的 **Transparency > Transparency** 属性设置为 **Depth Pre-"
"Pass** 有时会有作用（以性能为代价）。你还可以尝试 **Alpha Hash** 模式。"

msgid ""
"If you want a material to fade with distance, use the StandardMaterial3D "
"distance fade mode **Pixel Dither** or **Object Dither** instead of **Pixel "
"Alpha**. This will make the material opaque, which also speeds up rendering."
msgstr ""
"如果你想让材质随着距离增加而淡出, 使用 StandardMaterial3D 的距离淡出模式"
"（distance fade mode）的 **Pixel Dither** 或 **Object Dither** 来代替 "
"**PixelAlpha** ，这将使材质不透明，还可以加快渲染速度。"

msgid ""
"Transparency sorting comparison (alpha-blended materials on the left, alpha "
"scissor materials on the right)"
msgstr "透明度排序对比（左侧为 alpha 混合材质，右侧为 alpha 裁剪材质）"

msgid "Multi-sample antialiasing"
msgstr "多采样抗锯齿"

msgid ""
"Antialiasing is explained in detail on the :ref:`doc_3d_antialiasing` page."
msgstr "抗锯齿在 :ref:`doc_3d_antialiasing` 页面上有详细解释。"

msgid ""
"Multi-sample antialiasing (MSAA) takes multiple *coverage* samples at the "
"edges of polygons when rendering objects. It does not increase the number of "
"*color* samples used to render a scene. Here's what this means in practice:"
msgstr ""
"多重样本抗锯齿(MSAA)指的是在渲染对象时在多边形的边上取多个覆盖样本(coverage "
"samples), 但它不会增加用于渲染场景的颜色样本数量. 下面是它在实践中的作用和局"
"限性:"

msgid ""
"Edges of meshes will be smoothed out nicely (as well as supersampling would)."
msgstr "网格的边缘将被很好地平滑(就像超采样一样)."

msgid ""
"Transparent materials that use *alpha testing* (1-bit transparency) won't be "
"smoothed out."
msgstr "使用alpha测试(1位透明度)的透明材质无法被平滑."

msgid ""
"Specular aliasing (\"sparkles\" that appear on reflective surfaces) won't be "
"reduced."
msgstr "镜面反射锯齿问题（即出现在反射表面上的“火花”（sparkle））无法解决。"

msgid ""
"There are several ways to work around this limitation depending on your "
"performance budget:"
msgstr "有几种方法可以解决这一限制, 这取决于你的绩效预算:"

msgid ""
"To make specular aliasing less noticeable, open the Project Settings and "
"enable **Rendering > Quality > Screen Space Filters > Screen Space Roughness "
"Limiter**. This filter has a moderate cost on performance, so it should only "
"be enabled if you actually need it."
msgstr ""
"为了使镜面反射锯齿不那么明显，请打开项目设置，开启高级设置，然后启用 **渲染 "
"> 抗锯齿 > 屏幕空间粗糙度限制器**\\ 。这个滤波器令渲染性能付出一些代价，只有"
"当你确实需要它时才应该启用。"

msgid ""
"Enable fast approximate antialiasing (FXAA) in addition to (or instead of) "
"MSAA. Since FXAA is a screen-space antialiasing method, it will smooth out "
"anything. As a downside, FXAA also makes the scene appear blurrier, "
"especially at resolutions below 1440p. FXAA also lacks temporal information, "
"which means its impact on specular aliasing is limited."
msgstr ""
"除了（或代替）MSAA 之外，还可以启用快速近似抗锯齿 (FXAA)。由于 FXAA 是一种屏"
"幕空间抗锯齿方法，因此它可以平滑任何内容。 而 FXAA 的缺点时会使场景显得更加模"
"糊，尤其是在分辨率低于 1440p 的情况下。 此外，FXAA 还缺乏时间信息，这意味着它"
"对镜面反射锯齿的影响有限。"

msgid ""
"Enable temporal antialiasing (TAA) in addition to (or instead of) MSAA. "
"Since TAA is a screen-space antialiasing method, it will smooth out "
"anything. As a downside, TAA also makes the scene appear blurrier, "
"especially at resolutions below 1440p. TAA provides superior quality "
"compared to FXAA and can effectively combat specular aliasing. However, TAA "
"has a greater performance cost compared to FXAA, and TAA can introduce "
"ghosting artifacts with fast movement."
msgstr ""
"除了（或代替）MSAA 之外，还可以启用临时抗锯齿 (TAA)。由于 TAA 是一种屏幕空间"
"抗锯齿方法，因此它可以平滑任何内容。而 TAA 的缺点是，它会使场景显得更加模糊，"
"尤其是在分辨率低于 1440p 的情况下。与 FXAA 相比，TAA 可以提供卓越的质量，并且"
"可以有效地对抗镜面反射锯齿。然而，与 FXAA 相比，TAA 的性能成本更高，并且 TAA "
"会在快速移动时引入重影伪像。"

msgid ""
"Render the scene at a higher resolution by increasing the **Scaling 3D > "
"Scale** project setting above ``1.0``. This technique is called supersample "
"antialiasing (SSAA) and is very slow. Its use is generally only recommended "
"for offline rendering."
msgstr ""
"通过将项目设置中 **缩放 3D > 缩放** 设置增加到 ``1.0`` 以上，就可以以更高分辨"
"率渲染场景。这种技术称为超采样抗锯齿 (SSAA)，它的速度非常慢。通常仅建议将其用"
"于离线渲染。"

msgid "Translation status"
msgstr "翻译状态"
