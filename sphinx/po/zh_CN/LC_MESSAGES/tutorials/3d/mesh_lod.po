# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Mesh level of detail (LOD)"
msgstr "网格的细节级别（LOD）"

msgid ""
"Level of detail (LOD) is one of the most important ways to optimize "
"rendering performance in a 3D project, along with :ref:"
"`doc_occlusion_culling`."
msgstr ""
"与 :ref:`doc_occlusion_culling` 一样，细节级别（LOD）是优化 3D 项目渲染性能的"
"最重要方法之一。"

msgid "On this page, you'll learn:"
msgstr "你会在这个页面中学习到："

msgid "How mesh LOD can improve your 3D project's rendering performance."
msgstr "网格 LOD 如何提高 3D 项目的渲染性能。"

msgid "How to set up mesh LOD in Godot."
msgstr "如何在 Godot 中设置网格 LOD。"

msgid ""
"How to measure mesh LOD's effectiveness in your project (and alternatives "
"you can explore if it doesn't meet your expectations)."
msgstr ""
"如何衡量网格 LOD 在项目中的效果（如果达不到预期效果，还可以探索其他方法）。"

msgid ""
"You can see how mesh LOD works in action using the `Occlusion Culling and "
"Mesh LOD demo project <https://github.com/godotengine/godot-demo-projects/"
"tree/master/3d/occlusion_culling_mesh_lod>`__."
msgstr ""
"你可以通过\\ `遮挡剔除与网格 LOD 演示项目 <https://github.com/godotengine/"
"godot-demo-projects/tree/master/3d/occlusion_culling_mesh_lod>`__\\ 观察到网"
"格 LOD 的工作原理。"

msgid "Introduction"
msgstr "前言"

msgid ""
"Historically, level of detail in 3D games involved manually authoring meshes "
"with lower geometry density, then configuring the distance thresholds at "
"which these lower-detailed meshes should be drawn. This approach is still "
"used today when increased control is needed."
msgstr ""
"从历史上看，3D 游戏中的细节层次包括手动绘制几何密度较低的网格，然后配置距离阈"
"值，在距离阈值上绘制这些细节较低的网格。如今，当需要加强控制时，这种方法仍在"
"使用。"

msgid ""
"However, in projects that have a large amount of detailed 3D assets, setting "
"up LOD manually can be a very time-consuming process. As a result, automatic "
"mesh decimation and LOD configuration is becoming increasingly popular."
msgstr ""
"然而，在拥有大量详细 3D 资产的项目中，手动设置 LOD 可能是一个非常耗时的过程。"
"因此，自动网格细分和 LOD 配置越来越受欢迎。"

msgid ""
"Godot provides a way to automatically generate less detailed meshes for LOD "
"usage on import, then use those LOD meshes when needed automatically. This "
"is completely transparent to the user. The `meshoptimizer <https://"
"meshoptimizer.org/>`__ library is used for LOD mesh generation behind the "
"scenes."
msgstr ""
"Godot 提供了一种方法，可以在导入时自动生成细节较少的网格供 LOD 使用，然后在需"
"要时自动使用这些 LOD 网格。这对用户完全透明。`meshoptimizer <https://"
"meshoptimizer.org/>`__ 库用于幕后的 LOD 网格生成。"

msgid ""
"Mesh LOD works with any node that draws 3D meshes. This includes "
"MeshInstance3D, MultiMeshInstance3D, GPUParticles3D and CPUParticles3D."
msgstr ""
"网格 LOD 适用于任何绘制 3D 网格的节点。这包括 MeshInstance3D、"
"MultiMeshInstance3D、GPUParticles3D 和 CPUParticles3D。"

msgid "Visual comparison"
msgstr "视觉比较"

msgid ""
"Here is an example of LOD meshes generated on import. Lower detailed meshes "
"will be used when the camera is far away from the object:"
msgstr ""
"以下是导入时生成 LOD 网格的示例。当摄像机远离物体时，将使用细节较少的网格："

msgid "From most detailed (left) to least detailed (right), shaded view"
msgstr "从最详细（左）到最不详细（右），阴影视图"

msgid ""
"Here's the same image with wireframe rendering to make the decimation easier "
"to see:"
msgstr "这是使用线框渲染的同一张图像，以使细分更容易被看到："

msgid "From most detailed (left) to least detailed (right), wireframe view"
msgstr "从最详细（左）到最不详细（右），线框视图"

msgid ""
"If you need to manually configure level of detail with artist-created "
"meshes, use :ref:`doc_visibility_ranges` instead of automatic mesh LOD."
msgstr ""
"如果你需要使用艺术家创建的网格手动配置细节层次，请使用 :ref:"
"`doc_visibility_ranges` 而不是自动网格 LOD。"

msgid "Generating mesh LOD"
msgstr "生成网格 LOD"

msgid ""
"By default, mesh LOD generation happens automatically for imported 3D scenes "
"(glTF, .blend, Collada, FBX). Once LOD meshes are generated, they will "
"automatically be used when rendering the scene. You don't need to configure "
"anything manually."
msgstr ""
"默认情况下，导入的 3D 场景（glTF、.blend、Collada、FBX）会自动生成网格 LOD。"
"生成 LOD 网格后，将在渲染场景时自动使用它们。你无需手动配置任何内容。"

msgid ""
"However, mesh LOD generation does **not** automatically happen for imported "
"3D meshes (OBJ). This is because OBJ files are not imported as full 3D "
"scenes by default, but only as individual mesh resources to load into a "
"MeshInstance3D node (or GPUParticles3D, CPUParticles3D, ...)."
msgstr ""
"然而，对于导入的 3D 网格（OBJ），网格LOD生成 **不会** 自动启动。这是因为 OBJ "
"文件默认情况下不作为完整的 3D 场景导入，而仅作为单独的网格资源加载到"
"MeshInstance3D 节点（或 GPUParticle3D，CPUParticles3D...）。"

msgid ""
"To make an OBJ file have mesh LOD generated for it, select it in the "
"FileSystem dock, go to the Import dock, change its **Import As** option to "
"**Scene** then click **Reimport**:"
msgstr ""
"为了使OBJ文件具有为其生成的网格LOD，在文件系统面板中选择它，去到导入面板，将"
"其 **导入为** 选项更改为 **场景** ，然后单击 **重新导入** ："

msgid "Changing the import type on an OBJ file in the Import dock"
msgstr "更改导入面板中 OBJ 文件的导入类型"

msgid "This will require restarting the editor after clicking **Reimport**."
msgstr "这需要在单击 **重新导入** 后重新启动编辑器。"

msgid ""
"The mesh LOD generation process is not perfect, and may occasionally "
"introduce rendering issues (especially in skinned meshes). Mesh LOD "
"generation can also take a while on complex meshes."
msgstr ""
"网格 LOD 生成过程并不完美，偶尔可能会出现渲染问题（尤其是在蒙皮网格中）。在复"
"杂网格上生成网格 LOD 也可能需要一段时间。"

msgid ""
"If mesh LOD causes a specific mesh to look broken, you can disable LOD "
"generation for it in the Import dock. This will also speed up resource "
"importing. This can be done globally in the 3D scene's import options, or on "
"a per-mesh basis using the Advanced Import Settings dialog."
msgstr ""
"如果网格 LOD 导致特定网格看起来已被损坏，则可以在导入面板中禁用该网格的 LOD "
"生成。这也将加快资源导入的速度。这可以在 3D 场景的导入选项中全局执行，也可以"
"使用“高级导入设置”对话框在逐个网格完成。"

msgid ""
"See :ref:`Importing 3D scenes "
"<doc_importing_3d_scenes_using_the_import_dock>` for more information."
msgstr ""
"详见\\ :ref:`导入 3D 场景 "
"<doc_importing_3d_scenes_using_the_import_dock>`\\ 。"

msgid "Comparing mesh LOD visuals and performance"
msgstr "比较网格 LOD 视觉效果和性能"

msgid ""
"To disable mesh LOD in the editor for comparison purposes, use the **Disable "
"Mesh LOD** advanced debug draw mode. This can be done using the menu in the "
"top-left corner of the 3D viewport (labeled **Perspective** or "
"**Orthogonal** depending on camera mode):"
msgstr ""
"要在编辑器中禁用网格 LOD 以进行比较，请使用 **禁用网格 LOD** 高级调试绘制模"
"式。这可以使用 3D 视口左上角的菜单来完成（标记为 **透视** 或 **正交** ，具体"
"取决于相机模式）："

msgid "Disabling mesh LOD in the 3D viewport's top-left menu"
msgstr "在 3D 视口左上角的菜单中禁用网格 LOD"

msgid ""
"Enable **View Frame Time** in the same menu to view FPS in the top-right "
"corner. Also enable **View Information** in the same menu to view the number "
"of primitives (vertices + indices) rendered in the bottom-right corner."
msgstr ""
"在同一菜单中启用 **查看帧时间** 以查看右上角的 FPS。同时在同一菜单中启用 **查"
"看信息** ，以查看右下角渲染的图元（顶点+索引）的数量。"

msgid ""
"If mesh LOD is working correctly in your scene and your camera is far away "
"enough from the mesh, you should notice the number of drawn primitives "
"decreasing and FPS increasing when mesh LOD is left enabled (unless you are "
"CPU-bottlenecked)."
msgstr ""
"如果网格 LOD 在场景中正常工作，并且摄影机离网格足够远时，你应注意到，当网格 "
"LOD 处于启用状态时，绘制的图元数量会减少，而 FPS 会增加（除非遭遇 CPU 瓶"
"颈）。"

msgid ""
"To see mesh LOD decimation in action, change the debug draw mode to "
"**Display Wireframe** in the menu specified above, then adjust the "
"**Rendering > Mesh LOD > LOD Change > Threshold Pixels** project setting."
msgstr ""
"若要查看网格 LOD 抽取的操作，请在上面指定的菜单中将调试绘制模式更改为 **显示"
"线框** ，然后调整 **渲染 > 网格 LOD > LOD 更改 > 阈值像素** 项目设置。"

msgid "Configuring mesh LOD performance and quality"
msgstr "配置网格 LOD 性能和质量"

msgid ""
"You can adjust how aggressive mesh LOD transitions should be in the root "
"viewport by changing the **Rendering > Mesh LOD > LOD Change > Threshold "
"Pixels** project setting. To change this value at run-time, set "
"``mesh_lod_threshold`` on the root viewport as follows:"
msgstr ""
"你可以通过更改 **渲染 > 网格 LOD > LOD 更改 > 阈值像素** 项目设置来调整根视口"
"中网格 LOD 转换的变化程度。要在运行时更改此值，请在根视口上设置 "
"``Mesh_LOD_Threshold``\\ ，如下所示："

msgid ""
"Each viewport has its own ``mesh_lod_threshold`` property, which can be set "
"independently from other viewports."
msgstr ""
"每个视口都有自己的 ``mesh_lod_threshold`` 属性，可以独立于其他视口进行设置。"

msgid ""
"The default mesh LOD threshold of 1 pixel is tuned to look *perceptually* "
"lossless; it provides a significant performance gain with an unnoticeable "
"loss in quality. Higher values will make LOD transitions happen sooner when "
"the camera moves away, resulting in higher performance but lower quality."
msgstr ""
"默认网格 LOD 阈值 1 像素经过调整，看起来 *感知上* 无损；它提供了显着的性能提"
"升，但质量却有不明显的损失。 当相机移开时，较高的值将使 LOD 过渡更快发生，从"
"而导致更高的性能但质量较低。"

msgid ""
"If you need to perform per-object adjustments to mesh LOD, you can adjust "
"how aggressive LOD transitions should be by adjusting the **LOD Bias** "
"property on any node that inherits from GeometryInstance3D. Values *above* "
"``1.0`` will make LOD transitions happen later than usual (resulting in "
"higher quality but lower performance). Values *below* ``1.0`` will make LOD "
"transitions happen sooner than usual (resulting in lower quality but higher "
"performance)."
msgstr ""
"如果需要对网格 LOD 执行逐对象调整，则可以通过调整从 GeometryInstance3D 继承的"
"任何节点上的 **LOD Bias** 属性来调整 LOD 过渡的激进程度。\\ *高于* ``1.0`` 的"
"值将使 LOD 转换发生得比通常晚（导致更高质量但更低的性能）。\\ *低于* ``1.0`` "
"的值将使 LOD 转换比通常更快发生（导致更低的质量但更高的性能）。"

msgid ""
"Additionally, ReflectionProbe nodes have their own **Mesh LOD Threshold** "
"property that can be adjusted to improve rendering performance when the "
"reflection probe updates. This is especially important for ReflectionProbes "
"that use the **Always** update mode."
msgstr ""
"此外，ReflectionProbe 节点具有自己的 **Mesh LOD Threshold** 属性，当反射探针"
"更新时，可以调整该属性以提高渲染性能。这对于使用 **Always** 更新模式的 "
"ReflectionProbe 尤为重要。"

msgid ""
"When rendering the scene, mesh LOD selection uses a screen-space metric. "
"This means it automatically takes camera field of view and viewport "
"resolution into account. Higher camera FOV and lower viewport resolutions "
"will make LOD selection more aggressive; the engine will display heavily "
"decimated models earlier when the camera moves away."
msgstr ""
"渲染场景时，网格 LOD 会选择使用屏幕空间标尺。这意味着它会自动考虑相机视野和视"
"口分辨率。更高的摄像机 FOV 和更低的视口分辨率将使 LOD 选择更加激进；当相机移"
"开时，引擎将更早地显示严重破坏的模型。"

msgid ""
"As a result, unlike :ref:`doc_visibility_ranges`, you don't need to do "
"anything specific in your project to take camera FOV and viewport resolution "
"into account."
msgstr ""
"因此，与 :ref:`doc_visibility_ranges` 不同，你无需在项目中执行任何特定操作，"
"即可考虑相机 FOV 和视口分辨率。"

msgid "Using mesh LOD with MultiMesh and particles"
msgstr "将网格 LOD 与 MultiMesh 和粒子结合使用"

msgid ""
"For LOD selection, the point of the node's :abbr:`AABB (Axis-Aligned "
"Bounding Box)` that is the closest to the camera is used as a basis. This "
"applies to any kind of mesh LOD (including for individual MeshInstance3D)s, "
"but this has some implications for nodes that display multiple meshes at "
"once, such as MultiMeshInstance3D, GPUParticles3D and GPUParticles3D. Most "
"importantly, this means that all instances will be drawn with the same LOD "
"level at a given time."
msgstr ""
"对于 LOD 选择，节点的 :abbr:`AABB (Axis-Aligned Bounding Box, 轴对齐边界框)` "
"最接近相机的点被用作基础。这适用于任何类型的网格 LOD（包括单个 "
"MeshInstance3D），但对于同时显示多个网格的节点（例如 MultiMeshInstance3D、"
"GPUParticles3D 和 GPUParticles3D）有一些影响。最重要的是，这意味着在给定时间"
"所有实例都将使用相同的 LOD 级别进行绘制。"

msgid ""
"If you are noticing incorrect LOD selection with GPUParticles3D, make sure "
"the node's visibility AABB is configured by selecting the GPUParticles3D "
"node and using **GPUParticles3D > Generate AABB** at the top of the 3D "
"viewport."
msgstr ""
"如果你发现 GPUParticles3D 的 LOD 选择不正确，请确保通过选择 GPUParticles3D 节"
"点并使用 3D 视口顶部的 **GPUParticles3D > 生成 AABB** 来配置节点的可见性 "
"AABB。"

msgid ""
"If you have instances in a MultiMesh that are far away from each other, they "
"should be placed in a separate MultiMeshInstance3D node. Doing so will also "
"improve rendering performance, as frustum and occlusion culling will be able "
"to cull individual nodes (while they can't cull individual instances in a "
"MultiMesh)."
msgstr ""
"如果 MultiMesh 中的实例彼此距离较远，则应将它们放置在单独的 "
"MultiMeshInstance3D 节点中。这样做还可以提高渲染性能，因为视锥体和遮挡剔除将"
"能够剔除单个节点（尽管它们无法剔除 MultiMesh 中的单个实例）。"

msgid "Translation status"
msgstr "翻译状态"
