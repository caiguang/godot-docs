# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Occlusion culling"
msgstr "遮挡剔除"

msgid ""
"In a 3D rendering engine, **occlusion culling** is the process of performing "
"hidden geometry removal."
msgstr "在3D渲染引擎中，**遮挡剔除** 是将被遮挡物体移除的过程。"

msgid "On this page, you'll learn:"
msgstr "你会在这个页面中学习到："

msgid "What are the advantages and pitfalls of occlusion culling."
msgstr "遮挡剔除的优缺点有哪些。"

msgid "How to set up occlusion culling in Godot."
msgstr "怎样在 Godot 中设置遮挡剔除。"

msgid "Troubleshooting common issues with occlusion culling."
msgstr "**解决 Godot 中控制器的问题** 。"

msgid ""
"You can see how occlusion culling works in action using the `Occlusion "
"Culling and Mesh LOD demo project <https://github.com/godotengine/godot-demo-"
"projects/tree/master/3d/occlusion_culling_mesh_lod>`__."
msgstr ""
"你可以使用 `遮挡剔除和网格 LOD 演示项目 <https://github.com/godotengine/"
"godot-demo-projects/tree/master/3d/occlusion_culling_mesh_lod>`__ 来了解遮挡"
"剔除的实际工作原理。"

msgid "Why use occlusion culling"
msgstr "为什么要使用遮挡剔除"

msgid ""
"In this example scene with hundreds of rooms stacked next to each other, a "
"dynamic object (red sphere) is hidden behind the wall in the lit room (on "
"the left of the door):"
msgstr ""
"这个示例场景中有数百个房间相邻堆叠，一个动态物体（红色球体）隐藏在明亮房间的"
"墙后面（门的左侧）："

msgid "Example scene with an occlusion culling-friendly layout"
msgstr "布局对遮挡剔除友好的示例场景"

msgid ""
"With occlusion culling disabled, all the rooms behind the lit room have to "
"be rendered. The dynamic object also has to be rendered:"
msgstr "遮挡剔除关闭后，光亮房间后的所有房间和动态物体都需要被渲染："

msgid "Example scene with occlusion culling disabled (wireframe)"
msgstr "禁用遮挡剔除的示例场景（线框）"

msgid "Example scene with occlusion culling **disabled** (wireframe)"
msgstr "**禁用** 遮挡剔除的示例场景（线框）"

msgid ""
"With occlusion culling enabled, only the rooms that are actually visible "
"have to be rendered. The dynamic object is also occluded by the wall, and "
"therefore no longer has to be rendered:"
msgstr ""
"遮挡剔除打开后，只有真正可见的房间被渲染，动态物体被墙遮挡住，因此也不用被渲"
"染："

msgid "Example scene with occlusion culling enabled (wireframe)"
msgstr "线框模式下启用遮挡剔除的范例场景"

msgid "Example scene with occlusion culling **enabled** (wireframe)"
msgstr "线框模式下 *启用* 遮挡剔除的范例场景"

msgid ""
"Since the engine has less work to do (fewer vertices to render and fewer "
"draw calls), performance will increase as long as there are enough occlusion "
"culling opportunities in the scene. This means occlusion culling is most "
"effective in indoor scenes, preferably with many smaller rooms instead of "
"fewer larger rooms. Combine this with :ref:`doc_mesh_lod` and :ref:"
"`doc_visibility_ranges` to further improve performance gains."
msgstr ""
"由于引擎只有更少的工作要做（更少的顶点和更少的 draw calls）,因此只要在场景中"
"有足够多的遮挡剔除机会，性能就会提高。所以说遮挡剔除在室内场景中最有效，尤其"
"是在很多较小的房间而不是较少更大的房间中。将此与 :ref:`doc_mesh_lod` 与 :ref:"
"`doc_visibility_ranges` 结合起来可以进一步提高性能效益。"

msgid ""
"When using the Clustered Forward rendering backend, the engine already "
"performs a *depth prepass*. This consists in rendering a depth-only version "
"of the scene before rendering the scene's actual materials. This is used to "
"ensure each opaque pixel is only shaded once, reducing the cost of overdraw "
"significantly."
msgstr ""
"当使用集群 Forward 渲染后端时，引擎已经执行了 *深度预处理* 。这包括在渲染场景"
"的实际材质之前渲染场景的仅深度（depth-only）版本。该技术用于确保每个不透明像"
"素仅着色一次，从而显着降低过度绘制的成本。"

msgid ""
"The greatest performance benefits can be observed when using the Forward "
"Mobile rendering backend, as it does not feature a depth prepass for "
"performance reasons. As a result, occlusion culling will actively decrease "
"shading overdraw with that rendering backend."
msgstr ""
"使用 Forward Mobile 渲染后端时可以观察到最大的性能优势，因为出于性能原因，它"
"并没有深度预处理。因此，遮挡剔除将主动减少渲染后端的着色过度绘制。"

msgid ""
"Nonetheless, even when using a depth prepass, there is still a noticeable "
"benefit to occlusion culling in complex 3D scenes. However, in scenes with "
"few occlusion culling opportunities, occlusion culling may not be worth the "
"added setup and CPU usage."
msgstr ""
"尽管如此，即使使用深度预处理，复杂 3D 场景中的遮挡剔除仍然有明显优势。然而，"
"在遮挡剔除机会很少的场景中，遮挡剔除可能不值得其增加的额外设定和 CPU 使用率。"

msgid "How occlusion culling works in Godot"
msgstr "Godot中的遮挡剔除如何运作"

msgid ""
"*\"occluder\" refers to the shape blocking the view, while \"occludee\" "
"refers to the object being hidden.*"
msgstr "* “遮挡物”是指遮挡视线的物体，而“被遮挡物”是指被遮挡的物体。*"

msgid ""
"In Godot, occlusion culling works by rasterizing the scene's occluder "
"geometry to a low-resolution buffer on the CPU. This is done using the "
"software raytracing library `Embree <https://github.com/embree/embree>`__."
msgstr ""
"在 Godot 中，遮挡剔除是通过将场景的遮挡几何体光栅化到低分辨率的缓存中实现的。"
"这是使用了软光追库 `Embree <https://github.com/embree/embree>`__ 来完成的。"

msgid ""
"The engine then uses this low-resolution buffer to test occludees' :abbr:"
"`AABB (Axis-Aligned Bounding Box)` against the occluder shapes. The "
"occludee's :abbr:`AABB (Axis-Aligned Bounding Box)` must be *fully occluded* "
"by the occluder shape to be culled."
msgstr ""
"然后，引擎使用低分辨率缓存来测试遮挡物的 :abbr:`AABB (Axis-Aligned Bounding "
"Box，轴对齐边界框)` 与遮挡物的形状。被遮挡物的 :abbr:`AABB (Axis-Aligned "
"Bounding Box，轴对齐边界框)` 必须被要剔除的遮挡物形状\\ *完全遮挡*\\ 。"

msgid ""
"As a result, smaller objects are more likely to be effectively culled than "
"larger objects. Larger occluders (such as walls) also tend to be much more "
"effective than smaller ones (such as decoration props)."
msgstr ""
"因此，较小的物体相较于较大的物体更可能被有效地剔除。较大的遮挡物（如墙壁）往"
"往比较小的遮挡物（如装饰道具）更有效。"

msgid "Setting up occlusion culling"
msgstr "设置遮挡剔除"

msgid ""
"The first step to using occlusion culling is to enable the **Rendering > "
"**Occlusion Culling > Use Occlusion Culling** project setting. (Make sure "
"the **Advanced** toggle is enabled in the Project Settings dialog to be able "
"to see it.)"
msgstr ""
"使用遮挡剔除的第一步是在项目设置中启用 **渲染>遮挡剔除>使用遮挡剔除**\\。（确"
"保在项目设置中启用 **高级设置** 选项，否则可能无法找到该设置。）"

msgid ""
"This project setting applies immediately, so you don't need to restart the "
"editor."
msgstr "项目设置会立即应用，无需重启编辑器。"

msgid ""
"After enabling the project setting, you still need to create some occluders. "
"For performance reasons, the engine doesn't automatically use all visible "
"geometry as a basis for occlusion culling. Instead, the engine requires a "
"simplified representation of the scene with only static objects to be baked."
msgstr ""
"在启用项目设置后，你仍然需要创建一些遮挡物。出于性能原因，引擎不会自动将所有"
"可见物体视为遮挡剔除的基础。相反，引擎需要只有静态物体被烘焙的简化场景表示。"

msgid "There are two ways to set up occluders in a scene:"
msgstr "有两种方法可以在场景中设置遮挡器："

msgid "Automatically baking occluders (recommended)"
msgstr "自动烘焙遮挡物（建议）"

msgid ""
"Only MeshInstance3D nodes are currently taken into account in the *occluder* "
"baking process. MultiMeshInstance3D, GPUParticles3D, CPUParticles3D and CSG "
"nodes are **not** taken into account when baking occluders. If you wish "
"those to be treated as occluders, you have to manually create occluder "
"shapes that (roughly) match their geometry."
msgstr ""
"当前 *遮挡物* 烘焙过程中仅考虑 MeshInstance3D 节点。烘焙遮挡物时， **不** 考"
"虑 MultiMeshInstance3D、GPUParticles3D、CPUParticles3D 和 CSG 节点。如果你希"
"望将它们也视为遮挡物，则必须手动建立以（大致）匹配其几何形状的遮挡物形状。"

msgid ""
"This restriction does not apply to *occludees*. Any node type that inherits "
"from GeometryInstance3D can be occluded."
msgstr ""
"该限制不适用于 *被遮挡者*。任何继承自 GeometryInstance3D 的节点类型都可以被遮"
"挡。"

msgid ""
"After enabling the occlusion culling project setting mentioned above, add an "
"OccluderInstance3D node to the scene containing your 3D level."
msgstr ""
"启用上述遮挡剔除的项目设置后，向你包含 3D 关卡的场景中新增 "
"OcclusionrInstance3D 节点。"

msgid ""
"Select the OccluderInstance3D node, then click **Bake Occluders** at the top "
"of the 3D editor viewport. After baking, the OccluderInstance3D node will "
"contain an Occluder3D resource that stores a simplified version of your "
"level's geometry. This occluder geometry appears as purple wireframe lines "
"in the 3D view (as long as **View Gizmos** is enabled in the **Perspective** "
"menu). This geometry is then used to provide occlusion culling for both "
"static and dynamic occludees."
msgstr ""
"选择 OccluderInstance3D 节点，然后单击 3D 编辑器视口顶部的 **烘焙遮挡器** 。"
"在烘焙后，OccluderInstance3D 节点将包含一个 Occluder3D 资源，用于存储关卡几何"
"体的简化版本。此遮挡物几何体在 3D 视图中显示为紫色线框线（只要在 **透视** 菜"
"单中启用 **查看小工具** ）。然后使用该几何体为静态和动态被遮挡物提供遮挡剔"
"除。"

msgid ""
"After baking, you may notice that your dynamic objects (such as the player, "
"enemies, etc…) are included in the baked mesh. To prevent this, set the "
"**Bake > Cull Mask** property on the OccluderInstance3D to exclude certain "
"visual layers from being baked."
msgstr ""
"烘焙后，你可能会注意到动态对象（例如玩家、敌人等）也被包含到了烘焙的网格中。"
"为了防止这种情况发生，请在 OccluderInstance3D 上设置 **Bake > Cull Mask** 属"
"性，以排除某些视觉层的烘焙。"

msgid ""
"For example, you can disable layer 2 on the cull mask, then configure your "
"dynamic objects' MeshInstance3D nodes to be located on the visual layer 2 "
"(instead of layer 1). To do so, select the MeshInstance3D node in question, "
"then on the **VisualInstance3D > Layers** property, uncheck layer 1 then "
"check layer 2. After configuring both cull mask and layers, bake occluders "
"again by following the above process."
msgstr ""
"例如，你可以禁用剔除蒙版上的第 2 层，然后将动态对象的 MeshInstance3D 节点配置"
"为位于可视层 2（而不是第 1 层）上。为此，请选择相关的 MeshInstance3D 节点，然"
"后在 **VisualInstance3D > Layers** 属性上，取消选中图层 1，再选中图层 2。配置"
"剔除蒙版和图层后，按照上述过程再次烘焙遮挡物。"

msgid "Manually placing occluders"
msgstr "手动放置遮挡器"

msgid ""
"This approach is more suited for specialized use cases, such as creating "
"occlusion for MultiMeshInstance3D setups or CSG nodes (due to the "
"aforementioned limitation)."
msgstr ""
"这种方法更适合专门的用例，例如为 MultiMeshInstance3D 设置或 CSG 节点创建遮挡"
"（由于上述限制）。"

msgid ""
"After enabling the occlusion culling project setting mentioned above, add an "
"OccluderInstance3D node to the scene containing your 3D level. Select the "
"OccluderInstance3D node, then choose an occluder type to add in the "
"**Occluder** property:"
msgstr ""
"启用上述遮挡剔除项目设置后，将 OcclusionrInstance3D 节点添加到包含 3D 关卡的"
"场景中。选择 OccluderInstance3D 节点，然后选择要添加到 **Occlusionr** 属性中"
"的遮挡器类型："

msgid "QuadOccluder3D (a single plane)"
msgstr "QuadOccluder3D（一个单平面）"

msgid "BoxOccluder3D (a cuboid)"
msgstr "BoxOccluder3D（一个立方体）"

msgid "SphereOccluder3D (a sphere-shaped occluder)"
msgstr "SphereOccluder3D（一个球形遮挡器）"

msgid "PolygonOccluder3D (a 2D polygon with as many points as you want)"
msgstr "PolygonOccluder3D（一个具有任意数量点的 2D 多边形）"

msgid ""
"There is also ArrayOccluder3D, whose points can't be modified in the editor "
"but can be useful for procedural generation from a script."
msgstr ""
"此外还有 ArrayOccluder3D，其点无法在编辑器中修改，但可用于通过脚本进行程序生"
"成。"

msgid "Previewing occlusion culling"
msgstr "预览遮挡剔除"

msgid ""
"You can enable a debug draw mode to preview what the occlusion culling is "
"actually \"seeing\". In the top-left corner of the 3D editor viewport, click "
"the **Perspective** button (or **Orthogonal** depending on your current "
"camera mode), then choose **Display Advanced… > Occlusion Culling Buffer**. "
"This will display the low-resolution buffer that is used by the engine for "
"occlusion culling."
msgstr ""
"可以启用调试绘制模式来预览遮挡剔除实际“看到”的内容。在 3D 编辑器视口的左上"
"角，单击 **透视** 按钮（或 **正交** ，具体取决于当前的相机模式），然后选择 **"
"显示高级... > 遮挡剔除缓冲** 。这将显示引擎用于遮挡剔除的低分辨率缓冲区。"

msgid ""
"In the same menu, you can also enable **View Information** and **View Frame "
"Time** to view the number of draw calls and rendered primitives (vertices + "
"indices) in the bottom-right corner, along with the number of frames per "
"second rendered in the top-right corner."
msgstr ""
"在同一菜单中，还可以启用 **查看信息** 和 **查看帧时间** 来查看右下角的绘制调"
"用和渲染图元（顶点+索引）的数量，以及右上角渲染的每秒帧数。"

msgid ""
"If you toggle occlusion culling in the project settings while this "
"information is displayed, you can see how much occlusion culling improves "
"performance in your scene. Note that the performance benefit highly depends "
"on the 3D editor camera's view angle, as occlusion culling is only effective "
"if there are occluders in front of the camera."
msgstr ""
"如果在显示此信息时在项目设置中切换遮挡剔除，你可以看到遮挡剔除对场景性能的改"
"善程度。请注意，性能优势在很大程度上取决于 3D 编辑器相机的视角，因为遮挡剔除"
"仅在相机前面存在遮挡器时才有效。"

msgid ""
"To toggle occlusion culling at run-time, set ``use_occlusion_culling`` on "
"the root viewport as follows:"
msgstr ""
"要在运行时切换遮挡剔除，请在根视口上设置“use_occlusion_culling”，如下所示："

msgid ""
"Toggling occlusion culling at run-time is useful to compare performance on a "
"running project."
msgstr "在运行时切换遮挡剔除，对于比较正在运行的项目的性能很相当有用。"

msgid "Performance considerations"
msgstr "性能方面的考虑"

msgid "Design your levels to take advantage of occlusion culling"
msgstr "在构建关卡时考虑遮挡"

msgid ""
"**This is the most important guideline.** A good level design is not just "
"about what the gameplay demands; it should also be built with occlusion in "
"mind."
msgstr ""
"**这是最重要的指导原则。** 好的关卡设计并不只是满足游戏性的需求，也应该同时考"
"虑遮挡。"

msgid ""
"For indoor environments, add opaque walls to \"break\" the line of sight at "
"regular intervals and ensure not too much of the scene can be seen at once."
msgstr ""
"对于室内环境，添加不透明的墙壁以定期“打断”视线，并确保一次不会看到太多场景。"

msgid ""
"For large open scenes, use a pyramid-like structure for the terrain's "
"elevation when possible. This provides the greatest culling opportunities "
"compared to any other terrain shape."
msgstr ""
"对于大型开放场景，请尽可能使用类似金字塔的结构来确定地形的标高。与任何其他地"
"形形状相比，这种设计提供了最大的剔除机会。"

msgid "Avoid moving OccluderInstance3D nodes during gameplay"
msgstr "避免在游戏过程中移动 OcclusionInstance3D 节点"

msgid ""
"This includes moving the parents of OccluderInstance3D nodes, as this will "
"cause the nodes themselves to move in global space, therefore requiring the :"
"abbr:`BVH (Bounding Volume Hierarchy)` to be rebuilt."
msgstr ""
"这包括移动 OccluderInstance3D 节点的父节点，因为这将导致节点本身在全局空间中"
"移动，因此需要重建 :abbr:`BVH (Bounding Volume Hierarchy)`。"

msgid ""
"Toggling an OccluderInstance3D's visibility (or one of its parents' "
"visibility) is not as expensive, as the update only needs to happen once "
"(rather than continuously)."
msgstr ""
"切换 OccluderInstance3D 的可见性（或其父级之一的可见性）并不那么耗费性能，因"
"为更新只需要发生一次（而不是连续发生）。"

msgid ""
"For example, if you have a sliding or rotating door, you can make the "
"OccluderInstance3D node not be a child of the door itself (so that the "
"occluder never moves), but you can hide the OccluderInstance3D visibility "
"once the door starts opening. You can then reshow the OccluderInstance3D "
"once the door is fully closed."
msgstr ""
"举个例子，如果你有一扇滑动门或旋转门，则可以使 OccluderInstance3D 节点不是门"
"本身的子节点（以便遮挡器永远不会移动），但可以在门开始打开后隐藏 "
"OccluderInstance3D 可见性。一旦门完全关闭，你就可以重新显示 "
"OcclusionrInstance3D。"

msgid ""
"If you absolutely have to move an OccluderInstance3D node during gameplay, "
"use a primitive Occluder3D shape for it instead of a complex baked shape."
msgstr ""
"如果你绝对必须在游戏过程中移动 OcclusionrInstance3D 节点，请为其使用原始 "
"Occlusionr3D 形状，而不是复杂的烘焙形状。"

msgid "Use the simplest possible occluder shapes"
msgstr "使用尽可能简单的遮挡器形状"

msgid ""
"If you notice low performance or stuttering in complex 3D scenes, it may "
"mean that the CPU is overloaded as a result of rendering detailed occluders. "
"Select the OccluderInstance3D node, increase the **Bake > Simplification** "
"property then bake occluders again."
msgstr ""
"如果发现复杂 3D 场景中性能低下或卡顿，则可能意味着 CPU 由于渲染（过于）详细的"
"遮挡器而过载。请选择 OccluderInstance3D 节点，增加 **Bake > Simplification** "
"属性，然后再次烘焙遮挡器。"

msgid ""
"Remember to keep the simplification value reasonable. Values that are too "
"high for the level's geometry may cause incorrect occlusion culling to "
"occur, as in :ref:`doc_occlusion_culling_troubleshooting_false_negative`."
msgstr ""
"请记住，保持合理的简化值。对于关卡几何形状来说，太高的值可能会导致发生不正确"
"的遮挡剔除，如 :ref:`doc_occlusion_culling_troubleshooting_false_negative` 中"
"所示的那样。"

msgid ""
"If this still doesn't lead to low enough CPU usage, you can try adjusting "
"the **Rendering > Occlusion Culling > BVH Build Quality** project setting "
"and/or decreasing **Rendering > Occlusion Culling > Occlusion Rays Per "
"Thread**. You'll need to enable the **Advanced** toggle in the Project "
"Settings dialog to see those settings."
msgstr ""
"如果这仍然没有让 CPU 使用率低下来，你可以尝试调整 **渲染 > 遮挡剔除 > BVH 构"
"建质量** 项目设置和/或减少 **渲染 > 遮挡剔除 > 每线程遮挡光线** 。你需要在“项"
"目设置”对话框中启用 **高级设置** 开关才能查看这些设置。"

msgid "Troubleshooting"
msgstr "故障排除"

msgid "My occludee isn't being culled when it should be"
msgstr "我的被遮挡物在应该被剔除的时候却没有被剔除"

msgid "**On the occluder side:**"
msgstr "**在遮挡器一侧：**"

msgid ""
"First, double-check that the **Bake > Cull Mask** property in the "
"OccluderInstance3D is set to allow baking the meshes you'd like. The "
"visibility layer of the MeshInstance3D nodes must be present within the cull "
"mask for the mesh to be included in the bake."
msgstr ""
"首先，仔细检查 OccluderInstance3D 中的 **Bake > Cull Mask** 属性是否设置为允"
"许烘焙你想要的网格。 MeshInstance3D 节点的可见性层必须存在于剔除遮罩中，网格"
"才能包含在烘焙中。"

msgid ""
"Also note that occluder baking only takes meshes with *opaque* materials "
"into account. Surfaces will *transparent* materials will **not** be included "
"in the bake, even if the texture applied on them is fully opaque."
msgstr ""
"此外请注意，遮挡器烘焙仅考虑具有 *不透明* 材质的网格。表面将 *透明* 材质将 **"
"不** 包含在烘焙中，即使应用在其上的纹理是完全不透明的。"

msgid ""
"Lastly, remember that MultiMeshInstance3D, GPUParticles3D, CPUParticles3D "
"and CSG nodes are **not** taken into account when baking occluders. As a "
"workaround, you can add OccluderInstance3D nodes for those manually."
msgstr ""
"最后，请记住，烘焙遮挡器时 **不** 考虑 MultiMeshInstance3D、GPUParticles3D、"
"CPUParticles3D 和 CSG 节点。作为一种解决方案，你可以手动为这些节点添加 "
"OccluderInstance3D 节点。"

msgid "**On the occludee side:**"
msgstr "**在被遮挡物一侧：**"

msgid ""
"Make sure **Extra Cull Margin** is set as low as possible (it should usually "
"be ``0.0``), and that **Ignore Occlusion Culling** is disabled in the "
"object's GeometryInstance3D section."
msgstr ""
"确保 **Extra Cull Margin** 设置为尽可能低（通常应为 ``0.0`` ），并且在对象的 "
"GeometryInstance3D 部分中禁用 **Ignore Occlusion Culling** 。"

msgid ""
"Also, check the AABB's size (which is represented by an orange box when "
"selecting the node). This axis-aligned bounding box must be *fully* occluded "
"by the occluder shapes for the occludee to be hidden."
msgstr ""
"另外，检查 AABB 的大小（选择节点时由橙色框表示）。此轴对齐的边界框必须被遮挡"
"器形状 *完全* 遮挡，才能隐藏被遮挡物。"

msgid "My occludee is being culled when it shouldn't be"
msgstr "我的被遮挡物在不应该被剔除的情况下被剔除"

msgid ""
"The most likely cause for this is that objects that were included in the "
"occluder bake have been moved after baking occluders. For instance, this can "
"occur when moving your level geometry around or rearranging its layout. To "
"fix this, select the OccluderInstance3D node and bake occluders again."
msgstr ""
"造成这种情况的最可能的原因是，遮挡器烘焙中包含的对象在烘焙遮挡器后已被移动。"
"例如，当移动关卡几何体或重新排列其布局时，就可能会发生这种情况。要解决此问"
"题，请选择 OccluderInstance3D 节点并再次烘焙遮挡物。"

msgid ""
"This can also happen because dynamic objects were included in the bake, even "
"though they shouldn't be. Use the :ref:`occlusion culling debug draw mode "
"<doc_occlusion_culling_preview>` to look for occluder shapes that shouldn't "
"be present, then :ref:`adjust the bake cull mask accordingly "
"<doc_occlusion_culling_baking>`."
msgstr ""
"这种情况也可能发生，因为动态对象包含在烘焙中，尽管它们不应该包含在内。请使用"
"` :ref:`遮挡剔除调试绘制模式<doc_occlusion_culling_preview>` 查找不应出现的遮"
"挡器形状，然后 :ref:`相应地调整烘焙剔除蒙版 "
"<doc_occlusion_culling_baking>` 。"

msgid ""
"The last possible cause for this is overly aggressive mesh simplification "
"during the occluder baking process. Select the OccluderInstance3D node, "
"decrease the **Bake > Simplification** property then bake occluders again."
msgstr ""
"最后一个可能的原因，是在遮挡器烘焙过程中使用了过于激进的网格简化。选择 "
"OccluderInstance3D 节点，减少 **Bake > Simplification** 属性，然后再次烘焙遮"
"挡器。"

msgid ""
"As a last resort, you can enable the **Ignore Occlusion Culling** property "
"on the occludee. This will negate the performance improvements of occlusion "
"culling for that object, but it makes sense to do this for objects that will "
"never be culled (such as a first-person view model)."
msgstr ""
"作为最后的手段，你可以启用被遮挡者的 **Ignore Occlusion Culling** 属性。这将"
"抵消该对象的遮挡剔除的性能改善，但对于永远不会被剔除的对象（例如第一人称视图"
"模型）来说这样做是有意义的。"

msgid "Translation status"
msgstr "翻译状态"
