# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Procedural geometry"
msgstr "程序式几何体"

msgid ""
"There are many ways to procedurally generate geometry in Godot. In this "
"tutorial series, we will explore a few of them. Each technique has its own "
"benefits and drawbacks, so it is best to understand each one and how it can "
"be useful in a given situation."
msgstr ""
"在 Godot 中，有许多方法可以通过程序生成几何体。在本系列教程中，我们将探讨其中"
"的几种方法。每种技术都有自己的优点和缺点，所以最好了解每种技术，以及它在特定"
"情况下如何发挥作用。"

msgid ""
"All the procedural geometry generation methods described here run on the "
"CPU. Godot doesn't support generating geometry on the GPU yet."
msgstr ""
"这里描述的所有程序几何生成（ procedural geometry generation ）方法都在 CPU 上"
"运行。 Godot 尚不支持在 GPU 上生成几何体。"

msgid "What is geometry?"
msgstr "什么是几何体？"

msgid ""
"Geometry is a fancy way of saying shape. In computer graphics, geometry is "
"typically represented by an array of positions called \"vertices\". In "
"Godot, geometry is represented by Meshes."
msgstr ""
"几何体是形状的一种花式说法。在计算机图形学中，几何体通常由称为“顶点”的位置数"
"组来表示。在 Godot 中，几何体用 Mesh（网格）来表示。"

msgid "What is a Mesh?"
msgstr "什么是网格？"

msgid ""
"Many things in Godot have mesh in their name: the :ref:`Mesh <class_Mesh>`, "
"the :ref:`ArrayMesh <class_ArrayMesh>`, the :ref:`ImmediateMesh "
"<class_ImmediateMesh>`, the :ref:`MeshInstance3D <class_MeshInstance3D>`, "
"the :ref:`MultiMesh <class_MultiMesh>`, and the :ref:`MultiMeshInstance3D "
"<class_MultiMeshInstance3D>`. While they are all related, they have slightly "
"different uses."
msgstr ""
"Godot 中的很多东西的名称中都有“Mesh”（网格）：:ref:`Mesh <class_Mesh>`、:ref:"
"`ArrayMesh <class_ArrayMesh>`、:ref:`ImmediateMesh <class_ImmediateMesh>`、:"
"ref:`MeshInstance3D <class_MeshInstance3D>`、:ref:`MultiMesh "
"<class_MultiMesh>`、和 :ref:`MultiMeshInstance3D "
"<class_MultiMeshInstance3D>`。虽然它们都是相关的，但它们的用途略有不同。"

msgid ""
"Meshes and ArrayMeshes are resources that are drawn using a MeshInstance3D "
"node. Resources like Meshes and ArrayMeshes cannot be added to the scene "
"directly. A MeshInstance3D represents one instance of a mesh in your scene. "
"You can reuse a single mesh in multiple MeshInstance3Ds to draw it in "
"different parts of your scene with different materials or transformations "
"(scale, rotation, position etc.)."
msgstr ""
"Mesh 和 ArrayMesh 是使用 MeshInstance3D 节点绘制的资源。像 Mesh 和 ArrayMesh "
"这样的资源不能直接添加到场景中。MeshInstance3D 代表的是某个网格在场景中的实"
"例。你可以在多个 MeshInstance3D 中重复使用同一个网格，用不同的材质或变换（缩"
"放、旋转、位置等）在场景的不同部分绘制它。"

msgid ""
"If you are going to draw the same object many times, it can be helpful to "
"use a MultiMesh with a MultiMeshInstance3D. MultiMeshInstance3Ds draw meshes "
"thousands of times very cheaply by taking advantage of hardware instancing. "
"The drawback with using a MultiMeshInstance3D is that each of your mesh's "
"surfaces are limited to one material for all instances. It uses an instance "
"array to store different colors and transformations for each instance, but "
"all the instances of each surface use the same material."
msgstr ""
"如果你要多次绘制同一个对象，那么将 MultiMesh 与 MultiMeshInstance3D 结合使用"
"会很有帮助。MultiMeshInstance3D 可以以非常低的性能成本绘制数千次网格，利用的"
"是硬件实例化的优势。使用 MultiMeshInstance3D 的缺点是所有网格的表面都只能使用"
"同一种材质。它使用一个实例数组为每个实例存储不同的颜色和变换，但所有实例的表"
"面使用的都是相同的材质。"

msgid "What a Mesh is"
msgstr "什么是网格"

msgid ""
"A Mesh is composed of one or more surfaces. A surface is an array composed "
"of multiple sub-arrays containing vertices, normals, UVs, etc. Normally the "
"process of constructing surfaces and meshes is hidden from the user in the :"
"ref:`RenderingServer <class_RenderingServer>`, but with ArrayMeshes, the "
"user can construct a Mesh manually by passing in an array containing the "
"surface information."
msgstr ""
"网格（Mesh）由一个或多个表面（Surface）组成。表面是由多个子数组组成的数组，包"
"含顶点、法线、UV 等。通常情况下，构造表面和网格的过程对用户来说是隐藏在 :ref:"
"`RenderingServer <class_RenderingServer>` 中的，但是通过 ArrayMesh，用户可以"
"通过传递一个包含表面信息的数组来手动构造网格。"

msgid "Surfaces"
msgstr "表面"

msgid ""
"Each surface has its own material. Alternatively, you can override the "
"material for all surfaces in the Mesh when you use a MeshInstance3D using "
"the :ref:`material_override "
"<class_GeometryInstance3D_property_material_override>` property."
msgstr ""
"每个表面都有自己的材质。使用 MeshInstance3D 时，你也可以使用 :ref:"
"`material_override <class_GeometryInstance3D_property_material_override>` 属"
"性来覆盖 Mesh 中所有表面的材质。"

msgid "Surface array"
msgstr "表面数组"

msgid ""
"The surface array is an array of length ``ArrayMesh.ARRAY_MAX``. Each "
"position in the array is filled with a sub-array containing per-vertex "
"information. For example, the array located at ``ArrayMesh.ARRAY_NORMAL`` is "
"a :ref:`PackedVector3Array <class_PackedVector3Array>` of vertex normals. "
"See :ref:`Mesh.ArrayType <enum_Mesh_ArrayType>` for more information."
msgstr ""
"表面数组是一个长度为 ``ArrayMesh.ARRAY_MAX`` 的数组。数组中的每个位置都有一个"
"子数组，包含每个顶点的信息。例如，位于 ``ArrayMesh.ARRAY_NORMAL`` 处的数组是"
"顶点法线的 :ref:`PackedVector3Array <class_PackedVector3Array>`\\ 。更多信息"
"请参阅 :ref:`Mesh.ArrayType <enum_Mesh_ArrayType>`。"

msgid ""
"The surface array can be indexed or non-indexed. Creating a non-indexed "
"array is as easy as not assigning an array at the index ``ArrayMesh."
"ARRAY_INDEX``. A non-indexed array stores unique vertex information for "
"every triangle, meaning that when two triangles share a vertex, the vertex "
"is duplicated in the array. An indexed surface array only stores vertex "
"information for each unique vertex and then also stores an array of indices "
"which maps out how to construct the triangles from the vertex array. In "
"general, using an indexed array is faster, but it means you have to share "
"vertex data between triangles, which is not always desired (e.g. when you "
"want per-face normals)."
msgstr ""
"表面数组可以是有索引的，也可以是非索引的。创建非索引数组就像在索引 "
"``ArrayMesh.ARRAY_INDEX`` 处不分配数组一样简单。非索引数组为每个三角形存储唯"
"一的顶点信息，也就是说，当两个三角形共用一个顶点时，顶点在数组中是重复的。有"
"索引的曲面数组只存储每个唯一顶点的顶点信息，然后还存储一个索引数组，它映射出"
"如何从顶点数组构造三角形。一般来说，使用索引数组的速度更快，但这意味着你必须"
"在三角形之间共享顶点数据，这并不总是需要的（例如，当你想要每面法线时）。"

msgid "Tools"
msgstr "工具"

msgid ""
"Godot provides different ways of accessing and working with geometry. More "
"information on each will be provided in the following tutorials."
msgstr ""
"Godot 提供了不同的访问和处理几何体的方法. 关于每种方法的更多信息将在下面的教"
"程中提供."

msgid "ArrayMesh"
msgstr "ArrayMesh"

msgid ""
"The ArrayMesh resource extends Mesh to add a few different quality of life "
"functions and, most importantly, the ability to construct a Mesh surface "
"through scripting."
msgstr ""
"ArrayMesh 资源扩展了 Mesh，增加了一些不同的便捷函数，最重要的是，可以通过脚本"
"构建 Mesh 表面。"

msgid ""
"For more information about the ArrayMesh, please see the :ref:`ArrayMesh "
"tutorial <doc_arraymesh>`."
msgstr ""
"有关ArrayMesh的更多信息, 请参阅 :ref:`ArrayMesh tutorial <doc_arraymesh>`."

msgid "MeshDataTool"
msgstr "MeshDataTool"

msgid ""
"The MeshDataTool is a resource that converts Mesh data into arrays of "
"vertices, faces, and edges that can be modified at runtime."
msgstr ""
"MeshDataTool是一个将Mesh数据转换为顶点, 面和边的数组的资源, 可以在运行时进行"
"修改."

msgid ""
"For more information about the MeshDataTool, please see the :ref:"
"`MeshDataTool tutorial <doc_meshdatatool>`."
msgstr ""
"有关 MeshDataTool 的完整列表, 请参见 :ref:`MeshDataTool tutorial "
"<doc_meshdatatool>`."

msgid "SurfaceTool"
msgstr "SurfaceTool"

msgid ""
"The SurfaceTool allows the creation of Meshes using an OpenGL 1.x immediate "
"mode style interface."
msgstr "SurfaceTool允许使用OpenGL 1.x即时模式风格的接口创建网格."

msgid ""
"For more information about the SurfaceTool, please see the :ref:`SurfaceTool "
"tutorial <doc_surfacetool>`."
msgstr ""
"有关SurfaceTool的更多信息, 请阅读 :ref:`SurfaceTool tutorial "
"<doc_surfacetool>`."

msgid "ImmediateMesh"
msgstr "ImmediateMesh"

#, fuzzy
msgid ""
"ImmediateMesh is a mesh that uses an immediate mode style interface (like "
"SurfaceTool) to draw objects. The difference between ImmediateMesh and the "
"SurfaceTool is that ImmediateMesh is drawn directly with code dynamically, "
"while the SurfaceTool is used to generate a Mesh that you can do whatever "
"you want with."
msgstr ""
"ImmediateMesh 是使用立即模式风格的接口绘制对象的网格（像 SurfaceTool 一样）。"
"ImmediateMesh 和 SurfaceTool 的区别在于，ImmediateMesh是直接用代码动态绘制"
"的，而SurfaceTool则是用来生成一个Mesh，你可以用它做任何你想做的事。"

msgid ""
"ImmediateMesh is useful for prototyping because of its straightforward API, "
"but it is slow because the geometry is rebuilt each time you make a change. "
"It is most useful for adding simple geometry for visual debugging (e.g. by "
"drawing lines to visualize physics raycasts etc.)."
msgstr ""
"ImmediateMesh 因为其直接的 API 而对原型设计很有用，但它的速度很慢，因为每次进"
"行修改时都要重建几何体。它最有用的是快速添加简单的几何体来进行可视化调试（例"
"如，通过绘制线条来可视化物理光线投射等）。"

msgid ""
"For more information about ImmediateMesh, please see the :ref:`ImmediateMesh "
"tutorial <doc_immediatemesh>`."
msgstr ""
"有关 ImmediateMesh的更多信息，请参见 :ref:`ImmediateMesh 教程 "
"<doc_immediatemesh>`\\ 。"

msgid "Which one should I use?"
msgstr "我应该使用哪一个？"

msgid ""
"Which approach you use depends on what you are trying to do and what kind of "
"procedure you are comfortable with."
msgstr "用哪种方法取决于你想做什么，以及你觉得什么样的做法用起来更舒服。"

msgid ""
"Both SurfaceTool and ArrayMesh are excellent for generating static geometry "
"(meshes) that don't change over time."
msgstr ""
"SurfaceTool和ArrayMesh都是生成不随时间变化的静态几何体(网格)的绝佳工具."

msgid ""
"Using an ArrayMesh is slightly faster than using a SurfaceTool, but the API "
"is a little more challenging. Additionally, SurfaceTool has a few quality of "
"life methods such as ``generate_normals()`` and ``index()``."
msgstr ""
"使用 ArrayMesh 比使用 SurfaceTool 稍快一些，但 API 的难度更大一些。另外，"
"SurfaceTool 还有一些便捷的方法，比如 ``generate_normals()`` 和 "
"``index()``\\ 。"

msgid ""
"ImmediateMesh is more limited than both ArrayMesh and SurfaceTool. However, "
"if you need the geometry to change every frame anyway, it provides a much "
"easier interface that can be slightly faster than generating an ArrayMesh "
"every frame."
msgstr ""
"ImmediateMesh 比 ArrayMesh 和 SurfaceTool 受到更多限制。但是，如果你本来就需"
"要每一帧都改变几何体，它提供的接口更简单，甚至可能比每一帧生成一个 ArrayMesh "
"更快。"

msgid ""
"The MeshDataTool is not fast, but it gives you access to all kinds of "
"properties of the mesh that you don't get with the others (edges, faces, "
"etc.). It is incredibly useful when you need that sort of data to transform "
"the mesh, but it is not a good idea to use it if that extra information is "
"not needed. The MeshDataTool is best used if you are going to be using an "
"algorithm that requires access to the face or edge array."
msgstr ""
"MeshDataTool 的速度并不快，但它可以让你访问网格的各种属性，而这些属性是其他工"
"具无法获得的（边、面等）。当你需要根据这类数据来变换网格时，它是非常有用的，"
"但如果不需要这些信息，就不适合使用。如果你要使用需要访问面数组或边数组的算"
"法，最好使用 MeshDataTool。"

msgid "Translation status"
msgstr "翻译状态"
