# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using Lightmap global illumination"
msgstr "使用光照贴图全局照明"

msgid ""
"Baked lightmaps are a workflow for adding indirect (or fully baked) lighting "
"to a scene. Unlike the :ref:`VoxelGI <doc_using_voxel_gi>` and :ref:`SDFGI "
"<doc_using_sdfgi>` approaches, baked lightmaps work fine on low-end PCs and "
"mobile devices, as they consume almost no resources at run-time. Also unlike "
"VoxelGI and SDFGI, baked lightmaps can optionally be used to store direct "
"lighting, which provides even further performance gains."
msgstr ""
"烘焙的光照贴图也是一种为场景添加间接光照（也叫全烘焙光照）的工作流程。与 :"
"ref:`VoxelGI <doc_using_voxel_gi>`和 :ref:`SDFGI <doc_using_sdfgi>` 的方法不"
"同，烘焙光照贴图在低端 PC 和移动设备上运行良好，因为它们在运行时几乎不消耗资"
"源。与 VoxelGI 和 SDFGI 的另一个不同点是，烘焙光照贴图还能够用来保存直接光"
"照，从而进一步提升性能。"

msgid ""
"Unlike VoxelGI and SDFGI, baked lightmaps are completely static. Once baked, "
"they can't be modified at all. They also don't provide the scene with "
"reflections, so using :ref:`doc_reflection_probes` together with it on "
"interiors (or using a Sky on exteriors) is a requirement to get good quality."
msgstr ""
"烘焙光照贴图与 VoxelGI 和 SDFGI 不同，是完全静态的，一旦被烘焙就完全不能被修"
"改。它也不能为场景提供反射，所以如果要达到较好的画质，在室内场景（或者是使用 "
"Sky 的室外场景）中就需要和 :ref:`doc_reflection_probes` 搭配使用。"

msgid ""
"As they are baked, they have fewer problems than VoxelGI and SDFGI regarding "
"light bleeding, and indirect light will often look better. The downside is "
"that baking lightmaps takes longer compared to baking VoxelGI. While baking "
"VoxelGI can be done in a matter of seconds, baking lightmaps can take "
"several minutes if not more. This can slow down iteration speed "
"significantly, so it is recommended to bake lightmaps only when you actually "
"need to see changes in lighting. Since Godot 4.0, lightmaps are baked on the "
"GPU, making light baking faster if you have a mid-range or high-end "
"dedicated GPU."
msgstr ""
"因为是烘焙出来的，所以在光线渗透方面的问题就比 VoxelGI 和 SDFGI 少很多，并且"
"间接光照也会看上去更漂亮。烘焙光照贴图的缺点是烘焙所需的时间比 VoxelGI 长很"
"多，VoxelGI 几秒钟就能搞定的烘焙，换成烘焙光照贴图就可能至少得花上几分钟。这"
"会严重拖慢迭代速度，所以推荐只在确实有查看光照变化的需求时进行光照贴图的烘"
"焙。从 Godot 4.0 开始，光照贴图烘焙在 GPU 上运行，如果你有中端或高端专用 "
"GPU，则光照烘焙的速度会更快。"

msgid ""
"Baking lightmaps will also reserve baked materials' UV2 slot, which means "
"you can no longer use it for other purposes in materials (either in the "
"built-in :ref:`doc_standard_material_3d` or in custom shaders)."
msgstr ""
"烘焙光照贴图还会占用被烘焙材质的 UV2 栏位，也就是说你无法再把 UV2 用于该材质"
"的其它用途（无论是内置的 :ref:`doc_standard_material_3d` 还是自定义着色器）。"

msgid ""
"Despite their lack of flexibility, baked lightmaps typically offer both the "
"best quality *and* performance at the same time in (mostly) static scenes. "
"This makes lightmaps still popular in game development, despite lightmaps "
"being the oldest technique for global illumination in video games."
msgstr ""
"尽管缺乏灵活性，但烘焙光照贴图通常在（大多数）静态场景中同时提供最佳质量和性"
"能。这使得光照贴图在游戏开发中仍然很受欢迎，尽管光照贴图是视频游戏中最古老的"
"全局光照技术。"

msgid ""
"Not sure if LightmapGI is suited to your needs? See :ref:"
"`doc_introduction_to_global_illumination_comparison` for a comparison of GI "
"techniques available in Godot 4."
msgstr ""
"不确定 LightmapGI 是否适合你的需求？Godot 4 中可用的 GI 技术的比较见 :ref:"
"`doc_introduction_to_global_illumination_comparison`\\ 。"

msgid "Visual comparison"
msgstr "视觉比较"

msgid "LightmapGI disabled."
msgstr "LightmapGI 已禁用。"

msgid "LightmapGI enabled (with indirect light baked only)."
msgstr "LightmapGI 已启用（仅烘焙间接光照）。"

msgid ""
"LightmapGI enabled (with indirect light baked only). Direct light is still "
"real-time, allowing for subtle changes during gameplay."
msgstr ""
"LightmapGI 已启用（仅烘焙间接光照）。直射光仍然是实时的，允许在游戏过程中进行"
"细微的修改。"

msgid "LightmapGI enabled (with direct and indirect light baked)."
msgstr "LightmapGI 已启用（直接和间接烘焙光照）。"

msgid ""
"LightmapGI enabled (with direct and indirect light baked). Best performance, "
"but lower quality visuals. Notice the blurrier sun shadow in the top-right "
"corner."
msgstr ""
"LightmapGI 已启用（直接和间接烘焙光照）。最佳性能，但视觉效果质量较低。请注意"
"右上角较模糊的太阳阴影。"

msgid ""
"Here are some comparisons of how LightmapGI vs. VoxelGI look. Notice that "
"lightmaps are more accurate, but also suffer from the fact that lighting is "
"on an unwrapped texture, so transitions and resolution may not be that good. "
"VoxelGI looks less accurate (as it's an approximation), but smoother overall."
msgstr ""
"以下是 LightmapGI 和 VoxelGI 的一些显示效果比较。可以看到光照贴图更精确，但也"
"由于光照事实上是位于展开纹理上的影响，所以过渡以及分辨率可能就没有那么理想。"
"VoxelGI 看上去没有那么精确（因为是近似估算），但总体上更平滑。"

msgid ""
"SDFGI is also less accurate compared to LightmapGI. However, SDFGI can "
"support large open worlds without any need for baking."
msgstr ""
"与 LightmapGI 相比，SDFGI 的准确性也较低。但是，SDFGI 可以支持大型开放世界，"
"而无需烘焙。"

msgid "Setting up"
msgstr "设置"

msgid ""
"First of all, before the lightmapper can do anything, the objects to be "
"baked need an UV2 layer and a texture size. An UV2 layer is a set of "
"secondary texture coordinates that ensures any face in the object has its "
"own place in the UV map. Faces must not share pixels in the texture."
msgstr ""
"首先，在光照贴图器可以执行任何操作之前，要烘焙的对象需要 UV2 图层和纹理大小。"
"UV2 图层是一组辅助纹理坐标，可确保对象中的任何面在 UV 贴图中都有自己的位置。"
"面与面之间不得共享纹理中的像素。"

msgid ""
"There are a few ways to ensure your object has a unique UV2 layer and "
"texture size:"
msgstr "这里有几种方法可以确保你的对象具有唯一的 UV2 层和纹理大小："

msgid "Unwrap on scene import (recommended)"
msgstr "场景导入时展开（推荐）"

msgid ""
"In most scenarios, this is the best approach to use. The only downside is "
"that, on large models, unwrapping can take a while on import. Nonetheless, "
"Godot will cache the UV2 across reimports, so it will only be regenerated "
"when needed."
msgstr ""
"大多数情况下，这可能是最好的方法。唯一的缺点是，在大型模型上，导入时展开可能"
"需要一段时间。不过 Godot 会在重新导入时缓存 UV2 ，所以只会在需要时重新生成。"

msgid ""
"Select the imported scene in the filesystem dock, then go to the **Import** "
"dock. There, the following option can be modified:"
msgstr ""
"在文件系统面板中选择被导入的场景，然后切换到\\ **导入**\\ 面板。这里可以修改"
"以下选项："

msgid ""
"The **Meshes > Light Baking** option must be set to **Static Lightmaps "
"(VoxelGI/SDFGI/LightmapGI)**:"
msgstr ""
"**网格 > 光照烘焙** 选项必须设置为 **Static Lightmaps (VoxelGI/SDFGI/"
"LightmapGI)**\\ （静态光照贴图）："

msgid ""
"When unwrapping on import, you can adjust the texture size using the "
"**Meshes > Lightmap Texel Size** option. *Lower* values will result in more "
"detailed lightmaps, possibly resulting in higher visual quality at the cost "
"of longer bake times and larger lightmap file sizes. The default value of "
"``0.2`` is suited for small/medium-sized scenes, but you may want to "
"increase it to ``0.5`` or even more for larger scenes. This is especially "
"the case if you're baking indirect lighting only, as indirect light is low-"
"frequency data (which means it doesn't need high-resolution textures to be "
"accurately represented)."
msgstr ""
"在导入并展开时，可以使用 **网格 > 光照贴图纹素大小** 选项调整纹理大小。\\ *较"
"低的*\\ 值将产生更详细的光照贴图，可能会以更长的烘焙时间和更大的光照贴图文件"
"大小为代价获得更高的视觉质量。默认值 ``0.2`` 适用于中小型场景，但对于较大的场"
"景，你可能希望将其增加到 ``0.5`` 甚至更多。如果你仅烘焙间接照明，则尤其如此，"
"因为间接光是低频数据（这意味着它不需要高分辨率纹理即可准确表示）。"

msgid ""
"The effect of setting this option is that all meshes within the scene will "
"have their UV2 maps properly generated."
msgstr "设置此选项的效果是场景中的所有网格都将正确生成其 UV2 贴图."

msgid ""
"When reusing a mesh within a scene, keep in mind that UVs will be generated "
"for the first instance found. If the mesh is re-used with different scales "
"(and the scales are wildly different, more than half or twice), this will "
"result in inefficient lightmaps. To avoid this, adjust the **Lightmap "
"Scale** property in the GeometryInstance3D section of a MeshInstance3D node. "
"This lets you *increase* the level of lightmap detail for specific "
"MeshInstance3D nodes (but not decrease it)."
msgstr ""
"如果在场景中复用了网格，请注意生成 UV 时只会使用第一个找到的实例。如果复用时"
"使用了不同的缩放比例（并且相差很大，超过了一半或者两倍），会导致生成低效的光"
"照贴图。为了避免这种情况，可以调整网格实例 3D 节点的 GeometryInstance3D 部分"
"中的 **Lightmap Scale** 属性。这样可以**增加特定 MeshInstance3D 节点的光贴图"
"细节（但不能减少）。"

msgid ""
"Also, the ``*.unwrap_cache`` files should *not* be ignored in version "
"control as these files guarantee that UV2 reimports are consistent across "
"platforms and engine versions."
msgstr ""
"另外，请\\ *不要*\\ 在版本控制系统中忽略 ``*.unwrap_cache`` 文件，这些文件可"
"以用来保证不同平台、不同版本的引擎在重新导入 UV2 时的一致性。"

msgid "Unwrap from within Godot"
msgstr "使用 Godot 进行展开"

msgid ""
"If this Mesh menu operation is used on an imported 3D scene, the generated "
"UV2 will be lost when the scene is reloaded."
msgstr ""
"如果在导入的 3D 场景上使用此 Mesh 菜单操作，则重新加载场景时生成的 UV2 将丢"
"失。"

msgid ""
"Godot has an option to unwrap meshes and visualize the UV channels. After "
"selecting a MeshInstance3D node, it can be found in the **Mesh** menu at the "
"top of the 3D editor viewport:"
msgstr ""
"Godot 可以选择展开网格并可视化 UV 通道。 选择 MeshInstance3D 节点后，可以在 "
"3D 编辑器视口顶部的 **Mesh** 菜单中找到它："

msgid ""
"This will generate a second set of UV2 coordinates which can be used for "
"baking. It will also set the texture size automatically."
msgstr "这将生成第二组 UV2 坐标, 可用于烘焙, 并且还将自动设置纹理大小."

msgid "Unwrap from your 3D modeling software"
msgstr "使用你自己的 3D 建模软件展开"

msgid ""
"The last option is to do it from your favorite 3D app. This approach is "
"generally **not recommended**, but it's explained so that you know it "
"exists. The main advantage is that, on complex objects that you may want to "
"re-import a lot, the texture generation process can be quite costly within "
"Godot, so having it unwrapped before import can be faster."
msgstr ""
"最后一种方法是在你喜欢的 3D 应用程序中进行操作。通常不推荐这种做法，但为了让"
"你知道它的存在，这里还是解释一下。这种做法的主要优势在于，针对可能要经常重新"
"导入的复杂对象，在 Godot 中进行纹理生成的代价可能相当高，所以在导入前展开可以"
"提高速度。"

msgid "Simply do an unwrap on the second UV2 layer."
msgstr "只需在第二个UV2层上进行展开即可。"

msgid ""
"Then import the 3D scene normally. Remember you will need to set the texture "
"size on the mesh after import."
msgstr "然后正常导入 3D 场景。记得在导入后为网格设置纹理大小。"

msgid ""
"If you use external meshes on import, the size will be kept. Be wary that "
"most unwrappers in 3D modeling software are not quality-oriented, as they "
"are meant to work quickly. You will mostly need to use seams or other "
"techniques to create better unwrapping."
msgstr ""
"如果在导入时使用外部网格，则将保留大小。请注意，3D 建模软件中的大多数解包器都"
"不是以质量为导向的，因为它们的目的是快速工作。你通常需要使用接缝或其他技术来"
"创建更好的展开效果。"

msgid "Generating UV2 for primitive meshes"
msgstr "为图元网格生成 UV2"

msgid ""
"This option is only available for primitive meshes such as :ref:"
"`class_BoxMesh`, :ref:`class_CylinderMesh`, :ref:`class_PlaneMesh`, etc."
msgstr ""
"此选项仅适用于图元网格，例如 :ref:`class_BoxMesh`\\ 、\\ :ref:"
"`class_CylinderMesh`\\ 、\\ :ref:`class_PlaneMesh` 等。"

msgid ""
"Enabling UV2 on primitive meshes allows you to make them receive and "
"contribute to baked lighting. This can be used in certain lighting setups. "
"For instance, you could hide a torus that has an emissive material after "
"baking lightmaps to create an area light that follows the shape of a torus."
msgstr ""
"在图元网格上启用 UV2 可以使它们接收烘焙照明并做出贡献。这可用于某些照明设置。"
"例如，你可以在烘焙光照贴图后隐藏具有自发光材质的圆环，以创建遵循圆环形状的区"
"域光。"

msgid ""
"By default, primitive meshes do not have UV2 generated to save resources (as "
"these meshes may be created during gameplay). You can edit a primitive mesh "
"in the inspector and enable **Add UV2** to make the engine procedurally "
"generate UV2 for a primitive mesh. The default **UV2 Padding** value is "
"tuned to avoid most lightmap bleeding, without wasting too much space on the "
"edges. If you notice lightmap bleeding on a specific primitive mesh only, "
"you may have to increase **UV2 Padding**."
msgstr ""
"默认情况下，图元网格不会生成 UV2 以节省资源（因为这些网格可以在游戏过程中创"
"建）。你可以在检查器中编辑基元网格并启用\\ **添加 UV2**\\ ，以使引擎按程序为"
"图元网格生成 UV2。默认的 UV2 填充值经过调整，以避免大多数光照贴图渗色，而不会"
"在边缘浪费太多空间。如果你注意到光照贴图仅在特定基元网格上渗色，则可能需要增"
"加 **UV2 填充**\\ 。"

msgid ""
"**Lightmap Size Hint** represents the size taken by a single mesh on the "
"lightmap texture, which varies depending on the mesh's size properties and "
"the **UV2 Padding** value. **Lightmap Size Hint** should not be manually "
"changed, as any modifications will be lost when the scene is reloaded."
msgstr ""
"**Lightmap Size Hint**\\ （光照贴图大小提示）表示光照贴图纹理上的单个网格所采"
"用的大小，该大小因网格的大小属性和 **UV2 Padding** 值而异。\\ **Lightmap "
"Size Hint** 不应手动更改，因为重新加载场景时任何修改都将丢失。"

msgid "Checking UV2"
msgstr "检查 UV2"

msgid ""
"In the **Mesh** menu mentioned before, the UV2 texture coordinates can be "
"visualized. If something is failing, double-check that the meshes have these "
"UV2 coordinates:"
msgstr ""
"在前面提到的\\ **网格**\\ 菜单中， 可以显示 UV2 纹理坐标。如果出现问题，请仔"
"细检查网格是否具有以下 UV2 坐标："

msgid "Setting up the scene"
msgstr "设置场景"

msgid ""
"Before anything is done, a **LightmapGI** node needs to be added to a scene. "
"This will enable light baking on all nodes (and sub-nodes) in that scene, "
"even on instanced scenes."
msgstr ""
"首先需要在场景中添加一个 **LightmapGI** 节点。这将在该场景中的所有节点（和子"
"节点）上启用光照烘焙，甚至在实例化场景中也是如此。"

msgid ""
"A sub-scene can be instanced several times, as this is supported by the "
"baker. Each instance will be assigned a lightmap of its own. To avoid issues "
"with inconsistent lightmap texel scaling, make sure to respect the rule "
"about mesh scaling mentioned before."
msgstr ""
"烘焙器支持同一子场景存在多个实例，它们会有各自独立的光照贴图（前提是你得遵守"
"之前提过的关于缩放的规则）。"

msgid "Setting up meshes"
msgstr "设置网格"

msgid ""
"For a **MeshInstance3D** node to take part in the baking process, it needs "
"to have its bake mode set to **Static**. Meshes that have their bake mode "
"set to **Disabled** or **Dynamic** will be ignored by the lightmapper."
msgstr ""
"对于要参与烘焙过程的 **MeshInstance3D** 节点，需要将其光照烘焙模式设置为 "
"**Static** 。光照烘焙模式设置为 **Disabled** 或 **Dynamic** 的网格体将被光照"
"贴图器忽略。"

msgid ""
"When auto-generating lightmaps on scene import, this is enabled "
"automatically."
msgstr "在场景导入时自动生成光照贴图时, 会自动启用此功能."

msgid "Setting up lights"
msgstr "设置灯光"

msgid ""
"Lights are baked with indirect light only by default. This means that "
"shadowmapping and lighting are still dynamic and affect moving objects, but "
"light bounces from that light will be baked."
msgstr ""
"默认情况下，灯光采用间接灯光烘焙。这意味着阴影贴图和光照仍然是动态的并影响移"
"动的物体，但从该光反射的光将被烘焙。"

msgid ""
"Lights can be disabled (no bake) or be fully baked (direct and indirect). "
"This can be controlled from the **Bake Mode** menu in lights:"
msgstr ""
"灯可以禁用(不烘焙)或完全烘焙(直接和间接). 这可以通过灯光中的 **烘焙模式** 菜"
"单进行控制:"

msgid "The modes are:"
msgstr "模式有："

msgid "Disabled"
msgstr "Disabled（禁用）"

msgid ""
"The light is ignored when baking lightmaps. This is the mode to use for "
"dynamic lighting effects such as explosions and weapon effects."
msgstr ""
"烘焙光照贴图时，光线会被忽略。这个模式可以用于动态光照效果，例如爆炸和武器特"
"效。"

msgid ""
"Hiding a light has no effect on the resulting lightmap bake. This means you "
"must use the Disabled bake mode instead of hiding the Light node by "
"disabling its **Visible** property."
msgstr ""
"隐藏灯光对生成的光照贴图烘焙没有影响。这意味着你必须使用禁用烘焙模式，而不是"
"通过禁用其 **Visible** 属性来隐藏 Light 节点。"

msgid "Dynamic"
msgstr "Dynamic"

msgid ""
"This is the default mode, and is a compromise between performance and real-"
"time friendliness. Only indirect lighting will be baked. Direct light and "
"shadows are still real-time, as they would be without LightmapGI."
msgstr ""
"这是默认的模式，是性能与实时友好性的折衷。只会烘焙间接光照。直接灯光和阴影仍"
"旧是实时的，就像没有 LightmapGI 时一样。"

msgid ""
"This mode allows performing *subtle* changes to a light's color, energy and "
"position while still looking fairly correct. For example, you can use this "
"to create flickering static torches that have their indirect light baked."
msgstr ""
"这个模式可以在保持显示效果相对正确的同时，允许进行灯光颜色、能量、以及位置的 "
"*微调* 。例如，你可以借此实现静态火把的闪烁，它的间接光照仍然是烘焙的。"

msgid "Static"
msgstr "Static"

msgid ""
"Both indirect and direct lighting will be baked. Since static surfaces can "
"skip lighting and shadow computations entirely, this mode provides the best "
"performance along with smooth shadows that never fade based on distance. The "
"real-time light will not affect baked surfaces anymore, but it will still "
"affect dynamic objects. When using the **All** bake mode on a light, dynamic "
"objects will not cast real-time shadows onto baked surfaces, so you need to "
"use a different approach such as blob shadows instead. Blob shadows can be "
"implemented with a Decal node."
msgstr ""
"间接和直接光照都将被烘焙。 由于静态表面可以完全跳过照明和阴影计算，因此此模式"
"提供了最佳性能，并且实现永远不会根据距离而衰退的平滑阴影。 实时光将不再影响烘"
"焙表面，但仍会影响动态对象。 在灯光上使用 **All** （全部） 烘焙模式时，动态对"
"象不会将实时阴影投射到烘焙表面上，因此你需要使用别的方法，例如斑点阴影。 斑点"
"阴影可以使用 Decal 节点来实现。"

msgid ""
"The light will not be adjustable at all during gameplay. Moving the light or "
"changing its color (or energy) will not have any effect on static surfaces."
msgstr ""
"游戏过程中无法调整灯光。灯光的移动、改变颜色（或者调整能量）都不会对静态表面"
"产生影响。"

msgid ""
"Since bake modes can be adjusted on a per-light basis, it is possible to "
"create hybrid baked light setups. One popular option is to use a real-time "
"DirectionalLight with its bake mode set to **Dynamic**, and use the "
"**Static** bake mode for OmniLights and SpotLights. This provides good "
"performance while still allowing dynamic objects to cast real-time shadows "
"in outdoor areas."
msgstr ""
"由于烘焙模式可以根据每个光源进行调整，所以可以创建混合烘焙光源设置。 一种比较"
"流行的选择是使用实时 DirectionalLight，并将其烘焙模式设置为 **Dynamic** ，并"
"使用 OmniLights 和 SpotLights 的 **Static** 烘焙模式。 这样做能有良好的性能，"
"同时仍然允许动态对象在室外区域投射实时阴影。"

msgid ""
"Fully baked lights can also make use of light nodes' **Size** (omni/spot) or "
"**Angular Distance** (directional) properties. This allows for shadows with "
"realistic penumbra that increases in size as the distance between the caster "
"and the shadow increases. This also has a lower performance cost compared to "
"real-time PCSS shadows, as only dynamic objects have real-time shadows "
"rendered on them."
msgstr ""
"完全烘焙的灯光还可以利用灯光节点的 **大小** （全向/聚光）或 **角度距离** （方"
"向）属性。 这允许阴影具有真实的半影，随着阴影投射者和阴影之间距离的增加，半影"
"的尺寸也会增加。 与实时 PCSS 阴影相比，这也具有较低的性能成本，因为只有动态对"
"象才会在其上渲染实时阴影。"

msgid "Baking"
msgstr "烘焙"

msgid ""
"To begin the bake process, click the **Bake Lightmaps** button at the top of "
"the 3D editor viewport when selecting the LightmapGI node:"
msgstr ""
"要开始烘焙过程，请在选择 LightmapGI 节点时，单击 3D 编辑器视口顶部的 **烘焙光"
"照贴图** 按钮："

msgid ""
"This can take from seconds to minutes (or hours) depending on scene size, "
"bake method and quality selected."
msgstr ""
"根据场景大小、所选烘焙方法以及质量的不同，其过程可能花费几秒钟到几分钟不等"
"（也可能是几小时）。"

msgid ""
"Baking lightmaps is a process that can require a lot of video memory, "
"especially if the resulting texture is large. Due to internal limitations, "
"the engine may also crash if the generated texture size is too large (even "
"on systems with a lot of video memory)."
msgstr ""
"烘焙光照贴图是一个可能需要大量视频内存（即显存）的过程，尤其是当生成的纹理很"
"大时。 由于内部限制，如果生成的纹理尺寸太大（即使在具有大量视频内存的系统"
"上），引擎也可能崩溃。"

msgid ""
"To avoid crashes, make sure the lightmap texel size in the Import dock is "
"set to a high enough value."
msgstr "为了避免崩溃，请在导入面板上确保光照贴图的纹素大小设置到了足够高的值。"

msgid "Tweaks"
msgstr "调整"

msgid ""
"**Quality:** Four bake quality modes are provided: Low, Medium, High, and "
"Ultra. Higher quality takes more time, but result in a better-looking "
"lightmap with less noise. The difference is especially noticeable with "
"emissive materials or areas that get little to no direct lighting. Each bake "
"quality mode can be further adjusted in the Project Settings."
msgstr ""
"**Quality**\\ ：提供了四种烘焙质量模式：Low（低级）、Medium（中级）、High（高"
"级）、Ultra（超级）。质量越高所需的时间越长，但最终光照贴图的显示效果越好、噪"
"点也越少。针对自发光材质或者几乎没有直接光照的地方，不同质量模式之间的区别尤"
"为显著。每个烘焙质量模式都可以在项目设置中进一步调整。"

msgid ""
"**Bounces:** The number of bounces to use for indirect lighting. The default "
"value (``3``) is a good compromise between bake times and quality. Higher "
"values will make light bounce around more times before it stops, which makes "
"indirect lighting look smoother (but also possibly brighter depending on "
"materials and geometry)."
msgstr ""
"**Bounces** ：（反弹）间接光照的反弹次数。默认值（ ``3`` ）是烘焙时间和质量之"
"间的一个平衡点。取值越高，光线在停止之前反弹的次数越多，间接光照的效果也就越"
"好（同时也越亮）。在做最初的光照迭代工作时，建议把反弹次数减小到 ``1`` 以加快"
"烘焙速度。请注意，降低反弹次数会让场景变暗。"

msgid ""
"**Bounce Indirect Energy:** The global multiplier to use when baking lights' "
"indirect energy. This multiplies each light's own **Indirect Energy** value. "
"Values different from ``1.0`` are not physically accurate, but can be used "
"for artistic effect."
msgstr ""
"**Bounce Indirect Energy：** （反弹间接能量）烘焙灯光间接能量时使用的全局乘"
"数。这会乘以每个灯自己的 **Indirect Energy** 值。不是 ``1.0`` 的值在物理上并"
"不准确，但可以用于艺术效果。"

msgid ""
"**Directional:** If enabled, stores directional information for lightmaps. "
"This improves normal mapped materials' appearance for baked surfaces, "
"especially with fully baked lights (since they also have direct light "
"baked). The downside is that directional lightmaps are slightly more "
"expensive to render. They also require more time to bake and result in "
"larger file sizes."
msgstr ""
"**Directional：** （定向）如果启用，则存储光照贴图的方向信息。 这改善了烘焙表"
"面的法线贴图材质的外观，尤其是在完全烘焙的灯光下（因为它们也有直接光线烘"
"焙）。 缺点是定向光照贴图的渲染成本稍高。 它们还需要更多的时间来烘焙，从而导"
"致文件大小更大。"

msgid ""
"**Interior:** If enabled, environment lighting will not be sourced. Use this "
"for purely indoor scenes to avoid light leaks."
msgstr ""
"**Interior：** （内部）如果启用，将不会获取环境照明。 将其用于纯室内场景以避"
"免漏光。"

msgid ""
"**Use Texture for Bounces:** If enabled, a texture with the lighting "
"information will be generated to speed up the generation of indirect "
"lighting at the cost of some accuracy. The geometry might exhibit extra "
"light leak artifacts when using low resolution lightmaps or UVs that stretch "
"the lightmap significantly across surfaces. Leave this enabled if unsure."
msgstr ""
"**Use Texture for Bounces：** （使用纹理进行反弹）如果启用，将生成带有照明信"
"息的纹理，以加快间接照明的生成速度，但会牺牲一定的精度。当使用低分辨率光照贴"
"图或在表面上明显地拉伸光照贴图的 UV 时，几何体可能会出现额外的漏光伪影。如果"
"不确定，请默认启用此功能。"

msgid ""
"**Use Denoiser:** If enabled, uses a denoising algorithm to make the "
"lightmap significantly less noisy. This increases bake times and can "
"occasionally introduce artifacts, but the result is often worth it. See :ref:"
"`doc_using_lightmap_gi_denoising` for more information."
msgstr ""
"**Use Denoiser：** （使用降噪器）如果启用，则使用去噪算法使光照贴图的噪点明显"
"减少。这个设置开启会增加烘烤时间，并且偶尔会引入伪影，但结果通常是值得的。请"
"参阅 :ref:`doc_using_lightmap_gi_denoising` 了解更多信息。"

msgid ""
"**Denoiser Strength:** The strength of denoising step applied to the "
"generated lightmaps. Higher values are more effective at removing noise, but "
"can reduce shadow detail for static shadows. Only effective if denoising is "
"enabled and the denoising method is :abbr:`JNLM (Non-Local Means with Joint "
"Filtering)` (:abbr:`OIDN (Open Image Denoise)` does not have a denoiser "
"strength setting)."
msgstr ""
"**Denoiser Strength：** （降噪器强度）应用于生成的光照贴图的去噪步骤的强度。"
"值越高，消除噪点越有效，但会减少静态阴影的阴影细节。仅当启用降噪且降噪方法"
"为 :abbr:`JNLM (Non-Local Means with Joint Filtering)`时才有效（ :abbr:`OIDN "
"(Open Image Denoise)` 没有降噪强度设置）。"

msgid ""
"**Bias:** The offset value to use for shadows in 3D units. You generally "
"don't need to change this value, except if you run into issues with light "
"bleeding or dark spots in your lightmap after baking. This setting does not "
"affect real-time shadows casted on baked surfaces (for lights with "
"**Dynamic** bake mode)."
msgstr ""
"**Bias** ：（偏置）用于 3D 单位阴影的偏移值。 通常不需要更改此值，除非烘焙后"
"光照贴图中遇到光渗色（light bleeding）或黑点问题（dark spots）。 此设置不会影"
"响烘焙表面上投射的实时阴影（对于具有 **Dynamic** 光照烘焙模式的灯光）。"

msgid ""
"**Max Texture Size:** The maximum texture size for the generated texture "
"atlas. Higher values will result in fewer slices being generated, but may "
"not work on all hardware as a result of hardware limitations on texture "
"sizes. Leave this at its default value of ``16384`` if unsure."
msgstr ""
"**Max Texture Size：** （最大纹理尺寸）生成的纹理图集的最大纹理尺寸。 较高的"
"值将导致生成的切片较少，但由于硬件对纹理大小的限制，可能无法在所有硬件上工"
"作。 如果不确定，请将其保留为默认值 ``16384`` 。"

msgid ""
"**Environment > Mode:** Controls how environment lighting is sourced when "
"baking lightmaps. The default value of **Scene** is suited for levels with "
"visible exterior parts. For purely indoor scenes, set this to **Disabled** "
"to avoid light leaks and speed up baking. This can also be set to **Custom "
"Sky** or **Custom Color** to use environment lighting that differs from the "
"actual scene's environment sky."
msgstr ""
"**Environment > Mode：** （环境 > 模式）控制烘焙光照贴图时环境光照的来源方"
"式。 **Scene** 的默认值适用于具有可见外部部件的关卡。 对于纯室内场景，将其设"
"置为 **Disabled** 以避免漏光并加快烘焙速度。 也可以将其设置为 **自定义天空** "
"或 **自定义颜色** 以使用与实际场景的环境天空不同的环境照明。"

msgid ""
"**Gen Probes > Subdiv:** See :ref:`doc_using_lightmap_gi_dynamic_objects`."
msgstr ""
"**Gen Probes > Subdiv：** （生成探针 > 细分）详见 :ref:"
"`doc_using_lightmap_gi_dynamic_objects`。"

msgid "**Data > Light Data:** See :ref:`doc_using_lightmap_gi_data`."
msgstr ""
"**Data > Light Data：** （数据 > 光照数据）详见 :ref:"
"`doc_using_lightmap_gi_data`。"

msgid "Balancing bake times with quality"
msgstr "平衡烘焙时间和质量"

msgid ""
"Since high-quality bakes can take very long (up to dozens of minutes for "
"large complex scenes), it is recommended to use lower quality settings at "
"first. Then, once you are confident with your scene's lighting setup, raise "
"the quality settings and perform a \"final\" bake before exporting your "
"project."
msgstr ""
"因为高质量的烘焙可能花费非常长的时间（大型复杂场景可能需要数十分钟），推荐首"
"先设置成较低质量。 之后，场景的照明设置到了让你非常满意的程度，就可以提高质量"
"设置，并在导出项目之前执行“最终”烘焙。"

msgid ""
"Reducing the lightmap resolution by increasing **Lightmap Texel Size** on "
"the imported 3D scenes will also speed up baking significantly. However, "
"this will require you to reimport all lightmapped 3D scenes before you can "
"bake lightmaps again."
msgstr ""
"通过增加导入的 3D 场景上的 **光照贴图纹素尺寸** 来降低光照贴图分辨率，也会显"
"着地加快烘焙速度。 但是，这将要求你重新导入所有有光照贴图的 3D 场景，然后才能"
"再次烘焙光照贴图。"

msgid "Denoising"
msgstr "降噪"

msgid ""
"Since baking lightmaps relies on raytracing, there will always be visible "
"noise in the \"raw\" baked lightmap. Noise is especially visible in areas "
"that are difficult to reach by bounced light, such as indoor areas with "
"small openings where the sunlight can enter. Noise can be reduced by "
"increasing bake quality, but doing so will increase bake times significantly."
msgstr ""
"由于烘焙光照贴图依赖于光线追踪，因此“原始的”烘焙光照贴图中始终会存在可见的噪"
"点。在反射光难以到达的区域（例如阳光可以进入的开口较小的室内区域），噪点尤其"
"明显。提高烘焙质量可以减少噪点，但这样做会显着增加烘焙时间。"

msgid "Comparison between denoising disabled and enabled"
msgstr "禁用降噪和启用降噪之间的比较"

msgid ""
"Comparison between denoising disabled and enabled (with the default JNLM "
"denoiser)."
msgstr "禁用降噪和启用降噪之间的比较（使用默认的 JNLM 降噪器）。"

msgid ""
"To combat noise without increasing bake times too much, a denoiser can be "
"used. A denoiser is an algorithm that runs on the final baked lightmap, "
"detects patterns of noise and softens them while attempting to best preseve "
"detail. Godot offers two denoising algorithms:"
msgstr ""
"为了消除噪点而不过多增加烘焙时间，可以使用降噪器。降噪器是一种在最终烘焙光照"
"贴图上运行的算法，检测噪声模式并软化它们，同时尝试最好地保留细节。 Godot 提供"
"了两种降噪算法："

msgid "JNLM (Non-Local Means with Joint Filtering)"
msgstr "JNLM（Non-Local Means with Joint Filtering，联合过滤的非局部均值）"

msgid ""
"JNLM is the default denoising method and is included in Godot. It uses a "
"simple but efficient denoising algorithm known as *non-local means*. JNLM "
"runs on the GPU using a compute shader, and is compatible with any GPU that "
"can run Godot 4's Vulkan-based rendering methods. No additional setup is "
"required."
msgstr ""
"JNLM 是 Godot 自带的默认的降噪方法。它使用一种简单但有效的降噪算法，称为 *非"
"局部均值* （non-local means）。 JNLM 使用计算着色器在 GPU 上运行，并且与任何"
"可以运行 Godot 4 的基于 Vulkan 的渲染方法的 GPU 相兼容。该方法无需额外设置。"

msgid ""
"JNLM's denoising can be adjusted using the **Denoiser Strength** property "
"that is visible when **Use Denoiser** enabled. Higher values can be more "
"effective at removing noise, at the cost of suppressing shadow detail for "
"static shadows."
msgstr ""
"JNLM 的降噪可以使用 **Denoiser Strength** 属性进行调整，该属性在启用 **Use "
"Denoiser** 后可见。较高的 **Denoiser Strength** 值可以更有效地消除噪声，但代"
"价是会抑制静态阴影的阴影细节。"

msgid "Comparison between JNLM denoiser strength values"
msgstr "不同 JNLM 降噪强度值之间的对比"

msgid ""
"Comparison between JNLM denoiser strength values. Higher values can reduce "
"detail."
msgstr "不同 JNLM 降噪强度值之间的对比。较高的值将会减少阴影细节。"

msgid "OIDN (Open Image Denoise)"
msgstr "OIDN （Open Image Denoise）"

msgid ""
"Unlike JNLM, OIDN uses a machine learning approach to denoising lightmaps. "
"It features a model specifically trained to remove noise from lightmaps "
"while preserving more shadow detail in most scenes compared to JNLM."
msgstr ""
"与 JNLM 不同，OIDN 使用机器学习方法对光照贴图进行降噪。与 JNLM 相比，ODIN 具"
"有经过专门训练的模型，可消除光照贴图的噪点，同时在大多数场景中保留更多阴影细"
"节。"

msgid ""
"OIDN can run on the GPU if hardware acceleration is configured. With a "
"modern high-end GPU, this can provide a speedup of over 50× over CPU-based "
"denoising:"
msgstr ""
"如果配置了硬件加速，OIDN 可以在 GPU 上运行。借助现代高端 GPU，与基于 CPU 的降"
"噪相比，这个配置可以提供超过 50 倍的加速："

msgid "On AMD GPUs, HIP must be installed and configured."
msgstr "在 AMD GPU 上，必须安装和配置 HIP。"

msgid ""
"On NVIDIA GPUs, CUDA must be installed and configured. This may "
"automatically be done by the NVIDIA installer, but on Linux, CUDA libraries "
"may not be installed by default. Double-check that the CUDA packages from "
"your Linux distribution are installed."
msgstr ""
"在 NVIDIA GPU 上，必须安装并配置 CUDA。CUDA的安装配置可能由 NVIDIA 安装程序自"
"动完成，但在 Linux 上，默认情况下可能不会安装 CUDA 库。仔细检查你的 Linux 发"
"行版中的 CUDA 软件包是否已安装。"

msgid "On Intel GPUs, SYCL must be installed and configured."
msgstr "在 Intel GPU 上，必须安装和配置 SYCL。"

msgid ""
"If hardware acceleration is not available, OIDN will fall back to "
"multithreaded CPU-based denoising. To confirm whether GPU-based denoising is "
"working, use a GPU utilization monitor while baking lightmaps and look at "
"the GPU utilization percentage and VRAM utilization while the denoising step "
"is shown in the Godot editor. The ``nvidia-smi`` command line tool can be "
"useful for this."
msgstr ""
"如果硬件加速不可用，OIDN 将回退到基于多线程 CPU 的降噪。要确认基于 GPU 的降噪"
"是否有效，请在烘焙光照贴图时使用 GPU 利用率监视器，并在 Godot 编辑器中显示去"
"噪步骤时查看 GPU 利用率和 VRAM 利用率。 对此， ``nvidia-smi`` 命令行工具很有"
"用。"

msgid ""
"OIDN is not included with Godot due to its relatively large download size. "
"You can download precompiled OIDN binary packages from its `website <https://"
"www.openimagedenoise.org/downloads.html>`__. Extract the package to a "
"location on your PC, then specify the path to the ``oidnDenoise`` executable "
"in the Editor Settings (**FileSystem > Tools > OIDN > OIDN Denoise Path**). "
"This executable is located within the ``bin`` folder of the binary package "
"you extracted."
msgstr ""
"由于 OIDN 的下载包相对较大，所以它不包含在 Godot 中。你可以从其`网站<https://"
"www.openimagedenoise.org/downloads.html>`__ 下载预编译的 OIDN 二进制包。将包"
"解压到 PC 上的某个位置，然后在编辑器设置中指定 ``oidnDenoise`` 可执行文件的路"
"径（ **文件系统 > 工具 > OIDN > OIDN 降噪器路径** ）。该可执行文件位于你提取"
"的二进制包的 ``bin`` 文件夹中。"

msgid ""
"After specifying the path to the OIDN denoising executable, change the "
"denoising method in the project settings by setting **Rendering > "
"Lightmapping > Denoiser** to **OIDN**. This will affect all lightmap bakes "
"on this project after the setting is changed."
msgstr ""
"指定 OIDN 降噪可执行文件的路径后，通过将 **渲染 > 光照贴图 > 降噪器** 设置为 "
"**OIDN** 来更改项目设置中的降噪方法。设置更改后，这将影响该项目上的所有光照贴"
"图烘焙。"

msgid ""
"The denoising method is configured in the project settings instead of the "
"editor settings. This is done so that different team members working on the "
"same project are assured to be using the same denoising method for "
"consistent results."
msgstr ""
"降噪方法需要在项目设置中配置，而不是在编辑器设置中。这样做是为了确保同一项目"
"的不同团队成员使用相同的降噪方法，以最终获得一致的表现。"

msgid "Comparison between JNLM and OIDN denoisers"
msgstr "JNLM 和 OIDN 降噪器的比较"

msgid ""
"Comparison between JNLM and OIDN denoisers. Notice how OIDN better preserves "
"detail and reduces seams across different objects."
msgstr ""
"JNLM 和 OIDN 降噪器之间的比较。请注意 OIDN 如何更好地保留细节并减少不同对象之"
"间的接缝。"

msgid "Dynamic objects"
msgstr "动态对象"

msgid ""
"Unlike VoxelGI and SDFGI, dynamic objects receive indirect lighting "
"differently compared to static objects. This is because lightmapping is only "
"performed on static objects."
msgstr ""
"与 VoxelGI 和 SDFGI 不同，动态对象接收间接光照的方式与静态对象不同。 这是因为"
"光照贴图仅在静态对象上执行。"

msgid ""
"To display indirect lighting on dynamic objects, a 3D probe system is used, "
"with light probes being spread throughout the scene. When baking lightmaps, "
"the lightmapper will calculate the amount of *indirect* light received by "
"the probe. Direct light is not stored within light probes, even for lights "
"that have their bake mode set to **Static** (as dynamic objects continue to "
"be lit in real-time)."
msgstr ""
"为了显示动态对象上的间接照明，使用了 3D 探针系统，其中光照探针遍布整个场景。 "
"烘焙光照贴图时，光照贴图器将计算探针接收到的 *间接* 光量。 直射光不会存储在光"
"照探针中，即使对于将烘焙模式设置为 **Static** 的光源也是如此（因为动态对象继"
"续会实时点亮）。"

msgid "There are 2 ways to add light probes to a scene:"
msgstr "有两种方法可以向场景中添加光照探针："

msgid ""
"**Automatic:** Set **Gen Probes > Subdiv** to a value other than "
"**Disabled**, then bake lightmaps. The default is ``8``, but you can choose "
"a greater value to improve precision at the cost of longer bake times and "
"larger output file size."
msgstr ""
"**Automatic（自动）：**\\ 将 **Gen Probes > Subdiv** 设置为 **Disabled** 以外"
"的值，然后烘焙光照贴图。 默认值为 ``8``\\ ，不过你可以选择更大的值来提高精"
"度，但代价是烘焙时间会更长且输出文件大小会更大。"

msgid ""
"**Manual:** In addition or as an alternative to generating probes "
"automatically, you can add light probes manually by adding :ref:"
"`class_LightmapProbe` nodes to the scene. This can be used to improve "
"lighting detail in areas frequently travelled by dynamic objects. After "
"placing LightmapProbe nodes in the scene, you must bake lightmaps again for "
"them to be effective."
msgstr ""
"**Manual（手动）：** 作为除自动生成探针之外，或者作为自动生成探针的替代方案，"
"你可以通过向场景添加 :ref:`class_LightmapProbe` 节点来手动添加光照探针。 这可"
"用于改善动态物体经常经过的区域的照明细节。 在场景中放置 LightmapProbe 节点"
"后，必须再次烘焙光照贴图才能使其生效。"

msgid ""
"After baking lightmaps, you will notice white spheres in the 3D scene that "
"represent how baked lighting will affect dynamic objects. These spheres do "
"**not** appear in the running project."
msgstr ""
"烘焙光照贴图后，你会注意到 3D 场景中的白色球体，它们表现了烘焙光照将如何影响"
"动态对象。 这些球体 **不会** 出现在正在运行的项目中。"

msgid ""
"If you want to hide these spheres in the editor, toggle **View > Gizmos > "
"LightmapGI** at the top of the 3D editor (a \"closed eye\" icon indicates "
"the gizmo is hidden)."
msgstr ""
"如果要在编辑器中隐藏这些球体，请在3D编辑器的顶部切换 **View > Gizmos > "
"LightmapGI** （“闭眼”图标表示这个 Gizmo 已隐藏）。"

msgid "Lightmap data"
msgstr "光照贴图数据"

msgid ""
"The **Data > Light Data** property in the LightmapGI node contains the "
"lightmap data after baking. Textures are saved to disk, but this also "
"contains the capture data for dynamic objects, which can be heavy. If you "
"are using a scene in ``.tscn`` format, you should save this resource to an "
"external binary ``.lmbake`` file to avoid bloating the ``.tscn`` scene with "
"binary data encoded in Base64."
msgstr ""
"LightmapGI 节点中的 **Data > Light Data** 属性包含烘焙后的光照贴图数据。纹理"
"会被保存到磁盘上，但这里还会包含动态对象的捕获数据，数据量可能非常大。如果你"
"使用的是 ``.tscn`` 格式的场景，应该将此资源保存成外部的二进制 ``.lmbake`` 文"
"件，否则 ``.tscn`` 场景可能因为使用 Base64 编码二进制数据而变得巨大。"

msgid ""
"The generated EXR file can be viewed and even edited using an image editor "
"to perform post-processing if needed. However, keep in mind that changes to "
"the EXR file will be lost when baking lightmaps again."
msgstr ""
"如果有后期处理的需要，可以使用图像编辑器查看并编辑所生成的 EXR 文件。不过请注"
"意，重新烘焙贴图会覆盖你对 EXR 文件的修改。"

#, fuzzy
msgid "Reducing LightmapGI artifacts"
msgstr "减少 VoxelGI 光照泄漏和伪影"

msgid ""
"If you notice LightmapGI nodes popping in and out of existence as the camera "
"moves, this is most likely because the engine is rendering too many "
"LightmapGI instances at once. Godot is limited to rendering 8 LightmapGI "
"nodes at once, which means up to 8 instances can be in the camera view "
"before some of them will start flickering."
msgstr ""

msgid "Translation status"
msgstr "翻译状态"
