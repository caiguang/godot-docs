# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Heads up display"
msgstr "游戏信息显示"

msgid ""
"The final piece our game needs is a User Interface (UI) to display things "
"like score, a \"game over\" message, and a restart button."
msgstr ""
"我们的游戏最后还需要用户界面（User Interface，UI），显示分数、“游戏结束”信"
"息、重启按钮。"

msgid ""
"Create a new scene, click the \"Other Node\" button and add a :ref:"
"`CanvasLayer <class_CanvasLayer>` node named ``HUD``. \"HUD\" stands for "
"\"heads-up display\", an informational display that appears as an overlay on "
"top of the game view."
msgstr ""
"创建新场景，点击“其他节点”按钮，然后添加一个 :ref:`CanvasLayer "
"<class_CanvasLayer>` 节点并命名为 ``HUD``\\ 。“HUD”是“heads-up display”（游戏"
"信息显示）的缩写，是覆盖在游戏视图上显示的信息。"

msgid ""
"The :ref:`CanvasLayer <class_CanvasLayer>` node lets us draw our UI elements "
"on a layer above the rest of the game, so that the information it displays "
"isn't covered up by any game elements like the player or mobs."
msgstr ""
":ref:`CanvasLayer <class_CanvasLayer>` 节点可以让我们在游戏的其他部分的上一层"
"绘制 UI 元素，这样它所显示的信息就不会被任何游戏元素（如玩家或敌人）所覆盖。"

msgid "The HUD needs to display the following information:"
msgstr "HUD 中需要显示以下信息："

msgid "Score, changed by ``ScoreTimer``."
msgstr "得分，由 ``ScoreTimer`` 更改。"

msgid "A message, such as \"Game Over\" or \"Get Ready!\""
msgstr "消息，例如“Game Over”或“Get Ready!”"

msgid "A \"Start\" button to begin the game."
msgstr "“Start”按钮来开始游戏。"

msgid ""
"The basic node for UI elements is :ref:`Control <class_Control>`. To create "
"our UI, we'll use two types of :ref:`Control <class_Control>` nodes: :ref:"
"`Label <class_Label>` and :ref:`Button <class_Button>`."
msgstr ""
"UI 元素的基本节点是 :ref:`Control <class_Control>` 。要创建 UI，我们需使用 :"
"ref:`Control <class_Control>` 下的两种节点：\\ :ref:`Label <class_Label>` "
"和 :ref:`Button <class_Button>`。"

msgid "Create the following as children of the ``HUD`` node:"
msgstr "创建以下节点作为 ``HUD`` 的子节点："

msgid ":ref:`Label <class_Label>` named ``ScoreLabel``."
msgstr "名为分数标签 ``ScoreLabel`` 的 :ref:`Label <class_Label>`\\ 。"

msgid ":ref:`Label <class_Label>` named ``Message``."
msgstr "名为消息 ``Message`` 的 :ref:`Label <class_Label>`\\ 。"

msgid ":ref:`Button <class_Button>` named ``StartButton``."
msgstr "名为开始按钮 ``StartButton`` 的 :ref:`Button <class_Button>`\\ 。"

msgid ":ref:`Timer <class_Timer>` named ``MessageTimer``."
msgstr "名为信息计数器 ``MessageTimer`` 的 :ref:`Timer <class_Timer>`\\ 。"

msgid ""
"Click on the ``ScoreLabel`` and type a number into the ``Text`` field in the "
"Inspector. The default font for ``Control`` nodes is small and doesn't scale "
"well. There is a font file included in the game assets called \"Xolonium-"
"Regular.ttf\". To use this font, do the following:"
msgstr ""
"点击 ``ScoreLabel`` 并在“检查器”的 ``Text`` 字段中键入一个数字。 ``Control`` "
"节点的默认字体很小，不能很好地缩放。游戏资产包中有一个叫作“Xolonium-Regular."
"ttf”的字体文件。 使用此字体需要执行以下操作："

msgid ""
"Under \"Theme Overrides > Fonts\", choose \"Load\" and select the \"Xolonium-"
"Regular.ttf\" file."
msgstr ""
"在“Theme Overrides > Fonts”（主题覆盖 > 字体）中选择“加载”，然后选"
"中“Xolonium-Regular.ttf”文件。"

msgid ""
"The font size is still too small, increase it to ``64`` under \"Theme "
"Overrides > Font Sizes\". Once you've done this with the ``ScoreLabel``, "
"repeat the changes for the ``Message`` and ``StartButton`` nodes."
msgstr ""
"字体尺寸仍然太小，请在“Theme Overrides > Font Sizes”（主题覆盖 > 字体大小）下"
"将其增加到 ``64``\\ 。当 ``ScoreLabel`` 完成此操作后，请重复对 ``Message`` "
"和 ``StartButton`` 节点做同样的修改。"

msgid ""
"**Anchors:** ``Control`` nodes have a position and size, but they also have "
"anchors. Anchors define the origin - the reference point for the edges of "
"the node."
msgstr ""
"**锚点：**\\ ``Control`` 节点具有位置和大小，但它也有锚点（Anchor）。锚点定义"
"的是原点——节点边缘的参考点。"

msgid ""
"Arrange the nodes as shown below. You can drag the nodes to place them "
"manually, or for more precise placement, use \"Anchor Presets\"."
msgstr ""
"请将节点如下图排列。拖动节点可以手动放置，也可以使用“锚点预设（Anchor "
"Preset）”进行更精确的定位。"

msgid "ScoreLabel"
msgstr "ScoreLabel"

msgid "Add the text ``0``."
msgstr "添加文本 ``0``\\ 。"

msgid ""
"Set the \"Horizontal Alignment\" and \"Vertical Alignment\" to ``Center``."
msgstr "将“Horizontal Alignment”和“Vertical Alignment”设置为 ``Center``\\ 。"

msgid "Choose the \"Anchor Preset\" ``Center Top``."
msgstr "为“Anchor Preset”选择 ``Center Top``\\ 。"

msgid "Message"
msgstr "Message"

msgid "Add the text ``Dodge the Creeps!``."
msgstr "添加文本 ``Dodge the Creeps!``\\ 。"

msgid ""
"Set the \"Autowrap Mode\" to ``Word``, otherwise the label will stay on one "
"line."
msgstr "将“Autowrap Mode”设置为 ``Word``\\ ，否则标签只会有一行。"

msgid ""
"Under \"Control - Layout/Transform\" set \"Size X\"  to ``480`` to use the "
"entire width of the screen."
msgstr ""
"在“Control - Layout/Transform”中将“Size X”设置为 ``480``\\ ，使用屏幕的完整宽"
"度。"

msgid "Choose the \"Anchor Preset\" ``Center``."
msgstr "为“Anchor Preset”选择 ``Center``\\ 。"

msgid "StartButton"
msgstr "StartButton"

msgid "Add the text ``Start``."
msgstr "添加文本 ``Start``\\ 。"

msgid ""
"Under \"Control - Layout/Transform\", set \"Size X\" to ``200`` and \"Size "
"Y\" to ``100`` to add a little bit more padding between the border and text."
msgstr ""
"在“Control - Layout/Transform”中将“Size X”设置为 ``200``\\ 、“Size Y”设置为 "
"``100``，在边框和文本之间添加间距。"

msgid "Choose the \"Anchor Preset\" ``Center Bottom``."
msgstr "为“Anchor Preset”选择 ``Center Bottom``\\ 。"

msgid "Under \"Control - Layout/Transform\", set \"Position Y\" to ``580``."
msgstr "在“Control - Layout/Transform”中将“Position Y”设置为 ``580``\\ 。"

msgid ""
"On the ``MessageTimer``, set the ``Wait Time`` to ``2`` and set the ``One "
"Shot`` property to \"On\"."
msgstr ""
"在 ``MessageTimer`` 中，将 ``Wait Time`` 设置为 ``2`` 并将 ``One Shot`` 属性"
"设置为“启用”。"

msgid "Now add this script to ``HUD``:"
msgstr "现将这个脚本添加到 ``HUD``\\ ："

msgid ""
"We now want to display a message temporarily, such as \"Get Ready\", so we "
"add the following code"
msgstr "当想显示一条临时消息时，比如“Get Ready”，就会调用这个函数"

msgid ""
"We also need to process what happens when the player loses. The code below "
"will show \"Game Over\" for 2 seconds, then return to the title screen and, "
"after a brief pause, show the \"Start\" button."
msgstr ""
"我们还需要处理玩家死亡的情况。以下代码会显示 2 秒“Game Over”，然后返回标题屏"
"幕，暂停一会儿之后再显示“Start”按钮。"

msgid ""
"This function is called when the player loses. It will show \"Game Over\" "
"for 2 seconds, then return to the title screen and, after a brief pause, "
"show the \"Start\" button."
msgstr ""
"当玩家死亡时调用这个函数。将显示“Game Over”2 秒，然后返回标题屏幕并显"
"示“Start”按钮。"

msgid ""
"When you need to pause for a brief time, an alternative to using a Timer "
"node is to use the SceneTree's ``create_timer()`` function. This can be very "
"useful to add delays such as in the above code, where we want to wait some "
"time before showing the \"Start\" button."
msgstr ""
"当你需要暂停片刻时，可以使用场景树的 ``get_tree().create_timer(2)`` 函数替代"
"使用 ``Timer`` 节点。这对于延迟非常有用，例如在上述代码中，在这里我们需要在显"
"示“开始”按钮前等待片刻。"

msgid "Add the code below to ``HUD`` to update the score"
msgstr "将以下更新分数代码添加到 ``HUD`` 中"

#, fuzzy
msgid ""
"Connect the ``pressed()`` signal of ``StartButton`` and the ``timeout()`` "
"signal of ``MessageTimer``, and add the following code to the new functions:"
msgstr ""
"连接 ``MessageTimer`` 的 ``timeout()`` 信号和 ``StartButton`` 的 "
"``pressed()`` 信号，然后在新函数中添加以下代码："

msgid "Connecting HUD to Main"
msgstr "将 HUD 场景连接到 Main 场景"

msgid ""
"Now that we're done creating the ``HUD`` scene, go back to ``Main``. "
"Instance the ``HUD`` scene in ``Main`` like you did the ``Player`` scene. "
"The scene tree should look like this, so make sure you didn't miss anything:"
msgstr ""
"现在我们完成了 ``HUD`` 场景，保存并返回 ``Main`` 场景。和 ``Player`` 场景的做"
"法一样，在 ``Main`` 场景中实例化 ``HUD`` 场景。如果你没有错过任何东西，完整的"
"场景树应该像这样："

msgid ""
"Now we need to connect the ``HUD`` functionality to our ``Main`` script. "
"This requires a few additions to the ``Main`` scene:"
msgstr ""
"现在我们需要将 ``HUD`` 功能与我们的 ``Main`` 脚本连接起来。这需要在 ``Main`` "
"场景中添加一些内容："

msgid ""
"In the Node tab, connect the HUD's ``start_game`` signal to the "
"``new_game()`` function of the Main node by clicking the \"Pick\" button in "
"the \"Connect a Signal\" window and selecting the ``new_game()`` method or "
"type \"new_game\" below \"Receiver Method\" in the window. Verify that the "
"green connection icon now appears next to ``func new_game()`` in the script."
msgstr ""
"在“节点”选项卡中，点击“连接信号”窗口中的“选取”按钮，选择 ``new_game()`` 方法"
"或在窗口的“接收方法”下面输入“new_game”，将 HUD 的 ``start_game`` 信号连接到 "
"Main 节点的 ``new_game()`` 函数。请确认脚本中 ``func new_game()`` 的旁边出现"
"了一个绿色的连接图标。"

msgid ""
"In ``new_game()``, update the score display and show the \"Get Ready\" "
"message:"
msgstr "在 ``new_game()`` 函数中，更新分数显示并显示“Get Ready”消息："

msgid "In ``game_over()`` we need to call the corresponding ``HUD`` function:"
msgstr "在 ``game_over()`` 中我们需要调用相应的 ``HUD`` 函数："

msgid ""
"Finally, add this to ``_on_score_timer_timeout()`` to keep the display in "
"sync with the changing score:"
msgstr ""
"最后，将下面的代码添加到 ``_on_score_timer_timeout()`` 中，保持不断变化的分数"
"的同步显示："

msgid ""
"Remember to remove the call to ``new_game()`` from ``_ready()`` if you "
"haven't already, otherwise your game will start automatically."
msgstr ""
"如果还没做的话，请不要忘记在 ``_ready()`` 中移除对 ``new_game()`` 的调用。否"
"则你的游戏将自动开始。"

msgid ""
"Now you're ready to play! Click the \"Play the Project\" button. You will be "
"asked to select a main scene, so choose ``main.tscn``."
msgstr ""
"现在你就可以开始游戏了！点击“运行项目”按钮。此时会要求你选择一个主场景，选择 "
"``main.tscn`` 即可。"

msgid "Removing old creeps"
msgstr "删除旧的小怪"

msgid ""
"If you play until \"Game Over\" and then start a new game right away, the "
"creeps from the previous game may still be on the screen. It would be better "
"if they all disappeared at the start of a new game. We just need a way to "
"tell *all* the mobs to remove themselves. We can do this with the \"group\" "
"feature."
msgstr ""
"如果你一直玩到“游戏结束”，然后重新开始新游戏，上局游戏的小怪仍然显示在屏幕"
"上。更好的做法是在新游戏开始时清除它们。我们需要一个同时让\\ *所有*\\ 小怪删"
"除它自己的方法，为此可以使用“分组”功能。"

msgid ""
"In the ``Mob`` scene, select the root node and click the \"Node\" tab next "
"to the Inspector (the same place where you find the node's signals). Next to "
"\"Signals\", click \"Groups\" and you can type a new group name and click "
"\"Add\"."
msgstr ""
"在 ``Mob`` 场景中，选择根节点，然后单击检查器旁边的“节点”选项卡（在该位置可以"
"找到节点的信号）。 点击“信号”旁边的“分组”，然后可以输入新的组名称，点击“添"
"加”。"

msgid ""
"Now all mobs will be in the \"mobs\" group. We can then add the following "
"line to the ``new_game()`` function in ``Main``:"
msgstr ""
"现在，所有小怪都将属于“mobs”（小怪）分组。我们可以将以下行添加到 ``Main`` 中"
"的 ``new_game()`` 函数中："

msgid ""
"The ``call_group()`` function calls the named function on every node in a "
"group - in this case we are telling every mob to delete itself."
msgstr ""
"``call_group()`` 函数调用组中每个节点上的删除函数——让每个怪物删除其自身。"

msgid ""
"The game's mostly done at this point. In the next and last part, we'll "
"polish it a bit by adding a background, looping music, and some keyboard "
"shortcuts."
msgstr ""
"游戏在这一点上大部分已经完成。在下一部分和最后一部分中，我们将通过添加背景，"
"循环音乐和一些键盘快捷键来对其进行一些润色。"

msgid "Translation status"
msgstr "翻译状态"
