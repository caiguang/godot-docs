# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-27 19:04+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Moving the player with code"
msgstr "使用代码移动玩家"

msgid ""
"It's time to code! We're going to use the input actions we created in the "
"last part to move the character."
msgstr "该轮到编写代码了！我们将使用先前创建的输入动作来移动角色。"

msgid ""
"Right-click the ``Player`` node and select *Attach Script* to add a new "
"script to it. In the popup, set the *Template* to *Empty* before pressing "
"the *Create* button."
msgstr ""
"右键单击 ``Player`` 节点，选择\\ *附加脚本*\\ 为其添加一个新脚本。在弹出窗口"
"中，先将\\ *模板*\\ 设置为 *空*\\ ，后按下\\ *创建*\\ 按钮 。"

msgid "|image0|"
msgstr "|image0|"

msgid "image0"
msgstr "image0"

msgid ""
"Let's start with the class's properties. We're going to define a movement "
"speed, a fall acceleration representing gravity, and a velocity we'll use to "
"move the character."
msgstr ""
"先定义类的属性。我们将定义移动速率（标量）、重力加速度，以及一个我们将用来移"
"动角色的速度（向量）。"

msgid ""
"These are common properties for a moving body. The ``target_velocity`` is a :"
"ref:`3D vector <class_Vector3>` combining a speed with a direction. Here, we "
"define it as a property because we want to update and reuse its value across "
"frames."
msgstr ""
"这是一个移动物体的常见属性。 ``target_velocity`` 是一个组合了速度和方向的 :"
"ref:`3D 向量 <class_Vector3>`。在这里，我们将其定义为属性，因为我们希望在帧之"
"间更新并重用其值。"

msgid ""
"The values are quite different from 2D code because distances are in meters. "
"While in 2D, a thousand units (pixels) may only correspond to half of your "
"screen's width, in 3D, it's a kilometer."
msgstr ""
"这些值与二维代码完全不同，因为距离以米为单位。在 2D 中，一千个单位（像素）可"
"能只对应于屏幕宽度的一半，而在 3D 中，它是一千米。"

msgid ""
"Let's code the movement. We start by calculating the input direction vector "
"using the global ``Input`` object, in ``_physics_process()``."
msgstr ""
"那么来编写移动的代码。首先在 ``_physics_process()`` 中使用全局 ``Input`` 对象"
"来计算输入方向向量。"

msgid ""
"Here, we're going to make all calculations using the ``_physics_process()`` "
"virtual function. Like ``_process()``, it allows you to update the node "
"every frame, but it's designed specifically for physics-related code like "
"moving a kinematic or rigid body."
msgstr ""
"在这里，我们将使用 ``_physics_process()`` 虚函数进行所有计算。与 "
"``_process()`` 一样，它允许你每帧更新节点，但它是专门为物理相关代码设计的，例"
"如运动学物体或刚体。"

msgid ""
"To learn more about the difference between ``_process()`` and "
"``_physics_process()``, see :ref:`doc_idle_and_physics_processing`."
msgstr ""
"要了解更多关于 ``_process()`` 和 ``_physics_process()`` 之间的区别，见 :ref:"
"`doc_idle_and_physics_processing`\\ 。"

msgid ""
"We start by initializing a ``direction`` variable to ``Vector3.ZERO``. Then, "
"we check if the player is pressing one or more of the ``move_*`` inputs and "
"update the vector's ``x`` and ``z`` components accordingly. These correspond "
"to the ground plane's axes."
msgstr ""
"我们首先将一个 ``direction`` 变量初始化为 ``Vector3.ZERO``\\ 。然后，我们检查"
"玩家是否正在按下一个或多个 ``move_*`` 输入，并相应地更新矢量的 ``x`` 和 "
"``z`` 分量。它们对应于地平面的轴。"

msgid ""
"These four conditions give us eight possibilities and eight possible "
"directions."
msgstr "这四个条件给了我们八个可能性和八个可能的方向。"

msgid ""
"In case the player presses, say, both W and D simultaneously, the vector "
"will have a length of about ``1.4``. But if they press a single key, it will "
"have a length of ``1``. We want the vector's length to be consistent, and "
"not move faster diagonally. To do so, we can call its ``normalized()`` "
"method."
msgstr ""
"如果玩家同时按下 W 键 和 D 键，这个向量长度大约为 ``1.4``\\ 。但如果他们只按"
"一个键，则它的长度将为 ``1``\\ 。我们希望该向量的长度保持一致，而不是在对角线"
"上移动得更快。为此，我们需调用其 ``normalize()`` 方法。"

msgid ""
"Here, we only normalize the vector if the direction has a length greater "
"than zero, which means the player is pressing a direction key."
msgstr ""
"在这里，我们只在方向的长度大于零的情况下对向量进行归一化，因为玩家正在按某个"
"方向键。"

msgid ""
"We compute the direction the ``$Pivot`` is looking by creating a :ref:`Basis "
"<class_Basis>` that looks in the ``direction`` direction."
msgstr ""

msgid ""
"Then, we update the velocity. We have to calculate the ground velocity and "
"the fall speed separately. Be sure to go back one tab so the lines are "
"inside the ``_physics_process()`` function but outside the condition we just "
"wrote above."
msgstr ""
"然后，更新速度。需要分别计算地面速度和下降速度。请确保 tab 缩进，使行在 "
"``_physics_process()`` 函数内部，而不在刚编写的条件外部。"

msgid ""
"The ``CharacterBody3D.is_on_floor()`` function returns ``true`` if the body "
"collided with the floor in this frame. That's why we apply gravity to the "
"``Player`` only while it is in the air."
msgstr ""
"如果物体在这一帧中与地板发生了碰撞，那么 ``CharacterBody3D.is_on_floor()`` 函"
"数就会返回 ``true``\\ 。这就是为什么我们只在空中对 ``Player`` 施加重力。"

msgid ""
"For the vertical velocity, we subtract the fall acceleration multiplied by "
"the delta time every frame. This line of code will cause our character to "
"fall in every frame, as long as it is not on or colliding with the floor."
msgstr ""
"对于垂直速度，在每一帧中减去下降加速度乘以增量时间（delta time，每个帧之间的"
"时间，也称帧时间）。这条代码将使角色在没有在地板上或是碰撞地板的情况下，每帧"
"都会下降。"

msgid ""
"The physics engine can only detect interactions with walls, the floor, or "
"other bodies during a given frame if movement and collisions happen. We will "
"use this property later to code the jump."
msgstr ""
"物理引擎只有在运动和碰撞发生的情况下才能检测到在某一帧中与墙壁、地板或其他物"
"体的相互作用。我们将在后面使用这个属性来编写跳跃的代码。"

msgid ""
"On the last line, we call ``CharacterBody3D.move_and_slide()`` which is a "
"powerful method of the ``CharacterBody3D`` class that allows you to move a "
"character smoothly. If it hits a wall midway through a motion, the engine "
"will try to smooth it out for you. It uses the *velocity* value native to "
"the :ref:`CharacterBody3D <class_CharacterBody3D>`"
msgstr ""
"在最后一行，我们调用了 ``CharacterBody3D.move_and_slide()``\\ ，这是 "
"``CharacterBody3D`` 类的一个强大方法，可以让你顺利地移动一个角色。如果它在运"
"动过程中撞到了墙，引擎会试着为你把它进行平滑处理。它使用的是 :ref:"
"`CharacterBody3D <class_CharacterBody3D>` 自带的\\ *速度*\\ 值"

msgid "And that's all the code you need to move the character on the floor."
msgstr "这就是你在地面上移动角色所需的所有代码。"

msgid "Here is the complete ``Player.gd`` code for reference."
msgstr "下面是供参考的完整 ``Player.gd`` 代码。"

msgid "Testing our player's movement"
msgstr "测试玩家的移动"

msgid ""
"We're going to put our player in the ``Main`` scene to test it. To do so, we "
"need to instantiate the player and then add a camera. Unlike in 2D, in 3D, "
"you won't see anything if your viewport doesn't have a camera pointing at "
"something."
msgstr ""
"将玩家放在 ``Main`` 场景中进行测试，这时，需要先实例化玩家，然后添加相机。 "
"3D 与 2D 不同，如果没有添加摄像机，你将无法看到任何物体。"

msgid ""
"Save your ``Player`` scene and open the ``Main`` scene. You can click on the "
"*Main* tab at the top of the editor to do so."
msgstr ""
"保存 ``Player`` 场景，然后打开 ``Main`` 场景。可以点击编辑器顶部的 *Main* 选"
"项卡切换。"

msgid "|image1|"
msgstr "|image1|"

msgid "image1"
msgstr "image1"

msgid ""
"If you closed the scene before, head to the *FileSystem* dock and double-"
"click ``main.tscn`` to re-open it."
msgstr ""
"如果场景之前已关闭，请转到 *文件系统* 面板，双击 ``main.tscn`` 文件重新打开。"

msgid ""
"To instantiate the ``Player``, right-click on the ``Main`` node and select "
"*Instantiate Child Scene*."
msgstr ""
"要实例化 ``Player`` ，可右键单击 ``Main`` 节点，然后选择 *实例化子场景* 。"

msgid "|image2|"
msgstr "|image2|"

msgid "image2"
msgstr "image2"

msgid ""
"In the popup, double-click ``player.tscn``. The character should appear in "
"the center of the viewport."
msgstr "在弹出窗口中，双击 ``player.tscn`` ，角色将显示在视窗的中心。"

msgid "Adding a camera"
msgstr "添加摄像机"

msgid ""
"Let's add the camera next. Like we did with our *Player*\\ 's *Pivot*, we're "
"going to create a basic rig. Right-click on the ``Main`` node again and "
"select *Add Child Node*. Create a new :ref:`Marker3D <class_Marker3D>`, and "
"name it ``CameraPivot``. Select ``CameraPivot`` and add a child node :ref:"
"`Camera3D <class_Camera3D>` to it. Your scene tree should look like this."
msgstr ""
"接下来我们来添加摄像机。和 *Player* 的 *Pivot* 类似，我们要创建一个基本的架"
"构。再次右键单击 *Main* 节点，这次选择\\ *添加子节点*\\ 。新建一个 :ref:"
"`Marker3D <class_Marker3D>`\\ ，命名为 *CameraPivot*\\ ，然后添加一个 :ref:"
"`Camera3D <class_Camera3D>` 节点作为其子项。你的场景树应该看起来像这样。"

msgid "|image3|"
msgstr "|image3|"

msgid "image3"
msgstr "image3"

msgid ""
"Notice the *Preview* checkbox that appears in the top-left when you have the "
"*Camera* selected. You can click it to preview the in-game camera projection."
msgstr ""
"请注意在选中 *Camera* 时，左上角会出现一个\\ *预览*\\ 复选框。你可以单击预览"
"游戏中的摄像机投影视角。"

msgid "|image4|"
msgstr "|image4|"

msgid "image4"
msgstr "image4"

msgid ""
"We're going to use the *Pivot* to rotate the camera as if it was on a crane. "
"Let's first split the 3D view to be able to freely navigate the scene and "
"see what the camera sees."
msgstr ""
"我们要使用 *Pivot* 来旋转摄像机，让他像被吊车吊起来一样。让我们先拆分 3D 视"
"图，以便在进行自由移动的同时观察摄像机拍摄到的内容。"

msgid ""
"In the toolbar right above the viewport, click on *View*, then *2 "
"Viewports*. You can also press :kbd:`Ctrl + 2` (:kbd:`Cmd + 2` on macOS)."
msgstr ""
"在视口上方的工具栏中，单击\\ *视图*\\ ，然后单击\\ *2 个视口*\\ 。你也可以"
"按 :kbd:`Ctrl + 2`\\ （macOS 上则为 :kbd:`Cmd + 2`\\ ）。"

msgid "|image11|"
msgstr "|image11|"

msgid "image11"
msgstr "image11"

msgid "|image5|"
msgstr "|image5|"

msgid "image5"
msgstr "image5"

msgid ""
"On the bottom view, select your :ref:`Camera3D <class_Camera3D>` and turn on "
"camera Preview by clicking the checkbox."
msgstr ""
"在下面那个视图中，选中 :ref:`Camera3D <class_Camera3D>`\\ ，然后勾选预览复选"
"框打开摄像机预览。"

msgid "|image6|"
msgstr "|image6|"

msgid "image6"
msgstr "image6"

msgid ""
"In the top view, move the camera about ``19`` units on the Z axis (the blue "
"one)."
msgstr "在上面那个视图中，将摄像机沿 Z 轴（蓝色）移动 ``19`` 个单位。"

msgid "|image7|"
msgstr "|image7|"

msgid "image7"
msgstr "image7"

msgid ""
"Here's where the magic happens. Select the *CameraPivot* and rotate it "
"``-45`` degrees around the X axis (using the red circle). You'll see the "
"camera move as if it was attached to a crane."
msgstr ""
"接下来就是关键。选中 *CameraPivot* 并将其围绕 X 周旋转 ``-45`` 度（使用红色的"
"圆圈）。你会看到摄像机就像是被连上了吊车一样移动。"

msgid "|image8|"
msgstr "|image8|"

msgid "image8"
msgstr "image8"

msgid ""
"You can run the scene by pressing :kbd:`F6` and press the arrow keys to move "
"the character."
msgstr "你可以按 :kbd:`F6` 运行场景，然后按方向键来移动角色。"

msgid "|image9|"
msgstr "|image9|"

msgid "image9"
msgstr "image9"

msgid ""
"We can see some empty space around the character due to the perspective "
"projection. In this game, we're going to use an orthographic projection "
"instead to better frame the gameplay area and make it easier for the player "
"to read distances."
msgstr ""
"因为透视投影的缘故，我们会在角色的周围看到一些空白区域。在这个游戏中，我们要"
"使用的是正交投影，从而更好地展示游戏区域，让玩家更易于识别距离。"

msgid ""
"Select the *Camera* again and in the *Inspector*, set the *Projection* to "
"*Orthogonal* and the *Size* to ``19``. The character should now look flatter "
"and the ground should fill the background."
msgstr ""
"再次选中 *Camera*\\ ，然后在\\ *检查器* 中将 *Projection*\\ （投影）设为 "
"*Orthogonal*\\ （正交）、将 *Size*\\ （大小）设为 ``19``\\ 。角色现在看起来应"
"该更加扁平，背景应该被地面充满。"

msgid ""
"When using an orthogonal camera in Godot 4, directional shadow quality is "
"dependent on the camera's *Far* value. The higher the *Far* value, the "
"further away the camera will be able to see. However, higher *Far* values "
"also decrease shadow quality as the shadow rendering has to cover a greater "
"distance."
msgstr ""
"当在 Godot 4 中使用正交相机时，方向阴影的质量取决于相机的 *Far* 值。\\ *Far* "
"越高，相机能够看到的距离就更远。然而由于更高的 *Far* 值会使得阴影渲染必须覆盖"
"到更远的距离，这个操作也会导致阴影质量下降。"

msgid ""
"If directional shadows look too blurry after switching to an orthogonal "
"camera, decrease the camera's *Far* property to a lower value such as "
"``100``. Don't decrease this *Far* property too much, or objects in the "
"distance will start disappearing."
msgstr ""
"如果在切换到正交相机后方向阴影看起来变得模糊，请减小相机的 *Far* 属性到更低的"
"值，如 ``100`` 。请不要将 *Far* 属性减小得太多，否则远处的物体将会开始消失。"

msgid "|image10|"
msgstr "|image10|"

msgid "image10"
msgstr "image10"

msgid ""
"Test your scene and you should be able to move in all 8 directions and not "
"glitch through the floor!"
msgstr ""
"测试你的场景，你应该能够在所有 8 个方向上移动，并且不会在地板上出现故障！"

msgid ""
"Ultimately, we have both player movement and the view in place. Next, we "
"will work on the monsters."
msgstr "这样，我们就完成了玩家的移动以及视图。接下来，我们要来处理怪物。"

msgid "Translation status"
msgstr "翻译状态"
